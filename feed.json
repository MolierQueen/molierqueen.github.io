{
    "version": "https://jsonfeed.org/version/1",
    "title": "Molier",
    "description": "iOS 开发 移动App 博客 杂谈 随笔 相册",
    "home_page_url": "https://oliverqueen.cn",
    "items": [
        {
            "id": "https://oliverqueen.cn/2021-05-03-iOS%20Crash%E9%98%B2%E6%8A%A4%E4%BD%A0%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%B0%B1%E5%A4%9F%E4%BA%86-%E4%B8%8A%E7%AF%87/",
            "url": "https://oliverqueen.cn/2021-05-03-iOS%20Crash%E9%98%B2%E6%8A%A4%E4%BD%A0%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%B0%B1%E5%A4%9F%E4%BA%86-%E4%B8%8A%E7%AF%87/",
            "title": "iOS Crash防护你看这个就够了 - 上篇",
            "date_published": "2023-12-30T14:16:08.546Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"0x1-为什么要做crash防护\"><a class=\"anchor\" href=\"#0x1-为什么要做crash防护\">#</a> 0x1 为什么要做 Crash 防护</h1>\n<p>在产品开发过程中 Crash 率是一个很重要的指标，也是一个团队中几乎所有的部门都应该关注或者去参与提升的一个指标，他不仅代表着整个产品的质量，也是一个团队整体技术能力的体现。更低的 Crash 率不但能让产品获得更好的用户口碑，在整个流程中也能让团队成员获得更多的成长，加深对 iOS 系统底层的理解，为今后的开发带了更大的帮助。</p>\n<p><img data-src=\"https://image-1256056152.cos.ap-nanjing.myqcloud.com/1111111111.jpeg\" alt=\"\" /></p>\n<p><span id=\"more\"></span></p>\n<h1 id=\"0x2-为什么要写这篇文章\"><a class=\"anchor\" href=\"#0x2-为什么要写这篇文章\">#</a> 0x2 为什么要写这篇文章</h1>\n<p>起因也是因为自己的项目踩了 FB 的 SDK 的坑：2020.7.10，FB 后台下发数据错误，导致大量使用 FB SDK 的 App 发生启动 Crash，影响用户之多，范围之大，再加上当时包括我们的大部分 App 也缺乏相关的防护或者是容错处理，Crash 率瞬间飙升，重新发版又要走发布流程，只能依赖 FB 后台的修复，当时束手无策十分被动，所以决定自己做一套较为完整的 Crash 防护体系，来避免这样的场景再次发生。第二个目的就是，发生问题后我也第一之间查阅了网上的一些资料和其他团队的做法，发现大家的方式各有千秋，方法不同，效果不同，所以我也决定把市面上能找到的好的思路和方法再结合自己的一些想法和经验记录下来。最后也是因为知识是要沉淀、积累和分享的，也算是巩固和加深自己的理解吧。</p>\n<h1 id=\"0x3-怎么做\"><a class=\"anchor\" href=\"#0x3-怎么做\">#</a> 0x3 怎么做</h1>\n<p>其实当时 Crash 的场景很简单，本来一个 Dictionary 参数 FB 后台却下发了个 String 类型的数据，这样一来解析时候必然会 Crash，解决的话其实只要做一层参数安全校验即可。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq58dki0g7j31ai0u01fd.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq58c923pfj31020t8k5g.jpg\" alt=\"\" /></p>\n<p>但是这么简单的问题，大部分 App 都没处理好，证明在流程上一定有大家注意不到的地方，暴露出来的只是冰山一角，我们机制一定存在着某种问题，或者存在可以优化的地方。</p>\n<p>要想避免这种情况，就要先梳理出处理 Crash 的流程：</p>\n<h2 id=\"icrash处理流程\"><a class=\"anchor\" href=\"#icrash处理流程\">#</a> I：Crash 处理流程</h2>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6lcsxy6jj31bw0u0n1w.jpg\" alt=\"\" /></p>\n<p>在 iOS 系统中基本可以总结出这四个步骤，</p>\n<ul>\n<li>\n<p>Crash 防护 - 通过 Hook 等手段，对一些类似容器类进行入参校验等措施，来进来避免 Crash 的发生</p>\n</li>\n<li>\n<p>Crash 拦截 - 如果第一步防护失败，那么在 Crash 走到这一步就要进行拦截，要让我们发现异常</p>\n</li>\n<li>\n<p>Crash 上报 - 对防护的、捕获的 Crash 进行防护，生成有效的日志进行上报，尽可能的还原堆栈。</p>\n</li>\n<li>\n<p>Crash 后续流程 - Crash 发生后如何做才能最大限度的保护用户体验，如何优雅的 Crash</p>\n</li>\n</ul>\n<h2 id=\"iicrash防护\"><a class=\"anchor\" href=\"#iicrash防护\">#</a> II：Crash 防护</h2>\n<p>Crash 防护方式主要分两种：针对非内存问题通常采用 AOP 方式，内存问题采用 zombie 对象的方式，</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6lrlbl0vj30qi07mdg5.jpg\" alt=\"\" /><br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6ls764zyj30qm06cjrq.jpg\" alt=\"\" /></p>\n<h3 id=\"aopbr\"><a class=\"anchor\" href=\"#aopbr\">#</a> AOP：&lt;br&gt;</h3>\n<p>iOS 中 AOP 的相关知识网上线程的代码也很多，这里就不在赘述，但是在 AOP 这种频繁调用的场景中就需要注意的地方和坑点比较多。</p>\n<ul>\n<li>\n<p>AOP 的影响范围问题：当时用了普通的方式对数组相关的方法进行了 Hook，结果上线后发现大量的类似 Crash。 <code>[UIKeyboardLayoutStar release]: message sent to deallocated instance UIKeyboardLayoutStar</code></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6m6njbm8j30o40d0q8q.jpg\" alt=\"\" /><br />\n在通过一些其他场景可以判断出是因为 HookNSMutableArr 的相关方法，导致系统类的调用受到了影响。</p>\n<p>通过 Xcode 调试发现，因为 Hook 的本质就是在原有的系统调用前插入一个用户自定义的函数进行方法交换，那么在某种极端情况下（比如多线程），传入该函数的变量被释放，这样一来再走到原本系统调用的时候正常释放时就会出现重复释放的情况。大概的流程为</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6mhmeprhj31hm0fu75v.jpg\" alt=\"\" /></p>\n<p>该场景在测试过程中很难复现，但是一旦到了线上，用户量覆盖够大后该问题就会显现出来。解决方式很简单，Hook 尽量在 MRC 下进行，使用 autorelease pool 进行包装。保证内部变量在当前的 runloop 结束时候进行释放。</p>\n</li>\n<li>\n<p>AOP 的性能问题：上面说了 AOP 的原理是会多一层方法调用，那么再结合 iOS 的方法转发流程可想而知，AOP 必定会造成性能的损耗，而且在 Crash 防护场景下频繁调用，性能问题一定不能忽略。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6mswloauj310o0u0jx8.jpg\" alt=\"\" /></p>\n<p>通过上图看出，方法调用流程最终会返回出对应的 IMP 指针供外部调用，作为动态语言，OC 无法确定开发者会再什么时候插入或者交换哪个函数，所以必须通过这一套流程进行类似校验的逻辑。</p>\n<p>使用过 AOP 的同学一定知道在 AOP 前会先做一层校验</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+(void)hookClass:(Class)classObject isClassMetohd:(BOOL)classMethod fromSelector:(SEL)fromSelector toSelector:(SEL)toSelector </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Class <span class=\"keyword\">class</span> = classObject;</span><br><span class=\"line\">    Method fromMethod = <span class=\"keyword\">class</span><span class=\"constructor\">_getInstanceMethod(<span class=\"params\">class</span>, <span class=\"params\">fromSelector</span>)</span>;</span><br><span class=\"line\">    Method toMethod = <span class=\"keyword\">class</span><span class=\"constructor\">_getInstanceMethod(<span class=\"params\">class</span>, <span class=\"params\">toSelector</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">//  添加前进行检测</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (classMethod) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">class</span> = <span class=\"keyword\">object</span><span class=\"constructor\">_getClass(<span class=\"params\">classObject</span>)</span>;</span><br><span class=\"line\">        fromMethod = <span class=\"keyword\">class</span><span class=\"constructor\">_getClassMethod(<span class=\"params\">class</span>, <span class=\"params\">fromSelector</span>)</span>;</span><br><span class=\"line\">        toMethod = <span class=\"keyword\">class</span><span class=\"constructor\">_getClassMethod(<span class=\"params\">class</span>, <span class=\"params\">toSelector</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">class</span><span class=\"constructor\">_addMethod(<span class=\"params\">class</span>, <span class=\"params\">fromSelector</span>, <span class=\"params\">method_getImplementation</span>(<span class=\"params\">toMethod</span>)</span>, <span class=\"keyword\">method</span><span class=\"constructor\">_getTypeEncoding(<span class=\"params\">toMethod</span>)</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">class</span><span class=\"constructor\">_replaceMethod(<span class=\"params\">class</span>, <span class=\"params\">toSelector</span>, <span class=\"params\">method_getImplementation</span>(<span class=\"params\">fromMethod</span>)</span>, <span class=\"keyword\">method</span><span class=\"constructor\">_getTypeEncoding(<span class=\"params\">fromMethod</span>)</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">method</span><span class=\"constructor\">_exchangeImplementations(<span class=\"params\">fromMethod</span>, <span class=\"params\">toMethod</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 所以在方法我们在上面代码中的 toSelector 中 当我们需要调用回原方法时直接调用对应的函数指针即可</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6rm11f7dj30nm05a74e.jpg\" alt=\"\" /></p>\n<p>最终我对直接调用 IMP 的方法做了测试，分别是 Demo 中和 App 中的某一个场景，测试数据如下，对比结果还是较为明显。这也就是为什么 Swift 或者一些其他静态语言比 OC 快的原因。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6rw5k68mj313c0r6n13.jpg\" alt=\"\" /></p>\n</li>\n</ul>\n<h3 id=\"zombiebr\"><a class=\"anchor\" href=\"#zombiebr\">#</a> Zombie：&lt;br&gt;</h3>\n<p>使用僵尸对象来解决内存问题一直是苹果主推的方式，Xcode 也有相关设置，在 Debug 下打开相应开关，但是一旦把该功能放到线上做防护或监控就要考虑很多的问题。</p>\n<ul>\n<li>\n<p>zombie 入口问题：换句话说就是在哪个地方生成 zombie 对象，看了一些相关的 SDK 都是采用 Dealloc 作为入口函数，不是不行，只是不是最优。原因有两点:</p>\n<ul>\n<li>\n<p>1: 苹果已经不建议在 ARC 下主动调用 dealloc，目前只能采用 performSelector 或者其他动态调用的方式。</p>\n</li>\n<li>\n<p>2: 容易漏掉  <code>Objc_destructInstance</code> ，所有的成员变量、属性都会在这个函数中释放，如果漏掉这个函数就会生成一个并不干净的僵尸对象，内存占用过高，白白浪费内存空间。</p>\n</li>\n</ul>\n<p>综上两点我最终选择在 Free 函数中生成僵尸对象</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6sr4ebj5j30vx0u0dhq.jpg\" alt=\"\" /></p>\n</li>\n<li>\n<p>zombie 内存阈值问题：僵尸对象会占用内存空间，然而在线上环境操作内存一定要小心且一定要有一套完整的逻辑，当超过某一个内存阈值后需要及时清空僵尸对象。内存阈值的确定便成了关键，这里会遇到两个问题：</p>\n<ul>\n<li>\n<p>&lt;font color='red'&gt; 1：内存问题一定会和机型强相关，如何根据不同的机型调整不同的阈值？ &lt;/font&gt;</p>\n</li>\n<li>\n<p>&lt;font color='red'&gt; 2：如何做到根据线上情况灵活动态调整？&lt;/font&gt;</p>\n</li>\n</ul>\n<p>我们的底线是在加入 zombie 后不能触发 memorywarning，所以我先对大部分机型做了 memorywarning 阈值测试：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6t2xweqcj312g0sg0xq.jpg\" alt=\"\" /></p>\n<p>从上图可以看出当 App 占用内存达到总内存的 57%~69% 时候会触发内存警告，而且由于 iphone 中有一部分内存是系统保留内存并不会给到开发者，所以我们可用的也就 50% 左右，我总结出如下公式：</p>\n<p>公式 1：不能触发内存警告  <code>Y = 0.5 * deviceMem – currentAppMem</code></p>\n<p>公式 2: 僵尸对象的内存占用再大也不会超过 App 本身的内存  <code>Y = min ( ( 0.5 * deviceMem – currentAppMem ) , currentAppMem)</code></p>\n<p>上面两个公式看似完美，但是还是有优化的地方，因为并不是 APP 中所有的变量都有可能成为僵尸对象，可能只是其中的某一部分需要被监控，所以得到最终的内存阈值计算公式：</p>\n<p>&lt;font color=red size=5 face=&quot;黑体&quot;&gt;Y = min ( ( 0.5 * deviceMem – currentAppMem ) , currentAppMem / N )&lt;/font&gt;</p>\n<p>因为 app 占用内存随时在变，所以可以加一个定时器每隔一定时间去更新该值。</p>\n<p>上面公式的 N 还有一个好处就是我们可以后台动态下发，根据线上内存引起 Crash 量，如果 Crash 量大，那可能就需要更大的内存阈值去保存僵尸对象，就可以把 N 调小，反正调大，这样就可以无视机型的差异根据 Crash 的情况进行远程配置。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6tozx4odj316l0u079c.jpg\" alt=\"\" /></p>\n<p>通过如图的线上数据可以看出 随着 N 的减小，zombie 的内存阈值在增加，但是并不会超过内存警告阈值，确保了内存健康。</p>\n<p>下图表示了不同的 N 值对应不同的捕获野指针问题的数量，各自 App 可以根据自己的业务情况进行调整。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6tse6e79j31zo0kkk0x.jpg\" alt=\"\" /></p>\n</li>\n<li>\n<p>zombie 更新策略问题：目前大家的做法都是在加入新的 zombie 对象时候检查是否超过阈值，达到阈值后删掉之前的 zombie 对象再加入新的对象，这样的清理逻辑是依赖于新 zombie 对象的加入，如果没有新对象的加入那么缓存空间也不会有变化，zombie 空间一旦生成就无法删掉，无法做到缓存的自清理，等于 App 无故增大了内存占用。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6u18gh6cj30wa0saad2.jpg\" alt=\"\" /></p>\n<p>同样借鉴 LRU 最近最久未使用的逻辑，每隔 30s 会检测下缓存情况，超过 30s 还未被使用的 zombie 对象将被删除，30s 是一个经验值，通过大量测试发现，内存问题一般会发生在对象被销毁的 30s 内，超过 30s 再出现的概率及小。这样可以做到缓存自清理的逻辑。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6u92wzy3j30n00si41c.jpg\" alt=\"\" /></p>\n<p>通过 Instrument 测试发现该 zombie 逻辑并不会对 App 本身的内存造成太大的影响。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6ucxjfn5j31c60u078q.jpg\" alt=\"\" /></p>\n</li>\n</ul>\n<p>\n\t\t\t<script>\n\t\t\t\tconsole.error(\"Error: [hexo-tag-aplayer] Specified asset file not found ( https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E5%B0%B9%E6%98%94%E7%9C%A0%20-%20%E5%A5%94%E8%B5%B4%E6%98%9F%E7%A9%BA.mp3)\");\n\t\t\t</script></p>\n",
            "tags": [
                "iOS",
                "Crash防护"
            ]
        },
        {
            "id": "https://oliverqueen.cn/How-to-create-a-Swift-Command-Line-tool/",
            "url": "https://oliverqueen.cn/How-to-create-a-Swift-Command-Line-tool/",
            "title": "How to create Swift CLI",
            "date_published": "2023-03-28T09:42:10.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"为什么要做cli\"><a class=\"anchor\" href=\"#为什么要做cli\">#</a> 为什么要做 CLI</h2>\n<p>命令行工具<strong> CLI (command-line interface)</strong> 是开发者必不可少的工具之一，编写命令行工具来处理一些工作上的事情也是开发者必备的技能。对于一些重复性的工作，使用命令行脚本可以将任务自动化，这将极大的提升我们的工作效率。同时也能避免因为人为的因素导致错误。比如批量处理一些文件、表格等，在 APP 开发中<strong>持续集成</strong>的概念也是建立在一些列的自动化命令行脚本的基础之上。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/111.png\" alt=\"\" /></p>\n<h2 id=\"为什么使用swift\"><a class=\"anchor\" href=\"#为什么使用swift\">#</a> 为什么使用 Swift</h2>\n<p>命令行的开发语言有很多，比如最基本的 <code>shell脚本</code> ，还有常见的 <code>Python</code> 、 <code>Go</code> 、 <code>Ruby</code>  等。而 iOS 开发者工作中最常用也是最熟悉的就是 Objective-c 和 Swift 语言，所以这会带来几个个问题。</p>\n<ul>\n<li>App 开发者编写脚本语言需要一定的学习成本。</li>\n<li>App 开发者编写脚本时候需要频繁的进行语言切换。</li>\n<li>Swift 作为苹果主推的语言，iOS 相关的脚本都已经使用 Swift 开发，比如一些 <code>重签</code> 、 <code>动态库注入</code> 脚本等。Swift 开发的命令行程序不但能像正常的脚本语言一样完成各种批处理任务，而且对 iOS 的项目有天然的优势。</li>\n</ul>\n<p>虽然 <code>Objective-c</code>  编写的代码也可以通过 <code>clang XXXXXX.m -framework Foundation -o XXXXX</code>  来编译成可执行文件来使用，但是毕竟 Objective-c 一开始设计的初衷并不包含命令行程序，所以一些功能上还在存在不少缺陷，比如参数的传入与处理。而 Swift 在官方一推出的时候就宣传了 Swift 可以开发 App 、脚本、后台服务、前端等，应用广泛。</p>\n<h2 id=\"swift-cli基本流程\"><a class=\"anchor\" href=\"#swift-cli基本流程\">#</a> Swift CLI 基本流程</h2>\n<h3 id=\"1工程创建\"><a class=\"anchor\" href=\"#1工程创建\">#</a> 1：工程创建</h3>\n<p>使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc3dpZnQub3JnL3BhY2thZ2UtbWFuYWdlci8=\"> Swift Package Manager（SPM）</span>来创建工程，SPM 是苹果官方提供的一个用于管理源代码分发的工具，类似于 Cocoapods 或者 Carthage，但是更轻量化，并且 Xcode 原生支持，无需配置各种环境，可以直接使用。</p>\n<p><figure class=\"highlight shell\"><figcaption><span>工程创建</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">cd</span> CLIDemo  // 进入到你的文件夹</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">swift package init --<span class=\"built_in\">type</span> executable</span></span><br></pre></td></tr></table></figure></p>\n<p>执行完命令后会生成所需要的文件</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304011746092.png\" alt=\"\" /></p>\n<p>其中</p>\n<ul>\n<li>\n<p>Package.swift ：类似 Cocoapods 中的 Podfile 文件，里面描述了一些库的引用依赖关系，和工程配置。</p>\n</li>\n<li>\n<p>Source/CLIDemo 文件夹：我们的工程目录，后续我们新加源代码或者文件都放到该目录下。</p>\n</li>\n<li>\n<p>CLIDemo.swift：命令行程序入口，不可更改文件名字，里面包含 main 函数。</p>\n<p><figure class=\"highlight swift\"><figcaption><span>入口main函数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@main</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">CLIDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">private(set)</span> <span class=\"keyword\">var</span> text <span class=\"operator\">=</span> <span class=\"string\">&quot;Hello, World!&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">func</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"type\">CLIDemo</span>().text)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>Tests 文件夹：测试工程，与正常的 Xcode 工程类似。</p>\n</li>\n</ul>\n<h3 id=\"2使用xcode开发\"><a class=\"anchor\" href=\"#2使用xcode开发\">#</a> 2：使用 Xcode 开发</h3>\n<p>工程文件结构创建好之后目前还缺少 <code>XXX.xcodeproj</code>  文件，没办法用 Xcode 直接打开，使用如下命令创建 Xcode 入口</p>\n<p><figure class=\"highlight shell\"><figcaption><span>Xcode入口创建</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">swift package generate-xcodeproj</span></span><br></pre></td></tr></table></figure></p>\n<p>然后打开生成的 <code>CLIDemo.xcodeproj</code>  文件，将运行设备选择为 Mac，然后编译运行后就可以在 Xcode 的控制台看到输出的 Hello World 文案，截止到此，我们的整个命令行开发工程就已经搭建完成。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304011801713.png\" alt=\"\" /></p>\n<p>同样除了使用 Xcode GUI 的当时编译运行之外也可以使用命令行方式进行</p>\n<p><figure class=\"highlight shell\"><figcaption><span>编译运行</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">swift run CLIDemo</span></span><br></pre></td></tr></table></figure></p>\n<p>然后得到相同的输出</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304011813359.png\" alt=\"\" /></p>\n<h3 id=\"3参数传递与处理\"><a class=\"anchor\" href=\"#3参数传递与处理\">#</a> 3：参数传递与处理</h3>\n<h4 id=\"方式1系统api解析参数\"><a class=\"anchor\" href=\"#方式1系统api解析参数\">#</a> 方式 1：系统 API 解析参数</h4>\n<p>上面讲述工程创建和命令行编写，通常我们在调用命令行的时候会带有参数</p>\n<p><figure class=\"highlight shell\"><figcaption><span>命令参数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">command</span> 参数1 参数2 参数3 ....</span></span><br></pre></td></tr></table></figure></p>\n<p>同样在代码层面也有解析参数的 API</p>\n<p><figure class=\"highlight swift\"><figcaption><span>CommandLine</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Command-line arguments for the current process.</span></span><br><span class=\"line\"><span class=\"keyword\">@frozen</span> <span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">CommandLine</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Access to the raw argc value from C.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> argc: <span class=\"type\">Int32</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Access to the raw argv value from C. Accessing the argument vector</span></span><br><span class=\"line\">    <span class=\"comment\">/// through this pointer is unsafe.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> unsafeArgv: <span class=\"type\">UnsafeMutablePointer</span>&lt;<span class=\"type\">UnsafeMutablePointer</span>&lt;<span class=\"type\">Int8</span>&gt;?&gt; &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> arguments: [<span class=\"type\">String</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用方式比较简单</p>\n<p><figure class=\"highlight swift\"><figcaption><span>解析参数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 解析外部传进来的参数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arguments <span class=\"operator\">=</span> <span class=\"type\">CommandLine</span>.arguments</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第一个参数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> firstArg <span class=\"operator\">=</span> arguments[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二个参数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> secondtArg <span class=\"operator\">=</span> arguments[<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;My args = <span class=\"subst\">\\(arguments)</span>  first = <span class=\"subst\">\\(firstArg)</span>  second = <span class=\"subst\">\\(secondtArg)</span>&quot;</span>);</span><br></pre></td></tr></table></figure></p>\n<p>需要注意这里返回的参数数组中第一个元素是可执行文件本身路径，然后用户真正的输入的第一个参数是从第二个元素开始，类似与 iOS 中 <code>objcMsgSend</code>  函数，其中第一个参数是 self。然后可以通过解析这些参数来达到不同的目的</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304031744585.png\" alt=\"\" /></p>\n<h4 id=\"方式2使用swiftargumentparser\"><a class=\"anchor\" href=\"#方式2使用swiftargumentparser\">#</a> 方式 2：使用 SwiftArgumentParser</h4>\n<p>在实际使用中，一个完善的命令行参数一定不会这么简单，而且我们在解析参数的时候也不知道使用方传入参数的顺序，一些简单的命令，或者只有一个参数的情况下可以使用 CommandLine 的 API，更复杂的情况下需要时用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zd2lmdHBhY2thZ2VpbmRleC5jb20vYXBwbGUvc3dpZnQtYXJndW1lbnQtcGFyc2VyLzEuMi4yL2RvY3VtZW50YXRpb24vYXJndW1lbnRwYXJzZXIvZ2V0dGluZ3N0YXJ0ZWQ=\"> SwiftArgumentParser</span> 来进行处理。</p>\n<p><code>SwiftArgumentParser</code>  是苹果开源的一个用 Swift 编写的参数解析器，用于解析命令行参数（command-line arguments），具有直观、易用、简洁、安全的特点。虽然是苹果自己开发的，但是毕竟还是外部库需要使用 <code>Swift package</code>  打包进来，对 <code>Package</code>  文件进行编写</p>\n<p><figure class=\"highlight swift\"><figcaption><span>Package.swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> PackageDescription</span><br><span class=\"line\"><span class=\"keyword\">let</span> package <span class=\"operator\">=</span> <span class=\"type\">Package</span>(</span><br><span class=\"line\">    name: <span class=\"string\">&quot;CLIDemo&quot;</span>,</span><br><span class=\"line\">    dependencies: [</span><br><span class=\"line\">        <span class=\"comment\">//引入swift-argument-parser解析器</span></span><br><span class=\"line\">        .package(url: <span class=\"string\">&quot;https://github.com/apple/swift-argument-parser&quot;</span>, from: <span class=\"string\">&quot;1.2.0&quot;</span>),</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    targets: [</span><br><span class=\"line\">        .executableTarget(</span><br><span class=\"line\">            name: <span class=\"string\">&quot;CLIDemo&quot;</span>,</span><br><span class=\"line\">            dependencies: [</span><br><span class=\"line\">                <span class=\"comment\">//将解析器依赖到target</span></span><br><span class=\"line\">                .product(name: <span class=\"string\">&quot;ArgumentParser&quot;</span>, package: <span class=\"string\">&quot;swift-argument-parser&quot;</span>),</span><br><span class=\"line\">            ]),</span><br><span class=\"line\">        .testTarget(</span><br><span class=\"line\">            name: <span class=\"string\">&quot;CLIDemoTests&quot;</span>,</span><br><span class=\"line\">            dependencies: [<span class=\"string\">&quot;CLIDemo&quot;</span>]),</span><br><span class=\"line\">    ]</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>同时 <code>CLIDemo.swift</code>  代码文件也要相应的进行修改</p>\n<ul>\n<li>1：引入<strong> ArgumentParser</strong></li>\n<li>2：将 struct 改为 Class（方便后续的开发），并遵循 <code>ParsableCommand</code>  协议</li>\n<li>3：修改 main 函数为 run：因为遵循协议后，原来的 main 被 <code>ParsableCommand</code>  接管入口，内部会调用函数名为 <code>run</code>  的函数作为入口。</li>\n</ul>\n<p><figure class=\"highlight swift\"><figcaption><span>CLIDemo.swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ArgumentParser</span><br><span class=\"line\"><span class=\"keyword\">@main</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CLIDemo</span>: <span class=\"title class_\">ParsableCommand</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">required</span> <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">run</span>() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 解析外部传进来的参数</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> arguments <span class=\"operator\">=</span> <span class=\"type\">CommandLine</span>.arguments</span><br><span class=\"line\">        <span class=\"comment\">// 第一个参数</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> firstArg <span class=\"operator\">=</span> arguments[<span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"comment\">// 第二个参数</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> secondtArg <span class=\"operator\">=</span> arguments[<span class=\"number\">2</span>]</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;My args = <span class=\"subst\">\\(arguments)</span>  first = <span class=\"subst\">\\(firstArg)</span>  second = <span class=\"subst\">\\(secondtArg)</span>&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>工程修改完后已经具备了 <code>ArgumentParser</code>  的开发环境，ArgumentParser 的参数分为三类</p>\n<ul>\n<li>@Argument：无标记位参数，与上面介绍的直接使用 CommandLine 的 API 解析方式相似，该类型的参数没有别名标记位，而且必须按照用户传入的顺序做解析。</li>\n<li>@Option：带有标记位参数，这个类型的参数就是通过别名或者标记为来标识的，也是我们常见的参数用法比如  <code>-n myName</code>  或者 <code>--name myName</code> 。其中 <code>-n</code>  和 <code>--name</code>  就是该参数的长别名和短别名，同样因为有了别名，所以解析时候不用关系用户输入参数的顺序。</li>\n<li>@Flag：标记位，是一个 bool 变量，比如常用  <code>--verbose</code> ， <code>-h</code>  等</li>\n</ul>\n<p><figure class=\"highlight swift\"><figcaption><span>参数解析</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">var</span> configuration <span class=\"operator\">=</span> <span class=\"type\">CommandConfiguration</span>(abstract: <span class=\"string\">&quot;这是一个测试Demo&quot;</span>)</span><br><span class=\"line\"><span class=\"meta\">@Argument</span>(help: <span class=\"string\">&quot;这是一个Argument 参数&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> argumentArg: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Argument&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Option</span>(name: [.short, .long], help: <span class=\"string\">&quot;这是一个option参数&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> optionArg: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;option&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Flag</span>(name: [.short, .long], help: <span class=\"string\">&quot;这是一个Flag参数&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> flagArg: <span class=\"type\">Bool</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure></p>\n<p>关于参数的描述系统提供以下定义，通常使用 <code>short</code>  和 <code>long</code></p>\n<p><figure class=\"highlight swift\"><figcaption><span>参数定义</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">Representation</span>: <span class=\"title class_\">Hashable</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> long <span class=\"comment\">// 参数原标记位，就是变量名</span></span><br><span class=\"line\">  <span class=\"keyword\">case</span> customLong(<span class=\"keyword\">_</span> name: <span class=\"type\">String</span>, withSingleDash: <span class=\"type\">Bool</span>)  <span class=\"comment\">// 自定义标记位</span></span><br><span class=\"line\">  <span class=\"keyword\">case</span> short <span class=\"comment\">// 参数短标记位  为-加上变量名第一个字母</span></span><br><span class=\"line\">  <span class=\"keyword\">case</span> customShort(<span class=\"keyword\">_</span> char: <span class=\"type\">Character</span>, allowingJoined: <span class=\"type\">Bool</span>) <span class=\"comment\">// 自定义短标记位</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>ArgumentParser</code>  默认集成了 <code>-h</code>  参数，完成以上参数定义后，通过 <code>-h</code>  输出我们命令行 Demo 帮助文档</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304032145234.png\" alt=\"\" /></p>\n<div class=\"note warning\">\n<p>注意：参数命名时候如果使用驼峰结构，最终的参数会被添加 <code>-</code>  比如上面的我定义的 <code>flagArg</code> ，最终命令行的 Flag 参数为 <code>--flag-arg</code> 。所以这里尽量不用驼峰结构。</p>\n</div>\n<h3 id=\"4调试运行\"><a class=\"anchor\" href=\"#4调试运行\">#</a> 4：调试运行</h3>\n<p>因为我们是在 Xcode 中编程开发，所以不用每次都跑到命令行中取执行 <code>Swift run CLIDemo XXX</code>  来编译运行我们的工具，这样不然切来切去影响工作效率，而且没法使用断点调试，正确的方式是像正常的 iOS 开发一样直接在 Xcode 中编译运行。而参数传递可以在 Xcode 上方的 <code>Edit Scheme</code>  中处理</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304032152232.png\" alt=\"\" /></p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304032153290.png\" alt=\"\" /></p>\n<p>然后编译运行即可，以上行为等价于在终端中输入 <code>swift run CLIDemo arg1 -f -o option</code></p>\n<h3 id=\"5编译成可执行文件\"><a class=\"anchor\" href=\"#5编译成可执行文件\">#</a> 5：编译成可执行文件</h3>\n<p>我们假设已经完成了命令行程序的编写，最终要达到的目是执行我们的命令行程序然后输出 Hello World!，那么首先我们需要把代码编译成可执行文件，通过如下命令</p>\n<p><figure class=\"highlight shell\"><figcaption><span>编译成可执行文件</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp; swift build -c release</span><br></pre></td></tr></table></figure></p>\n<p>编译之后我们可以在工程目录下找到我们产物</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304011810603.png\" alt=\"\" /></p>\n<p>这样一来我们就可以把该文件进行分发，让其他人或者服务器端使用我们的的命令行工具了，如果有需要可以把该文件放到 /usr/local/bin/ 目录下，这样可以在任意路径下使用</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304011817712.png\" alt=\"\" /></p>\n<h2 id=\"swift-cli实战ipa下载器\"><a class=\"anchor\" href=\"#swift-cli实战ipa下载器\">#</a> Swift CLI 实战 (iPa 下载器)</h2>\n<p>上面讲了一个 Swift CLI 工具从开发到使用的完整流程，但是一个真正的命令行工具一定不仅仅是输出一个 Hello World，需要有 <code>子命令</code> 、 <code>公共参数</code> 、 <code>二次输入</code> ， <code>敏感输入</code> ， <code>终端输出样式</code> ， <code>进度回调</code> 等功能。本节内容会通过实现一个 ipa 下载器，来介绍下 Swift CLI 的一些进阶用法，这些用法几乎能覆盖之后百分之九十的工作场景。</p>\n<p>一个 iPa 下载器可以从 Appstore 下载 App，同时集成了 Appstore 相关能力，如 <code>登录</code> ， <code>搜索</code> ， <code>下载</code> 等。我们可以将这些能力封装成不同的子命令来进行调用，像如下这样</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304062017381.png\" alt=\"\" /></p>\n<h3 id=\"1子命令\"><a class=\"anchor\" href=\"#1子命令\">#</a> 1：子命令</h3>\n<p>子命令也是 <code>ArgumentParser</code>  的能力项之一，可以在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zd2lmdHBhY2thZ2VpbmRleC5jb20vYXBwbGUvc3dpZnQtYXJndW1lbnQtcGFyc2VyLzEuMi4yL2RvY3VtZW50YXRpb24vYXJndW1lbnRwYXJzZXIvY29tbWFuZHNhbmRzdWJjb21tYW5kcw==\">这里</span>查看官方文档，具体代码</p>\n<p><figure class=\"highlight swift\"><figcaption><span>子命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">var</span> configuration <span class=\"operator\">=</span> <span class=\"type\">CommandConfiguration</span>(abstract: <span class=\"string\">&quot;一个iPa下载工具&quot;</span>, subcommands: [<span class=\"type\">Search</span>.<span class=\"keyword\">self</span>, <span class=\"type\">Login</span>.<span class=\"keyword\">self</span>, <span class=\"type\">Download</span>.<span class=\"keyword\">self</span>])</span><br></pre></td></tr></table></figure></p>\n<p>其中要创建子命令对应的 <code>.swift</code>  文件。且每个文件中都应像之前的 CLIDemo.swift 的结构一样，定义自己的类，且遵循 <code>ParsableCommand</code>  协议，以 Search 举例，其他 <code>同级</code> 子命令同理，子命令 <code>嵌套</code> 子命令，结构类似，以此类推。</p>\n<p><figure class=\"highlight swift\"><figcaption><span>子命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Search</span>: <span class=\"title class_\">ParsableCommand</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">required</span> <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> configuration <span class=\"operator\">=</span> <span class=\"type\">CommandConfiguration</span>(abstract: <span class=\"string\">&quot;搜索appstore上的App&quot;</span>)</span><br><span class=\"line\">   <span class=\"keyword\">func</span> <span class=\"title function_\">run</span>() &#123;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2公共参数\"><a class=\"anchor\" href=\"#2公共参数\">#</a> 2：公共参数</h3>\n<p>当有多个子命令的时候我们一定会有一些参数是公用的，比如上面展示的 <code>--verbose</code> ，如果每个子命令文件都写一遍显然不现实，所以 <code>ArgumentParser</code>  提供了<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zd2lmdHBhY2thZ2VpbmRleC5jb20vYXBwbGUvc3dpZnQtYXJndW1lbnQtcGFyc2VyLzEuMi4yL2RvY3VtZW50YXRpb24vYXJndW1lbnRwYXJzZXIvb3B0aW9uZ3JvdXA=\"> OptionGroup 选项组</span>的能力。</p>\n<p>我们可以在一个公共的类或结构体中定义一系列公用参数，然后在需要使用公共参数的子命令文件中定义 <code>@OptionGroup</code>  如下图。在解析的时候可以用 <code>GlobalOptions.verbose</code>  来取值</p>\n<p><figure class=\"highlight swift\"><figcaption><span>参数组</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">GlobalOptions</span>: <span class=\"title class_\">ParsableArguments</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Flag</span>(name: .shortAndLong)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> verbose: <span class=\"type\">Bool</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Argument</span> <span class=\"keyword\">var</span> values: [<span class=\"type\">Int</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Search</span>: <span class=\"title class_\">ParsableArguments</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Option</span> <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"meta\">@OptionGroup</span> <span class=\"keyword\">var</span> globals: <span class=\"type\">GlobalOptions</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3appstore登录\"><a class=\"anchor\" href=\"#3appstore登录\">#</a> 3：Appstore 登录</h3>\n<p>首先登录需要输入用户名密码，所以 Login 文件的参数一定是包含 username，password，使用上面提到的方式很容易将这两个参数传入，但是输入密码的时候如果是明文的话就太不安全了，终端输入密码的方式都是 <code>隐式输入</code> ，同样我们的工具也要具备这个能力，使用 <code>getpass</code>  函数可以达到隐式输入图的目的，这样打字就不会显示到终端中，也不用为密码单独分配一个参数。</p>\n<p><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CommonMethod().showCommonMessage(text: <span class=\"string\">&quot;请输入密码：&quot;</span>)</span><br><span class=\"line\">  guard let psd = getpass(<span class=\"string\">&quot;&quot;</span>) <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"> \t CommonMethod().showErrorMessage(text: <span class=\"string\">&quot;需要输入密码&quot;</span>)</span><br><span class=\"line\">   Login.<span class=\"keyword\">exit</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304062055076.png\" alt=\"\" /></p>\n<ul>\n<li>登录 Api  <code>&quot;https://p25-buy.itunes.apple.com/WebObjects/MZFinance.woa/wa/authenticate?guid=MAC地址&quot;</code></li>\n</ul>\n<h3 id=\"4二次输入\"><a class=\"anchor\" href=\"#4二次输入\">#</a> 4：二次输入</h3>\n<p>拿到用户名和密码可以进行 Appstore API 请求进行登录了，但是 Appstore 是有二次认证的，所以我们还需要输入一个授权码。此时我们可以通过 Appstore 服务端返回的信息来提示用户输入授权码，需要授权码的错误信息为 <code>MZFinance.BadLogin.Configurator_message</code> ，此时我们的进程还未结束，需要用户 <code>二次输入</code> ，对应的 api 为 <code>readLine</code></p>\n<p><figure class=\"highlight swift\"><figcaption><span>二次输入</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">CommonMethod</span>().showWarningMessage(text: <span class=\"string\">&quot;请输入双重认证的Code：&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> authCode <span class=\"operator\">=</span> <span class=\"built_in\">readLine</span>();</span><br><span class=\"line\"><span class=\"keyword\">self</span>.authCode <span class=\"operator\">=</span> authCode <span class=\"operator\">??</span> <span class=\"string\">&quot;&quot;</span></span><br></pre></td></tr></table></figure></p>\n<p>收到用户的授权码后，携带授权码重新请求 Appstore API 接口即可，</p>\n<h3 id=\"5本地持久化\"><a class=\"anchor\" href=\"#5本地持久化\">#</a> 5：本地持久化</h3>\n<p>登录成功后会获得 <code>DSID Token</code>  以及相关 Cookie 信息，需要把这些信息持久化到本地，避免每次使用该工具都要走登录流程，持久化的方式可以使用数据库、UserDefault、写文件等方式进行，这些对于 iOS 开发人员来说并不陌生。</p>\n<h3 id=\"6文件搜索\"><a class=\"anchor\" href=\"#6文件搜索\">#</a> 6：文件搜索</h3>\n<p>文件搜索比较简单，我们可以通过 APP 的名字进行搜索，入参为：</p>\n<ul>\n<li>appname ：APP 名称</li>\n<li>appid：APP 在 applestore 上的 ID（非必要）</li>\n<li>limit：结果条数限制（非必要）</li>\n<li>Country：APP 所在国家（非必要）</li>\n</ul>\n<p>整个搜索流程为：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304081440040.png\" alt=\"\" /></p>\n<p>App 搜索的 API 为 <code>https://itunes.apple.com/search</code></p>\n<h3 id=\"7文件下载\"><a class=\"anchor\" href=\"#7文件下载\">#</a> 7：文件下载</h3>\n<p>通过上一步拿到的 bundleid 调用 AppStore 的下载接口可以实现 ipa 包的下载，所以这里的入参为：</p>\n<ul>\n<li>bundleid：App 的 bundleid</li>\n<li>path：下载路径</li>\n</ul>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304081526063.png\" alt=\"\" /></p>\n<p>拼接好请求后很容易就进入下载流程开始下载了。在 Swift 中可以使用系统原生的 NSUrlsession 或者使用一些开源三方空类似 Alamofire、moya 等。</p>\n<h3 id=\"8命令行输出样式\"><a class=\"anchor\" href=\"#8命令行输出样式\">#</a> 8：命令行输出样式</h3>\n<p>在执行下载任务或者一些耗时任务，我们需要提供进度条来给使用者一定的提示，终端中的进度条其实也是通过各种各样的字符编码组成的图案，同时通过不同的颜色来区分不同的状态</p>\n<ul>\n<li>\n<p>下载中</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304081506567.png\" alt=\"\" /></p>\n</li>\n<li>\n<p>下载完成</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304081508595.png\" alt=\"\" /></p>\n</li>\n<li>\n<p>下载失败</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304081518284.png\" alt=\"\" /></p>\n</li>\n</ul>\n<p>进度条图案是由两部分组成</p>\n<ul>\n<li>表示完成字符：█</li>\n<li>表示剩余字符：░</li>\n</ul>\n<h4 id=\"进度\"><a class=\"anchor\" href=\"#进度\">#</a> 进度</h4>\n<p>默认生成 50 个░，然后每次下载进度回调回来我们会根据百分比把已完成的部分用█替换，这样就展示了类似一个进度条在前进的样式。如果追求精细化，可以根据命令行窗口的宽度来动态调整进度条的长度，避免窗口过小，导致进度条会折行显示。</p>\n<p>同时为了保证进度条保持在一行，所以每次展示都要把光标移到开始位置然后在该行重新展示，这里使用 \\r 打头，同时去掉 print 函数末尾自带的 \\n 操作。这里封装一个显示进度的函数</p>\n<p><figure class=\"highlight swift\"><figcaption><span>进度条</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">showProcess</span>(<span class=\"params\">process</span>:<span class=\"type\">Float</span>, <span class=\"params\">customEnd</span>:<span class=\"type\">String</span>) -&gt; <span class=\"type\">Void</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//  宽度50</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> barW <span class=\"operator\">=</span> <span class=\"number\">50</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> com <span class=\"operator\">=</span> <span class=\"type\">Int</span>(<span class=\"type\">Float</span>(barW)<span class=\"operator\">*</span><span class=\"type\">Float</span>(process))</span><br><span class=\"line\">    <span class=\"keyword\">let</span> rem <span class=\"operator\">=</span> barW <span class=\"operator\">-</span> com</span><br><span class=\"line\">\t\t<span class=\"comment\">//  自定义结尾文案和颜色</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> endStr <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> color <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> customEnd.count <span class=\"operator\">&gt;</span> <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">      endStr <span class=\"operator\">=</span> customEnd</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  \t<span class=\"comment\">//  下载完成样式</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> com <span class=\"operator\">==</span> <span class=\"number\">50</span> &#123;</span><br><span class=\"line\">      endStr <span class=\"operator\">=</span> <span class=\"string\">&quot;下载完成：【100%】&quot;</span></span><br><span class=\"line\">      color <span class=\"operator\">=</span> <span class=\"string\">&quot;<span class=\"subst\">\\u&#123;001B&#125;</span>[0;32m&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t  <span class=\"comment\">// 进度条</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> bar <span class=\"operator\">=</span> <span class=\"type\">String</span>(repeating: <span class=\"string\">&quot;█&quot;</span>, count: com) <span class=\"operator\">+</span> <span class=\"type\">String</span>(repeating: <span class=\"string\">&quot;░&quot;</span>, count: rem)</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 打印进度条</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;<span class=\"subst\">\\r</span><span class=\"subst\">\\(color)</span><span class=\"subst\">\\(bar)</span> <span class=\"subst\">\\(endStr)</span>&quot;</span>, terminator: <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">  </span><br><span class=\"line\">  \t<span class=\"comment\">// 刷新输出缓冲区</span></span><br><span class=\"line\">    fflush(stdout)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"颜色\"><a class=\"anchor\" href=\"#颜色\">#</a> 颜色</h4>\n<p>在文本前添加相应的编码可以更改文本的样式，比如</p>\n<ul>\n<li>\n<p>文字颜色  <code>\\u&#123;001b&#125;[?m</code>    其中 <code> ? ∈ [30, 37]</code> 。</p>\n<p><figure class=\"highlight shell\"><figcaption><span>颜色</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">黑（black）：\\u&#123;001b&#125;[30m</span><br><span class=\"line\">红（red）：\\u&#123;001b&#125;[31m</span><br><span class=\"line\">绿（green）：\\u&#123;001b&#125;[32m</span><br><span class=\"line\">黄（yellow）：\\u&#123;001b&#125;[33m</span><br><span class=\"line\">蓝（blue）：\\u&#123;001b&#125;[34m</span><br><span class=\"line\">品红（magenta）：\\u&#123;001b&#125;[35m</span><br><span class=\"line\">蓝绿（cyan）：\\u&#123;001b&#125;[36m</span><br><span class=\"line\">白（white）：\\u&#123;001b&#125;[37m</span><br><span class=\"line\">还原初始（reset） ：\\u&#123;001b&#125;[0m</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>文字背景颜色 <code>\\u&#123;001b&#125;[?m</code> ，其中  <code>? ∈ [40, 47]</code> 。</p>\n<p><figure class=\"highlight shell\"><figcaption><span>背景</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">黑（black）：\\u&#123;001b&#125;[40m</span><br><span class=\"line\">红（red）：\\u&#123;001b&#125;[41m</span><br><span class=\"line\">绿（green）：\\u&#123;001b&#125;[42m</span><br><span class=\"line\">黄（yellow）：\\u&#123;001b&#125;[43m</span><br><span class=\"line\">蓝（blue）：\\u&#123;001b&#125;[44m</span><br><span class=\"line\">品红（magenta）：\\u&#123;001b&#125;[45m</span><br><span class=\"line\">蓝绿（cyan）：\\u&#123;001b&#125;[46m</span><br><span class=\"line\">白（white）：\\u&#123;001b&#125;[47m</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>字体样式</p>\n<p><figure class=\"highlight shell\"><figcaption><span>字体</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">加粗加亮：\\u&#123;001b&#125;[1m</span><br><span class=\"line\">降低亮度：\\u&#123;001b&#125;[2m</span><br><span class=\"line\">斜体：\\u&#123;001b&#125;[3m</span><br><span class=\"line\">下划线：\\u&#123;001b&#125;[4m</span><br><span class=\"line\">反色：\\u&#123;001b&#125;[7m</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<p>以上命令可以单独使用，也可以组合使用，如将以下条件组合在一起</p>\n<ul>\n<li>\\u {001b}[1m ：加粗加亮</li>\n<li>\\u {001b}[4m：下划线</li>\n<li>\\u {001b}[42m：绿色背景</li>\n<li>\\u {001b}[31m：红色字体</li>\n</ul>\n<p><figure class=\"highlight swift\"><figcaption><span>示例文字</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;<span class=\"subst\">\\n</span><span class=\"subst\">\\u&#123;001b&#125;</span>[1m<span class=\"subst\">\\u&#123;001b&#125;</span>[4m<span class=\"subst\">\\u&#123;001b&#125;</span>[42m<span class=\"subst\">\\u&#123;001b&#125;</span>[31m 这是一段绿色背景红色字体加粗带有下划线的文字&quot;</span>)</span><br></pre></td></tr></table></figure></p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304081605787.png\" alt=\"\" /></p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>做完以上操作后一个 ipa 下载器就完成了，具体的源码可以查看<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL01vbGllclF1ZWVuL015SXBhTWFuYWdlcg==\">此处</span>。使用 Swift 编写 CLI 可以极大的提高 iOS 开发者的开发效率，降低脚本语言的学习成本，同时随时 Apple 对 Swift 的不断更新迭代，未来也许能用 swift 做更多的事情。</p>\n",
            "tags": []
        },
        {
            "id": "https://oliverqueen.cn/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E9%80%89%E6%8B%A9/",
            "url": "https://oliverqueen.cn/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E9%80%89%E6%8B%A9/",
            "title": "程序员如何进阶",
            "date_published": "2023-01-10T11:30:33.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"技术管理\"><a class=\"anchor\" href=\"#技术管理\">#</a> 技术？管理？</h2>\n<p>在程序员的职业生涯中一直逃不开的一个话题，也是网上议论最多的话题就是 “35 岁之后的码农的职业规划该走技术路线还是管理路线”，尤其是在疫情时代，大环境不好，各个公司各种各样的 “毕业典礼” 也让这个话题在程序员的圈子里被推上顶峰。我也一直在思考这个问题，毕竟也到了该未雨绸缪的时刻，不过更多的还是通过给自己制定更完善的职业规划，来增加自己的抗风险能力和核心竞争力。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202301101851232.png\" alt=\"\" /></p>\n<p>一两年之前当时还是只管简简单单写代码，并做好组织交代的任务的时候自己就开始思考这个问题，那时候思考的方式很简单，我个人有个对比方法，就是生活在中遇到选择的时候都会用这种方式去对比，两个候选方案放在一起，把每个方案的优点和缺点列出来，然后看下优点是不是对我有足够的吸引力，缺点是不是也不是不能接受，以此来选择一个对我来说还算不错的方案。对应到这个问题上来就是搞技术，更加纯粹，更加专一，也更符合码农的性格，缺点可能是，需要耐得住寂寞，持续钻研，回报周期长等；而做管理虽然听着好听，会有各种 title，但是事情更多更杂，需要处理很多技术之外的事情，也是大部分程序员不擅长的。所以当时的我的出的答案是，感觉还是技术攻关，技术突破才能带给我更多的成就感和满足感。</p>\n<h2 id=\"技术管理-2\"><a class=\"anchor\" href=\"#技术管理-2\">#</a> 技术 + 管理！</h2>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202301101919974.png\" alt=\"\" /></p>\n<p>但是当时忽略了一个问题，要知道对比的前提是一定要了解所对比的东西，那个时候我对管理根本没有概念，也没有接触过相关的书籍或资料，仅凭一己之见来做出比较片面的判断。后来随着自己也慢慢参与到管理工作中，同时也接触了一些技术领域和管理领域的大牛后才对技术 or 管理有了更新的认识：我发现那些看似走技术路线的人并不是在孤军奋战，他们一定是一个项目组或者是一个团队在一起研究一个技术点，随着他们从事这个工作时间的变长，这些当时选择走技术路线的人慢慢的也都成为了这个团队的管理者或者是领头人；同样那些的当时看似走了管理路线的人也一定是因为他们的技术水平达到了相应的高度才有资格以管理者的身份去管理团队，做了管理后一样需要继续钻研技术，使自己的技术储备可以支撑自己的管理工作。这样一来再回过头看文章开头的问题 “走技术路线还是管理路线” 其实就是一个伪命题，真正的答案应该是：<strong>技术管理都要走也都会走，只是不同阶段侧重点不一样</strong>。</p>\n<h2 id=\"技术-管理\"><a class=\"anchor\" href=\"#技术-管理\">#</a> 技术 -&gt; 管理</h2>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202301101900671.png\" alt=\"\" /></p>\n<p>既然上面说了两个都要走，那要具体怎么走，下面会结合自己的一些亲身经历来总结下。从你的毕业时间开始时算，不同的阶段要有不同的侧重点，技术或者是管理其实是大类，里面具体细分了不同的细节。</p>\n<ul>\n<li>毕业三年之内：刚出校园有激情与活力，对一切充满未知和好奇，这个期间可以尝试接触不同的领域，不停地试错，但是最终的目的是找好自己的目标，也就是今后需要全力以赴深耕的方向。这一点很重要。如果等你工作了四五年了还是不知道自己想要做什么，还在不停的变换方向的话就比较危险了。</li>\n<li>毕业六七年左右：这段时间是技术深耕期，基于之前的方向深挖技术深度，提高自己的专业程度，其实这段时期对于程序员来说算是比较好度过的，只用专心研究技术，比较单纯和纯粹。打造自己在业内的影响力，提高自己的核心竞争力是这个阶段的首要目标，因为这个阶段之后基本上年龄也 30 + 了。</li>\n<li>毕业七八年之后：这个时期大部分人觉得自己会面临是走技术路线还是管理路线的问题，但是正如前面所说，想单纯的技术钻研一路走到黑，并不现实，大部分人还是在各大公司企业的，并不是研究所。而且随着年龄的增长经验的积累，管理是必不可少的一项技能，所以与其说大家面临的选择是走技术路线还是管理路线，倒不如说如何从技术路线快速过度到管理路线。这这也是绝大多数人的职业路程。</li>\n</ul>\n<h2 id=\"关于自己\"><a class=\"anchor\" href=\"#关于自己\">#</a> 关于自己</h2>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202301101903639.png\" alt=\"\" /></p>\n<p>这一两年我也是处在了转变期，有过迷茫但最终感觉算是找到了方向，最近一年时间事情比较多，尤其需要跨团队沟通的事情较多，所以也加深了我的思考。如何从一种状态转为另一种状态其实就是如何改变之前的习惯，去让自己养成新的习惯，再细化到技术 -&gt; 管理这个事情上来说就是如何改变之前的工作方式、思考方式、沟通方式。</p>\n<p>但其实转变思维并不是一件容易的事情，刚开始承担一些管理工作的时候，我还是非常容易陷入之前单兵作战的肌肉记忆中。比如需求评审的时候会陷入技术细节的思考和讨论，编码开发时候会纠结怎么样写能让这段代码看起来更优雅，指导新人或者 review 他人代码的时候，看到不合理的的代码难以控制直接帮他们改好或者重写他人代码的冲动。甚至很长一段时间都会难以转变这样的思路，而且当时也确实有这样做过。当一个管理者陷入这样的细节中其实就会非常的累，后面的工作中也印证了这一点，所以才开始反思是不是自己的工作方式，思考方式有问题。导致了过多的不必要的精力消耗。</p>\n<h2 id=\"change\"><a class=\"anchor\" href=\"#change\">#</a> Change</h2>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202301101912439.png\" alt=\"\" /></p>\n<p>其实工作经验在三到五年的程序员想发挥自己专业优势，出色的完成本职工作，太正常不过，这个年限的人大都饱含激情与热情，并执着于自己在做的事情。不过如果当你到了第三个阶段后还有这种想法就有点危险了。这种想法在前期会加速你的进步，但是在后期尤其是开始步入管理线后，可能成为你成长的绊脚石。<strong>实际上，工作中大部分棘手的事情都不是执行，而是从各种不确定中寻找到一条确定的路径，简单来说就是各种渠道的信息输入＋不断的沟通确认＋最后的决策</strong>，如果一直纠结局限于技术细节那就很难站在全局的角度去思考问题，所以如果没理解这一点就很难完成太好的转变。</p>\n<p>其实是否钻研技术细节不重要，关键是你需要有能力判断当前业务发展最大的瓶颈是什么，比如当前就是卡在某个技术难点，初阶的同学搞不定，那么你亲自出马技术攻坚合情合理，没任何问题，但是如果现在缺的是规划，缺的是拨开云雾指明方向，那么再钻到代码细节里就不太合适了。所以并不是说走管理线后就可以忽略技术。你的技术水平，技术能力是也是团队管理中重要的因素，但更重要的是要有自己的判断力，看清团队或者团队成员现在面临的根本问题是什么，要有透过现象看本质的洞察力。</p>\n<p>对自己从事的工作充满热情是一种优秀的品质，正如前面所说，在不同的阶段需要有不同的侧重点，我们的一腔热情与干劲也不要用错了方向。当你还是初学者或者中级高级程序员的话你的热情要用在技术探索上，追求最优的解法，最好的方法，出色的完成工作内容，同时保持学习；而当你是高级程序员，开始或已经在承担了一些管理工作的话，那么你的技术热情和精力应更多的用在探索自身和团队的边界并且从外部视角来发掘对业务有贡献的方向上，同时也要保持学习。作为管理者如果还是陷入技术细节的话在领导看来你就是分不清主次，在同事看来你名不副实，在下属看来你也抢占了本应属于他们的发展空间。</p>\n<h2 id=\"end\"><a class=\"anchor\" href=\"#end\">#</a> end</h2>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202301101920978.png\" alt=\"\" /></p>\n<p>其实思维的转变不是那么容易，没有人是天生的领导者，可能有的人天生聪慧，技术探索总是快人一步，可能有的人天生开朗，擅长沟通，但是对大局的把控，对本质的洞察以及最后做出准确的判断并决策的能力是需要经过无数的事情来磨炼的。技术和管理绝不是两个独立的道路，技术会巩固管理，而管理是是发展的必然趋势，所以还是之前那句话，相比于纠结两条路的选择，做好自己角色的转换才最重要的事情。对于我个人来讲，不能说今年做的很好，只能说相比之前有进步，但更重要的是找到了方向。</p>\n",
            "tags": []
        },
        {
            "id": "https://oliverqueen.cn/iPa%E9%80%86%E5%90%91%E4%B9%8B%E8%B7%AF/",
            "url": "https://oliverqueen.cn/iPa%E9%80%86%E5%90%91%E4%B9%8B%E8%B7%AF/",
            "title": "iPa逆向之路",
            "date_published": "2022-11-15T11:40:49.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景</h2>\n<p>逆向工程相对于正向的开发，可能关注的没有那么高，尤其是相比于安卓或者其他平台，苹果的安全机制更严格，逆向的流程也会更繁琐，除了有 ASLR（地址空间布局随机化），还有 FairPlay DRM 的 iPA 加密方式，也就是我们俗称的壳。这个给逆向工作带来了更多的挑战。但是 <code>更好更安全的加密方式也只是增加破解的成本，并不是绝对的安全</code> ，这也是逆向的前提。</p>\n<p>最近也正在做一些调研的工作，需要从技术层面去分析其他 App 的一些底层逻辑，要用到 iOS 的逆向相关的技术，但是由于笔者做这些工作的时候正处于 MacOS、iOS、Xcode 三个系统的大版本更新期间，一些系统的运行方式和逻辑发生变化，所以导致网上能找到的资料基本都失效了，所以写文档记录下。</p>\n<h2 id=\"前置工作\"><a class=\"anchor\" href=\"#前置工作\">#</a> 前置工作</h2>\n<h3 id=\"环境\"><a class=\"anchor\" href=\"#环境\">#</a> 环境</h3>\n<ul>\n<li>Mac 架构： Intel 架构</li>\n<li>MacOS： 13.0.1 (22A400)</li>\n<li>Xcode 版本：Version 14.1 (14B47b)</li>\n<li>iOS 系统版本：iOS 16.0</li>\n</ul>\n<h3 id=\"相关工具\"><a class=\"anchor\" href=\"#相关工具\">#</a> 相关工具</h3>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zb3VyY2Vmb3JnZS5uZXQvcHJvamVjdHMvbWFjaG92aWV3Lw==\">MachOView</span>\n<ul>\n<li>用来查看 Mach-o 的文件结构，以及各个部分的信息</li>\n</ul>\n</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3N0ZXZlbnlnYXJkLmNvbS9wcm9qZWN0cy9jbGFzcy1kdW1wLw==\">class-dump</span>\n<ul>\n<li>class-dump，顾名思义，就是用来 dump 目标对象 的 class 信息的工具。它利用 Objective-C 语言的 runtime 特性，将存储在 Mach-O 文件中的头文件信息提取出 来，并生成对应的.h 文件。</li>\n</ul>\n</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0Fsb25lTW9ua2V5L01vbmtleURldg==\">MonkeyDev</span>\n<ul>\n<li>非越狱开发插件，可以进行动态库注入，hook 相关操作</li>\n</ul>\n</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaG9wcGVyYXBwLmNvbS8=\">Hopper Disassembler</span>\n<ul>\n<li>Hopper Disassembler 是 Mac 上的一款二进制反汇编器，基本上满足了工作上的反汇编的需要，包括伪代码以及控制流图 (Control Flow Graph)，支持 ARM 指令集并针对 Objective-C 的做了优化。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"ipa下载\"><a class=\"anchor\" href=\"#ipa下载\">#</a> iPa 下载</h2>\n<p>iOS App 的逆向的所有操作都是基于 iPa 的操作，所以大前提是要有目标 iPa，这里提供三种方式来进行 iPa 下载，大家可以选择适合自己的方式下载。</p>\n<h3 id=\"方式1三方应用市场\"><a class=\"anchor\" href=\"#方式1三方应用市场\">#</a> 方式 1：三方应用市场</h3>\n<p>现在这样的应用市场比较多，多是平替 iTunes 的一些软件</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaTQuY24v\">爱思助手</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaXRvb2xzLmNuLw==\">iTools</span></li>\n</ul>\n<p>使用如上的三方软件可以很快的下载对应的 ipa 包，但是由于上述市场都是镜像自 AppStore 的内容，并且自己重签名，所以更新的及时性可能没有那么快，也没有那么全，而且因为是被第三方进行了修改重签，所以内容也不一定保证和官方的一致。如果不在乎这些的话还是可以采取这类的方式下载。</p>\n<h3 id=\"方式2apple-configuration\"><a class=\"anchor\" href=\"#方式2apple-configuration\">#</a> 方式 2：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdXBwb3J0LmFwcGxlLmNvbS9hcHBsZS1jb25maWd1cmF0b3I=\">Apple Configuration</span></h3>\n<p>可以直接从 Mac 上的 Apple Store 上下载，官方出品，原本是给手机上安装 app 的。用此方式其实是利用了该 App 的 App 下载机制来进行 ipa 导出的</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84np4us32j310y0io75z.jpg\" alt=\"image-20221114144926709\" /></p>\n<p>选择添加 App，然后在弹出的弹窗中选择 App 并且下载</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84nq4zkpwj30ys0na0vm.jpg\" alt=\"image-20221114145027227\" /></p>\n<p>这个时候如果你手机上没有安装该 App，则直接会安装成功，此时我们再点击安装下载，然后就会收到 <code>设备上已经存在相同的App，是否覆盖安装的提示</code> 的弹窗，此时我们 &lt;font color='red'&gt; 不要理会 &lt;/font &gt; 这个弹窗。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84nvzsytmj30u00y6mz0.jpg\" alt=\"image-20221114145604307\" /></p>\n<p>然后到如下路径就可以取到对应的 ipa</p>\n<p><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~<span class=\"regexp\">/Library/</span>Group Containers<span class=\"regexp\">/K36BKF7T3D.group.com.apple.configurator/</span>Library<span class=\"regexp\">/Caches/</span>Assets<span class=\"regexp\">/TemporaryItems/</span>MobileApps/</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"方式3-dumpapp\"><a class=\"anchor\" href=\"#方式3-dumpapp\">#</a> 方式 3 <a href=\"%5Bhttps://dumpapp.com%5D(https://dumpapp.com/)\">DumpApp</a></h3>\n<p>是一个第三的网站，同在线砸壳 + ipa 下载的服务，因为我们最终想要的就是一个砸壳之后的 ipa，所以这个网站直接帮我们做好了，只不过是收费的，每个 app 是 9 元，但是有多个境外的 App 市场，比较全面。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84par73tqj30be07saa1.jpg\" alt=\"image-20221114154450405\" /></p>\n<h2 id=\"ipa砸壳\"><a class=\"anchor\" href=\"#ipa砸壳\">#</a> iPa 砸壳</h2>\n<p>如果 iPa 的获取方式选择方式 3，则可以略过砸壳步骤</p>\n<p>app 上传到 AppStore 后   苹果使用 fairplay DRM 来加密，就是我们所说的壳 DRM 全称 Digital Rights Management，即数字版权保护。苹果为了保护 App Store 分发的音乐 / 视频 / 书籍 / App 免于盗版，开发了 Fairplay DRM 技术。</p>\n<p>所有逆向都是建立在砸壳的前提下，砸壳的方式有两种：</p>\n<h3 id=\"静态砸壳\"><a class=\"anchor\" href=\"#静态砸壳\">#</a> 静态砸壳</h3>\n<p>就是不依赖程序运行，直接用 ipa 包就可以进行砸壳解密，比如说我已经知道了他的加密算法，或者我通过暴力破解了他的加密算法，然后对 ipa 进行解密，但是这样的方法难度较大，而且如果人家一旦换了加密方式或者有其他的改动，那解密方式就不生效了，常见的静态砸壳工具有以下</p>\n<ul>\n<li>[fouldecrypt](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL055YU1pc3R5L2ZvdWxkZWNyeXB0\">NyaMisty/fouldecrypt: A lightweight and simpling iOS binary decryptor (github.com)</span>)</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0xha3IyMzMvSXJpZGl1bQ==\">Iridium</span></li>\n</ul>\n<h3 id=\"动态砸壳\"><a class=\"anchor\" href=\"#动态砸壳\">#</a> 动态砸壳</h3>\n<p>与静态相反，动态砸壳就是依赖运行时的原理来进行解密，不过与其说是解密，倒不如说是内存提取，因为无论 ipa 包用什么加密方式，最终都是解密后运行到内存里面的，所以我们可以认为 <code>一个ipa在内存上的数据是未加密的</code> ，所以此时我们只要把内存上的数据提取出来即可，整个过程也不涉及到解密操作，及时后面 Apple 更换加密方式，也不影响动态砸壳的过程。</p>\n<p>动态砸壳的方式和工具有很多，现在基本已经流水线化了，可以使用以下方式和工具来进行处理，前提是要有一个越狱的手机。</p>\n<ul>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzODkzNDk5OTA0MDA4\">dumpdecrypted</span></p>\n</li>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzODkzNDk5OTA0MDE0\">Clutch</span></p>\n</li>\n</ul>\n<h3 id=\"成果检验\"><a class=\"anchor\" href=\"#成果检验\">#</a> 成果检验</h3>\n<p>砸壳后需要检查是否砸壳成功，找到对应砸壳后的的 ipa，点进去找到 mach-o 文件，执行如下命令，然后在输出查看 <code>cryptid</code>  字段如果为 <code>0</code>  就说明砸壳成功。XXX = mach-o 名字</p>\n<p><figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">otool -l XXXXX <span class=\"string\">|grep cry</span></span><br></pre></td></tr></table></figure></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84ripqxklj30tx02imxg.jpg\" alt=\"image-20221114170141723\" /></p>\n<h2 id=\"头文件导出\"><a class=\"anchor\" href=\"#头文件导出\">#</a> 头文件导出</h2>\n<p>砸壳后的的第一步就是将 ipa 文件的头.h 文件导出，然后根据 头文件的方法和属性进行逆向分析，在找到对应的 hook 点。通常我们使用 class-dump，可以去他的官网下载对应的文件，然后将文件拷贝到对应的目录下。</p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo cp class-dump /usr/local/bin   </span><br></pre></td></tr></table></figure></p>\n<p>这一步没什么问题，拷贝完成重启终端就可以调用 class-dump 的方法了.</p>\n<h3 id=\"导出\"><a class=\"anchor\" href=\"#导出\">#</a> 导出</h3>\n<p>执行下面的命令，导出头文件，需要注意的是：导出后会有上万个个文件，所以目标目录最好不要选 Desktop 或者其他的根目录</p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class-dump -S -s -H XXXXX -o /path/to/headers/</span><br></pre></td></tr></table></figure></p>\n<p>有的时候会收到这样的错误</p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error:Cannot find offset for address 0xd80000000101534a in stringAtAddress:</span><br></pre></td></tr></table></figure></p>\n<p>这是因为项目使用了 Oc 和 Swift 的混编，需要赋予 class-dump 文件权限即可</p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chmod 777 /usr/local/bin/class-dump</span><br></pre></td></tr></table></figure></p>\n<p>之后就可以导出成功了。</p>\n<h2 id=\"monkeydev\"><a class=\"anchor\" href=\"#monkeydev\">#</a> MonkeyDev</h2>\n<p>这是一个为越狱和非越狱开发人员准备的工具，主要包括四个模块:</p>\n<ul>\n<li>\n<p>Logos Tweak</p>\n<ul>\n<li>使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RoZW9zL3RoZW9zL3dpa2kvSW5zdGFsbGF0aW9u\"> theos</span> 提供的 <code>logify.pl</code>  工具将 <code>*.xm</code>  文件转成 <code>*.mm</code>  文件进行编译，集成了 <code>CydiaSubstrate</code> ，可以使用 <code>MSHookMessageEx</code>  和 <code>MSHookFunction</code>  来 <code>Hook</code>  OC 函数和指定地址。</li>\n</ul>\n</li>\n<li>\n<p>CaptainHook Tweak</p>\n<ul>\n<li>使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3JwZXRyaWNoL0NhcHRhaW5Ib29rLw==\"> CaptainHook</span> 提供的头文件进行 OC 函数的 Hook 以及属性的获取。</li>\n</ul>\n</li>\n<li>\n<p>Command-line Tool</p>\n<ul>\n<li>可以直接创建运行于越狱设备的命令行工具</li>\n</ul>\n</li>\n<li>\n<p>MonkeyApp</p>\n<ul>\n<li>这是自动给第三方应用集成 Reveal、Cycript 和注入 dylib 的模块，支持调试 dylib 和第三方应用，支持 Pod 给第三放应用集成 SDK，只需要准备一个砸壳后的 ipa 或者 app 文件即可。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"安装\"><a class=\"anchor\" href=\"#安装\">#</a> 安装</h3>\n<p>Monkeydev 依赖<span class=\"exturl\" data-url=\"aHR0cHM6Ly90aGVvcy5kZXYvZG9jcy9pbnN0YWxsYXRpb24=\"> Theos</span>.Theos 是一个越狱开发工具包，由 iOS 越狱界知名人士 Dustin Howett 开发并分享到 GitHub 上。Theos 与其他越狱开发工具相比，最大特点就是简单：下载安装简单、Logos 语法简单、编译发布简单，可以让使用者将精力都放在开发工作上去。</p>\n<h4 id=\"安装thoes\"><a class=\"anchor\" href=\"#安装thoes\">#</a> 安装 Thoes</h4>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo git clone --recursive https://github.com/theos/theos.git /opt/theos</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"安装monkeydev\"><a class=\"anchor\" href=\"#安装monkeydev\">#</a> 安装 Monkeydev</h4>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo /bin/sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/AloneMonkey/MonkeyDev/master/bin/md-install)&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"卸载monkeydev\"><a class=\"anchor\" href=\"#卸载monkeydev\">#</a> 卸载 Monkeydev</h4>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo /bin/sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/AloneMonkey/MonkeyDev/master/bin/md-uninstall)&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"更新monkeydev\"><a class=\"anchor\" href=\"#更新monkeydev\">#</a> 更新 Monkeydev</h4>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo /bin/sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/AloneMonkey/MonkeyDev/master/bin/md-update)&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"安装问题\"><a class=\"anchor\" href=\"#安装问题\">#</a> 安装问题</h4>\n<p>在安装过程中，修改用户  <code>profile</code>  文件时，找不到  <code>MacOSX Package Types.xcspec</code>  和  <code>MacOSX Product Types.xcspec</code>  文件</p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/Library/Xcode/Specifications/MacOSX Package Types.xcspec not found</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>这个是因为最新的 Xcode14 中 这个路径已经改变，所以原路径无法找到，不过如果大家需要逆向的事 iOS 的 App 到这一步可以不用关心，这个是 MacOS 相关的模板文件。此时打开 Xcode 如果有以下模版文件，并能成功创建工程即可。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84skm4dlej30li0fbjsb.jpg\" alt=\"image-20221114173807449\" /></p>\n<h4 id=\"编译报错\"><a class=\"anchor\" href=\"#编译报错\">#</a> 编译报错</h4>\n<p>通过上一步的模板文件创建好工程后，直接真机编译运行，这个时候会提示编译错误</p>\n<p><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iOS <span class=\"keyword\">file</span> not found: <span class=\"regexp\">/usr/</span>lib/libstdc++.dylib</span><br></pre></td></tr></table></figure></p>\n<p>这是因为 <code>Xcode 10</code>  之后删除的 <code>libstdc++</code>  库。可以参考此<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2RibXo1MDIvTW9ua2V5RGV2X1hjb2RlMTQ=\">解决方案</span>。之后就可以编译成功了，并且手机上可以跑起来。</p>\n<p>第二个错误是 Fishhook 中的错误，这个是是由于 Fishhook 用的是比较老的版本，本身存在 bug，只要去 github 官网找到 fishhook 最新代码 copy 过来即可。</p>\n<h3 id=\"文件结构\"><a class=\"anchor\" href=\"#文件结构\">#</a> 文件结构</h3>\n<p>文件结构如下如图</p>\n<p><img data-src=\"https://upload-images.jianshu.io/upload_images/1609369-0a4b973075bc5df2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/854/format/webp\" alt=\"image-20221114174320781\" /></p>\n<p>这是一个标准的 MonkeyDemo 的结构</p>\n<ul>\n<li>\n<p><code>TargetApp</code> ：放目标 <code>ipa</code>  的文件，将需要逆向的破壳 <code>ipa</code>  放在此处</p>\n</li>\n<li>\n<p><code>Logos</code> ：编写相关 <code>hook</code>  的文件，所有 <code>hook</code>  操作在此处，但是因为该文件下要用了 logos 语句，有一定的学习成本，所以后面的 hook 函数可以直接写在上面的 MonkeyDeomDyLib.m 中</p>\n</li>\n<li>\n<p><code>fishhook</code> ：用来 <code>hook</code>  系统函数的库</p>\n</li>\n</ul>\n<p>上方的 MonkeyDeomDyLib 就是我们即将注入进去的动态库。</p>\n<h3 id=\"动态库注入\"><a class=\"anchor\" href=\"#动态库注入\">#</a> 动态库注入</h3>\n<p>运行 demo 后动态库注入成功，控制台会有如下输出</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84swti61vj31le0qn43z.jpg\" alt=\"image-20221114174950556\" /></p>\n<p><figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">🎉!!！congratulations!!！🎉\\n👍----------------insert dylib success----------------👍</span><br></pre></td></tr></table></figure></p>\n<p>但是如果是和我一样的运行环境，你是大概率看不到的，因为会注入失败。这里尝试了两种方式</p>\n<ul>\n<li>insert_dylib 同样注入失败，</li>\n<li>optool 注入成功</li>\n</ul>\n<p>下面说下 optool 使用</p>\n<ul>\n<li>\n<p>下载编译 optool</p>\n<p><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https:<span class=\"regexp\">//gi</span>thub.com<span class=\"regexp\">/alexzielenski/</span>optool.git</span><br><span class=\"line\">cd optool</span><br><span class=\"line\">git submodule update --init --recursive</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>找到编译产物</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84t2mlrmaj30aa0b7wer.jpg\" alt=\"image-20221114175525945\" /></p>\n</li>\n<li>\n<p>把编译产物拷贝到 <code>/opt/MonkeyDev/bin</code>  下</p>\n</li>\n<li>\n<p>修改 <code>/opt/MonkeyDev/Tools/pack.sh</code></p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">顶部插入</span><br><span class=\"line\">OPTOOL=&quot;$&#123;MONKEYDEV_PATH&#125;/bin/optool&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">同上面一样</span><br><span class=\"line\">修改插入动态库工具代码</span><br><span class=\"line\">&quot;$OPTOOL&quot; install -c load -p &quot;@executable_path/Frameworks/lib&quot;&quot;$&#123;TARGET_NAME&#125;&quot;&quot;Dylib.dylib&quot; -t &quot;$&#123;BUILD_APP_PATH&#125;/$&#123;APP_BINARY&#125;&quot;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>然后保存重新运行即可注入成功</p>\n</li>\n</ul>\n<h3 id=\"pod使用\"><a class=\"anchor\" href=\"#pod使用\">#</a> pod 使用</h3>\n<p>在调试 App 时候我们会用到类似 lookIn 或者 FLEX 的等工具来看 App 的层级结构和 沙盒文件，同样需要 pod 来接入。</p>\n<ul>\n<li>\n<p>像平时创建 podfile 文件一样 进入到工程目录 <code>pod init</code></p>\n</li>\n<li>\n<p>在生成的 podfile 中添加 pod，但是要注意是在 &lt;font color='red'&gt; DemoLib &lt;/font &gt; 的 trarget 中添加，因为我们的 pod 是打入动态库的，然后由动态库带入 App</p>\n<p><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Uncomment the next line to define a global platform for your project</span></span><br><span class=\"line\"><span class=\"comment\"># platform :ios, &#x27;9.0&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">target <span class=\"string\">&#x27;Demo&#x27;</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">  <span class=\"comment\"># Comment the next line if you don&#x27;t want to use dynamic frameworks</span></span><br><span class=\"line\">  use_frameworks!</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">target <span class=\"string\">&#x27;DemoDylib&#x27;</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">  <span class=\"comment\"># Comment the next line if you don&#x27;t want to use dynamic frameworks</span></span><br><span class=\"line\">  use_frameworks!</span><br><span class=\"line\"></span><br><span class=\"line\">    pod <span class=\"string\">&#x27;FLEX&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    pod <span class=\"string\">&#x27;LookinServer&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>然后 <code>pod install</code>  即可看到效果</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h85lo8xilij31b90u0ada.jpg\" alt=\"image-20221115102451908\" /></p>\n</li>\n</ul>\n<h3 id=\"代码hook\"><a class=\"anchor\" href=\"#代码hook\">#</a> 代码 Hook</h3>\n<p>通过 Lookin 我们可以找到入手点和对应的类名，然后通过之前导出的头文件可以查看类名对应的函数，接下来就是要看下函数里面做了哪些事情，就要用到 Hook 手段，MonkeyDev 给我们封装好了 Hook 相关的方法，包括 OC 和 C 的 Hook 函数</p>\n<ul>\n<li>\n<p>CHDeclareClass</p>\n<p>注册类名。也就是注册要被 hook 的函数所在的类，比如</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CHDeclareClass(MYViewController)</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>CHOptimizedMethod1</p>\n<p>hook 实例方法，你会发现后面跟了数字 1~10，代表被 hook 的函数的参数的个数，比如我将要 hook 的函数只有一个参数 那么就使用 CHOptimizedMethod1 参数含义为</p>\n<ul>\n<li>\n<p>第一个参数，一般传 self</p>\n</li>\n<li>\n<p>第二个参数，传返回值类型，没有返回值就是 void</p>\n</li>\n<li>\n<p>第三个参数，函数所在的类名</p>\n</li>\n<li>\n<p>第四个参数，方法名</p>\n</li>\n<li>\n<p>第五个参数，函数参数的类型</p>\n</li>\n<li>\n<p>第六个参数，函数参数的变量</p>\n<p>其中第五第六个参数在 CHOptimizedMethod1 ~10 中会重复 1~10 次</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CHOptimizedMethod1(self, void, MYViewController, appMethod, id, para) &#123;</span><br><span class=\"line\">    NSLog(@&quot;appMethod被Hook = %@&quot;, para);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n</li>\n<li>\n<p>CHOptimizedClassMethod3</p>\n<p>hook 类方法，所有函数定义同上</p>\n</li>\n<li>\n<p>CHConstructor 结构</p>\n<p>用来注册刚才的 hook 操作</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CHConstructor&#123;</span><br><span class=\"line\">  // 注册将要hook的类</span><br><span class=\"line\">    CHLoadLateClass(MYViewController);</span><br><span class=\"line\">\t// 注册将要hook 的方法</span><br><span class=\"line\">    CHHook1(MYViewController, appMethod);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面流程执行完成后就可以看到函数被 Hook 了</p>\n</li>\n</ul>\n<h2 id=\"hopper-disassembler\"><a class=\"anchor\" href=\"#hopper-disassembler\">#</a> Hopper Disassembler</h2>\n<p>上面的步骤讲了如何通过 lookin 或者 reveal 等工具来定位类名，然后通过类名在头文件中找到函数名，然后通过 hook 手段来改变函数的一些表现，但是在如何没有拿到.m 文件的前提下看到某个函数的实现呢？比如一个函数中都做了哪些操作，调用了哪些其他函数，以及调用链是怎样的？</p>\n<p>这个时候就需要用到 <code>Hopper Disassembler</code>  或者 <code>IDA Pro</code>  这样的工具了，不过目前遇到的困难是在笔者的系统环境下，这两个软件的破解版无法安装，而且 <code>IDA Pro</code>  的官方试用版还不支持 Arm 的汇编，所以只能使用 Hopper Disassembler 来举例子。打开软件，将 <code>对应App 的Mach-o</code>  文件拖入 Hopper 中等待它分析完成</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h85mc4b62oj31ec0u075n.jpg\" alt=\"image-20221115104755241\" /></p>\n<p>处理完后的界面左边会显示方法名，支持搜索查询，中间区域显示的是汇编代码，我们搜索一个在之前 dump 出的头文件中的一个函数名试下。</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[XXXXXXXX listenerDownloadLyricWithSongId:resultBlock:]</span><br></pre></td></tr></table></figure></p>\n<p>可以看到中间的部分显示出来函数所对应的汇编代码</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h861n7q3isj317b0u0dlg.jpg\" alt=\"image-20221115193733635\" /></p>\n<p>然后按快捷键 <code>Option+enter</code>  即可转为伪 OC 代码，虽然包含一些的寄存器信息，但是也足以分析了。同时双击可以跳转到对应的函数内部。</p>\n<h2 id=\"最后\"><a class=\"anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>以上就是目前的逆向调研过程，这里先记录下，后面还会深入研究，有新的发现会同步更新此文章。</p>\n",
            "tags": [
                "iOS",
                "逆向"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2022-08-24-WWDC22%EF%BC%9ARuntime%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%92%8CApp%E5%87%8F%E5%8C%85/",
            "url": "https://oliverqueen.cn/2022-08-24-WWDC22%EF%BC%9ARuntime%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%92%8CApp%E5%87%8F%E5%8C%85/",
            "title": "WWDC22：Runtime的性能优化和App减包",
            "date_published": "2022-08-24T07:04:39.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>本 Session 讲了为了让你的应用包体积更小，运行更快，启动速度更快，我们对 Swift 和 Objective-C 运行时做了怎样的优化。同时通过本 Session 你将发现如何通过高效的协议检查，更小的消息发送，以及优化后的 ARC 机制，来提高你的 App 性能。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202301102018054.png\" alt=\"\" /></p>\n<p><span id=\"more\"></span></p>\n<p><div class=\"media-container\"><div class=\"player\" data-type=\"audio\" data-src='[\"https://music.163.com/#/song?id=1929370102\"]'></div></div></p>\n<h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>WWDC2022 上苹果更新了 Xcode14，里面提到了一些相关的优化。其中讲了通过对 Swift 和 Objective-C 运行时做了一些优化，达到了包体积变得更小、运行速度更快，启动速度更快的目的。如果你是用 Xcode14 来构建 App，那么会有其中三点优化</p>\n<ul>\n<li>高效的协议检查（针对 Swift protocol check）</li>\n<li>更快的消息发送机制（message send）</li>\n<li>release 和 retain 调用优化（release &amp; retain）</li>\n<li>Autorelease elision 的优化（自动释放省略）</li>\n</ul>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202301102019048.png\" alt=\"\" /></p>\n<p>当你用 Swift 或 Objective-C 编写代码时，其实是会经历三个个步骤。</p>\n<ul>\n<li>编码，通过 Xcode 编写代码</li>\n<li>编译，使用了 Swift 和 Clang 编译器</li>\n<li>运行，通过 Swift 和 Objective-C 运行时中完成</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gp9rcbq1j215t0u0754.jpg\" alt=\"image-20220823144936761\" /></p>\n<p>此次的这些关键优化其实就是在第三步骤运行时来完成的，运行时嵌入在我们所有平台的操作系统中。编译器在构建时不能做的事情，运行时可以做。而此次所有的修改其实对于开发者来说是无感透明的，所以任何代码都不用改动，只要你使用 Xcode14 来进行打包编译，便会享受的这些优化点。</p>\n<h2 id=\"swift协议检查protocol-checks\"><a class=\"anchor\" href=\"#swift协议检查protocol-checks\">#</a> Swift 协议检查（Protocol checks）</h2>\n<p>先来看一个例子！</p>\n<p><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个协议</span></span><br><span class=\"line\"><span class=\"keyword\">protocol</span> <span class=\"title class_\">CustomLoggable</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 协议中定义一个属性 customString，只读属性</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> customLogString: <span class=\"type\">String</span> &#123; <span class=\"keyword\">get</span> &#125;        </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个log函数，参数为Any类型</span></span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">log</span>(<span class=\"params\">value</span>: <span class=\"keyword\">Any</span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">//如果value遵循CustomLoggable协议，就输出字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> value <span class=\"operator\">=</span> value <span class=\"keyword\">as?</span> <span class=\"type\">CustomLoggable</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">debugPrint</span>(value.customLogString)        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"operator\">...</span>        </span><br><span class=\"line\">    &#125;       </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个Event类型 遵循协议，并实现customLogString</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Event</span>: <span class=\"title class_\">CustomLoggable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> date: <span class=\"type\">String</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> customLogString: <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;<span class=\"subst\">\\(<span class=\"keyword\">self</span>.name)</span>, on <span class=\"subst\">\\(<span class=\"keyword\">self</span>.date)</span>&quot;</span>    </span><br><span class=\"line\">    &#125;        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>看上面代码，因为 log 函数的参数需要输出字符串，所以在输出前要先判断这个 value 是否遵循 CustomLoggable 协议，Swift 是静态语言，所以一般来说这样的检查都是发生在编译时期。但是编译器不一定能拿到足够的协议元数据信息来完成检查。比如这里并不知道每次传入的 Any 类型是哪个确定类型，也就无法确定是否遵循  <code>CustomLoggable</code>  协议。所以这种检查常常发生运行时，系统借助计算好的协议检查元数据 (protocol check metadata)，运行库知道这个特殊对象是否符合协议。</p>\n<p>这些元数据的构建虽然大部分在编译期间，但是还是有一部分是要在运行时完成，比如上面的例子，而且一个项目中肯定不止有一个协议，所以随着协议越多运行时的效率就越低，对于用户来说这个时间大部分是启动时间，所以用户感知为启动时间变长。而 Xcode14 新推的的 Swift Runtime 解决了这个问题，只要你是用 Xcode14 编译且运行在 iOS16 及以上版即可。</p>\n<p>按照苹果的说法，他们会把 <code>是否遵循协议</code> 的这个判断前置到 build 时期，也就是把 <code>协议元数据计算</code> 的步骤前置到 build 中，具体就是他把这些操作放在 App 可执行文件和启动时任何动态库的 dyld 闭包的一部分</p>\n<p>为什么这样做可以节省启动时间，需要先了解下 app 启动流程，需要一个知识背景 <code>从iOS11开始dyld3被加入，iOS13第三方库也开始使用dyld3加载。</code> 所以我们要看下 dyld3 的加载流程</p>\n<p><img data-src=\"https://upload-images.jianshu.io/upload_images/2438680-b5edfa4c2bcdb205.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1044/format/webp\" alt=\"img\" /></p>\n<p><em>dyld 3</em> 主要包含了两个过程 进程外（启动前）和进程内（启动后），我们来看启动前做了那些事情</p>\n<ul>\n<li>进程外 <em>Mach-O</em> 分析器和编译器 （<em>out-of-process mach-o parser</em>）<br />\n<em>dyld 3</em> 中将采用提前写入把结果数据缓存成文件的方式构成一个 <em>lauch closure</em>（可以理解为缓存文件）</li>\n<li>分析依赖库</li>\n<li>执行符号查找</li>\n<li><em>Write closure</em> 缓存服务 (<em>launch closure cache</em> )<br />\n 系统程序的 <em>closure</em> 直接内置在 <em>shared cache</em> 中，而对于第三方 APP，将在 APP 安装或更新时生成，这样就能保证 <em>closure</em> 总是在 APP 打开之前准备好。说白了就是把上面做的结果全都缓存起来</li>\n</ul>\n<p>综上看来以前需要在 in-process 中做的事情，现在在 out-of-process 就可以完成，启动时或者运行时直接读取缓存数据即可，加快了启动速度和运行时的性能。其实在笔者看来当我们下载或者更新 App 的时候 App 上的进度条其实是分两部分 <code>正在下载</code> 和 <code>正在安装</code> ，此次的优化可能略微提高安装的时长来降低启动速度，提高运行时性能。</p>\n<p><code>on apps that rely heavily in Swift, this could add up to half the launch time</code>  如果有条件的同学可以试下是否可以提高这么多的启动耗时。</p>\n<h2 id=\"消息发送优化message-send\"><a class=\"anchor\" href=\"#消息发送优化message-send\">#</a> 消息发送优化（Message send）</h2>\n<p>直接抛结果，苹果这边给到的数据是使用 Xcode14 编译打包的数据可以让 ARM64 上发送消息消耗从 12 字节降低到 8 字节，二进制大小也有 2% 的降低，也就是苹果对包大小和性能都做了优化，默认是同时开启的，由苹果来平衡两者的关系，当然也可以使用 <code>objc_stubs_small</code>  来仅仅优化包大小。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5grqpljrej215t0u0aax.jpg\" alt=\"image-20220823161510950\" /></p>\n<p>下面我们看下是怎么优化的，同样使用官方代码举例</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 声明一个日历对象</span><br><span class=\"line\">NScalendar *cal = [self makeCalendar];</span><br><span class=\"line\"></span><br><span class=\"line\">// 声明一个日期对象并赋值</span><br><span class=\"line\">NSDateComponents *dateComponents = [[NSDateComponents alloc] init];</span><br><span class=\"line\">dateComponents.year = 2022;</span><br><span class=\"line\">dateComponents.month = 2022;</span><br><span class=\"line\">dateComponents.day = 2022;</span><br><span class=\"line\">S</span><br><span class=\"line\">// 把日期转换为date</span><br><span class=\"line\">NSDate *theDate = [cal dateFromComponents: dateComponents];</span><br><span class=\"line\"></span><br><span class=\"line\">// 返回date</span><br><span class=\"line\">return theDate;</span><br></pre></td></tr></table></figure></p>\n<p>大家知道 OC 调用方法最终会走到 <code>_objc_msgSend</code> ，所以上面代码不算最终的 return，会走 7 个  <code>_objc_msgSend</code> ，其中每一个都需要一条指令来调用就是 bl 如下图</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gsa0ef9kj20n00gidgx.jpg\" alt=\"image-20220823163343886\" /></p>\n<p>该函数定义为 <code>Id objc_msgSend(id self, SEL _cmd, ...) </code> ，参数定义为 self 是函数的调用方，SEL 为具体调用哪个函数，具体的方法查找流程就不在这里赘述。</p>\n<p>我们拿其中具体的一个函数调用来分析</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSDate *theDate = [cal dateFromComponents: dateComponents]; </span><br></pre></td></tr></table></figure></p>\n<p>比如这个函数调用，转化为 mesagesend 的时候就变成这样</p>\n<p><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_msgSend(cal, @selector(dateFromComponents))</span><br></pre></td></tr></table></figure></p>\n<p>为了告诉运行时调用哪个方法，我们必须传递一个 Selector 给这些 objc_msgSend 调用，就如上图的 <code>@selector(dateFromComponents)</code></p>\n<p>我们再来看 <code>Id objc_msgSend(id self, SEL _cmd, ...)</code>  执行后他是怎么执行汇编指令的。</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用adrp找到该方法的地址   消耗4字节</span><br><span class=\"line\">adrp x1, [selector &quot;dateFromComponents&quot;]  </span><br><span class=\"line\"></span><br><span class=\"line\">// 将 地址加载到X1寄存器中  消耗4字节</span><br><span class=\"line\">ldr  x1, [x1, selector &quot;dateFromComponents&quot;] </span><br><span class=\"line\"></span><br><span class=\"line\">// 执行bl指令跳转到该方法并执行  消耗4字节</span><br><span class=\"line\">bl _objc_msgSend</span><br></pre></td></tr></table></figure></p>\n<p>从上面的代码看出每次执行方法调用都会 走以上三个步骤，每个步骤消耗 4 字节 一共消耗 12 字节，而前两步是准备 selector，任何一次方法调用都会执行他，目前的策略是每调一个方法都会生成上面三步，那么此时优化空间就来了。</p>\n<p>因为这里存在相同的代码（前两步）， <code>我们可以考虑共享它，并且只在每个 selector 中触发它一次，而不是每次发送消息时都生成这段指令代码</code> 。所以我们可以把这部分相同代码提取出来，放到一个小助手函数中 (helper function), 并调用该函数。通过使用同一 selector 进行多次调用 (通过传递参数不同，内部指令是相同的，现在封装成一个存根函数，以前是散落在各个 _objc_msgSend 调用处)，我们可以保存所有这些指令字节。所以可以理解为 <code>把前两步封装一下</code></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gvtbfnh1j20n00git9h.jpg\" alt=\"image-20220823183604633\" /></p>\n<p>所以原来的调用就变成了</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bl _objc_msgSend$dateFromComponents 4字节</span><br><span class=\"line\">bl _objc_msgSend    4字节</span><br></pre></td></tr></table></figure></p>\n<p>这也就是苹果说的从 12 字节优化到 8 字节，其中 <code>_objc_msgSend$dateFromComponents</code>  也被称为 <code>selector stub 存根函数</code></p>\n<p>同样 <code>_objc_msgSend</code>  本身也有一个存根函数写法</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gw1kpzuzj20n00giwfd.jpg\" alt=\"image-20220823184401200\" /></p>\n<p>这样一来我们现在就有两个存根函数</p>\n<ul>\n<li>_objc_msgSend$dateFromComponents:</li>\n<li>_objc_msgSend:</li>\n</ul>\n<p>这两个函数封装了一些通用的东西，共享了最多的代码，使代码尽可能的小，但是这样带来的不足是我需要连着两个 bl 跳转，这对操作系统来说开销较大。所以为了平衡包体积和性能，我们可以使用下面这种方法来提升这一点。我们可以把前面调用的两个存根函数封装成一个 (都封装成_objc_msgSend$dateFromComponents)，这样，我们可以使代码更紧凑，不需要那么多调用。如下图这样</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gwei63esj20bo07u74l.jpg\" alt=\"image-20220823185626349\" /></p>\n<p>这就回到了之前的问题，你可以通过 <code>_objc_stubs_small</code>  标记了只降低包大小，或者采用默认的方式让系统自动平衡，两者的区别在汇编层面就体现在如下图</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gwg7hnugj20n00gidhc.jpg\" alt=\"image-20220823185804687\" /></p>\n<p>综上：这就是 Meesage send 占用从 12 bytes 降低到 8 bytes 和二进制大小下降 12% 的原因</p>\n<h2 id=\"retain-and-release\"><a class=\"anchor\" href=\"#retain-and-release\">#</a> Retain and release</h2>\n<p>这个优化是苹果这边使 Retain and release 的开销更小，苹果的说法是 Retain and release 的调用开销从 8 字节降低到 4 字节，同时包体积也会有 2% 的优化</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gwkqxaenj20n00gidg9.jpg\" alt=\"image-20220823190226429\" /></p>\n<p>我们知道 ARC 相比于 MRC 是开发者不需要再写 retain、release 这些代码，其实并不是不需要，而是编译器帮我们自动在需要的位置插入了这些代码，所以换句话说他们还是存在的，只是你看不到也不用在关心他们。</p>\n<p>还是拿之前的例子来说</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Retain/release calls inserted by ARC</span><br><span class=\"line\">NScalendar *cal = [self makeCalendar]; // bl    _objc_retain</span><br><span class=\"line\"></span><br><span class=\"line\">NSDateComponents *dateComponents = [[NSDateComponents alloc] init]; // bl    _objc_retain</span><br><span class=\"line\">dateComponents.year = 2022; </span><br><span class=\"line\">dateComponents.month = 2022;</span><br><span class=\"line\">dateComponents.day = 2022;</span><br><span class=\"line\"></span><br><span class=\"line\">NSDate *theDate = [cal dateFromComponents: dateComponents]; // bl    _objc_retain</span><br><span class=\"line\">return theDate;</span><br><span class=\"line\">// bl    _objc_release </span><br><span class=\"line\">// bl    _objc_release </span><br><span class=\"line\">// bl    _objc_release </span><br></pre></td></tr></table></figure></p>\n<p>在变量创建的时候我们使用 retain 来增加的他的引用计数不被销毁，在方法结束后我们使用 release 来销毁不需要的变量，这也是 iOS 的内存管理机制。在 ARC 下这些都是编译器我们插入的代码，我们无需关心。</p>\n<p>retain 和 release 都是 C 语言的函数，他们携带一个参数就是被操作的对象，同时他遵循 C 语言的 ABI，所以当你调用这些方法的时候系统还会为你做一些额外的事情，比如下图中的 mov 操作，而这些操正是我们优化的用武之地，通过自定义调用重新约定 retain/release 接口，我们可以根据对象指针的位置，适当的使用正确的变量，这样就可以不用移动它。简单的说， <code>就是修改了底层 ABI</code> 。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gwylzjkuj20n00giab1.jpg\" alt=\"image-20220823191546398\" /></p>\n<p>我们是怎么做的优化呢？看下之前的流程，我们用下面这行代码举例</p>\n<p><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_release(dateComponents); </span><br><span class=\"line\"><span class=\"comment\">// mov  x0, x20                    消耗4 字节                                                                                                                                                           </span></span><br><span class=\"line\"><span class=\"comment\">// bl    _objc_release         消耗4字节</span></span><br></pre></td></tr></table></figure></p>\n<p>流程为</p>\n<ul>\n<li>先执行 mov 把副本地址（X20, 也就是对象的地址）存到寄存器 x0</li>\n<li>然后 bl 跳转到 <code>_objc_release</code>  函数进行释放</li>\n</ul>\n<p>根据之前讲的每个指令消耗 4 字节，所以这里消耗 8 字节</p>\n<p>我们修改 ABI 之后其省掉调用 mov 指令 然后原本跳转到_objc_release 函数 改为跳转到 <code>_objc_release_x20</code>  函数，而 mov 的指令放到 C 语言更底层的 ABI 里面去做，你可以理解为 <code>我们封装了一个新的retain、release函数，你只要传入一个寄存器地址我就去更底层的地方完成mov操作，所以效率更高了</code> 。现在因为只用执行一条指令，所以内存消耗为 4 字节。现在的流程看起来为</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gx83ebs8j20n00giab9.jpg\" alt=\"image-20220823192452605\" /></p>\n<p>这么看来我们代码里大量的 release 和 retain 都经过这样的样的优化所以整体的二进制包降低 2% 同时调用内存消耗游 8 字节变为 4 字节，同时 ABI 接口修改，去除冗余 mov 指令调用，下沉到 ABI。 <code>由于 ABI 是内嵌系统</code> ，这里新增 mov 指令占用可以忽略不计。</p>\n<p><code>Apple 果然是坚持用户体验优先，为了更好体验不惜修改 c 的 ABI</code></p>\n<h2 id=\"autorelease-elision自动释放省略优化\"><a class=\"anchor\" href=\"#autorelease-elision自动释放省略优化\">#</a> Autorelease elision（自动释放省略优化）</h2>\n<p>iOS 中除了使用 release 之外还有另一个 就是 autorelease 自动释放机制，同样在这个地方苹果也做了自动释放省略的优化让自动释放机制效率更高。我们来看下面这个例子</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Return Value Autoreleases </span><br><span class=\"line\"></span><br><span class=\"line\">theWWDCDate = [event getWWDCDate];</span><br><span class=\"line\"></span><br><span class=\"line\">-(NSDate*)getWWDCDate &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    return theDate;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>创建一个临时对象 (theDate)，并将其返回给调用方 (event)。 <code>getWWDCDate()</code>  方法中返回临时的 theDate，然后调用完成 (返回 theDate 之后，getWWDCDate 就调用完成)。这时调用方（event）将其保存到自己的变量中（theWWDCDate 中）。</p>\n<p>根据系统插入 retain 和 release 的机制来说应该是这样的，但是明显 retain 处不能进行 release，因为我需要吧 theDate 返回回去，如果这里释放了我就没办法呢返回了。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gy19928nj20n00gi3yz.jpg\" alt=\"image-20220823195254398\" /></p>\n<p>因此，为了解决上述问题，需要使用一个特殊的约定用来返回这个临时返回值。这就引入了 Autorelease，这样调用者能够 retain 它。autorelease 在这里保证在调用方可以正常返回该值，而不被提前释放，延长释放生命周期。你之前可能看到过 autorelease 和 autoreleasePools：其实这是一种将 release 操作推迟到稍后某个时间的方法。所以上面的代码改为 Autorelease</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Return Value Autoreleases </span><br><span class=\"line\"></span><br><span class=\"line\">theWWDCDate = [[event getWWDCDate] retain];</span><br><span class=\"line\"></span><br><span class=\"line\">-(NSDate*)getWWDCDate &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    return [theDate autorelease]; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>系统并不知道他在什么时候会被释放，反正只要不在 retain 的时候释放就行，所以我在 retain 的时候先打个标记，标记他之后可能会被释放。但是这样的操作目前会带来一些开销，其实就是 <code>我虽然打了release标记，但是我明明一会还要retain，没必要多此一举</code> ，所以基于此我们之前引入了 <code>Autorelease elision</code>  来减少这部分开销（ <code>如果Autorelease后紧接一个retain我就都不做了</code> ）。我们先从汇编层面看下 Autorelease elision 做了什么</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gy8n9wnzj20n00giwf7.jpg\" alt=\"image-20220823195959365\" /></p>\n<p>提炼出以下代码</p>\n<p><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// What the compiler emits</span></span><br><span class=\"line\"> bl    _getWWDCDate </span><br><span class=\"line\"> mov   x29, x29</span><br><span class=\"line\"> bl    _objc_retainAutoreleasedReturnValue</span><br><span class=\"line\"></span><br><span class=\"line\"> b    _objc_autoreleaseReturnValue   <span class=\"comment\">// autorelease -&gt; runtime -&gt; _objc_autoreleaseReturnValue</span></span><br></pre></td></tr></table></figure></p>\n<p>其实就是以下步骤</p>\n<ul>\n<li>当我们返回值调用 Autorelease 时候系统会调用 <code>_objc_autoreleaseReturnValue</code>  来返回一个 <code>autoreleased value</code></li>\n<li>执行 Autorelease 后编译器会添加个标记 <code>mov x29, x29</code>   而这句指令在实际运行中这个指令会变为二进制的形式变为 <code>0xAA1D03FD</code></li>\n<li>后续的操作就运行时会先判断是否有对应的标记 <code>0xAA1D03FD</code> ，如果有，这意味着编译器告诉 runtime, 我们将返回一个已经被标记，但是将立即被持有（retain） 的临时变量，后面就不需要再 retain 操作了</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5h056kleej20n00gigm5.jpg\" alt=\"image-20220823210550374\" /></p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static ALWAYS_INLINE bool </span><br><span class=\"line\">callerAcceptsOptimizedReturn(const void *ra)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // fd 03 1d aa    mov fp, fp</span><br><span class=\"line\">    // arm64 instructions are well-aligned</span><br><span class=\"line\">    if (*(uint32_t *)ra == 0xaa1d03fd) &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">        // 返回true 需要优化 把release、rentain删掉</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>说白了就是在返回值身上调用 <code>objc_autoreleaseReturnValue</code>  方法时，runtime 将这个返回值 object 标记（储存在 TLS 中），然后直接返回这个 object（不调用 autorelease）；同时，在外部接收这个返回值的 <code>objc_retainAutoreleasedReturnValue</code>  里，发现有之前的标记（TLS 中正好存了这个对象），那么直接返回这个 object（清楚之前的标记且不再调用 retain）。</p>\n<p>注意：TLS 相关的含义可以参考 [这里](<span class=\"exturl\" data-url=\"aHR0cDovL3NlYW5jaGVuc2UuZ2l0aHViLmlvLzIwMTgvMDkvMjAvZWFybGdyZXktc291cmNlLWNvZGUtcmVhZC0xLyNUTFM=\">EarlGrey 源码阅读（一） | SeanChense</span>)</p>\n<p>但是这里有一个问题，以二进制的形式来加载代码并不是很常见，而且我们不但要加载它还要比较他尤其在 CPU 上并不是最优策略，所以这里还是有开销的，因此我们看下如何优化。</p>\n<p>同样执行流程，当执行完 <code> _objc_autoreleaseReturnValue</code>  函数时候我们会获得一个返回地址，这个地址是一个指针，指向了被标记为 Autorelease 的对象。然后代码继续执行到 <code>_objc_retainAutoreleasedReturnValue</code>  这里要进行 reatin，而被 reatain 的变量地址我们也可以拿到，所以只要比较这两个指针即可，这样一来我们也不再需要 mov 操作</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5h0ws62g0j20n00gidg3.jpg\" alt=\"image-20220823213224122\" /></p>\n<p>优化点</p>\n<ul>\n<li>把原来的比较二进制数据改为比较指针。速度更快效率更高</li>\n<li>减少 mov 指令 减少 4 字节，二进制大小预计降低 2%</li>\n</ul>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>这就是 Xcode14+iOS16 的编译期间优化，可以看出苹果也在帮我们完成 OKR 减少包体积，提高启动速度，增加代码执行效率，同时也能看出苹果在追求极致用户体验道路上所做的事情。本文部分翻译自<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL3ZpZGVvcy9wbGF5L3d3ZGMyMDIyLzExMDM2My8=\"> Improve app size and runtime performance</span>，同时也添加了自己的思考。</p>\n",
            "tags": [
                "iOS",
                "WWDC2022"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2022-06-13-WWDC2022-iOS%E7%AF%87%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/",
            "url": "https://oliverqueen.cn/2022-06-13-WWDC2022-iOS%E7%AF%87%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/",
            "title": "WWDC2022-iOS篇完全解析",
            "date_published": "2022-06-13T09:05:31.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景</h1>\n<p>Apple 于北京时间 2022 年 6 月 7 日举办了 WWDC2022，作为一名 Apple 开发者，不仅仅是为了保持技术敏感度，同时也希望在第一时间将新的内容呈现在大家眼前。本文对发布会内容做了整理归纳，并着重对 iOS 的新内容进行分析。希望这篇文章对大家有所帮助的同时也给我们的产品带来更多的可能性。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h344hz8cl3j21g20pswhk.jpg\" alt=\"9690f67c1bc2cc62bd8729e5182ef19a\" /></p>\n<p><span id=\"more\"></span></p>\n<p>相对于 iOS15 来说，iOS16 的整体变化比较大，尤其是在我们看得见的地方，比如一些 UI 样式，交互行为和一些新增的功能。下面会按照 WWDC 的出厂顺序来介绍，其中包含了每个改动点的细节以及个人的理解和后面的展望。</p>\n<h1 id=\"developer\"><a class=\"anchor\" href=\"#developer\">#</a> Developer</h1>\n<h2 id=\"xcode相关\"><a class=\"anchor\" href=\"#xcode相关\">#</a> Xcode 相关</h2>\n<p>新版的 Xcode 同样也跟新了相关的内容，帮助开发者提高开发效率。</p>\n<h4 id=\"方法吸顶以及代码提示\"><a class=\"anchor\" href=\"#方法吸顶以及代码提示\">#</a> 方法吸顶以及代码提示</h4>\n<p>在之前的版本中，如果方法函数过多超了一屏展示，随着滚动函数名不可见，而新版的 Xcode 提供了类似 TableViewHeader 的效果，让方法名和实现名字固定在顶部，方便随时查看和复制。对小屏还是比较友好的。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342t0jx5qj215h0u040m.jpg\" alt=\"enter image description here\" /></p>\n<p>同样在使用初始化方法的时候如果是支持传入参数的初始化方法也会通过斜体来进行参数提示 (Swift 专属)</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342t2czj8j20u00akt9s.jpg\" alt=\"enter image description here\" /></p>\n<h4 id=\"xcode安装体积\"><a class=\"anchor\" href=\"#xcode安装体积\">#</a> Xcode 安装体积</h4>\n<p>新版的 Xcode 优化了包体积，同时在进行安装的时候可以自定义需要哪些平台，需要哪些模拟器，笔者亲测相比之前的无脑把 AppleTV、Apple Watch、ipad 等都安装下来的情况来看，整个包体积减少了十几个 G 左右。对于小存储的 MacBook 是一个福音。</p>\n<h4 id=\"xcode编译与调试\"><a class=\"anchor\" href=\"#xcode编译与调试\">#</a> Xcode 编译与调试</h4>\n<p>根据苹果的描述新版 Xcode 优化项目的编译速度， <code>得益于更强大的并行编译能力，项目构建速度提升至高可达 25%</code> 。</p>\n<ul>\n<li>改善前：先编译 framework 里的代码，然后生成 module，然后编译 app 里的代码，最终经过链接完成了构建。</li>\n<li>改善后：通过提高并发，缩短了构建的关键的路径</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tn4mxij20yl0u0415.jpg\" alt=\"enter image description here\" /></p>\n<p>同时单元测试的效率也提高了 30%</p>\n<p>Xcode14 还支持输出编译期间每个阶段的耗时和详细信息，相比之前的只能通过控制台的名字描述要直观不少。<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342x91jz4j21910u0wir.jpg\" alt=\"编译耗时\" /></p>\n<p>对于 LLDB，现在还可以看到执行的过程和信息，对于一些需要长时间跑的命令较为友好，类似于 <code>--verbose</code>  参数的含义</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tgt828j21dg0323yy.jpg\" alt=\"enter image description here\" /></p>\n<p>在新版的 Xcode 中除了 App 和系统的日志，同样支持 LLDB 的日志输出，当时在用 LLDB 调试的时候发生 Crash，便可以到相关路径中找到对应日志。<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342t3pka9j21ay02kjrp.jpg\" alt=\"enter image description here\" /></p>\n<h2 id=\"开发者模式\"><a class=\"anchor\" href=\"#开发者模式\">#</a> 开发者模式</h2>\n<p>新版的 iOS 和 Watch OS 引入了新的开发者模式，原理和安卓的开发者模式类似，用苹果的话说是为了 <code>开发者模式可防止人们无意中在其设备上安装可能有害的软件，并减少开发者专用功能所暴露的攻击媒介。</code> ，对于普通人来说确实可以提高安全性，之前只要是加入了开发者账号的手机都可以从 Xcode 编译运行第三方的 App，或者按照企业证书的签名包，而不这些手机主人都是无感的，现在需要手机主人通过多重确认来打开此功能后才可以进行安装非 <code>App Store</code>  和 <code>Testfilght</code>  渠道的包。</p>\n<p>但是这个对于开发者来说并不友好，首先是调试过程有会多增加一些步骤，而且在自动化测试方面，所有的手机都要先通过命令来打开开发者模式，并且根据苹果的说法，使用命令行进行开关要确保手机没有密码，否则会被拒绝运行。这里笔者也尝试在未打开 <code>开发者模式</code> 的情况下进行 Xcode 编译，确实会失败。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342ygml7gj208y01kdfo.jpg\" alt=\"enter image description here\" /></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3358k3glij207s087aaa.jpg\" alt=\"\" /></p>\n<p>笔者预测该功能可能是为后续的第三方 App 市场做准备，因为现在虽然苹果不支持三方市场，但是普通用户还是可以通过一些三方网站安装重签包，同时他们并不知道这些包会带来潜在的危险，再加上欧盟一些反垄断政策的施压，所以苹果决定逐步开放三方应用市场，这应该就是第一步吧，先让用户意识到这样做可能会有一些危害。</p>\n<p><code>无论是美国的《美国选择与创新法案》、还是欧盟的《数字市场法案》，都要求苹果在App Store之外为用户提供额外的应用下载渠道。现在看来，苹果方面可能已经认为改变欧盟与美国的态度已经不太可能了，那么既然支持侧载或许无法避免，那么让用户更难发现侧载功能的入口就成为了备选项。</code></p>\n<h1 id=\"lockscreen\"><a class=\"anchor\" href=\"#lockscreen\">#</a> LockScreen</h1>\n<h2 id=\"锁屏样式\"><a class=\"anchor\" href=\"#锁屏样式\">#</a> 锁屏样式</h2>\n<p>重新修改了锁屏的样式，在优化了时间显示的字体的同时也在锁屏上提供了更多能力，展示更多的信息，并加入了一些新的交互样式，通过在锁屏界面长按来进入锁屏界面的编辑状态，这个动画效果有点类似安卓的编辑桌面的效果。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3430h983bg208a0gnhe7.gif\" alt=\"image\" /></p>\n<p>iOS16 的锁屏样式可以大致分为两类</p>\n<ul>\n<li>动态锁屏<br />\n比如在 Beta1 中可以看到的天气锁屏，依赖于天气 App 的信息，在点亮屏幕的一瞬间可以在锁定屏幕上动态显示天气的效果，比如雨雪风晴等，持续几秒钟后停止。笔者预测该能力后续会和 Livephoto 关联起来，实现用户自定义动态照片，毕竟现在的 livephoto 设置锁屏之后只有在长按才会触发播放，到时候长按的手势会和设置锁屏的手势冲突，所以 livephoto 必然会变成自动播放，</li>\n</ul>\n<p>再长远预测的话也可能后续会把该能力开放给第三方 App 来定制动态锁屏的图片，类型于现在的天气 App。比如 QQ 音乐的专辑封面，歌手的演唱动图等。目前动态背景只支持锁屏界面，解锁后进入桌面便会停止，估计是处于性能考虑，动态桌面的可能性不大，应该仅限于锁屏。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tiho1zg207u0gou0z.gif\" alt=\"image\" /></p>\n<ul>\n<li>静态照片<br />\n iPhone 一直可以支持设置静态照片为锁屏壁纸，但是 iOS16 给静态照片锁屏提供了更多的玩法。</li>\n<li>照片随机切换：用户可以选定一组照片来作为锁屏壁纸，类似于幻灯片放映的样式，切换的频率可以设置为  <code>每次点亮</code>  、  <code>每次点击</code>  、  <code>每小时</code>  、  <code>每天</code>  。</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tuul3fg207z0gnqvl.gif\" alt=\"image\" /></p>\n<ul>\n<li>照片景深：这个能力算是 iOS16 更新比较大的，通过机器学习模型将照片中的主体突出，可以遮挡在时间上，这里的主体可以是图片中任何可区分的物体，不仅仅是人像模式的照片。(在实际使用中，经常会失败，beta1 还是不够稳定)</li>\n</ul>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzExYno5bmoyMGkyMTJ5YWNpLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h34311bz9nj20i212yaci.jpg</span>&quot; alt=&quot;image#268px #578px&quot; style=&quot;zoom:50%;&quot; /&gt; &lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzI0OHBnOWoyMG11MTh1ZG1oLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h343248pg9j20mu18udmh.jpg</span>&quot; alt=&quot;image#292px #574px&quot; style=&quot;zoom:43%;&quot; /&gt;</p>\n<ul>\n<li>表情壁纸：将 IPhone 输入法中自带的表情进行一定规律的排列组合形成一张壁纸，最多支持输入六个表情。</li>\n<li>颜色壁纸：可以定义一些渐变颜色</li>\n<li>官方背景图壁纸。一些官方图片，支持景深效果</li>\n</ul>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MnRxcXZldWoyMGh3MTB3cTViLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tqqveuj20hw10wq5b.jpg</span>&quot; alt=&quot;image#189px #390px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h2 id=\"锁屏组件\"><a class=\"anchor\" href=\"#锁屏组件\">#</a> 锁屏组件</h2>\n<p>iOS16 在锁屏界面可以展示更多的信息，其中就包括了锁屏小组件的加入。可以看到锁屏顶部分三个区域。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzJkMTZoc2oyMGllMTNhZGllLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3432d16hsj20ie13adie.jpg</span>&quot; alt=&quot;image#270px #577px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<ul>\n<li>顶部：顶部区域是一个小的小组件区域，同时只能容纳一种小组件放置，🇳信息量有限。</li>\n<li>中部：中部区域是固定展示时间的区域，不可放置自定义小组件。只能展示时间信息，但是用户可自定义字体（包括阿拉伯文、天成文）和颜色。</li>\n<li>底部：底部区域为第二个小组件区域，范围较大，最多可容纳 4 个正方形（1*1）的小组件。同时支持排列组合。</li>\n</ul>\n<p>目前小组件的支持非常有限，目前只能将系统级的 App 的组件放上去，并不支持第三方 App，笔者尝试写了一个小组件，在主屏幕上可以正常添加，但是在锁定屏幕无法使用，猜测两个原因，一是目前是 Beta1 版可能还没有开放三方 App 的小组件，后续会陆续优化上来；第二个原因可能是处于性能或者其他因素考虑锁频组件和主屏组件不是一套逻辑，并不互通，但是通过查看 Xcode Beta 版本的代码，没有看到相关线索，不过 WWDC 也提到了，一些功能在后续会以 API 的形式像开发者提供。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MnR5bThndGoyMGk2MTMwNzdoLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tym8gtj20i613077h.jpg</span>&quot; alt=&quot;image#266px #571px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h2 id=\"锁屏通知\"><a class=\"anchor\" href=\"#锁屏通知\">#</a> 锁屏通知</h2>\n<p>iOS16 调整了锁屏的样式，增加了锁屏界面所展示的信息和交互，所以希望锁屏界面不要被大量的通知遮挡，因此从新调整了通知推送的位置和出现动画。iOS16 之前：通知铺满锁屏，同时新的通知会插到到最上面。从上往下依次排列。iOS16 之后：锁屏区域被限定在底部一小块区域，新来的通知会插到第一层，但是默认只展示 3 个（叠放的形式），想看更多的话跟之前一样，上拉即可。任何新增的通知，包括常驻的音乐播放调都是从下往上增长，通知增长到一定高度就会开始折叠，这样的好处就是可以给锁屏留出空间，不至于被占满。</p>\n<p>这样的修改确实可以让锁屏界面看的更整洁，且能让用户看到自己喜欢的锁屏画面，但是带来一个问题是用户想要查看通知内容时候需要多做一步上拉的操作，可能会稍微影响到 Push 的效果，比如点击率之类的指标。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3432t13nsg207m0go7wr.gif\" alt=\"image\" /></p>\n<h2 id=\"live-activities\"><a class=\"anchor\" href=\"#live-activities\">#</a> Live Activities</h2>\n<p>上面说的苹果弱化了通知展示的样式，默认采用了折叠策略给锁屏留出了更大的空间，但是为了让用户实时的追踪想要的信息便推出了  <code>Live Activities</code>  。该控件可以常驻在锁屏界面，且能够实时刷更新的一个 UI 控件，</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tq7i9qj214g0mg3zz.jpg\" alt=\"image\" /></p>\n<p>WWDC 上举了一个恰当的例子，比如我在追踪一场比赛，我需要知道实时的比分信息，但是又不方便拿着手机 app 观看直播，所以支持了  <code>Live Activities</code>  能力的 App 可以再锁屏界面来实时展示比赛信息，同时不需要解锁屏幕，还有优步的信息。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzMxbGNyM2oyMHdjMG13bjFnLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h34331lcr3j20wc0mwn1g.jpg</span>&quot; alt=&quot;image#321px #227px&quot; style=&quot;zoom: 33%;&quot; /&gt;&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzM3NWh2ZWoyMHc2MG0wanZhLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h343375hvej20w60m0jva.jpg</span>&quot; alt=&quot;image#334px #228px&quot; style=&quot;zoom: 35%;&quot; /&gt;</p>\n<p>这有点类似于锁屏的音乐播放条。同时 IOS16 针对音乐播放调界面也做 UI 优化，可以通过点击来实现封面图展开，同时背景设置为封面的魔法色，实现全屏沉浸式播放。但是笔者实测时候并未在 beta 版上成功使用该功能，SDK 中也没有看到相关代码。应该是在后续的版本开放更新。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzVsb3c4Z2oyMGhrMHhlNDFqLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3435low8gj20hk0xe41j.jpg</span>&quot; alt=&quot;image#305px #580px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h2 id=\"专注模式\"><a class=\"anchor\" href=\"#专注模式\">#</a> 专注模式</h2>\n<p>苹果去年推出了  <code>专注模式</code>  ，但是专注模式的切换需要到控制中心，或者设置菜单中进行切换，隐藏较深，在这次的 iOS16 中，苹果将专注模式和锁定屏幕绑定起来，也就是实现专注模式和锁定屏幕  <code>一一对应</code>  的关系，一个锁屏对应一套锁屏组件和一个专注模式。</p>\n<p>比如我下图中两个锁定屏幕分别对应两种模式，工作模式可以设置只接受某些 App 的推送（比如企业微信。WeSing 等），忽略某些不重要的通知。右边的游戏模式可以吧比较关注的电量信息放到锁屏，同时屏蔽通知避免游戏误操作。关键是在 iOS16 上两种模式的切换只要在锁屏上长按就可以进行更改，方便很多。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzV0a3QxZWoyMGcyMHpnYWQxLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3435tkt1ej20g20zgad1.jpg</span>&quot; alt=&quot;image#337px #744px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h1 id=\"信息app\"><a class=\"anchor\" href=\"#信息app\">#</a> 信息 App</h1>\n<h2 id=\"消息编辑\"><a class=\"anchor\" href=\"#消息编辑\">#</a> 消息编辑</h2>\n<p>根据 WWDC 的描述，信息 App 带来的三个呼声最高的功能（应该是国外用户）</p>\n<ul>\n<li>动态编辑信息：对于已经发送出去的信息，如果发现错别字，可以直接在自己刚刚发送的对话气泡上进行修改，像这样，就不需要再撤回然后重新辑后发送。</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3436v6e47g20go080e86.gif\" alt=\"image\" /></p>\n<ul>\n<li>\n<p>标记未读（国内玩腻了的）</p>\n</li>\n<li>\n<p>消息撤回（国内玩腻了的）</p>\n</li>\n</ul>\n<h2 id=\"shareapi\"><a class=\"anchor\" href=\"#shareapi\">#</a> ShareApi</h2>\n<p>iOS15 中提到了  <code>SharePlay</code>  的能力，但是当时该能力必须基于 FaceTime。在 iOS16 中，该能力已经扩展的信息 App 中。笔者认为，  <code>SharePlay</code>  的能力后续会形成套单独的 SDK（类似于 AirPlay 的 SDK），供第三方 App 接入，且不依赖 Facetim 和信息等系统 App。这对于音视频的 App 是有比较大的帮助，可以一起听歌、看视频。但是对于版权的管理要更为严格。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM3cmhidXc2Y2oyMGkyMGx3YWJ3LmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h37rhbuw6cj20i20lwabw.jpg</span>&quot; alt=&quot;image#389px #472px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h1 id=\"语音输入\"><a class=\"anchor\" href=\"#语音输入\">#</a> 语音输入</h1>\n<p>苹果在很早的版本就支持语音输入，但是有一个弊端就是语音输入和键盘输入是两个独立的过程。而在 iOS16 中输入文本时，可在语音和触控这两种方式间无缝切换。无需中断听写，照样可用键盘打字、轻点文本栏、移动光标，或插入快速输入建议。<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h37rautdseg20go080e89.gif\" alt=\"image\" /></p>\n<h1 id=\"coreml\"><a class=\"anchor\" href=\"#coreml\">#</a> CoreML</h1>\n<h2 id=\"livetext\"><a class=\"anchor\" href=\"#livetext\">#</a> LiveText</h2>\n<p>CoreML 是苹果早期发布的机型学习 API，通过他可训练一些人工智能相关的东西，其中 iOS15 推出的  <code>LiveText</code>  便是其中之一，他可以让我们对图片里面的一些文字做提取操作，在 iOS16 中，apple 增强了  <code>LiveText</code>  的能力，除了静态图片，还加入了视频帧的支持。  <code>Live Text in Video</code>  , 根据 WWDC 的描述，在播放视频的时候进行暂停，便可以提取当前帧上的文字内容。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h37rfclnkvj21mp0u0dkd.jpg\" alt=\"image\" /></p>\n<p>选中后除了对文字进行复制操作外，iOS16 还提供了一些其他的快捷功能，其中包括汇率转换、翻译。更重要的是，实况文本的 API 已经开发给开发者使用，很快我们就能从 app 的照片和视频中提取相关的文字信息。</p>\n<h2 id=\"visual-look-up\"><a class=\"anchor\" href=\"#visual-look-up\">#</a> Visual Look Up</h2>\n<p>也是苹果之前基于机器学习提供的一个能力，可以检测照片中的物体，来识别是什么东西，在 iOS16 中，该能力被大幅加强，同时集成到了照片 App 中。用户可以打开一个照片，通过长按，把照片主体拖动出来到相应的 App 中。（拖出的图片为 png 图片）</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3437xq1cag207n0gnkk7.gif\" alt=\"image\" /></p>\n<p>该能力已经提供独立的 API，目前的 Apple 的  <code>可立拍</code>   App 里面将 Core ML 的能力运用到视频处理中，大家可以下载体验。</p>\n<h1 id=\"apple-pay\"><a class=\"anchor\" href=\"#apple-pay\">#</a> Apple Pay</h1>\n<h2 id=\"apple-pay-later\"><a class=\"anchor\" href=\"#apple-pay-later\">#</a> Apple pay later</h2>\n<p>类似于国内的京东白条、蚂蚁花呗，不同的是   <code>Apple pay later</code>   只提供 4 周或者 6 周的分期还款，且无息。</p>\n<h2 id=\"钥匙共享\"><a class=\"anchor\" href=\"#钥匙共享\">#</a> 钥匙共享</h2>\n<p>通过常用的通讯类 app，安全地共享钱包 app 中的钥匙（智能家居钥匙，汽车钥匙等）。你可以决定钥匙的使用地点和时间，并能随时撤销。</p>\n<h2 id=\"追踪订单\"><a class=\"anchor\" href=\"#追踪订单\">#</a> 追踪订单</h2>\n<p>可以查看票据，还能直接在钱包 app 中追踪你的 Apple Pay 订单。商户可以将订单的相续信息推送到消费者的钱包里</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzhlcnF1ZmoyMGVnMHNrZ243LmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3438erqufj20eg0skgn7.jpg</span>&quot; alt=&quot;image#304px #601px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h1 id=\"apple-map\"><a class=\"anchor\" href=\"#apple-map\">#</a> Apple Map</h1>\n<h2 id=\"增加途经点规划\"><a class=\"anchor\" href=\"#增加途经点规划\">#</a> 增加途经点规划</h2>\n<p>国内高德百度已经玩了很久的功能，在导航的时候可以在起点和终点之间增加途经点。快车顺风车经常要用的功能。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzhzZjJlZ2oyMGR5MHQwbjA4LmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3438sf2egj20dy0t0n08.jpg</span>&quot; alt=&quot;image#297px #618px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h2 id=\"实时公交信息\"><a class=\"anchor\" href=\"#实时公交信息\">#</a> 实时公交信息</h2>\n<p>可以查看公交出行的公交信息，包括公交时间，公交线路，公交价格等，同样也是国内使用了很久的能力。</p>\n<h2 id=\"共享交通工具查看\"><a class=\"anchor\" href=\"#共享交通工具查看\">#</a> 共享交通工具查看</h2>\n<p>可以在地图上看到附近的共享汽车、共享滑板车、共享单车等。同样也是国能很多共享单车厂商实现了的能力。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzliM21lb2oyMGhxMHcwNzZxLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3439b3meoj20hq0w076q.jpg</span>&quot; alt=&quot;image#307px #554px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h1 id=\"apple-tv-amp-apple-news\"><a class=\"anchor\" href=\"#apple-tv-amp-apple-news\">#</a> Apple TV &amp;amp; Apple News</h1>\n<p>Apple TV 和 Apple News 是两个不同的东西，之所以放到一起说是因为他们在 iOS16 中提供了相同的能力，都新增了体育板块，可以每周免费观看两场比赛，同时可以和 iPhone 联动，在锁屏上展示   <code>Live Activities</code></p>\n<h1 id=\"家长控制\"><a class=\"anchor\" href=\"#家长控制\">#</a> 家长控制</h1>\n<p>家长控制的粒度更细，除了是否可以启动某个 App，还可以详细控制某个 App 的权限，比如禁止某个 App 访问摄像头权限，来避免儿童色情的问题。之后的开发者可能要在权限控制这里做额外的判断。除了允许、拒绝、未决定外，新增了家长控制的枚举条件。</p>\n<h1 id=\"homekit\"><a class=\"anchor\" href=\"#homekit\">#</a> HomeKit</h1>\n<p>接入了更多智能家居品牌。同时和其他主流品牌一起在 HomeKit 的基础上创立了新的智能家居协议标准   <code>matter</code>  。可以让智能家居跨平台协同操作。目前已经有一部分厂商支持了   <code>matter</code></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3439rmf5bj21sq0sqtcw.jpg\" alt=\"image\" /></p>\n<h1 id=\"crarplay\"><a class=\"anchor\" href=\"#crarplay\">#</a> CrarPlay</h1>\n<p>苹果也看出了现在汽车发展的趋势就是大屏幕，而且一辆车往往不止一块屏幕，所以在 iOS16 上，苹果针对这个现象重新优化了 CraePlay，新的 CarPlay 不仅仅可以通过车机来控制 iPhone，还可以通过 iPhone 来设置车机的主题。 支持新 CarPlay 的车型将于 2023 年下半年生产，前期支持的车型为</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h343a6xc3bj21vm0tmtbn.jpg\" alt=\"image\" /></p>\n<p><code>新一代 CarPlay 车载将出类拔萃的 iPhone 体验带入车内。它可为车内所有的驾驶员屏幕提供内容，包括仪表盘在内，让你的爱车和 iPhone 在体验上融为一体。车载的收音机、空调等功能可直接通过 CarPlay 车载来控制。而多种个性化选项，包括小组件以及精选的仪表盘设计，更带来独特的驾驶体验。</code></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h343ak4evxj221o0t60ya.jpg\" alt=\"\" /></p>\n<h1 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h1>\n<p>以上就是 WWDC 中关于 iOS 的相关内容，笔者第一时间更新了 iOS16 的 Beta 版本，但也遇到一些问题</p>\n<ul>\n<li>iOS16 官方最低支持到 iPhone 8 系列，但是 iPhone 8 更新后，很多功能无法使用，建议使用 iPhoneXs 以及以上机型体验。</li>\n<li>WWDC 中提到的大部分功能现在都无法在 Beta1 中体验。且最新的 XcodeBeta 中也没有相关的新 Api，不过 WWDC 上也说了，iOS16 上的功能会在后续稍晚的时候以 API 的形式提供。</li>\n<li>Beta1 耗电发热非常夸张，尤其是在锁屏界面。可能还需相关优化，目前手机必须连着电源使用。</li>\n</ul>\n<p>文中提到得到一些功能更新虽然和国内开发者关系不大，但是毕竟都是业务层面的东西，底层都是通用的，毕竟技术无国界，也希望能将更新的技术用到自己的项目中，提高用户的产品体验，向用户展示出我们的专业能力和创新能力。希望这篇文章能对 iOS 开发者和产品同学在后续的技术、产品规划上有一定的帮助。</p>\n",
            "tags": [
                "iOS",
                "WWDC2022"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2022-05-26-Apple%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/",
            "url": "https://oliverqueen.cn/2022-05-26-Apple%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/",
            "title": "Apple登录流程详解",
            "date_published": "2022-05-26T02:53:20.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"1背景\"><a class=\"anchor\" href=\"#1背景\">#</a> 1：背景</h2>\n<p>2019 年苹果推出 苹果登录（Sign in with Apple）方式，要求 2020 年 4 月之后运行在 iOS13 及以上系统的 APP 如果使用第三方或社交登录服务（如 Facebook、谷歌、 Twitter、Linkedln 或亚马逊等），必须向用户提供 “以苹果账号登录” 服务的选项。其中苹果的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDJmempqd3d1YWoyMTY0MHA0NDRkLmpwZw==\">审核细则 4.8</span> 也明确的规定了这一点。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2lmep99kij21ns0rkaba.jpg\" alt=\"\" /></p>\n<p><span id=\"more\"></span></p>\n<p>&lt;font color=&quot;#dd0000&quot;&gt; 不过需要注意的一点是腾讯系列的产品如果只是使用微信、QQ 登录并不算第三方登录，所以可以添加 AppleID 登录方式。&lt;/font&gt;&lt;br /&gt;</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2fzjjwwuaj21640p444d.jpg\" alt=\"\" /></p>\n<h2 id=\"2前置配置\"><a class=\"anchor\" href=\"#2前置配置\">#</a> 2：前置配置</h2>\n<h4 id=\"21-xcode工程配置\"><a class=\"anchor\" href=\"#21-xcode工程配置\">#</a> 2.1 Xcode 工程配置</h4>\n<p>选中工程 trager，在 capabilities 中添加 AppleID 登录的能力</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g28b5w8aj21960u0769.jpg\" alt=\"\" /></p>\n<h4 id=\"22-开发者账号配置\"><a class=\"anchor\" href=\"#22-开发者账号配置\">#</a> 2.2 开发者账号配置</h4>\n<p>基于授权码的后端验证方式需要此步骤，如果使用 JWT 验证方式则不依赖此步骤，不过建议按顺序看完多做了解。</p>\n<p>该步骤的最终目的是获取用于校验客户端身份的所需内容，其中包括以下三个内容</p>\n<ul>\n<li>\n<p>生成一个用于校验客户端身份的密钥文件</p>\n</li>\n<li>\n<p>获取 KeyID</p>\n</li>\n<li>\n<p>获取 iss（TeamID）</p>\n</li>\n</ul>\n<p>&lt;font color=&quot;#dd0000&quot;&gt; 注意：该步骤需要登录 Apple 开发者账号并对其进行功能的配置、开启、以及描述文件更新等操作，可能需要证书管理团队或者有相关权限的人员来处理，并由他们将对应信息输出 &lt;/font&gt;&lt;br /&gt;</p>\n<h5 id=\"步骤一能力开启\"><a class=\"anchor\" href=\"#步骤一能力开启\">#</a> <strong>步骤一：能力开启</strong></h5>\n<p>进入开发者账号，选择需要支持 AppleID 登录能力的应用并进入打开其 AppleID 登录的功能<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g335dozbj219o0kiwg6.jpg\" alt=\"\" /><br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g36gha89j216x0u0gnx.jpg\" alt=\"\" /></p>\n<h5 id=\"步骤二更新profile\"><a class=\"anchor\" href=\"#步骤二更新profile\">#</a> <strong>步骤二：更新 profile</strong></h5>\n<p>对 app 的任何更改都会导致现有的 profile 文件失效，所以需要重新生成 profile 描述文件。<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g38wg6kij20ia08qmxk.jpg\" alt=\"\" /><br />\n按照如下路径操作，点进已经 <code>invalid</code>  的描述文件并重新生成<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g3em4u2oj21fq0lc75x.jpg\" alt=\"\" /></p>\n<h5 id=\"步骤三生成密钥文件\"><a class=\"anchor\" href=\"#步骤三生成密钥文件\">#</a> <strong>步骤三：生成密钥文件</strong></h5>\n<p>进入如下界面点击 <code>加号</code> 进行生成<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g3hh2cz2j216m0ms406.jpg\" alt=\"\" /></p>\n<p>填完并勾选 <code>Sigin with apple</code>  后点击右侧的 <code>Configure</code>  进行配置，在配置页面选择需要开启苹果登录的 app 并保存，然后回到上一页并开始注册<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g3kyolw0j21m10u043i.jpg\" alt=\"\" /><br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g3ps0bfjj21v70u0td1.jpg\" alt=\"\" /><br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g3qw6gvmj22120s0dkq.jpg\" alt=\"\" /></p>\n<p>最终注册成功后会有 KeyID、TeamID 和可供下载的密钥文件<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g3umbtqzj21wg0s4gqg.jpg\" alt=\"\" /></p>\n<p>密钥文件格式为.p8 实际是文本文件<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g3yn74llj212g0badht.jpg\" alt=\"\" /></p>\n<p>&lt;font color=&quot;#dd0000&quot;&gt; 注意：密钥文件只能被下载一次，下载后保存在安全的地方，丢了的话只能重新申请了 &lt;/font&gt;&lt;br /&gt;</p>\n<h2 id=\"3登录流程\"><a class=\"anchor\" href=\"#3登录流程\">#</a> 3：登录流程</h2>\n<p>登录流程分两大块，一个是客户端部分，一个是后端部分，其中后端部分有两种校验方式 <code>基于授权码的后端验证</code> 、 <code>基于JWT的算法验证</code> ，稍后会一一讲解。总体流程如下图：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g4un5dizj20ve0u0dip.jpg\" alt=\"\" /></p>\n<h4 id=\"31-客户端侧\"><a class=\"anchor\" href=\"#31-客户端侧\">#</a> 3.1 客户端侧</h4>\n<h5 id=\"步骤一授权\"><a class=\"anchor\" href=\"#步骤一授权\">#</a> <strong>步骤一：授权</strong></h5>\n<p>对于客户端来说 AppleID 登录与传统的三方登录流程一样，分为 <code>调用接口</code> 与 <code>回调信息获取</code> 两步，唯一不同点是苹果登录的 API 是在 iOS SDK 内部封装，只用导入对应头文件即可<br />\n <code>#import &lt;AuthenticationServices/AuthenticationServices.h&gt; </code></p>\n<p>关于登录入口，苹果对 AppleID 登录的 UI 有严格的限制，因此专门提供了提供了一套继承于 <code>UIControl</code>  等控件来供开发者使用 <code>ASAuthorizationAppleIDButton</code></p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ASAuthorizationAppleIDButton * appleIDBtn = [ASAuthorizationAppleIDButton buttonWithType:ASAuthorizationAppleIDButtonTypeDefault style:ASAuthorizationAppleIDButtonStyleWhite];</span><br><span class=\"line\">appleIDBtn.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">100</span>, <span class=\"number\">60</span>);</span><br><span class=\"line\">[appleIDBtn addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(didAppleIDBtnClicked) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:appleIDBtn];</span><br></pre></td></tr></table></figure></p>\n<p>其中按钮的 <code>文案类型</code> 和 <code>UI风格</code> 可以通过枚举进行配置<br />\n <figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//  文案类型</span><br><span class=\"line\">typedef <span class=\"type\">NS_ENUM</span>(<span class=\"type\">NSInteger</span>, <span class=\"type\">ASAuthorizationAppleIDButtonType</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationAppleIDButtonTypeSignIn</span>,</span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationAppleIDButtonTypeContinue</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationAppleIDButtonTypeSignUp</span> <span class=\"type\">API_AVAILABLE</span>(ios(13.2), macos(10.15.1), tvos(13.1)) <span class=\"type\">API_UNAVAILABLE(watchos)</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationAppleIDButtonTypeDefault</span> = <span class=\"type\">ASAuthorizationAppleIDButtonTypeSignIn</span>,</span><br><span class=\"line\">&#125; <span class=\"type\">NS_SWIFT_NAME</span>(<span class=\"type\">ASAuthorizationAppleIDButton</span>.<span class=\"type\">ButtonType</span>) <span class=\"type\">API_AVAILABLE</span>(ios(13.0), macos(10.15), tvos(13.0)) <span class=\"type\">API_UNAVAILABLE</span>(watchos);</span><br><span class=\"line\"></span><br><span class=\"line\">//  <span class=\"type\">UI</span>风格</span><br><span class=\"line\">typedef <span class=\"type\">NS_ENUM</span>(<span class=\"type\">NSInteger</span>, <span class=\"type\">ASAuthorizationAppleIDButtonStyle</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationAppleIDButtonStyleWhite</span>,</span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationAppleIDButtonStyleWhiteOutline</span>,</span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationAppleIDButtonStyleBlack</span>,</span><br><span class=\"line\">&#125; <span class=\"type\">NS_SWIFT_NAME</span>(<span class=\"type\">ASAuthorizationAppleIDButton</span>.<span class=\"type\">Style</span>) <span class=\"type\">API_AVAILABLE</span>(ios(13.0), macos(10.15), tvos(13.0)) <span class=\"type\">API_UNAVAILABLE</span>(watchos);</span><br></pre></td></tr></table></figure><br />\n 但是并不推荐这种方式使用，原因如下：</p>\n<ul>\n<li>1：固定 UI 无法满足业务的定制化需求</li>\n<li>2：文案固定，多语言配置需要在单独的地方去配置文案</li>\n</ul>\n<p>所以建议自己写 UI，直接在点击事件中调用 AppleID 的相关 API 进行授权登陆操作，具体代码为，其中 <code>ASAuthorizationAppleIDRequest</code>  为是否使用 Keychain 信息，如果如果 KeyChain 里面也有登录信息的话，可以直接使用里面保存的用户名和密码进行登录。可以根据实际业务需求来<br />\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">KINFO</span>(@<span class=\"string\">&quot;[AppleLoginWrapper]开始苹果登录鉴权&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">@available</span>(<span class=\"keyword\">iOS</span> <span class=\"number\">13.0</span>, <span class=\"operator\">*</span>)) &#123;</span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationAppleIDProvider</span> <span class=\"operator\">*</span>provider <span class=\"operator\">=</span> [<span class=\"type\">ASAuthorizationAppleIDProvider</span> new];</span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationAppleIDRequest</span> <span class=\"operator\">*</span>request <span class=\"operator\">=</span> [provider createRequest];</span><br><span class=\"line\">    request.requestedScopes <span class=\"operator\">=</span> @[ <span class=\"type\">ASAuthorizationScopeFullName</span>, <span class=\"type\">ASAuthorizationScopeEmail</span> ]; <span class=\"comment\">//请求的用户信息</span></span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationPasswordRequest</span> <span class=\"operator\">*</span> keychainRequest <span class=\"operator\">=</span> [[[<span class=\"type\">ASAuthorizationPasswordProvider</span> alloc] <span class=\"keyword\">init</span>] createRequest];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationController</span> <span class=\"operator\">*</span>vc <span class=\"operator\">=</span> [[<span class=\"type\">ASAuthorizationController</span> alloc] initWithAuthorizationRequests:@[ request ,keychainRequest]];</span><br><span class=\"line\">    vc.delegate <span class=\"operator\">=</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    vc.presentationContextProvider <span class=\"operator\">=</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    [vc performRequests];</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Fallback on earlier versions</span></span><br><span class=\"line\">    <span class=\"type\">KINFO</span>(@<span class=\"string\">&quot;[AppleLoginWrapper]iOS系统低于13&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"步骤二信息回调\"><a class=\"anchor\" href=\"#步骤二信息回调\">#</a> <strong>步骤二：信息回调</strong></h5>\n<p>依赖的两个 delegate<br />\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark- 代理 ASAuthorizationControllerDelegate</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)authorizationController:(ASAuthorizationController *)controller didCompleteWithAuthorization:(ASAuthorization *)authorization &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  成功</span></span><br><span class=\"line\">    <span class=\"comment\">//  其中`authorization.credential`包含了Token，用户ID等授权所需信息，可上报到后台</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"type\">void</span>)authorizationController:(ASAuthorizationController *)controller didCompleteWithError:(<span class=\"built_in\">NSError</span> *)error &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  失败</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark- 代理ASAuthorizationControllerPresentationContextProviding</span></span><br><span class=\"line\">- (ASPresentationAnchor)presentationAnchorForAuthorizationController:(ASAuthorizationController *)controller &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  展示在哪个Window上</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.view.window;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"步骤三用户id状态校验\"><a class=\"anchor\" href=\"#步骤三用户id状态校验\">#</a> <strong>步骤三：用户 ID 状态校验</strong></h5>\n<p>防止用户注销 AppleId 或 停止使用 Apple ID 的状态处理<br />\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">-</span> (<span class=\"type\">BOOL</span>)application:(<span class=\"type\">UIApplication</span> <span class=\"operator\">*</span>)application didFinishLaunchingWithOptions:(<span class=\"type\">NSDictionary</span> <span class=\"operator\">*</span>)launchOptions &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Override point for customization after application launch.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">@available</span>(<span class=\"keyword\">iOS</span> <span class=\"number\">13.0</span>, <span class=\"operator\">*</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 注意 存储用户标识信息需要使用钥匙串来存储 这里使用NSUserDefaults 做的简单示例</span></span><br><span class=\"line\">        <span class=\"type\">NSString</span> <span class=\"operator\">*</span> userIdentifier <span class=\"operator\">=</span> [[<span class=\"type\">NSUserDefaults</span> standardUserDefaults] valueForKey:@<span class=\"string\">&quot;appleID&quot;</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (userIdentifier) &#123;</span><br><span class=\"line\">            <span class=\"type\">ASAuthorizationAppleIDProvider</span> <span class=\"operator\">*</span> appleIDProvider <span class=\"operator\">=</span> [[<span class=\"type\">ASAuthorizationAppleIDProvider</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">            [appleIDProvider getCredentialStateForUserID:userIdentifier</span><br><span class=\"line\">                                              completion:<span class=\"operator\">^</span>(<span class=\"type\">ASAuthorizationAppleIDProviderCredentialState</span> credentialState, <span class=\"type\">NSError</span> <span class=\"operator\">*</span> _Nullable error) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">switch</span> (credentialState) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"type\">ASAuthorizationAppleIDProviderCredentialAuthorized</span>:</span><br><span class=\"line\">                        <span class=\"comment\">// 授权状态有效</span></span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"type\">ASAuthorizationAppleIDProviderCredentialRevoked</span>:</span><br><span class=\"line\">                        <span class=\"comment\">// 苹果账号登录的凭据已被移除，需解除绑定并重新引导用户使用苹果登录</span></span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"type\">ASAuthorizationAppleIDProviderCredentialNotFound</span>:</span><br><span class=\"line\">                        <span class=\"comment\">// 未登录授权，直接弹出登录页面，引导用户登录</span></span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"type\">ASAuthorizationAppleIDProviderCredentialTransferred</span>:</span><br><span class=\"line\">                        <span class=\"comment\">// 授权AppleID提供者凭据转移</span></span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">YES</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"32-sever侧\"><a class=\"anchor\" href=\"#32-sever侧\">#</a> 3.2 Sever 侧</h4>\n<p>基于上面流程图，Sever 侧校验 Token 有效性的方式有两种：</p>\n<h5 id=\"方式一基于授权码的后端验证\"><a class=\"anchor\" href=\"#方式一基于授权码的后端验证\">#</a> <strong>方式一：基于授权码的后端验证</strong></h5>\n<p>后端在收到客户端传递的包含 token 的信息后进行验证</p>\n<ul>\n<li>构建 client_secret<br />\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----BEGIN PRIVATE KEY-----</span><br><span class=\"line\">BASE64编码后的密钥 (步骤<span class=\"number\">2.2</span>中获得)</span><br><span class=\"line\">-----END PRIVATE KEY-----</span><br><span class=\"line\"> </span><br><span class=\"line\">public  byte<span class=\"literal\">[]</span> read<span class=\"constructor\">Key()</span> throws Exception &#123;</span><br><span class=\"line\">    String temp = <span class=\"string\">&quot;密钥文件中间的编码字符串&quot;</span>;</span><br><span class=\"line\">    return <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Base64</span>.</span></span>decode<span class=\"constructor\">Base64(<span class=\"params\">temp</span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">构建client_secret关键代码：</span><br><span class=\"line\"></span><br><span class=\"line\">String client_id = <span class=\"string\">&quot;...&quot;</span>; <span class=\"comment\">// 被授权的APP ID(步骤2.2中获得)</span></span><br><span class=\"line\">Map&lt;String, Object&gt; header = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;<span class=\"literal\">()</span>;</span><br><span class=\"line\">header.put(<span class=\"string\">&quot;kid&quot;</span>, <span class=\"string\">&quot;密钥id&quot;</span>); <span class=\"comment\">// 参考后台配置(步骤2.2中获得)</span></span><br><span class=\"line\">Map&lt;String, Object&gt; claims = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;<span class=\"literal\">()</span>;</span><br><span class=\"line\">claims.put(<span class=\"string\">&quot;iss&quot;</span>, <span class=\"string\">&quot;team id&quot;</span>); <span class=\"comment\">// 参考后台配置 team id(步骤2.2中获得)</span></span><br><span class=\"line\">long now = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>current<span class=\"constructor\">TimeMillis()</span><span class=\"operator\"> / </span><span class=\"number\">1000</span>;</span><br><span class=\"line\">claims.put(<span class=\"string\">&quot;iat&quot;</span>, now);</span><br><span class=\"line\">claims.put(<span class=\"string\">&quot;exp&quot;</span>, now + <span class=\"number\">86400</span><span class=\"operator\"> * </span><span class=\"number\">30</span>); <span class=\"comment\">// 最长半年，单位秒</span></span><br><span class=\"line\">claims.put(<span class=\"string\">&quot;aud&quot;</span>, <span class=\"string\">&quot;https://appleid.apple.com&quot;</span>); <span class=\"comment\">// 默认值</span></span><br><span class=\"line\">claims.put(<span class=\"string\">&quot;sub&quot;</span>, client_id);</span><br><span class=\"line\">PKCS8EncodedKeySpec pkcs8EncodedKeySpec = <span class=\"keyword\">new</span> <span class=\"constructor\">PKCS8EncodedKeySpec(<span class=\"params\">readKey</span>()</span>);</span><br><span class=\"line\">KeyFactory keyFactory = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">KeyFactory</span>.</span></span>get<span class=\"constructor\">Instance(<span class=\"string\">&quot;EC&quot;</span>)</span>;</span><br><span class=\"line\">PrivateKey privateKey = keyFactory.generate<span class=\"constructor\">Private(<span class=\"params\">pkcs8EncodedKeySpec</span>)</span>;</span><br><span class=\"line\">String client_secret = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Jwts</span>.</span></span>builder<span class=\"literal\">()</span>.set<span class=\"constructor\">Header(<span class=\"params\">header</span>)</span>.set<span class=\"constructor\">Claims(<span class=\"params\">claims</span>)</span>.sign<span class=\"constructor\">With(SignatureAlgorithm.ES256, <span class=\"params\">privateKey</span>)</span>.compact<span class=\"literal\">()</span>;       </span><br></pre></td></tr></table></figure></li>\n<li>验证客户端 Token<br />\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span> <span class=\"built_in\">url</span> = <span class=\"string\">&quot;https://appleid.apple.com/auth/token&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// POST 请求</span></span><br><span class=\"line\">HttpSynClient client = <span class=\"keyword\">new</span> HttpSynClient(<span class=\"number\">5000</span>, <span class=\"number\">5000</span>, <span class=\"number\">5000</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">String</span>&gt; form = <span class=\"keyword\">new</span> HashMap&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">String</span>&gt;();</span><br><span class=\"line\">form.put(<span class=\"string\">&quot;client_id&quot;</span>, client_id);</span><br><span class=\"line\">form.put(<span class=\"string\">&quot;client_secret&quot;</span>, client_secret);</span><br><span class=\"line\">form.put(<span class=\"string\">&quot;code&quot;</span>, code);form.put(<span class=\"string\">&quot;grant_type&quot;</span>,<span class=\"string\">&quot;authorization_code&quot;</span>);</span><br><span class=\"line\">form.put(<span class=\"string\">&quot;redirect_uri&quot;</span>, redirectUrl);</span><br><span class=\"line\">HttpResponse result = client.excutePost(<span class=\"built_in\">url</span>, form);</span><br><span class=\"line\">System.out.println(result);</span><br></pre></td></tr></table></figure></li>\n<li>上述步骤结束后即可将结果回调给客户端，进行登录或者是错误处理\n<ul>\n<li>成功示例<br />\n <figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\"><span class=\"attr\">&quot;access_token&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;a0996b16cfb674c0eb0d29194c880455b.0.nsww.5fi5MVC-i3AVNhddrNg7Qw&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;token_type&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;Bearer&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;expires_in&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">3600</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;refresh_token&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;r9ee922f1c8b048208037f78cd7dfc91a.0.nsww.KlV2TeFlTr7YDdZ0KtvEQQ&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;id_token&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;eyJraWQiOiJBSURPUEsxIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL2FwcGxlaWQuYXBwbGUuY29tIiwiYXVkIjoiY29tLnNreW1pbmcuYXBwbGVsb2dpbmRlbW8iLCJleHAiOjE1NjU2NjU1OTQsImlhdCI6MTU2NTY2NDk5NCwic3ViIjoiMDAwMjY2LmRiZTg2NWIwYWE3MjRlMWM4ODM5MDIwOWI5YzdkNjk1LjAyNTYiLCJhdF9oYXNoIjoiR0ZmODhlX1ptc0pqQ2VkZzJXem85ZyIsImF1dGhfdGltZSI6MTU2NTY2NDk2M30.J6XFWmbr0a1hkJszAKM2wevJF57yZt-MoyZNI9QF76dHfJvAmFO9_RP9-tz4pN4ua3BuSJpUbwzT2xFD_rBjsNWkU-ZhuSAONdAnCtK2Vbc2AYEH9n7lB2PnOE1mX5HwY-dI9dqS9AdU4S_CjzTGnvFqC9H5pt6LVoCF4N9dFfQnh2w7jQrjTic_JvbgJT5m7vLzRx-eRnlxQIifEsHDbudzi3yg7XC9OL9QBiTyHdCQvRdsyRLrewJT6QZmi6kEWrV9E21WPC6qJMsaIfGik44UgPOnNnjdxKPzxUAa-Lo1HAzvHcAX5i047T01ltqvHbtsJEZxAB6okmwco78JQA&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></li>\n<li>失败示例<br />\n <figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\"><span class=\"attr\">&quot;error&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;invalid_client&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"方式二基于jwt验证原理\"><a class=\"anchor\" href=\"#方式二基于jwt验证原理\">#</a> <strong>方式二：基于 JWT 验证原理</strong></h5>\n<ul>\n<li>\n<p>获取苹果公钥，并保存</p>\n<p>用到公钥接口  <code>https://appleid.apple.com/auth/keys</code> <br />\n 返回值样例<br />\n <figure class=\"highlight prolog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"string\">&quot;keys&quot;</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;kty&quot;</span>: <span class=\"string\">&quot;RSA&quot;</span>, </span><br><span class=\"line\">        <span class=\"string\">&quot;kid&quot;</span>: <span class=\"string\">&quot;AIDOPK1&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;use&quot;</span>: <span class=\"string\">&quot;sig&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;alg&quot;</span>: <span class=\"string\">&quot;RS256&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;n&quot;</span>: <span class=\"string\">&quot;lxrwmuYSAsTfn-lUu4goZSXBD9ackM9OJuwUVQHmbZo6GW4Fu_auUdN5zI7Y1dEDfgt7m7QXWbHuMD01HLnD4eRtY-RNwCWdjNfEaY_esUPY3OVMrNDI15Ns13xspWS3q-13kdGv9jHI28P87RvMpjz_JCpQ5IM44oSyRnYtVJO-320SB8E2Bw92pmrenbp67KRUzTEVfGU4-obP5RZ09OxvCr1io4KJvEOjDJuuoClF66AT72WymtoMdwzUmhINjR0XSqK6H0MdWsjw7ysyd_JhmqX5CAaT9Pgi0J8lU_pcl215oANqjy7Ob-VMhug9eGyxAWVfu_1u6QJKePlE-w&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;e&quot;</span>: <span class=\"string\">&quot;AQAB&quot;</span></span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>验证客户端的 Token 有效性</p>\n<p>客户端会传以下几个值给服务端</p>\n<ul>\n<li>\n<p>userID：授权的用户唯一标识</p>\n</li>\n<li>\n<p>email、fullName：授权的用户资料</p>\n</li>\n<li>\n<p>authorizationCode：授权 code</p>\n</li>\n<li>\n<p>identityToken：授权用户的 JWT 凭证<br />\n示例 identityToken：授权用户的 JWT 凭证<br />\n <figure class=\"highlight smali\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eyJraWQiOiJBSURPUEsxIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL2FwcGxlaWQuYXBwbGUuY29tIiwiYXVkIjoiY29tLmZ1bi5BcHBsZUxvZ2luIiwiZXhwIjoxNTY4NzIxNzY5LCJpYXQiOjE1Njg3MjExNjksInN1YiI6IjAwMDU4MC4wODdjNTU0ZGNlMzU0NjZmYTg1YzVhNWQ1OTRkNTI4YS4wODAxIiwiY19oYXNoIjoiel9KY0RscFczQjJwN3ExR0Nna1JaUSIsImF1dGhfdGltZSI6MTU2ODcyMTE2OX0.WmSa4LzOzYsdwTqAJ_8mub4Ls3eyFkxZoGLoy-U7DatsTd_JEwAs3_OtV4ucmj6ENT3153iCpYY6vBxSQromOMcXsN74IrUQew24y_zflN2g4yU8ZVvBCbTrR_6p9f2fbeWjZiyNcbPCha0dv45E3vBjyHhmffWnk3vyndBBiwwuqod4pyCZ3UECf6Vu-o7dygKFpMHPS1ma60fEswY5d-_TJAFk1HaiOfFo0XbL6kwqAGvx8HnraIxyd0n8SbBVxV_KDxf15hdotUizJDW7N2XMdOGQpNFJim9SrEeBhn9741LWqkWCgkobcvYBZsrvnUW6jZ87SLi15rvIpq8_fw</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\ntoken 被解密后分为三个部分</p>\n</li>\n<li>\n<p>header: 包括了 key id 与加密算法</p>\n</li>\n<li>\n<p>payload:</p>\n<ul>\n<li>iss: 签发机构，苹果</li>\n<li>aud: 接收者，目标 app</li>\n<li>exp：过期时间</li>\n<li>iat: 签发时间</li>\n<li>sub: 用户 id</li>\n<li>c_hash: 一个哈希数列</li>\n<li>auth_time: 签名时间</li>\n</ul>\n</li>\n<li>\n<p>signature: 用于验证 JWT 的签名</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Token 验证原理：</p>\n<p>因为 idnetityToken 使用非对称加密 RSASSA【RSA 签名算法】 和 ECDSA【椭圆曲线数据签名算法】，当验证签名的时候，利用公钥来解密 Singature，当解密内容与 base64UrlEncode (header) + “.” + base64UrlEncode (payload) 的内容完全一样的时候，表示验证通过。</p>\n</li>\n<li>\n<p>防止中间人攻击原理：</p>\n<p>该 token 是苹果利用私钥生成的一段 JWT，并给出公钥我们对 token 进行验证，由于中间人并没有苹果的私钥，所以它生成出来的 token 是没有办法利用苹果给出的公钥进行验证的，确保的 token 的安全性。</p>\n</li>\n</ul>\n<h2 id=\"4-总结\"><a class=\"anchor\" href=\"#4-总结\">#</a> 4 总结</h2>\n<p>目前使用的是基于授权码的后端验证方式，每次收到客户端登录请求后都会像苹果服务器发送 post 请求来验证，导致受网络影响较大。如果改成第一种方式后，除了获取公钥外不再依赖网络请求，可降低网络异常情况带来的损失。但是服务端要定期刷新公钥，防止公钥变化带来的验证失败</p>\n<h2 id=\"5-参考文档\"><a class=\"anchor\" href=\"#5-参考文档\">#</a> 5 参考文档</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIub2t0YS5jb20vYmxvZy8yMDE5LzA2LzA0L3doYXQtdGhlLWhlY2staXMtc2lnbi1pbi13aXRoLWFwcGxl\">https://developer.okta.com/blog/2019/06/04/what-the-heck-is-sign-in-with-apple</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2NuL3NpZ24taW4td2l0aC1hcHBsZS8=\">https://developer.apple.com/cn/sign-in-with-apple/</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2RvY3VtZW50YXRpb24vc2lnbmlud2l0aGFwcGxlcmVzdGFwaS9nZW5lcmF0ZV9hbmRfdmFsaWRhdGVfdG9rZW5z\">https://developer.apple.com/documentation/signinwithapplerestapi/generate_and_validate_tokens</span></p>\n",
            "tags": [
                "iOS",
                "Apple登录"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2021-07-27-%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E4%B8%80%E5%9C%BAPresentation/",
            "url": "https://oliverqueen.cn/2021-07-27-%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E4%B8%80%E5%9C%BAPresentation/",
            "title": "如何做好一场Presentation",
            "date_published": "2021-07-26T16:14:53.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"0x1-前言\"><a class=\"anchor\" href=\"#0x1-前言\">#</a> 0X1 前言：</h2>\n<p>其实很早就想写这篇文章了，当时晋级答辩之后本想趁热打铁，把自己的一些经历和想法分享出来和大家一起探讨，但是工作上的事情七七八八，再加上拖延症犯了，所以导致直到今天大家才能看到这篇文章。不奢求大家看过文章后晋级答辩就能一路绿灯，只是希望能在答辩季这关键时期给需要的人些许的启发或者能与大家产生一些共鸣，更主要的是希望本文能起到抛砖引玉的作用，大家都可以将自己的经历和想法分享出来。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNgy1gsvni8ogskj31ts0u00zc.jpg\" alt=\"\" /></p>\n<p><span id=\"more\"></span></p>\n<p>对于大部分开发同学来说，Presentation 一直都是短板，因为答辩不仅仅是技术能力本身的体现，还涉及到包括但不限于以下几个方面：</p>\n<ul>\n<li>\n<p>信息分类检索聚合能力。</p>\n</li>\n<li>\n<p>PPT 的书写能力。</p>\n</li>\n<li>\n<p>临场发挥、表达能力。</p>\n</li>\n</ul>\n<h2 id=\"0x2-如何选取素材\"><a class=\"anchor\" href=\"#0x2-如何选取素材\">#</a> 0x2 如何选取素材？</h2>\n<p>想要解决问题就要知道都有哪些问题，以及这些问题是怎么来的，然后再对症下药。在答辩前也跟不少同事聊过，总结了几个大家都会提到的问题，其中被提到次数最多的就是 “不知道要答什么”。每个人都会说，这半年没做过什么 &lt; font color=&quot;#dd0000&quot;&gt; 有技术含量 &lt;/font &gt; 的事情，&lt;font color=&quot;#dd0000&quot;&gt; 业务需求 &lt;/font &gt; 都忙不过来。关键字已经标红，可以看出来这两个因素是阻挠我们的真凶。</p>\n<h4 id=\"21技术含量\"><a class=\"anchor\" href=\"#21技术含量\">#</a> 2.1：技术含量？</h4>\n<p>对于一个技术答辩来说什么样的事情算是有技术含量？其实并不一定是那种前无古人后无来者的高精尖技术突破，也不是多么高深莫测的技术点。其实做移动端，或者大前端开发的人都知道，互联网在我国也有几十年的发展史，能挖的技术点早已经被挖透了，各种知识随便 google 一下就一大堆，想在这种环境下研究新技术出来实在是难于登天。所以大家有这样的疑问也是情理之中的。</p>\n<p>既然这样我们何不换一个思路去思考问题，稍稍改变一下 <code>技术含量</code> 这个词的定义。我个人的理解是 <code>在技术方面能对现有项目起到正向优化效果，或者能提高现有工作的效率的工作</code> ，凡是这样的工作，都值得被用来答辩或者作为 Presentation 的素材，这样一来，是不是感觉能答辩的东西就很多了，可选的范围变广了。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNgy1gsuruavcq7j30u00k40uw.jpg\" alt=\"\" /></p>\n<h4 id=\"22业务需求\"><a class=\"anchor\" href=\"#22业务需求\">#</a> 2.2：业务需求？</h4>\n<p>这是这里面临第二个 “难题”。的确大部分的同事的大部分时间都跟业务需求打交道，需求的点子是产品同学想的，代码也是按照需求单里面的写的，乍一看确实没什么可说的。但是大家都是在公司上班的人，业务需求肯定躲不过。其实现代技术的发展一开始都是由人类需求来驱动的。比如音视频编码技术，流媒体技术，各种加解密、排序算法等，都是先有需求再有技术产出，而针对同一个需求的不同技术方案也有 <code>优劣差异</code> ，比如 H264,H265；比如各种排序算法的复杂度等。所以我们答辩的内容最好是要从平时各种需求去挖掘，而实现需求时方案的 <code>优劣差异</code> 正是我们需要展示出的亮点。这一套做完后我们再通过业务需求本身的一些数据来佐证我们论点。</p>\n<p>这样一来形成一个完整的闭环，让 <code>业务需求</code> 从绊脚石变成促成我们一次答辩或者 Presentation 成功的一个助推剂。有业务需求作为支撑，可以使我们的内容更加有说服力，不至于让我们的 presentation 变成纸上谈兵。换句话来说，过多的业务需求未必是一件坏事，不过这就需要我们在做每个需求时都要有认真的思考，我们不仅仅是要完成需求本事，而是要考虑同样的工作如何做的更好。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNgy1gsurso7t1lj30xc0huaau.jpg\" alt=\"\" /></p>\n<p>这时候一定会有人说，技术需求大多简单没什么值得说的地方。其实对于移动端来说，目前的编程语言都已经是非常高级的语言，我们在平时的开发中几乎接触不到底层的东西，比如汇编，或者硬件之类的。安卓和苹果都通过层层封装为开发者屏蔽了底层的实现，但是我们真的明白当我调用一个高级接口的时候底层都做了哪些事情吗？打个很简单的比方：大家都知道圆角或者透明图层会导致离屏渲染，会影响性能，但是有多少人能说出为什么会离屏渲染？离屏渲染时候 CPU 在做什么、GPU 在做什么？切圆角触发了哪些 GPU 的指令？GPU 和 CPU 以及各种显示管线是如何交互的？其实我们并不是缺少素材，而是缺乏透过问题看本质的能力。对于大前端来说我们接触到的都只是冰山一角，而冰山下面的东西是值得我们去细细挖掘的。</p>\n<h4 id=\"23兜底策略\"><a class=\"anchor\" href=\"#23兜底策略\">#</a> 2.3：兜底策略！</h4>\n<p>如果看了上面两段还是不知道说什么那兜底策略就是： <code>能报就报，先报再说</code> ，人都是有惰性的，不逼自己一把永远不知道自己的潜力，而且对自己个人成长有益事情要学会争取，答辩或者 presentation 的意义不仅仅是升职加薪，其中的过程也能学到很多东西，对自己各方面能力都是很大的提高，之前基本所有参与过的同学都说过：“答辩掉层皮，但是能学到很多东西”。对于这种好事我们怎么能拒绝呢？</p>\n<h2 id=\"0x3-开始ppt之前要做什么\"><a class=\"anchor\" href=\"#0x3-开始ppt之前要做什么\">#</a> 0x3 开始 PPT 之前要做什么</h2>\n<p>PPT 是答辩中必不可少的一个部分，但是 PPT 只是一个辅助工具，他的作用是把自己的想法更加具象的表达出来。所以最重要的是我们的想法和思路，以及我们的内容，在这里笔者建议 &lt;font color=&quot;#dd0000&quot;&gt; 不要着急写 PPT！&lt;/font&gt;，因为过早的写 PPT 就避免不了后期大量的修改，很容易导致前功尽弃。而且过早的写也容易禁锢自己的思路。</p>\n<p>对于什么时候开始写，这个可能要取决于每个人内容的积累程度，当你相关的知识储备到达一定量级的时候你自然就会感觉” 下笔如有神 “，这个时候就可以开始了。这里还是建议最晚开始时间要在答辩前一个月左右。关于如何做知识积累，我这边有个方法：在平时工作时候，将答辩相关的知识点全部都记录在一个文档里，不需要记录多详细，可能是一行网址、一个截图、一个书名 + 页数，甚至是一行 API。在 PPT 开始前必须保证这个文档已经形成了一套较为完整的知识体系，这样之后才能快速高质量的完成 PPT。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNgy1gsvme0203eg30f80gonpr.gif\" alt=\"\" /></p>\n<p>这里用笔者的亲身经历举例，第一次答辩时候没有经验，很早就把重心放到了 PPT 书写上，导致在该做技术积累的时候时间都花在构思 PPT 上。最终的结果就是 PPT 改了无数版，面目全非，而且最后发现技术深度不够，信息密度不够，才开始后期恶补。第二次答辩吸取了教训，早早地就把各种相关知识点沉淀到文档中，确定了大方向和提纲。然后最后一个月左右的时间，从该文档中进行信息提取整合，写 PPT 的效率翻倍，而且自始至终基本不会有结构上太大的修改。</p>\n<h2 id=\"0x4-如何写ppt\"><a class=\"anchor\" href=\"#0x4-如何写ppt\">#</a> 0x4 如何写 PPT</h2>\n<p>知道了要讲什么东西，那这节来看看如何把一件事情清晰的描述出来。就像写代码一样，任何事情都要有条理，要有先后顺序，先讲什么后讲什么，都必须遵循一定的规律，虽说不上要引人入胜，但是至少让听众或者评委能顺着你的思路走。所以在写 PPT 或者演讲稿之前要从上帝视角来审视整个流程，整理出一个大概的提纲，之后的工作才是细化内容，挖掘深度等。根据事物发展的客观规律，并以时间线为依托，一个好的描述手法基本可以分为以下几个部分。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNgy1gsuv69e6bkg30xc0ioql2.gif\" alt=\"\" /></p>\n<h4 id=\"41背景\"><a class=\"anchor\" href=\"#41背景\">#</a> 4.1：背景</h4>\n<p>做任何事情都有原因，在开始一切之前反问一下自己 <code>我为什么要做这个事情？</code> 。但是这里的原因并不是” 因为有这个产品需求所以我做了 “，因为 presentation 的素材绝对不是需求本身，而是由需求引出的更高层次的思考，来源于需求，高于需求。因此 &lt; font color=&quot;#dd0000&quot;&gt; 背景是建立在你对现状清晰的认识的基础上，指出现阶段存在的问题，并表达出要迫切优化的诉求 &lt;/font&gt;。换句话说 <code>背景</code> 就是让听众带着问题听下去，你也可以通过不同的问题来主导听众的思考方向。</p>\n<ul>\n<li>描述方式：背景的描述方式尽量采用 &lt;font color=&quot;#dd0000&quot;&gt;1. 2. 3.  ... 点来列出来 &lt;/font&gt;，这样不仅清晰明了，而且也方便后面的针对性解答，起到点题的作用。</li>\n</ul>\n<h4 id=\"42竞品对比\"><a class=\"anchor\" href=\"#42竞品对比\">#</a> 4.2：竞品对比</h4>\n<p>之前也讲过，互联网发展这么久，任何问题都有现成的解决方案，所以你能想到的问题其他人也一定会想到，说不定别人已经有了一套成熟的体系，所以要体现自己的价值就一定要找到我们比他强的地方，或者是我们不能用他人的只能用你的原因。这点很重要，前期不做好功课，不然等评委问道了 <code>用XXX一样可以解决问题，你为什么还重复造轮子?</code>  的时候哑口无言，那就很尴尬了。</p>\n<p>竞品对比要尽量找些知名度较高的竞品，这样更有说服力，也更能衬托出你所做内容的优势。同时要思考全面，让听众能感受到你对行业的敏感性和思考问题的全面性。</p>\n<ul>\n<li>描述方式：该模块尽量采用 &lt;font color=&quot;#dd0000&quot;&gt; 表格 &lt;/font &gt; 描述，通过不同维度的对比来突出自己的优势。但是有一点要注意，不要一味的贬低竞品，可以在一些无关痛痒或者跟本次演讲内容无关的地方去肯定他人的做法，不然会让人觉得你做的东西也比较廉价。</li>\n</ul>\n<h4 id=\"43工作内容描述\"><a class=\"anchor\" href=\"#43工作内容描述\">#</a> 4.3：工作内容描述</h4>\n<p>这个环节就是真正开始描述自己所做的事情，有以下几点要注意</p>\n<ul>\n<li>\n<p>不要写流水账，要突出亮点。</p>\n</li>\n<li>\n<p>尽量不要贴代码，除非你的代码很优秀没有破绽，或者是官方 API，不然非常容易被挑战。</p>\n</li>\n<li>\n<p>文字一定要越少越好，不然很容易变成照着读 (那样评委就会自己读而不去听你讲的了)，把你想写的话尽量通过图表达出来。</p>\n</li>\n<li>\n<p>每一页的内容不要过多，一页不能出现两个主题。</p>\n</li>\n<li>\n<p>合理使用动画和转场效果，避免花里胡哨。</p>\n</li>\n<li>\n<p>描述顺序最好跟照前面背景中提到的问题顺序一致，这样可以保证和背景中的问题要一一对应起来。</p>\n</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNgy1gsvkt02wfaj30hi0b7q47.jpg\" alt=\"\" /></p>\n<h4 id=\"44数据佐证\"><a class=\"anchor\" href=\"#44数据佐证\">#</a> 4.4：数据佐证</h4>\n<p>对于任何的工作，数据是最有说服力的证明，尽量选择线上数据，进行纵向、横向对比</p>\n<ul>\n<li>\n<p>纵向对比：同一个项目中，在你所做工作介入前和介入后 对于项目某项指标的提升做对比。</p>\n</li>\n<li>\n<p>横向对比：同市面上的其他相似方案在对于项目的某项指标上的提升进行对比，类似于上文提到的竞品对比。</p>\n</li>\n<li>\n<p>描述方式：尽量采用表格，饼图、折线图等数据图表并配以少量的文字描述来进行展示。</p>\n</li>\n</ul>\n<h4 id=\"45后续优化点\"><a class=\"anchor\" href=\"#45后续优化点\">#</a> 4.5：后续优化点</h4>\n<p>对于在计划中但还没有完成或开始的工作可以写到该模块下，但是要注意的是该处不要写 <code>过于简单或者很容易实现</code> 的内容，不然很容易被挑战：” 为什么不一起做完再来讲？“。该模块还有一个重要的功能就是对上面所讲内容的一个补充，体现出自己考虑问题的广度和深度。对于该模块所涉及到的知识点可以理解的不那么细，毕竟是预研阶段，但是要让评委或者是听众知道你在有计划的执行下去，同时后续方案已经具备了一定的可行性。</p>\n<h4 id=\"46关于口水稿\"><a class=\"anchor\" href=\"#46关于口水稿\">#</a> 4.6：关于口水稿</h4>\n<p>口水稿就是把自己要说的一字不漏的直接写在 PPT 备注里面，包含一些白话和口语。可能大多数同学会认为，对于一些不善于表达的同学可以添加口水稿。但是个人觉得对于每个人来说口水稿都是必要的，不仅仅是在答辩过程中能给你相应的提示，更重要的是写口水稿的过程其实就是模拟答辩的过程，你可以梳理自己的思路，对于 PPT 查漏补缺。这一点是非常重要的。一般在最后一到两版的 PPT 开始写口水稿，笔者在这个期间也发现了很多问题，其中不乏一些逻辑错误，或者表达错误。</p>\n<h4 id=\"47其他建议\"><a class=\"anchor\" href=\"#47其他建议\">#</a> 4.7：其他建议</h4>\n<ul>\n<li>\n<p>关于主题</p>\n<p>尽量选择一个主题来表述，如果一定要选择多个项目，一定要分清主次，最好 1：9 或者 2：8 来讲，同时非主要内容要先讲，然后再开始最重要的内容。因为大部分评委或者听众会对你最后讲的内容记忆深刻，而且 Q&amp;A 环节也是在最后。</p>\n</li>\n<li>\n<p>关于篇幅</p>\n<p>答辩总时长 30 分钟，PPT 最终有效页数要控制在 35 页内，如果超了这个页数说明你的内容不够精简，要做适当的调整，&lt;font color=&quot;#dd0000&quot;&gt; 确保每一个字都不是废话，都要有自己的使命。&lt;/font&gt;</p>\n</li>\n</ul>\n<h2 id=\"0x5-答辩前如何准备\"><a class=\"anchor\" href=\"#0x5-答辩前如何准备\">#</a> 0x5 答辩前如何准备</h2>\n<p>&lt;/br&gt;</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNgy1gsvmqw7dnkj30u00w6jtv.jpg\" alt=\"\" /></p>\n<p>&lt;/br&gt;</p>\n<p>很多同学会担心紧张，个人认为其实紧张分两种，一种是正常的生理反应，这个谁都避免不了，但是这样的紧张基本不会影响到临场的发挥。另一种就是由于自己准备不充分而带来的慌张、自我怀疑、没有安全感的状态，这个就比较可怕，他会极大的影响到你的发挥表现，而且准备不充分本身就是致命的错误。</p>\n<p>其实第二种紧张的状态也比较好解决，这里提供几个方法：</p>\n<ul>\n<li>\n<p>自己在家或者会议室多进行模拟答辩 (要卡时间 30 分钟)，对自己要求高的可以进行脱稿。</p>\n</li>\n<li>\n<p>多找资深的同事或者 leader 帮你过 PTT。</p>\n</li>\n<li>\n<p>积极参加团队内的预答辩，争取一切表现自己的机会。</p>\n</li>\n<li>\n<p>尽可能的考虑周全，把评委可能挑战的点都想到，同时要有兜底策略，如果评委真的问道没有准备的或者不会的问题要怎么办 (这个可以找过来人分享他们的经验)。</p>\n</li>\n</ul>\n<p>真正的胸有成竹的时候你会有一种急于展示自我的跃跃欲试的感觉，与其说紧张倒不如说激动，当你有这种感觉的时候说明你离成功不远了。自信的人才最有可能发挥自己的全部实力。</p>\n<h2 id=\"0x6-最后\"><a class=\"anchor\" href=\"#0x6-最后\">#</a> 0x6 最后</h2>\n<p>如果你都已经按照上面做了，那么其实最后的结果已经不重要了，我相信每个公司设立答辩机制的初衷一定都是提高员工的综合能力，提高公司整体竞争力，增进员工间的良性竞争氛围，提升技术产品敏感度等。这些都与职级和薪酬无关。全力以赴准备一次答辩，你就基本已经具备了这些优秀的特质。当然从结果导向的理论来说，还是希望大家顺利通过！</p>\n",
            "tags": []
        },
        {
            "id": "https://oliverqueen.cn/2021-05-05-iOS-Crash%E9%98%B2%E6%8A%A4%E4%BD%A0%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%B0%B1%E5%A4%9F%E4%BA%86-%E4%B8%8B%E7%AF%87/",
            "url": "https://oliverqueen.cn/2021-05-05-iOS-Crash%E9%98%B2%E6%8A%A4%E4%BD%A0%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%B0%B1%E5%A4%9F%E4%BA%86-%E4%B8%8B%E7%AF%87/",
            "title": "iOS Crash防护你看这个就够了-下篇",
            "date_published": "2021-05-05T02:23:42.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"0x1-previously\"><a class=\"anchor\" href=\"#0x1-previously\">#</a> 0x1: Previously</h1>\n<p><a href=\"https://oliverqueen.cn/2021/05/03/iOS%20Crash%E9%98%B2%E6%8A%A4%E4%BD%A0%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%B0%B1%E5%A4%9F%E4%BA%86-%E4%B8%8A%E7%AF%87/\">上篇</a> 中讲到了 Crash 处理流程分为四个环节，也分析了 Crash 防护的方法，本章来讲下其余三个环节。</p>\n<h1 id=\"0x2-crash的拦截\"><a class=\"anchor\" href=\"#0x2-crash的拦截\">#</a> 0x2: Crash 的拦截</h1>\n<p>所有的未被防护住的 Crash 最终会走到这里，在这里我们必须要保证拦截的  <code>全面性</code> 、 <code>稳定性</code> 尽可能多的拦截到所有类型的异常，同时拦截逻辑本身不能产生异常。那么我们需要通过以下几个方面去考虑。</p>\n<p><img data-src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fdingyue.ws.126.net%2F2020%2F0504%2Fa0ef0444j00q9saus002gc000xc00irm.jpg&amp;refer=http%3A%2F%2Fdingyue.ws.126.net&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1622826899&amp;t=2b1dd016c1ac10c52097431b7fa9af7d\" alt=\"\" /></p>\n<p><span id=\"more\"></span></p>\n<h2 id=\"i-crash类型\"><a class=\"anchor\" href=\"#i-crash类型\">#</a> I: Crash 类型</h2>\n<p>和多数操作系统一样，iOS 的异常也基本分为  <code>用户层</code>   <code>系统底层</code>   <code>信号</code>  这三个类别，接下来我们看下每种异常都做了哪些事情</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq7dqhr2e2j31860qg79l.jpg\" alt=\"\" /></p>\n<ul>\n<li>\n<p>Mach Exception &lt;br&gt;<br />\nMach 异常，分为两种情况，第一种是本身就是硬件层面或者系统层面的异常，这个大家比较好理解，因为 mach 是微内核，所以底层的内核级别的包括硬件的异常都是 mach 异常。另一种是 iOS 系统独有的逻辑或者说是苹果独有的。就是用户层面的异常也都首先下沉到 mach 层再发出来，也等于是另一种意义上的 mach 异常。苹果官方文档上写的是为了统一机制才做了这样的处理，但是没有说具体原因。他的触发流程大概为下图</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq7yp0q2aaj30f60uqtaf.jpg\" alt=\"\" /></p>\n<p>然后我去看 Runtime 的源码进一步证明了这个说法，runloop 中大量使用这种方式监听 mach 异常消息，一旦 Crash 随时准备打破循环，因为系统也需要监听 crash，统一出口将对监听来说对系统将变得非常方便。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq7yvd5gpvj30pc02mt9o.jpg\" alt=\"\" /></p>\n<p>根据代码上下文可以判断出，苹果会监听统一的异常端口，在出现异常后进行相应的操作，也印证了我当时的推断。</p>\n</li>\n<li>\n<p>Exception &lt;br&gt;<br />\n 很常见的异常，触发流程大概为<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq7z1qkeksj30g60lkaax.jpg\" alt=\"\" /></p>\n</li>\n<li>\n<p>signal &lt;br&gt;</p>\n<p>signal 的产生流程大概分为几种情况</p>\n<ul>\n<li>\n<p>由于  <code>MachExcption</code>  转换而成的 signal</p>\n</li>\n<li>\n<p>由于 Exception 而发出的 abort 信号</p>\n</li>\n<li>\n<p>用户自定义的信号</p>\n</li>\n</ul>\n<p>但是需要注意一点：&lt;font color=red size=3 face=&quot;黑体&quot;&gt; 收到 signal 不一定会 Crash，但是 Crash 一定会有 Signal 发出 &lt;/font&gt;</p>\n</li>\n</ul>\n<h2 id=\"ii-crash传递流程\"><a class=\"anchor\" href=\"#ii-crash传递流程\">#</a> II: Crash 传递流程</h2>\n<p>上面分析了每种 Crash 的类型，那么这三种类型的 Crash 是如何在 App 生命周期中传递的呢？他们又是如何相互转化以及相互之间有什么关系呢？</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq7z8sxdxoj313o0n07hs.jpg\" alt=\"\" /></p>\n<p>帮大家提取下上图中的几个关键信息</p>\n<ul>\n<li>\n<p>1：Exception 最终会转化为 Mach Exception</p>\n</li>\n<li>\n<p>2：通过 Mach 端口拦截的较为全面</p>\n</li>\n<li>\n<p>3：如果发生了 exception 那么就不会抛出对应的 signal 只能抛出 abort ();</p>\n</li>\n<li>\n<p>4：通过捕获 signal 是无法拦截到 exception。</p>\n</li>\n</ul>\n<h2 id=\"iii-拦截的选择\"><a class=\"anchor\" href=\"#iii-拦截的选择\">#</a> III: 拦截的选择</h2>\n<p>通过上面的分析大家一定会说通过 Mach 端口的拦截更加全面，毕竟苹果自己也在用。但是在实际使用中有一个问题，mach 会拦截所有的异常以及信号量，也就是随便一个操作（比如发一个自定义 signal 等）可能都被 mach 捕获，那么如果在其捕获回调中再进行捕获就会很容易发生死锁，而且容易和系统的处理产生冲突。当时看了 PLCrash 的文档，也看到了开发者写的一句话：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq7znanxjrj315y03odjv.jpg\" alt=\"\" /></p>\n<p>这样说明了大家确实被坑过。</p>\n<p>那接下来只剩 signal 和 exception，其实细心的同学早已发现这两个的优缺点是一个互补的状态</p>\n<ul>\n<li>\n<p>singal 能捕获除 Exception 之外的所有异常。</p>\n</li>\n<li>\n<p>exception 只能获取应用层的异常而对信号量无法处理</p>\n</li>\n</ul>\n<p>那么最终的方式采用 singnal + exception 的方式进行捕获，最终的流程为：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq7zrbfy5xj30c40okdgu.jpg\" alt=\"\" /></p>\n<h2 id=\"iv-坑点\"><a class=\"anchor\" href=\"#iv-坑点\">#</a> IV: 坑点</h2>\n<p>上面的流程图可以看出在每一个 CustomHandle 之前都会有一个 PreviousHandle，其实是因为在 iOS 系统中只能存在一个 customHandel，如果你的项目中接入了或者准备接入多个 Crash 防护相关的 SDK（虽然不建议这么做），那么多个 Handle 之间一定会产生冲突，导致堆栈不明确，或者丢失。所以在注册我们的 handle 前先将之前的 handle 指针保存下来，等我们的 handle 处理完后在通过函数指针调用回去，这样就能保证每一个 handle 都能被正常调用。</p>\n<ul>\n<li>\n<p>exception：通过 <code>NSGetUncaughtExceptionHandler</code>  获得之前 handle 指针，之后再通过 <code>NSSetUncaughtExceptionHandler(oldHandler);</code>  调用回去。</p>\n</li>\n<li>\n<p>signal: 使用 <code>sigaction</code>  函数获得之前的 handle 指针。</p>\n</li>\n</ul>\n<h1 id=\"0x3-堆栈获取\"><a class=\"anchor\" href=\"#0x3-堆栈获取\">#</a> 0x3: 堆栈获取</h1>\n<p>因为苹果使用了 (Address Space Layout Randomization) 地址空间配置随机加载技术，所以线上堆栈必须要通过符号表堆栈还原进行解读，不然的话就是内存地址。所以当我们使用 NSThread 的相关函数在 Debug 下虽然能看到可读性行的堆栈，但是在线上包上并不可取，那我们要怎么获取堆栈呢？先来看下符号表的构造：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq80i60uhsj30ya0eih1g.jpg\" alt=\"\" /></p>\n<p>之前拿到这样的符号表，我们通常手动还原，找一个相同系统的真机，找到对应库的基地址按照符号表上函数的偏移量进行计算（通过 LLDB 的相关函数）</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq80lfgy0hj30q208i0te.jpg\" alt=\"\" /></p>\n<p>通过看 Mach-o 相关接口可以找到相关函数进行端内符号表还原，大致流程为：</p>\n<ul>\n<li>\n<p>获取函数地址：</p>\n<ul>\n<li>\n<p>遍历 Mach-o 中的所有 image</p>\n</li>\n<li>\n<p>获取每个 image 的基地址</p>\n</li>\n<li>\n<p>通过堆栈偏移地址获取栈帧函数地址</p>\n</li>\n</ul>\n</li>\n<li>\n<p>将函数地址翻译成函数名</p>\n<ul>\n<li>\n<p>找到对应 Image 的 symple table 段的 nlist_64 结构体</p>\n</li>\n<li>\n<p>通过 nlist_64.n_un.n_strx 获取函数对应的字符串</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>最终的效果:</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq80unfse1j31fc0cin8n.jpg\" alt=\"\" /></p>\n<h1 id=\"0x4-crash后续\"><a class=\"anchor\" href=\"#0x4-crash后续\">#</a> 0x4: Crash 后续</h1>\n<p>通常在 AppCrash 后会在 handle 中做些上报操作.</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq80xn75voj31cc04ydg7.jpg\" alt=\"\" /></p>\n<p>但是这样做有两个问题：</p>\n<ul>\n<li>\n<p>苹果不推荐在 Handle 中做太多操作，而且数据上报等网络请求属于耗时操作，有可能没有完成 App 就被杀死。</p>\n</li>\n<li>\n<p>App 直接闪退，体验不好</p>\n</li>\n</ul>\n<p>通过查看 runloop 源码可以看出，在 Crash 发生后当前 runloop 中断</p>\n<p>&lt;font color='red'&gt; 注意：runloop 本次循环还在继续，但是循环已经被打破，本次循环结束后 app 才退出 &lt;/font&gt; 既下图的 retVal 被置为 NO<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq810qv4osj317e0nawla.jpg\" alt=\"\" /></p>\n<p>iOS Crash 发生后   runloop 中的 do-while 循环的条件会被置为 NO，然后 Handler 函数走完之后当前循环后直接结束，不会在进行下一次循环了，此时我们只需要再 handler 中再重启 runloop，便可以继续执行代码，通过观察 runloop 源码可以看出 这样的操作是在之前已经中断但是还没结束的 runloop 中开启一个新的 runloop，他依然可以接受各种事件，比如交互事件等，前提是每个 model 都要开启，因为不同操作是发生在不同阶段的。  但是之前 runloop 中的内容处于不可控状态，且之前的东西被永远的留在内存中，不可恢复，所以在做完相关操作后要立即结束 App，避免其他异常情况，这种做法类似于一种安全模式，在安全模式中处理相关的东西。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq814a1gryj31f00ac3zo.jpg\" alt=\"\" /></p>\n<p>函数调用：</p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> continueAfterCrash()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopRef</span> runLoop = <span class=\"built_in\">CFRunLoopGetCurrent</span>();</span><br><span class=\"line\">    <span class=\"built_in\">CFArrayRef</span> allModes = <span class=\"built_in\">CFRunLoopCopyAllModes</span>(runLoop);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *mode <span class=\"keyword\">in</span> (__bridge <span class=\"built_in\">NSArray</span> *)allModes)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CFRunLoopRunInMode</span>((<span class=\"built_in\">CFStringRef</span>)mode, <span class=\"number\">1.0e10</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq81k7k7xcj30cq0um0wg.jpg\" alt=\"\" /></p>\n<p>在新的 runloop 中我们做一些操作后再调用 abort 退出 App，比如弹出友好提示之类的操作，告知用户 app 即将退出，但是该操作存在风险，需要注意以下情况</p>\n<ul>\n<li>\n<p>新开 runloop 后之前的 runloop 内容便会永远的留在内存中变成不可控的状态如果一旦被访问可能会有异常，所以在做完我们必要的操作后要及时结束 App。</p>\n</li>\n<li>\n<p>安全模式必须保证稳定，在新 runloop 中执行的上报、弹窗或者其他逻辑必须要使用系统原生的 API，不能依赖任何第三方。</p>\n</li>\n<li>\n<p>尽量不要做太多的操作，及时结束。</p>\n</li>\n</ul>\n<h1 id=\"0x5-参考资料\"><a class=\"anchor\" href=\"#0x5-参考资料\">#</a> 0x5: 参考资料</h1>\n<ul>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2RvY3VtZW50YXRpb24=\">Apple iOS Api</span></p>\n</li>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9vcGVuc291cmNlLmFwcGxlLmNvbS8=\">iOS Open Sourcre</span></p>\n</li>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9vcGVuc291cmNlLmFwcGxlLmNvbS9zb3VyY2UvQ0YvQ0YtMTE1MS4xNi8=\">CFRunloop</span></p>\n</li>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL29wZW5zb3VyY2UuYXBwbGUuY29tL3RhcmJhbGxzL3hudS94bnUtMzI0OC42MC4xMC50YXIuZ3o=\">XNU 3248.60.10 源码</span></p>\n</li>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2RvY3VtZW50YXRpb24veGNvZGUvZGlhZ25vc2luZ19pc3N1ZXNfdXNpbmdfY3Jhc2hfcmVwb3J0c19hbmRfZGV2aWNlX2xvZ3MvYW5hbHl6aW5nX2FfY3Jhc2hfcmVwb3J0\">Understanding Crash Reports on iPhone OS</span></p>\n</li>\n<li>\n<p>《深入解析 MAC OS X &amp; IOS 操作系统》</p>\n</li>\n</ul>\n<h1 id=\"0x6-最后\"><a class=\"anchor\" href=\"#0x6-最后\">#</a> 0x6: 最后</h1>\n<p>大概这就是所有 Crash 防护的流程，通过两篇文章讲解，希望大家对 iOS 系统的 Crash 流程能有些许的了解，并没有贴太多的源码，其实还是解耦度不够，思路有了代码就很简单了。</p>\n<p>\n        <div id=\"aplayer-yREUnHKW\" class=\"aplayer aplayer-tag-marker\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t  <script>\n\t\t\t\t  var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":0,\"mutex\":true,\"music\":[{\"title\":\"错位时空\",\"author\":\"艾辰\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E8%89%BE%E8%BE%B0%20-%20%E9%94%99%E4%BD%8D%E6%97%B6%E7%A9%BA.mp3\",\"pic\":\"https://bkimg.cdn.bcebos.com/pic/a8ec8a13632762d0f7037ac288a71ffa513d26976830?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2UxMTY=,g_7,xp_5,yp_5/format,f_auto\",\"lrc\":\"https://歌词.lrc\"}]};\n\t\t\t\t  options.element = document.getElementById(\"aplayer-yREUnHKW\");\n\t\t\t\t  var ap = new APlayer(options);\n\t\t\t    window.aplayers || (window.aplayers = []);\n\t\t\t\t  window.aplayers.push(ap);\n\t\t\t  </script></p>\n",
            "tags": [
                "iOS",
                "Crash防护"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2020-11-28-%E6%B1%87%E7%BC%96%E5%92%8C%E6%A0%88/",
            "url": "https://oliverqueen.cn/2020-11-28-%E6%B1%87%E7%BC%96%E5%92%8C%E6%A0%88/",
            "title": "汇编和栈",
            "date_published": "2020-11-28T08:44:42.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"汇编和栈\"><a class=\"anchor\" href=\"#汇编和栈\">#</a> 汇编和栈</h1>\n<p>当一个函数传递了六个以上的参数时，多余的参数将通过堆栈传递。但是在堆栈上传递到底是什么意思呢？现在该通过深入研究一些 “与堆栈相关的” 寄存器以及堆栈中的内容，来深入探讨从程序集角度调用函数时的情况。当您进行逆向工程程序时，了解堆栈的工作方式非常有用，因为当没有可用的调试符号时，您可以帮助推断出在某个函数中正在操纵哪些参数。在下一单元中，您将使用本章中的知识在 LLDB 中构建命令，该命令将通过在内存中抓取函数来发现一些有趣的事情。让我们开始吧</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkww85fg8yj30u012ob29.jpg\" alt=\"\" /><br />\n<span id=\"more\"></span></p>\n<h2 id=\"让我们重游堆栈\"><a class=\"anchor\" href=\"#让我们重游堆栈\">#</a> 让我们重游堆栈</h2>\n<p>正如先前在第 6 章 “线程，框架和遍历” 中所讨论的，当程序执行时，内存会被布局，因此栈从 “高地址” 开始并向下增长，向着低地址增长；也就是说，朝向堆。</p>\n<blockquote>\n<p>之前说过：栈是从  <code>高地址 -&gt; 低地址</code> ，堆是从  <code>低地址 -&gt; 高地址</code> ，而 Windows 中栈是在堆的下方，所以 Windows 中内存是从  <code>中间向两边分布</code>  。 而 Linux 中 栈是在堆的上面，所以 Linux 中的内存是  <code>从两边向中间分布</code>  。</p>\n</blockquote>\n<p>很迷惑吗？通过下面这个图片你可以看出栈的移动方式。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4nnjpqxej30u00u1n29.jpg\" alt=\"\" /></p>\n<p>栈从高位地址开始。确切地说，它的高度取决于操作系统的内核。内核为每个正在运行的程序（每个线程）提供栈空间。</p>\n<p>栈的大小是有限的，并且随着内存地址空间的向下增长而增加。当栈上的空间用完时，指向栈  <code>“顶部”</code>  的指针从最高地址向下移动到最低地址。</p>\n<p>一旦栈达到内核给定的有限大小，或者如果栈越过了堆的边界，则称栈溢出。这是一个致命错误，通常称为栈溢出。</p>\n<h2 id=\"栈指针和基本指针寄存器\"><a class=\"anchor\" href=\"#栈指针和基本指针寄存器\">#</a> 栈指针和基本指针寄存器</h2>\n<p>您尚未了解的两个非常重要的寄存器是 RSP 和 RBP。栈指针寄存器 RSP 指向特定线程的栈头。栈的顶部将向下生长，因此将项目添加到栈时，RSP 将减少。 RSP 将始终指向栈的头部。下图展示了栈调用时栈指针变化的视觉效果。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4nukmaa7j31u80pidk4.jpg\" alt=\"\" /></p>\n<p>在上图中，堆栈指针的顺序如下：</p>\n<ul>\n<li>\n<p>栈指针当前指向第 3 帧。</p>\n</li>\n<li>\n<p>指令指针寄存器指向的代码调用一个新函数。堆栈指针将更新为指向 Frame 4，该 feame 可能负责指令指针中此新调用函数中的暂存空间和数据。</p>\n</li>\n<li>\n<p>函数的具体执行在第 4 帧中完成，执行完之后指针从第四帧弹出，并继续指向第三帧.</p>\n</li>\n</ul>\n<p>还有一个重要的寄存器是基址指针寄存器（RBP），在执行在方法 / 函数内部时有多种用途，程序使用 RBP 的偏移量来访问局部变量或函数参数。之所以能这样是因为 RBP 在函数序言中的函数开始处被设置为 RSP 寄存器的值。</p>\n<p>有趣的是，基本指针的之前内容在被设置为 RSP 寄存器的值之前就已存储在栈中。这是函数序言中发生的第一件事。由于基本指针已保存到堆栈中并设置为当前堆栈指针，因此只需知道基本指针寄存器中的值即可遍历堆栈。调试器在向您显示堆栈跟踪时会执行此操作。</p>\n<blockquote>\n<p>请注意：某些系统不使用基本指针，而且他们在编译你的程序的时候也不会出现基础指针。 其实他们的逻辑可能是使用了其他的寄存器来当做指针寄存器。 但这意味着调试变得更加困难。</p>\n</blockquote>\n<p>下面这个图片可以帮助解释。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4pfvxkx2j30u00vw12l.jpg\" alt=\"\" /></p>\n<p>当一个函数序言完成设置时，RBP 的内容将指向堆栈帧下面的前一个 RBP</p>\n<blockquote>\n<p>注意：当您通过单击 Xcode 中的帧或使用 LLDB 跳到另一个堆栈帧时，RBP 和 RSP 寄存器都将更改值以对应于新的帧！ 这是可以肯定的，因为函数的局部变量是由 RBP 的偏移量来获取的，如果 RBP 不变，则您将无法向该函数打印局部变量，甚至可能导致程序崩溃。 在探索 RBP 和 RSP 寄存器时，这可能会引起混乱，因此请始终牢记这一点。 您可以通过选择不同的帧并在 LLDB 控制台中键入 cpx $ rbp 或 cpx $ rsp 在 LLDB 中对此进行验证。</p>\n</blockquote>\n<p>那么，为什么这两个寄存器很重要？ 当使用调试信息编译程序时，调试信息将引用基本指针寄存器中的偏移量以获得变量。 这些偏移量被赋予名称，与您在源代码中为变量赋予的名称相同。<br />\n编译并优化程序以进行发布时，将打包打包到二进制文件中的调试信息。 尽管删除了这些变量和参数的引用的名称，但是您仍然可以使用堆栈指针和基指针的偏移量来查找这些引用的存储位置。</p>\n<h2 id=\"堆栈相关的操作码\"><a class=\"anchor\" href=\"#堆栈相关的操作码\">#</a> 堆栈相关的操作码</h2>\n<p>到目前为止，您已经了解了调用约定以及内存的布局方式，但是还没有真正探究许多操作码在 x64 汇编中的实际作用。 现在是时候更详细地介绍几种与堆栈相关的操作码了。</p>\n<h3 id=\"操作码-push\"><a class=\"anchor\" href=\"#操作码-push\">#</a> 操作码  <code>push</code></h3>\n<p>当需要将诸如 int，Objective-C 实例，Swift 类或引用之类的任何内容保存到堆栈时，将使用  <code>push</code>  操作码。 push 递减堆栈指针（请记住，因为堆栈向下增长），然后存储到新 RSP 指针所指向的内存地址里面。</p>\n<p><code>push</code>  指令后，最新推送的值将位于 RSP 指向的地址。 而先前的值应为 RSP 加上最近推送的值的大小 ----- 对于 64 位体系结构，通常为 8 个字节。<br />\n要查看具体示例，请考虑以下操作码：</p>\n<ul>\n<li>push 0x5</li>\n</ul>\n<p>这将使 RSP 递减，然后将值 5 存储在 RSP 指向的内存地址中。 因此，用 C 伪代码：</p>\n<pre><code>RSP = RSP - 0x8 \n*RSP = 0x5\n</code></pre>\n<h3 id=\"操作码-pop\"><a class=\"anchor\" href=\"#操作码-pop\">#</a> 操作码  <code>pop</code></h3>\n<p><code>pop</code>  操作码与  <code>push</code>  操作码完全相反。 pop 从 RSP 寄存器中获取值并将其存储到目的地。 接下来，RSP 递增 0x8，还是那句话 栈是从大到小的增长，所以递增<br />\n以下是  <code>pop</code>  的示例：</p>\n<ul>\n<li>pop rdx</li>\n</ul>\n<p>这将 RSP 寄存器的值存储到 RDX 寄存器中，然后递增 RSP 寄存器。 这是下面的伪代码：</p>\n<pre><code>RDX = *RSP\nRSP = RSP + 0x8\n</code></pre>\n<h3 id=\"操作码-call\"><a class=\"anchor\" href=\"#操作码-call\">#</a> 操作码  <code>call</code></h3>\n<p><code>call</code>  操作码负责执行功能。  <code>call</code>  将在被调用函数完成后将要返回的地址压入； 然后跳转到该函数。<br />\n想象一下内存中位于 0x7fffb34df410 的函数，如下所示：</p>\n<pre><code>0x7fffb34de913 &lt;+227&gt;: call   0x7fffb34df410            \n0x7fffb34de918 &lt;+232&gt;: mov    edx, eax\n</code></pre>\n<p>当执行一条指令时，首先将 RIP 寄存器递增，然后执行该指令。 因此，当执行调用指令时，RIP 寄存器将递增至 0x7fffb34de918，然后执行 0x7fffb34de913 指向的指令。 由于这是一条调用指令，因此将 RIP 寄存器压入堆栈（就像执行了压入一样），然后将 RIP 寄存器设置为值 0x7fffb34df410，即要执行的功能的地址。<br />\n伪代码类似于以下内容：</p>\n<pre><code>RIP = 0x7fffb34de918\nRSP = RSP - 0x8\n*RSP = RIP\nRIP = 0x7fffb34df410\n</code></pre>\n<p>之后，在位置 0x7fffb34df410 处继续。</p>\n<h3 id=\"操作码-ret\"><a class=\"anchor\" href=\"#操作码-ret\">#</a> 操作码  <code>ret</code></h3>\n<p><code>ret</code>  操作码与  <code>call</code>  相反，它从栈顶弹出栈顶值（如果程序集的 push 和 pops 匹配，它将是调用操作码推入的返回地址），然后将 RIP 寄存器设置为此地址。 因此，该操作可以返回到调用该函数的位置。</p>\n<p>现在，您已经对这四个重要的操作码有了基本的了解，是时候看看它们在起作用了。确保所有  <code>push</code>  操作码都与您的  <code>pop</code>  相匹配非常重要，否则堆栈将不同步。 例如，如果没有相应的  <code>pop</code>  消息用于弹出，则当在函数末尾执行  <code>ret</code>  时将弹出错误的值。 该操作将返回到某个随机位置，甚至可能不在程序中的有效位置。幸运的是，编译器将负责同步您的  <code>push</code>  和  <code>pop</code>  操作码。 您只需要在编写自己的程序集时担心这一点。</p>\n<h2 id=\"在一些操作中观察rbp和rsp寄存器\"><a class=\"anchor\" href=\"#在一些操作中观察rbp和rsp寄存器\">#</a> 在一些操作中观察 RBP 和 RSP 寄存器</h2>\n<p>现在，您已经了解了 RBP 和 RSP 寄存器以及操纵堆栈的四个操作码，现在是时候看看它们的作用了。<br />\n在 Registers 应用程序中，存在一个名为 StackWalkthrough（int）的函数。此 C 函数将一个整数作为参数，并用汇编语言编写（AT＆T 汇编语言，记住要能够找到源操作数和目标操作数的正确位置），并且位于 StackWalkthrough.s 中。打开此文件，环顾四周；无需立即了解所有内容。您将在一分钟内了解其工作原理。<br />\n通过桥接标头 Registers-Bridging-Header.h，Swift 可以使用此函数，因此您可以从 Swift 调用以汇编方式编写的此方法。<br />\n现在利用这一点。<br />\n打开 ViewController.swift，并在 viewDidLoad（）下面添加以下内容：</p>\n<pre><code>viewDidLoad():\noverride func awakeFromNib() &#123;\nsuper.awakeFromNib()\nStackWalkthrough(5)\n&#125;\n</code></pre>\n<p>这将给 StackWalkThrough 传入了参数 5。5 仅是一个用于显示堆栈工作方式的值。<br />\n在深入研究 RSP 和 RBP 之前，最好快速了解一下 StackWalkthrough 中发生的事情。在 StackWalkthrough 函数上创建一个符号断点。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4vuu0ylaj31uc0o44d4.jpg\" alt=\"\" /></p>\n<p>构建并运行。Xcode 会在 StackWalkthrough 中中断。一定要通过 source” 查看 StackWalkthrough 函数 (即使它是汇编)。通过源代码查看函数将显示 AT&amp;T 汇编 (因为它是用 AT&amp;T ASM 编写的)。<br />\nXcode 将显示以下程序集:</p>\n<pre><code>push  %rbp       ; Push contents of RBP onto the stack (*RSP = RBP, RSP decreases)\n\nmovq  %rsp, %rbp ; RBP = RSP\nmovq  $0x0, %rdx ; RDX = 0\nmovq  %rdi, %rdx ; RDX = RDI\npush  %rdx       ; Push contents of RDX onto the stack (*RSP = RDX, RSP decreases)\n\nmovq  $0x0, %rdx ; RDX = 0\npop   %rdx       ; Pop top of stack into RDX (RDX = *RSP, RSP increases)\n\npop   %rbp       ; Pop top of stack into RBP (RBP = *RSP, RSP increases)\n\nret              ; Return from function (RIP = *RSP, RSP increases)\n</code></pre>\n<p>上面的输出中已经为您添加了注释来帮助理解发生了什么。通读一遍，如果可以的话，试着理解它。您已经熟悉了 mov 指令，程序集的其余部分由您刚刚了解的与函数相关的操作码组成。<br />\n这个函数接受传入的整型参数 (您还记得，第一个参数是在 RDI 中传入的)，将其存储到 RDX 寄存器中，并将该参数压入堆栈。然后将 RDX 设置为 0x0，然后将从堆栈中  <code>pop</code>  的值存储回 RDX 寄存器。<br />\n请确保您在心里很好地理解这个函数中发生了什么，因为接下来您将研究 LLDB 中的寄存器。<br />\n回到 Xcode 中，在 ViewController.swift 的 awakeFromNib 函数的 StackWalkthrough (5) 行中使用 Xcode 的 GUI 创建一个断点。保留前面的 StackWalkthrough 符号断点，因为在研究寄存器时，您需要在 StackWalkthrough 函数的开始处停止。<br />\n构建和运行并等待 GUI 断点触发。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4weds4k8j31u807m45t.jpg\" alt=\"\" /></p>\n<p>现在通过  <code>Debug\\Debug Workflow\\Always Show Disassembly</code>  菜单让他以汇编形式展示，您将看到很可怕的东西：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4xdujj78j31uc0qw4qp.jpg\" alt=\"\" /></p>\n<p>哇！ 看那个！ 您已经正确进入了  <code>call</code>  操作码指令。 您是否想知道要输入什么功能？</p>\n<p>从这里开始，您将逐步完成每条汇编指令，同时打印出感兴趣的四个寄存器：RBP，RSP，RDI 和 RDX。 为了解决这个问题，在 LLDB 中输入以下内容</p>\n<ul>\n<li>(lldb) command alias dumpreg register read rsp rbp rdi rdx</li>\n</ul>\n<p>这将创建命令 dumpreg，它将 dump 四个感兴趣的寄存器。现在执行 dumpreg:</p>\n<ul>\n<li>(lldb) dumpreg</li>\n</ul>\n<p>然后你将看到一些熟悉的东西</p>\n<pre><code>rsp = 0x00007fff5fbfe820\nrbp = 0x00007fff5fbfe850\nrdi = 0x0000000000000005\nrdx = 0x0040000000000000\n</code></pre>\n<p>在本节中，dumpreg 的输出将覆盖在每个汇编指令上，以准确显示每个指令期间每个寄存器发生的情况。 同样，即使为您提供了这些值，您自己执行和理解这些命令也很重要。<br />\n您的屏幕将类似于以下内容：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4xion6coj31ue0p2qp1.jpg\" alt=\"\" /></p>\n<p>一旦跳入函数调用，请密切注意 RSP 寄存器，因为一旦 RIP 跳到 StackWalkthrough 的开头，它就会发生变化。 如您先前所知，RDI 寄存器将包含第一个参数的值，在这种情况下为 0x5。<br />\n在 LLDB 中，键入以下内容：</p>\n<ul>\n<li>(lldb) si</li>\n</ul>\n<p>这个命令是单步调试的命令，它告诉 LLDB 执行下一条指令，然后暂停调试器。<br />\n现在，您已进入 StackWalkthrough。 对于每一步，再次使用 dumpreg 转储寄存器。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4xm3o2d4j31ue0bwtjq.jpg\" alt=\"\" /></p>\n<p>请注意 RSP 寄存器中的差异。 RSP 指向的值现在将包含前一个函数的返回地址。 对于此特定示例，指向 0x7fff5fbfe758 的 RSP 将包含值 0x100002455-awakeFromNib 中紧随调用之后的地址。<br />\n现在通过 LLDB 进行验证：</p>\n<ul>\n<li>(lldb) x/gx $rsp</li>\n</ul>\n<p>输出将与 awakeFromNib 中调用操作码之后的地址立即匹配。接下来，执行 si，然后执行下一条指令的 dumpreg。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4xomkvtej31ua0bygwn.jpg\" alt=\"\" /></p>\n<p>RBP 的值被压入堆栈。 这意味着以下两个命令将产生相同的输出。 执行两个都进行验证。</p>\n<ul>\n<li>(lldb) x/gx $rsp</li>\n</ul>\n<p>这将查看栈指针寄存器所指向的内存地址。</p>\n<blockquote>\n<p>注意：等等，我只是在没有上下文的情况下向您抛出了一条新命令。 x 命令是内存读取命令的快捷方式。<br />\n/gx 表示以十六进制格式将内存格式化为一个巨大的字（8 个字节，还记得第 11 章 “汇编和内存” 中的术语吗？）。<br />\n奇怪的格式是由于该命令在 gdb 中的常用，您看到此命令语法已移植到 lldb 中，从而使从调试器的转换更加容易。</p>\n</blockquote>\n<p>现在看一下基础指针寄存器的值</p>\n<ul>\n<li>(lldb) p/x $rbp</li>\n</ul>\n<p>接下来让我继续单步调试</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4xsl5iu3j31ua0bqqdy.jpg\" alt=\"\" /></p>\n<p>基础指针被分配给堆栈指针的值。 使用 dumpreg 以及以下 LLDB 命令验证两者的值相同：</p>\n<ul>\n<li>(lldb) p (BOOL)($rbp == $rsp)</li>\n</ul>\n<p>请务必在表达式两边加上括号，否则 LLDB 无法正确解析它。<br />\n再次执行 si 和 dumpreg。 这次看起来像这样：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4xxevkm7j31ue0c4k2g.jpg\" alt=\"\" /></p>\n<p>RDX 寄存器被清零了，我们继续单步调试</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4xy3cd3bj31uc0bwdr1.jpg\" alt=\"\" /></p>\n<p>RDX 被设置为 RDI，你可以用 dumper 继续验证</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4xypwoucj31uc0byn8d.jpg\" alt=\"\" /></p>\n<p>RDX 被推入堆栈。 这意味着堆栈指针已递减，并且 RSP 指向一个值，该值将指向 0x5 的值。 确认下：</p>\n<ul>\n<li>(lldb) p/x $rsp</li>\n</ul>\n<p>这显示了指向 RSP 的当前值。 这意味着什么？</p>\n<ul>\n<li>(lldb) x/gx $rsp</li>\n</ul>\n<p>您将得到 0x5。 再次输入 si 以执行下一条指令：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4y24mnetj31ue0bygwp.jpg\" alt=\"\" /></p>\n<p>RDX 设置为 0x0。 这里没有什么太令人兴奋的，继续前进... 继续前进。 再次输入 si 和 dumpreg：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4y311lvsj31u60byal3.jpg\" alt=\"\" /></p>\n<p>堆栈的顶部 pop 到 RDX 中，您知道最近将其设置为 0x5。 RSP 递增 0x8。 再次输入 si 和 dumpreg：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4y3pxy7lj31uc0bygwo.jpg\" alt=\"\" /></p>\n<p>基本指针从堆栈中 pop，并重新分配回它进入该函数时的原始值。 调用规则指定 RBP 在函数调用之间应保持一致。 也就是说，RBP 离开职能后便无法更改为其他值，所以我们做一个好公民，恢复它的原来的值。</p>\n<p>进入 ret 操作码。 注意即将更改的 RSP 值。 再次输入 si 和 dumpreg：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4y6koug9j31ue0p0kh7.jpg\" alt=\"\" /></p>\n<p>返回地址从堆栈中 pop 并设置为 RIP 寄存器； 您知道这一点，因为您已经回到了调用该函数的位置。 然后，控制会在 awakeFromNib 中恢复，<br />\n哇！ 那很有趣！ 一个简单的功能，但是它说明了堆栈如何通过调用，推入，弹出和退出指令工作。</p>\n<h2 id=\"栈和7个以上的参数\"><a class=\"anchor\" href=\"#栈和7个以上的参数\">#</a> 栈和 7 个以上的参数</h2>\n<p>如第 10 章所述，x86_64 的调用规则将按顺序使用以下寄存器作为函数参数：RDI，RSI，RDX，RCX，R8，R9。 当一个函数需要六个以上的参数时，需要使用堆栈。<br />\n注意：当将大型结构传递给函数时，可能还需要使用堆栈。 每个参数寄存器只能保存 8 个字节（在 64 位体系结构上），因此，如果该结构需要 8 个以上的字节，则也需要在堆栈上传递该结构。 有严格的规则规定他们的调用方式，所有编译器都必须遵守。</p>\n<p>打开 ViewController.swift 并找到名为 executeLotsOfArguments 的函数。 您在第 10 章中使用了此功能来浏览寄存器。 现在，您将再次使用它，以了解如何将参数 7 及其以后的参数传递给该函数。<br />\n将以下代码添加到 viewDidLoad 的末尾：</p>\n<pre><code>_ = self.executeLotsOfArguments(one: 1, two: 2, three: 3,\n                                four: 4, five: 5, six: 6,\n                                seven: 7, eight: 8, nine: 9,\n                                ten: 10)\n</code></pre>\n<p>接下来，使用 Xcode GUI 在刚添加的行上创建一个断点。 生成并运行该应用程序，然后等待该断点出现。 您应该再次看到反汇编视图，但如果没有，请使用 “始终显示反汇编” 选项。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4yd1n45nj31ug0k81j0.jpg\" alt=\"\" /></p>\n<p>正如您在与堆栈相关的操作码一节中了解到的，call 负责函数的执行。因为在 RIP 现在的位置和 viewDidLoad 的结束之间只有一个调用操作码，这意味着这个调用必须负责调用 executeLotsOfArguments<br />\n 但是调用前的其他指令是什么呢？让我们找出答案。<br />\n这些指令根据需要设置堆栈以传递附加参数。你有你通常的 6 个参数被放入适当的寄存器，正如看到的指令在哪里 RIP 现在，从 mov edx, 0x1 开始。<br />\n但是参数 7 和以上需要在堆栈上传递。这可以通过以下说明来完成:</p>\n<pre><code>0x1000013e2 &lt;+178&gt;: mov    qword ptr [rsp], 0x7\n0x1000013ea &lt;+186&gt;: mov    qword ptr [rsp + 0x8], 0x8\n0x1000013f3 &lt;+195&gt;: mov    qword ptr [rsp + 0x10], 0x9\n0x1000013fc &lt;+204&gt;: mov    qword ptr [rsp + 0x18], 0xa\n</code></pre>\n<p>看起来很吓人，我会解释。<br />\n包含 RSP 和可选值的方括号表示取消引用，就像 C 编程中的 * 一样。上面的第一行说 “将 0x7 放入 RSP 指向的内存地址中。” 第二行说 “将 0x8 放入 RSP 所指向的内存地址加 0x8。” 等等。<br />\n这会将值放入堆栈。但是请注意，没有使用 push 指令显式推送这些值，这会减少 RSP 寄存器。这是为什么？</p>\n<p>嗯，如您所知，在调用指令期间，返回地址被压入堆栈。然后，在函数序言中，将基本指针压入堆栈，然后将基本指针设置为堆栈指针。<br />\n您还没有学到的是，编译器实际上会在堆栈上留出 “暂存空间” 的空间。也就是说，编译器根据需要在堆栈上为局部变量分配空间。<br />\n通过在函数序言中查找 sub rsp，VALUE 指令，可以轻松确定是否为堆栈帧分配了额外的暂存空间。例如，单击 viewDidLoad 堆栈框架并滚动到顶部。观察已创建多少暂存空间：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4ykh1ycej31u80nadpm.jpg\" alt=\"\" /></p>\n<p>看看一个变量指向的值…… 它现在肯定不能保持 0x1 的值。为什么一个引用一个看似随机的值？<br />\n 答案是由嵌入到寄存器应用程序的调试构建中的 DWARF 调试信息存储。你可以把这些信息转储到内存中，帮助你了解一个变量在引用什么。LLDB 中输入以下</p>\n<ul>\n<li>(lldb) image dump symfile Registers</li>\n</ul>\n<p>你会得到大量的输出。搜索 (Cmd + F) 单词 “one”; 在搜索的时候加上引号。然后会有如下输出</p>\n<pre><code>Swift.String, type_uid = 0x300000222\n0x7f9b4633a988:     Block&#123;0x300000222&#125;, ranges = [0x1000035e0-0x100003e7f)\n0x7f9b48171a20:       Variable&#123;0x30000023f&#125;, name = &quot;one&quot;, type = &#123;d50e000003000000&#125; 0x00007f9b4828d2a0 (Swift.Int), scope = parameter, decl = ViewController.swift:39, location =  DW_OP_fbreg(-32)\n</code></pre>\n<p>根据输出，名为 execute.Int 的变量位于 executeLotsOfArguments 中，其位置可以在 DW_OP_fbreg（-32）中找到。 这个相当模糊的代码实际上意味着基本指针减去 40，即 RBP-32。或者以十六进制表示，RBP-0x20。</p>\n<p>这是重要的信息。 它告诉调试器，始终可以在此内存地址中找到名为 one 的变量。 嗯，并非总是如此，但总是在该变量有效时（即它在范围内）。</p>\n<p>您可能想知道为什么它不能只是 RDI，因为那是将值传递给函数的地方，并且它也是第一个参数。 好了，RDI 稍后可能需要在函数中重用，因此使用堆栈是更安全的选择。</p>\n<p>调试器仍应在 executeLotsOfArguments 上停止。 确保您正在查看 “始终显示汇编” 输出并寻找汇编。 应该是第 16 行：</p>\n<pre><code>mov    qword ptr [rbp - 0x20], rdi\n</code></pre>\n<p>一旦在 executeLotsOfArguments 的汇编输出中找到它，就在该程序行上创建一个断点。<br />\n继续执行，以使 LLDB 停止在这一行汇编上。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4yviw6w4j31ue0naql9.jpg\" alt=\"\" /></p>\n<p>打印一个输出</p>\n<ul>\n<li>(lldb) po one</li>\n</ul>\n<p>还是乱码。 mph<br />\n 记住，RDI 将包含传递给函数的第一个参数。 因此，为了使调试器能够看到应该为 1 的值，需要将 RDI 写入存储 1 的地址。 在这种情况下，RBP-0x20。<br />\n现在，在 LLDB 中执行汇编指令步骤：</p>\n<ul>\n<li>(lldb) si</li>\n<li>(lldb) po one</li>\n</ul>\n<p>噢！... 是的！ 工作正常！ 所引用的值 1 正确持有值 0x1。<br />\n您可能想知道如果改变一个会发生什么。 好吧，在这种情况下，RBP-0x20 也需要更改。 这可能是需要在其中写入该值以及在何处使用它的另一条指令。 这就是为什么调试版本比发行版本要慢得多的原因。</p>\n<h2 id=\"栈的探索\"><a class=\"anchor\" href=\"#栈的探索\">#</a> 栈的探索</h2>\n<p>不用担心 本章即将完成。 但是，在堆栈探索中应该记住一些非常重要的要点。<br />\n如果您已经在使用函数，并且该函数已经完成了函数序言，则以下各项将适用于 x64 程序集：</p>\n<ul>\n<li>RBP 将指向此功能的堆栈帧的开始地方。</li>\n<li>RBP 将包含前一个堆栈帧的起始地址。 （在 LLDB 中使用 x /gx $ rbp 进行查看）。</li>\n<li>（RBP + 0x8）将指向堆栈跟踪中前一个函数的返回地址（在 LLDB 中使用 x /gx'$ rbp + 0x8' 进行查看）。</li>\n<li>（RBP + 0x10）将指向第 7 个参数（如果有）。</li>\n<li>（RBP + 0x18）将指向第 8 个参数（如果有）。</li>\n<li>（RBP + 0x20）将指向第 9 个参数（如果有）。</li>\n<li>（RBP + 0x28）将指向第十个参数（如果有）。</li>\n<li>RBP-X，其中 X 是 0x8 的倍数，将引用该函数的局部变量。</li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "https://oliverqueen.cn/2020-11-21-%E6%B1%87%E7%BC%96%E5%92%8C%E5%86%85%E5%AD%98/",
            "url": "https://oliverqueen.cn/2020-11-21-%E6%B1%87%E7%BC%96%E5%92%8C%E5%86%85%E5%AD%98/",
            "title": "汇编和内存",
            "date_published": "2020-11-21T08:50:53.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"汇编和内存\"><a class=\"anchor\" href=\"#汇编和内存\">#</a> 汇编和内存</h1>\n<p>你已经开了汇编学习的旅程，并且在前几章中你已经学习了汇编调用的一些黑魔法，你现在知道了，当一个函数被调用，他的参数和返回值是如何传递的。但是您还没学到的是将代码加载到内存后如何执行代码。</p>\n<p>在本章中，您将探索程序的执行方式。 您将看到一个特殊的寄存器，该寄存器用于告诉处理器应该从何处读取下一条指令，以及不同大小和内存分组如何产生截然不同的结果。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkww85fg8yj30u012ob29.jpg\" alt=\"\" /></p>\n<p><span id=\"more\"></span></p>\n<h2 id=\"设置英特尔风格汇编体验tm\"><a class=\"anchor\" href=\"#设置英特尔风格汇编体验tm\">#</a> 设置英特尔风格汇编体验™</h2>\n<p>如上一章所述，显示汇编有两种主要方法。 一种类型是 AT＆T 程序集，这个也是 LLDB 的默认程序集。 这种格式具有以下格式：</p>\n<pre><code>opcode（操作码）  source（源）  destination（目的地）\n</code></pre>\n<p>看一个具体的例子</p>\n<pre><code>movq  $0x78, %rax\n</code></pre>\n<p>这个操作会将十六进制值  <code>0x78</code>  移动到  <code>RAX</code>  寄存器中。 尽管这种汇编形式对某些人来说很不错，但从现在开始，您将使用英特尔的表示形式。</p>\n<blockquote>\n<p>注意：汇编的选择有点像一场大战，有的人说用 Inter 的格式，有的说是用 AT&amp;T 的格式，在 StackOverflow 中查看以下<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTcyNjAyL2F0dC12cy1pbnRlbC1zeW50YXgtYW5kLWxpbWl0YXRpb25z\">讨论</span><br />\n选择使用英特尔是因为大家都觉得英特尔在阅读方面更好，但有时在写作方面更差。 由于您正在学习调试，因此大部分时间是在阅读汇编而不是编写汇编。</p>\n</blockquote>\n<p>把以下的两行内容添加进  <code>~/.lldbinit file</code>  文件底部</p>\n<ul>\n<li>settings set target.x86-disassembly-flavor intel</li>\n<li>settings set target.skip-prologue false</li>\n</ul>\n<p>第一行告诉 LLDB 以 Intel 风格显示 x86 汇编（32 位和 64 位）。<br />\n第二行告诉 LLDB 不要跳过函数序言。 您在本书的前面已经了解了这一点，从现在开始，请不要跳过序言，因为您将直接从函数的第一条指令检查汇编。</p>\n<p>&lt;font color=#0099ff size=3 face=&quot;黑体&quot;&gt; 关于函数序言和函数尾声可以再参考这篇<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3phbmcxNDE1ODg3NjEvYXJ0aWNsZS9kZXRhaWxzLzEwMzk4NDIyNg==\">文章</span> &lt;/font&gt;</p>\n<p>&lt;font color=#DC143C size=3 face=&quot;黑体&quot;&gt; 注意：在编辑〜/.lldbinit 文件时，请确保您不使用 TextEdit 之类的程序，因为它将在文件中添加不必要的字符，这可能导致 LLDB 无法正确解析该文件。 一种简单（尽管很危险）的添加方法是通过如下的 Terminal 命令：echo“ settings set target.x86-disassembly-flavor intel” &gt;&gt;〜/.lldbinit。<br />\n确保其中有两个 “&gt;&gt;”，否则将覆盖〜/.lldbinit 文件中的所有先前内容。 如果您对终端机不满意，最好的选择是 nano（您之前使用过的编辑器）。&lt;/font&gt;</p>\n<p>英特尔风格将交换源值和目标值，删除 '％' 和 '$' 字符以及进行许多其他许多更改。 由于您还不会使用 AT＆T 语法，因此这里就不解释全部的差异，我们只单单学习 Inter 程序集就够了。</p>\n<p>看下面的示例，就是以 Inter 风格来展示，他看起来比较干净，比较好阅读。</p>\n<pre><code>mov  rax, 0x78\n</code></pre>\n<p>同样，这会将十六进制值 0x78 移到 RAX 寄存器中。<br />\n与前面显示的 AT＆T 风格相比，Intel 风格交换了源操作数和目标操作。 现在，目标操作数在源操作数之前。 在进行汇编时，务必始终确定正确的风格，这很重要，因为如果您不清楚要使用的风格，则可能会采取不同的操作。</p>\n<p>从现在开始，我们就开始使用 Inter 的汇编格式了。 如果您看到以 $ 字符开头的数字十六进制常量或以％开头的寄存器，你就要把他们转换成 Inter 的形式</p>\n<blockquote>\n<p>注：笔者反而觉得 AT&amp;T 的风格更适合中国汉语的语法，只是前面的 % 和 $ 有些奇怪罢了</p>\n</blockquote>\n<h2 id=\"创建cpx命令\"><a class=\"anchor\" href=\"#创建cpx命令\">#</a> 创建 cpx 命令</h2>\n<p>首先，您将创建自己的 LLDB 命令，之后会用到。<br />\n再次打开〜/.lldbinit（vim）。 然后将以下内容添加到文件底部：</p>\n<ul>\n<li>command alias -H &quot;Print value in ObjC context in hexadecimal&quot; -h &quot;Print in hex&quot; -- cpx expression -f x -l objc --</li>\n</ul>\n<p>cpx 是一个便捷命令，您可以使用 Objective-C 上下文以十六进制格式打印出某些内容。 尤其是在打印出寄存器内容时会用到。<br />\n请记住，寄存器在 Swift 上下文中不可用，因此您需要使用 Objective-C 上下文。<br />\n现在，您已经具有从汇编的角度探讨本章内容所需的工具！</p>\n<h2 id=\"位字节和其他术语\"><a class=\"anchor\" href=\"#位字节和其他术语\">#</a> 位，字节和其他术语</h2>\n<p>在开始探索内存之前，您需要了解一些有关内存分组方式的词汇。</p>\n<ul>\n<li>位 ：可以包含 1 或 0 的值称为位。您可以说在 64 位体系结构中每个地址有 64 位。很简单。</li>\n<li>字节：当 8 位组合在一起时，它们称为字节。一个字节可以容纳多少个唯一值？您可以通过计算 2 ^ 8（从 0 开始到 255 的 256 个值）来确定。</li>\n</ul>\n<p>许多信息以字节表示。例如，C 语言中 sizeof（）函数以字节为单位返回对象的大小。</p>\n<p>如果您熟悉 ASCII 字符编码，您会想起所有 ASCII 字符都可以保存在一个字节中。<br />\n现在是时候看看实际操作中的术语并学习一些技巧。<br />\n打开 Registers macOS 应用程序，您将在本章的资源文件夹中找到该应用程序。接下来，构建并运行该应用程序。一旦运行，请暂停程序并启动 LLDB 控制台。这将导致使用非 Swift 调试上下文，因为默认情况下暂停应用程序会带来非 Swift 上下文。<br />\n在 LLDB 中键入以下内容：</p>\n<ul>\n<li>p sizeof('A')</li>\n</ul>\n<p>这将打印出组成 'A' 字符所需的字节数</p>\n<pre><code>(unsigned long) $0 = 1\n</code></pre>\n<p>然后输入如下命令</p>\n<ul>\n<li>p/t 'A'</li>\n</ul>\n<p>你会得到</p>\n<pre><code>(char) $1 = 0b01000001\n</code></pre>\n<p>这是 ASCII 中字符 A 的二进制表示。<br />\n显示信息字节的另一种更常见的方法是使用十六进制值。 需要两个十六进制数字以十六进制表示一个信息字节。</p>\n<p>然后我们输入以下命令来打印出 “A” 的十六进制表示形式：</p>\n<ul>\n<li>p/x 'A'</li>\n</ul>\n<p>你将会得到</p>\n<pre><code>(char) $2 = 0x41\n</code></pre>\n<p>十六进制非常适合查看内存，因为一个十六进制数字恰好代表 4 位。 因此，如果您有 2 个十六进制数字，则您有 1 个字节。 如果您有 8 个十六进制数字，则您有 4 个字节。 等等。<br />\n这里还有一些适用于您的术语，这些术语在以后的章节中会很有用：</p>\n<ul>\n<li>Nybble：4 位，十六进制单个值</li>\n<li>Half word：16 位或 2 个字节</li>\n<li>Word：32 位或 4 个字节</li>\n<li>Double word or Giant word：64 位或 8 字节。</li>\n</ul>\n<p>使用此术语，您将可以探索不同的内存块。</p>\n<h2 id=\"rip寄存器\"><a class=\"anchor\" href=\"#rip寄存器\">#</a> RIP 寄存器</h2>\n<p>当程序执行时，将要执行的代码加载到内存中。 程序中接下来要执行的代码的位置由一个非常重要的寄存器决定：RIP 或指令指针寄存器。<br />\n让我们来看看实际情况。 再次打开 “register demo” 应用程序，然后导航到 AppDelegate.swift 文件。 修改文件，使其包含以下代码：</p>\n<pre><code>@NSApplicationMain\nclass AppDelegate: NSObject, NSApplicationDelegate &#123;\n\nfunc applicationWillBecomeActive(\n    _ notification: Notification) &#123;\n    print(&quot;\\(#function)&quot;)\n    self.aBadMethod()\n&#125;\n\nfunc aBadMethod() &#123;\n    print(&quot;\\(#function)&quot;)\n&#125;\n\nfunc aGoodMethod() &#123;\n    print(&quot;\\(#function)&quot;)\n&#125;\n&#125;\n</code></pre>\n<p>构建并运行该应用程序。 毫无疑问，控制台将会输出 该方法名  <code>applicationWillBecomeActive（_ :)</code>  ，然后输出  <code>aBadMethod</code>  。我们在在 aBadMethod 的开始处创建一个断点：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkwqomut9kj31v30u0h5e.jpg\" alt=\"\" /></p>\n<p>再次构建并运行。 在 aBadMethod 的开头命中断点后，导航至 Debug \\ Debug Workflow \\ Always Show Disassembly in Xcode。 现在，您将看到程序的实际汇编！</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkwqrg4bs4j30u00w8tq1.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkwqpnpyuwj32b30u0b29.jpg\" alt=\"\" /></p>\n<p>然后我们在控制台输入以下命令：</p>\n<pre><code>cpx $rip\n</code></pre>\n<p>这将使用您先前创建的 cpx 命令打印出指令指针寄存器。<br />\n您会注意到输出 LLDB 的地址与 Xcode 中绿线突出显示的地址是一样的：</p>\n<pre><code>(unsigned long) $1 = 0x0000000100008910\n</code></pre>\n<p>当然了每个人的电脑上显示的地址是不同的，而且每次执行时候的地址都可能不一样，但是在单次运行中绿线和控制台上显示的肯定是完全一样的。你试着在控制台下打以下命令：</p>\n<pre><code>(lldb) image lookup -vrn ^Registers.*aGoodMethod\n</code></pre>\n<p>这是一个很常用的查找命令，其中包含典型的正则表达式参数以及添加的参数  <code>-v</code>  ，该参数输出详细信息就像  <code>--verbose</code> 。<br />\n您会看到很多的东西。 在控制台中使用  <code>command + F</code>  来搜索关键字  <code>range = [</code>  其中范围中的第一个值便是</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkwra1dlerj31m00u0hdu.jpg\" alt=\"\" /></p>\n<p>该地址称为加载地址。 这是此函数在内存中的实际物理地址！这与您在 <code>image lookup</code>  命令中看到的常规输出不同，它仅显示函数相对于可执行文件的偏移量，也称为实现偏移量。 寻找函数地址时，区分加载地址和可执行文件中的实现偏移很重要，因为它会有所不同。</p>\n<p>将这个新地址复制到范围括号的开头。 对于此特定示例，aGoodMethod 的加载地址位于 0x0000000100008910。 现在将 aGoodMethod 的地址指向 RIP 寄存器。输入以下指令</p>\n<ul>\n<li>register write rip 0x0000000100008910</li>\n</ul>\n<p>单击继续，使用 Xcode 调试按钮单击 “继续”。 请一定用 Xcode 的按钮来继续，不要是用  <code>continue</code>  命令，因为在修改 RIP 寄存器并在控制台中继续操作时就会崩溃。按下 Xcode 继续按钮后，您会看到神奇的事情 -&gt; 未执行 aBadMethod（），而是执行了 aGoodMethod（）。 通过查看控制台日志中的输出来验证这一点。</p>\n<blockquote>\n<p>注意：修改 RIP 寄存器实际上非常危险。 您需要确 RIP 寄存器上的数据不会再被使用了，因为新功能将对 RIP 寄存器做出不正确的假设。 由于 aGoodMethod 和 aBadMethod 在功能上非常相似，因此您从一开始就停了下来，并且由于没有对 Registers 应用程序进行任何修改，因此不必担心。</p>\n</blockquote>\n<h2 id=\"寄存器和比特分解\"><a class=\"anchor\" href=\"#寄存器和比特分解\">#</a> 寄存器和比特分解</h2>\n<p>如上一章所述，x64 具有 16 个通用寄存器：RDI，RSI，RAX，RDX，RBP，RSP，RCX，RDX，R8，R9，R10，R11，R12，R13，R14 和 R15。<br />\n为了保持与 i386 的 32 位架构等以前的体系结构的兼容性，可以将寄存器分为 32 位，16 位或 8 位值。</p>\n<p>对于具有不同体系结构历史的寄存器，寄存器名称中的最前面的字符确定寄存器的大小。 例如，RIP 寄存器以 R 开头，它表示 64 位。 如果您希望使用等效于 RIP 寄存器的 32 位，则可以将 R 字符换成 E，以获得 EIP 寄存器。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkwsm5uzn1j30wj0u0qf1.jpg\" alt=\"\" /></p>\n<p>为什么这些有用？ 因为使用寄存器时，有时传递到寄存器的值不需要全部使用 64 位。 例如，考虑布尔数据类型：您真正需要的只是 1 或 0 以指示是或否（尽管实际上，布尔值将占用寄存器一个字节）。 基于语言的功能和约束，编译器知道这一点，有时只会将信息写入寄存器的某些部分。<br />\n让我们来看看实际情况。<br />\n删除 Registers 项目中的所有断点。 生成并运行项目。 现在，让程序暂停。输入以下内容：</p>\n<ul>\n<li>register write rdx 0x0123456789ABCDEF</li>\n</ul>\n<p>这会将值写入 RDX 寄存器。让我们停一分钟。 &lt;font color=red size=3&gt; 提示：您应该注意，写入寄存器可能会导致程序崩溃，尤其是当您希望写入的寄存器具有某种类型的数据时 &lt;/font&gt;。 但是你现在是在 demo 上做调试，所以请不要担心您的程序是否崩溃！<br />\n确认此值已成功写入 RDX 寄存器：</p>\n<ul>\n<li>p/x $rdx</li>\n</ul>\n<p>输出</p>\n<pre><code>(unsigned long) $0 = 0x0123456789abcdef\n</code></pre>\n<p>然后输入</p>\n<ul>\n<li>p/x $dx</li>\n</ul>\n<p>这将打印出 DX 寄存器，该寄存器是 EDX 寄存器的最低有效部分。 因此，这是一个半字。 您应该看到以下内容：</p>\n<pre><code>0xcdef\n</code></pre>\n<p>再输入</p>\n<ul>\n<li>p/x $dl</li>\n</ul>\n<p>这将打印出 DL 寄存器，它是 DX 寄存器的最低有效位 - 这次是一个字节。 您应该看到以下内容</p>\n<pre><code>0xef\n</code></pre>\n<p>最后输出如下指令</p>\n<ul>\n<li>p/x $dh</li>\n</ul>\n<p>这为您提供了 DX 寄存器的最高有效部分，即 DL 给出的另一半。 DL 中的 L 代表 “低” 而 DH 中的 H 代表 “高” 也就不足为奇了。<br />\n探索汇编时，请注意不同尺寸的寄存器。 寄存器的大小可以为其中包含的值提供线索。 例如，您可以轻松地查找通过 AL 寄存器返回布尔值的函数，因为布尔值将使用 8 个字节，&lt;font color=red size=3&gt; 而 AL 是 64 位 “返回值寄存器” RAX 的 8 位部分 &lt;/font&gt;</p>\n<h2 id=\"寄存器-r8-到-r15\"><a class=\"anchor\" href=\"#寄存器-r8-到-r15\">#</a> 寄存器 R8 到 R15</h2>\n<p>由于 R8 至 R15 系列寄存器仅针对 64 位架构而创建，因此它们使用完全不同的格式表示较小的寄存器。</p>\n<p>现在，您将看下 R9 的不同大小如何选择。生成并运行 Registers 应用程序，然后暂停调试器。像以前一样，将相同的十六进制值写入 R9 寄存器：</p>\n<ul>\n<li>register write $r9 0x0123456789abcdef</li>\n</ul>\n<p>输入以下内容，以确认您已设置 R9 寄存器成功：</p>\n<ul>\n<li>p/x $ r9</li>\n</ul>\n<p>输入以下内容，这将打印 R9 寄存器的低 32 位。请注意，它与您为 RDX 指定低 32 位（即 EDX）的方式有何不同。</p>\n<ul>\n<li>p/x $ r9d</li>\n</ul>\n<p>然后输入以下内容，这次您获得 R9 的低 16 位。同样，这与您为 RDX 进行此操作的方式不同</p>\n<ul>\n<li>p/x $ r9w</li>\n</ul>\n<p>再输入以下内容，打印出 R9 的低 8 位</p>\n<ul>\n<li>p/x $ r9l</li>\n</ul>\n<p>尽管这看起来有些乏味，但是您正在建立阅读汇编语言的技巧。</p>\n<h2 id=\"内存中断\"><a class=\"anchor\" href=\"#内存中断\">#</a> 内存中断</h2>\n<p>现在，您已经了解了指令指针，是时候进一步探索其背后的内存了。顾名思义，指令指针实际上是一个指针。它不执行 RIP 寄存器中存储的指令，而是执行 RIP 寄存器中指向的指令。</p>\n<p>在 LLDB 中看到这一点也许会更好地描述它。返回 Registers 应用程序中，打开 AppDelegate.swift 并再次在 aBadMethod 上设置一个断点。生成并运行该应用程序。</p>\n<p>命中断点并停止程序后，导航回到汇编视图。如果您忘记了该操作，但尚未为其创建键盘快捷键，则可以在 Debug \\ Debug Workflow \\ Always Show Disassembly 下找到它。<br />\n您会看到一堆汇编指令。看一下 RIP 寄存器的位置，该位置应指向函数的最开始。<br />\n对于该项目，aBadMethod 的起始地址始于 0x100008910。和往常一样，您的地址可能会有所不同。<br />\n在 LLDB 控制台中，键入以下内容：</p>\n<ul>\n<li>cpx $rip</li>\n</ul>\n<p>到现在为止，这将打印出指令指针寄存器的内容。如预期的那样，您将获得 aBadMethod 起始地址。 但是同样，RIP 寄存器指向内存中的值。 它指的是什么？ 嗯，您可以摆脱疯狂的 C 编码技巧（您还记得吗？）并取消引用指针，但是使用 LLDB 可以找到一种更为优雅的方法。<br />\n输入以下内容，将地址替换为您的 aBadMethod 函数的地址：</p>\n<ul>\n<li>memory read -fi -c1 0x100008910</li>\n</ul>\n<p>哇，该命令到底能做什么？  <code>memory read </code>  采用一个值，并读取您提供的内存地址所指向的内容。  <code>-f</code>  命令是一个格式参数。 在这种情况下，它是汇编指令格式。 最后，您说的是只希望使用 count 或 - c 参数打印一条汇编指令。<br />\n您将获得类似于以下内容的输出：</p>\n<pre><code>-&gt;  0x1000017c0: 55  pushq  %rbp\n</code></pre>\n<p>这是一些很好的输出。 它告诉您十六进制（0x55）中提供的汇编指令以及操作码，这些指令是  <code>pushq ％rbp</code>  操作</p>\n<blockquote>\n<p>注意：等等，您看到 '％' 吗？！ LLDB 中存在一个错误，当您以指令格式打印代码时，该错误不符合您的汇编风格。 请记住，如果您看到这种情况，则源和目标操作数将被反转！这就是 inter 指令集和 AT&amp;T 指令集的区别。</p>\n</blockquote>\n<p>让我们再看一下输出中的 “55”。 这是整个指令（即整个 pushq ％rbp）的编码。 不相信我吗？ 您可以验证它。 在 LLDB 中输入以下内容：</p>\n<ul>\n<li>expression -f i -l objc -- 0x55</li>\n</ul>\n<p>这实际上要求 LLDB 将 0x55 解释为 x64 操作码。 您将获得以下输出：</p>\n<pre><code>$1 = 55 pushq％rbp\n</code></pre>\n<p>该命令有点长，但这是因为如果您在 Swift 调试上下文中，则需要切换到 Objective-C 上下文。 但是，如果移至 Objective-C 调试上下文，则可以使用简短得多的便捷表达式。</p>\n<p>尝试单击 Xcode 左侧面板中的其他框架，以进入一个不包含 Swift 或 Objective-C / Swift 桥接代码的 Objective-C 上下文。 单击 Objective-C 函数中的任何框架。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkwvrtvgixj30u01efnix.jpg\" alt=\"\" /></p>\n<p>下一步，在 LLDB 控制台中键入以下内容：</p>\n<ul>\n<li>p/i 0x55</li>\n</ul>\n<p>好多了，对吧？<br />\n现在，回到手中的应用程序。 在 LLDB 中键入以下内容，再次用 aBadMethod 函数地址替换地址：</p>\n<ul>\n<li>memory read -fi -c10 0x1000017c0</li>\n</ul>\n<p>你讲获得以下输出：</p>\n<pre><code>-&gt; 0x100008910: 55                    pushq  %rbp\n0x100008911: 48 89 e5              movq   %rsp, %rbp\n0x100008914: 48 81 ec c0 00 00 00  subq   $0xc0, %rsp\n0x10000891b: 4c 89 6d f8           movq   %r13, -0x8(%rbp)\n0x10000891f: b8 01 00 00 00        movl   $0x1, %eax\n0x100008924: 89 c7                 movl   %eax, %edi\n0x100008926: e8 d5 05 00 00        callq  0x100008f00               ; symbol stub for: generic specialization &lt;preserving fragile attribute, Any&gt; of Swift._allocateUninitializedArray&lt;A&gt;(Builtin.Word) -&gt; (Swift.Array&lt;A&gt;, Builtin.RawPointer)\n0x10000892b: 48 89 c7              movq   %rax, %rdi\n0x10000892e: 48 89 45 a8           movq   %rax, -0x58(%rbp)\n0x100008932: 48 89 55 a0           movq   %rdx, -0x60(%rbp)\n</code></pre>\n<p>这里需要注意一些有趣的事情：汇编指令的长度可以变化。 看一下第一条指令，然后看输出中的其余指令。 第一条指令的长度为 1 个字节，用 0x55 表示。 以下指令的长度为三个字节。<br />\n确保您仍在 Objective-C 上下文中，并尝试打印出负责此指令的操作码。 它只有三个字节，所以您只需将它们连接在一起</p>\n<ul>\n<li>p/i 0x4889e5</li>\n</ul>\n<p>您将获得与  <code>mov ％rsp，％rbp</code>  指令完全无关的另一条指令！ 您会看到以下内容：</p>\n<pre><code>e5 89  inl    $0x89, %eax\n</code></pre>\n<p>是怎么做到的呢？ 也许现在是谈论字节序的好时机。</p>\n<h2 id=\"字节序这东西倒过来了\"><a class=\"anchor\" href=\"#字节序这东西倒过来了\">#</a> 字节序... 这东西倒过来了</h2>\n<p>x64 以及 ARM 系列体系结构设备均使用低位字节序，这意味着数据以最低有效字节在先的形式存储在内存中。 如果要将数字 0xabcd 存储在内存中，则会先存储 0xcd 字节，然后再存储 0xab 字节。<br />\n回到指令示例，这意味着指令 0x4889e5 将以 0xe5、0x89、0x48 的形式存储在存储器中。<br />\n返回到您先前遇到的 mov 指令，请尝试反转用于构成汇编指令的字节。 在 LLDB 中输入以下内容：</p>\n<ul>\n<li>p/i 0xe58948</li>\n</ul>\n<p>您现在将获得预期的汇编表示：</p>\n<pre><code>$2 = 48 89 e5  movq   %rsp, %rbp\n</code></pre>\n<p>让我们再看看一些小端实践的例子。 在 LLDB 中输入以下内容：</p>\n<ul>\n<li>memory read -s1 -c20 -fx 0x100008910</li>\n</ul>\n<p>此命令读取地址为 0x100008910 的内存。 -s1 选项可读取 1 个字节的大小块，-c20 选项可读取 20 个字节的大小块。 您会看到类似这样的内容：</p>\n<pre><code>0x100008910: 0x55 0x48 0x89 0xe5 0x48 0x81 0xec 0xc0\n0x100008918: 0x00 0x00 0x00 0x4c 0x89 0x6d 0xf8 0xb8\n0x100008920: 0x01 0x00 0x00 0x00\n</code></pre>\n<p>现在，将大小增加一倍，数量减少一半，就像这样：</p>\n<ul>\n<li>memory read -s2 -c10 -fx 0x100008910</li>\n</ul>\n<p>你会看到这样的输出</p>\n<pre><code>0x100008910: 0x4855 0xe589 0x8148 0xc0ec 0x0000 0x4c00 0x6d89 0xb8f8\n0x100008920: 0x0001 0x0000\n</code></pre>\n<p>请注意，当将内存值分组在一起时，由于使用了低位字节序，它们将被颠倒。<br />\n现在，将大小再增加一倍，数量再减少一半：</p>\n<ul>\n<li>memory read -s4 -c5 -fx 0x100008910</li>\n</ul>\n<p>然后你会看到如下输出</p>\n<pre><code>0x100008910: 0xe5894855 0xc0ec8148 0x4c000000 0xb8f86d89\n0x100008920: 0x00000001\n</code></pre>\n<p>与之前的输出相比，这些值再次被颠倒。<br />\n记住这一点非常重要，但在探索你自己的记忆时，这会让你变得很混乱。不仅内存的大小会给您一个潜在的错误答案，而且顺序也会给您一个潜在的错误答案。当你开始对着电脑大喊大叫时，当你试图弄清楚某样东西应该如何工作时，请记住这一点！</p>\n",
            "tags": []
        },
        {
            "id": "https://oliverqueen.cn/2020-11-19-%E6%B1%87%E7%BC%96%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E8%A7%84%E5%88%99/",
            "url": "https://oliverqueen.cn/2020-11-19-%E6%B1%87%E7%BC%96%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E8%A7%84%E5%88%99/",
            "title": "汇编寄存器的规则",
            "date_published": "2020-11-19T09:12:10.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"汇编寄存器的规则\"><a class=\"anchor\" href=\"#汇编寄存器的规则\">#</a> 汇编寄存器的规则</h1>\n<p>在本章中，您将了解到 CPU 使用的寄存器，并研究和修改传入函数的参数。您还将了解常见的苹果计算机架构，以及如何在函数中使用它们的寄存器。这就是所谓的架构调用约定。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkulov9q1ej31c10u0x6s.jpg\" alt=\"\" /><br />\n<span id=\"more\"></span><br />\n 了解汇编如何工作以及特定架构的调用约定如何工作是一项极其重要的技能。它可以让您观察没有源代码的函数参数，并允许您修改传入函数的参数。此外，有时转到底层汇编层面会更好，因为您的源代码可能对您不知道的变量有不同的或未知的名称。<br />\n例如，假设您想知道函数调用的第二个参数，但是我并不知道参数的名称是什么。汇编的知识会帮助你来观察这些函数中的参数。</p>\n<h2 id=\"汇编101\"><a class=\"anchor\" href=\"#汇编101\">#</a> 汇编 101</h2>\n<p>等等，所以到底什么是汇编？来看一个场景：您是否曾经打了一个断点，但是中断到没有源代码的地方？然后看到看到大量内存地址和可怕的简短命令？你是不是缩成一团，悄悄地对自己说你再也不会看这些密集的东西了？嗯… 这就是所谓的汇编！<br />\n 这里有一张 Xcode 中的断点调试图，它展示了模拟器中函数的汇编。<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gktboylxxdj322z0li150.jpg\" alt=\"\" /></p>\n<p>通过上图可以看出汇编代码可以被分成几个不同的部分。汇编指令中的每一行都包含一个操作码，可以认为是对计算机来说非常简单的指令。那么操作码是什么样子的呢？操作码是在计算机上执行一项简单任务的指令。例如下面的程序集片段:</p>\n<p><figure class=\"highlight mel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pushq   %rbx</span><br><span class=\"line\">subq    $0x228, %rsp </span><br><span class=\"line\">movq    %rdi, %rbx </span><br></pre></td></tr></table></figure></p>\n<p>在这个汇编模块中，您可以看到三种操作码: <code>pushq</code> 、 <code>subq</code>  和  <code>movq</code>  可以将操作码项看作要执行的操作。操作码后面的内容是源标签和目标标签。也就是说，这些是操作码所作用的对象。在上面的示例中，有几个寄存器，显示为  <code>rbx</code>  、 <code>rsp</code>  、 <code>rdi</code>  和  <code>rbp</code> 。前面的  <code>%</code>  告诉您这是一个寄存器。</p>\n<p>此外，您还可以找到一个十六进制的数字常量，如 0x228。这个常数之前的美元符号告诉你它是一个绝对值。现在不需要知道这段代码在做什么，因为您首先需要了解每个符号的含义。然后你会学到更多关于操作码的知识，并在以后的章节中编写你自己的程序。</p>\n<blockquote>\n<p>注意：在上面的示例中，请注意，在寄存器和常量之前有一堆％和 $。 这就是反汇编程序格式化程序集的展示方式。 但是可以通过两种主要方式展示汇编。 第一个是  <code>英特尔程序集</code>  ，第二个是  <code>AT＆T程序集</code>  。默认情况下，Apple 的反汇编程序工具都会以 AT＆T 格式显示，就如上例所示。 尽管这是一种很好的格式，但在眼睛上可能会有些困难。 在下一章中，您将把汇编格式更改为 Intel，并且从那以后将完全使用 Intel 汇编语法。</p>\n</blockquote>\n<h2 id=\"x86_64-vs-arm64\"><a class=\"anchor\" href=\"#x86_64-vs-arm64\">#</a> x86_64 vs ARM64</h2>\n<p>作为 Apple 平台的开发人员，学习汇编时要处理两种主要架构：x86_64 架构和 ARM64 架构。 x86_64 是最可能在 macOS 计算机上使用的体系结构，除非您运行的是 “古老” 的 Macintosh。x86_64 是 64 位体系结构，这意味着每个地址最多可以容纳 64 个 1 或 0。 另外，较旧的 Mac 使用 32 位架构，但是 Apple 在 2010 年底停止生产 32 位 Mac。 在 macOS 下运行的程序可能是 64 位兼容的，包括 Simulator 上的程序。 话虽如此，即使您的 macOS 是 x86_64，它仍然可以运行 32 位程序。如果对使用的硬件架构有疑问，可以在终端中运行以下命令来获取计算机的硬件架构：</p>\n<ul>\n<li>uname -m</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gktcxe1lm2j30c902xgll.jpg\" alt=\"\" /></p>\n<p>在能耗要求很高的移动设备（如 iPhone）上使用 ARM64 体系结构。ARM 强调节能功能，因此它减少了一组操作码，有助于简化复杂的汇编指令，从而降低了能耗。 这对您来说是个好消息，因为关于 ARM 的体系结构你需要学习的并不多。这是与之前显示的方法相同的屏幕截图，除了这次是在 iPhone 7 上的 ARM64 程序集中：<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gktd6atsyvj32140mv4bh.jpg\" alt=\"\" /><br />\n您现在可能无法区分这两种架构，但是您很快就会知道它们就像手背一样.</p>\n<blockquote>\n<p>Apple 最初在其许多 iOS 设备中都提供了 32 位 ARM 处理器，但此后便转移到了 64 位 ARM 处理器。 32 位 iOS 设备几乎已过时，因为 Apple 已通过各种 iOS 版本逐步淘汰了它们。 例如，iPhone 5 是最终的 32 位 iOS 设备，iOS 11 不支持该设备。支持 iOS 11 的 “最低” iPhone 是 64 位设备 iPhone 5s。近年来，32 位设备已出现在其他 Apple 产品中。 Apple Watch 的前两代是 32 位设备，但是第三代是 64 位设备。 此外，在较新的 macOS 设备上发现的 Apple Touch Bar（无疑是花哨的）也使用 32 位架构。</p>\n</blockquote>\n<p>由于最好专注于您将来的需求，因此本书将主要关注两种架构的 64 位汇编。 此外，您将首先开始学习 x86_64 程序集，然后过渡到学习 ARM64 程序集，以免感到困惑。 好吧，不要太困惑。</p>\n<h2 id=\"x86_64-寄存器调用规则\"><a class=\"anchor\" href=\"#x86_64-寄存器调用规则\">#</a> x86_64 寄存器调用规则</h2>\n<p>您的 CPU 使用一组寄存器来操纵正在运行的程序中的数据。这些是存储的基础，就像计算机中的 RAM 一样。但是，它们位于 CPU 本身上，因此 CPU 的这些部分可以快速访问这些寄存器。效率非常高，大多数指令涉及一个或多个寄存器，并执行一些操作，例如将寄存器的内容写入内存，将存储器的内容读取到寄存器或对两个寄存器执行算术运算例如 加，减等。</p>\n<p>在 x64 中（从现在开始，x64 是 x86_64 的缩写），机器使用 16 个通用寄存器来操纵数据。<br />\n这些寄存器是 RAX，RBX，RCX，RDX，RDI，RSI，RSP，RBP 和 R8 至 R15。这些名称对您现在意义不大，但是您很快就会发现每个寄存器的重要性。“在 x64 中调用函数时，寄存器的方式和使用遵循非常特定的规则。这决定了函数的参数应该去哪里以及函数完成时函数的返回值应该在哪里。这很重要，因此可以将一个编译器编译的代码与另一个编译器编译的代码一起使用。</p>\n<p>比如你看下面这个行代码：</p>\n<pre><code>NSString *name = @&quot;Zoltan&quot;;\nNSLog(@&quot;Hello world, I am %@. I'm %d, and I live in %@.&quot;, name, 30, @&quot;my father's basement&quot;);\n</code></pre>\n<p>NSLog 函数调用中传递了四个参数。 其中一些值按原样传递，而一个参数存储在局部变量中，然后在函数中作为参数引用。 但是，通过汇编查看代码时，计算机并不关心变量的名称 (name)； 它只关心该变量在内存中的位置。</p>\n<p>在 x64 汇编中调用函数时，以下寄存器用作参数。 尝试将它们提交到内存中，因为将来您会经常使用它们：</p>\n<pre><code>第一个参数：RDI\n第二个参数：RSI\n第三个参数：RDX\n第四个参数：RCX\n第五个参数：R8\n第六个参数：R9\n</code></pre>\n<p>如果有六个以上的参数，则使用程序的堆栈将其他参数传递给该函数。</p>\n<p>回到简单的 Objective-C 代码，上面的 OC 代码可以像下面这样的伪代码流程在寄存器中传递：</p>\n<p><figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">RDI</span> = @<span class=\"string\">&quot;Hello world, I am %@. I&#x27;m %d, and I live in %@.&quot;</span><span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"built_in\">RSI</span> = @<span class=\"string\">&quot;Zoltan&quot;</span><span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"built_in\">RDX</span> = <span class=\"number\">30</span><span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"built_in\">RCX</span> = @<span class=\"string\">&quot;my father&#x27;s basement&quot;</span><span class=\"comment\">;</span></span><br><span class=\"line\">NSLog(<span class=\"built_in\">RDI</span>, <span class=\"built_in\">RSI</span>, <span class=\"built_in\">RDX</span>, <span class=\"built_in\">RCX</span>)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure></p>\n<p>NSLog 调用完成后，指定的寄存器将包含如上所述的适当值。但是，一旦函数序言（准备堆栈和寄存器的函数的开始部分）完成执行，这些寄存器中的值就可能改变。生成的程序集可能会覆盖存储在这些寄存器中的值，或者在代码不再需要这些引用时丢弃这些引用。<br />\n这意味着，一旦离开函数的开始，就不能再假定这些寄存器将保存您要观察的期望值，除非您实际查看汇编代码看看它在做什么。<br />\n使用此调用规则的浏览寄存器会严重影响您的调试（和断点）策略。必须在函数调用开始时停止以查看或修改参数，而不必实际进入程序集。</p>\n<h2 id=\"objective-c-和寄存器\"><a class=\"anchor\" href=\"#objective-c-和寄存器\">#</a> Objective-C 和寄存器</h2>\n<p>如上一节所述，寄存器使用特定的调用规则。 您也可以将该知识其应用于其他语言。<br />\n当 Objective-C 执行方法时，将执行一个名为  <code>objc_msgSend</code>  的特殊 C 函数。 这些功能实际上有几种不同的类型，但稍后会介绍更多。 这是 Objective-C 动态消息分发的核心。 作为第一个参数，objc_msgSend 获取在其上发送消息的对象的引用。 随后是一个选择器，它只是一个 char *，用于指定在对象上调用的方法的名称。 最后，如果选择器指定应有参数，则 objc_msgSend 在函数中采用可变数量的参数。<br />\n让我们来看一个在 iOS 环境中的具体示例：</p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">id</span> <span class=\"built_in\">UIApplicationClass</span> = [<span class=\"built_in\">UIApplication</span> <span class=\"keyword\">class</span>];</span><br><span class=\"line\">objc_msgSend(<span class=\"built_in\">UIApplicationClass</span>, <span class=\"string\">&quot;sharedApplication&quot;</span>);</span><br></pre></td></tr></table></figure></p>\n<p>第一个参数是对 UIApplication 类的引用，其后是 sharedApplication 选择器 其实就是需要被调用的方法。 判断是否有参数的一种简单方法是简单地检查 Objective-C 选择器中的冒号。 每个冒号将代表一个方法中的参数。<br />\n我们下面来看一个 OC 的方法：</p>\n<p><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">NSString</span> *helloWorldString = [@<span class=\"string\">&quot;Can&#x27;t Sleep; &quot;</span>stringByAppendingString:@<span class=\"string\">&quot;Clowns will eat me&quot;</span>];</span><br></pre></td></tr></table></figure></p>\n<p>最终编译会变成：</p>\n<p><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">NSString</span> *helloWorldString; </span><br><span class=\"line\"><span class=\"attribute\">helloWorldString</span> = objc_msgSend(@<span class=\"string\">&quot;Can&#x27;t Sleep; &quot;</span>, <span class=\"string\">&quot;stringByAppendingString:&quot;</span>, @<span class=\"string\">&quot;Clowns will eat me&quot;</span>);</span><br></pre></td></tr></table></figure></p>\n<p>第一个参数是 NSString 的实例（@“Can't Sleep;”），后跟方法选择器，然后是方法调用的参数。</p>\n<h2 id=\"将理论付诸实践\"><a class=\"anchor\" href=\"#将理论付诸实践\">#</a> 将理论付诸实践</h2>\n<p>在本节中，您将使用本章资源包中提供的名为 Registers 的项目。<br />\n通过 Xcode 打开该项目，然后运行。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gktgwlp1cuj30x40glgoh.jpg\" alt=\"\" /></p>\n<p>这是一个非常简单的应用程序，仅显示 64 位寄存器里面的内容。 需要注意的是，该应用程序不会实时的显示寄存器的值； 它只能在特定的函数调用期间显示寄存器的值。 这意味着您不会看到这些寄存器的值有太多更改，因为在调用获取寄存器值的函数时它们可能具有相同（或相似）的值。<br />\n现在，您已经了解了 Registers macOS 应用程序背后的功能，为 NSViewController 的 viewDidLoad 方法创建一个符号断点。 记住，因为您正在使用 Mac 应用程序，所以请使用 “NS” 代替 “ UI”。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gktm1acug7j30ws0c8n13.jpg\" alt=\"\" /></p>\n<p>生成并重新运行该应用程序。触发断点后在 LLDB 控制台中键入以下内容：</p>\n<ul>\n<li>(lldb) register read</li>\n</ul>\n<p>这将列出处于暂停执行状态的所有主要寄存器。 但是输出了太多信息。 您应该有选择地打印出寄存器，并将其视为 Objective-C 对象。如果您还记得的话，-[NSViewController viewDidLoad] 将被转换为以下程序集伪代码：</p>\n<p><figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">RDI</span> = UIViewControllerInstance </span><br><span class=\"line\"><span class=\"built_in\">RSI</span> = <span class=\"string\">&quot;viewDidLoad&quot;</span></span><br><span class=\"line\">objc_msgSend(<span class=\"built_in\">RDI</span>, <span class=\"built_in\">RSI</span>)</span><br></pre></td></tr></table></figure></p>\n<p>考虑到 x64 调用规则，并且知道 objc_msgSend 的工作方式，您可以找到要加载的特定 NSViewController。<br />\n在 LLDB 控制台中键入以下内容：</p>\n<ul>\n<li>(lldb) po $rdi</li>\n</ul>\n<p>然后你会看到如下输出：</p>\n<p><figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">&lt;Registers.ViewController: 0x6080000c13b0&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>它输出了 RDI 寄存器中的 NSViewController 引用，您现在知道该引用是该方法的第一个参数的位置。</p>\n<p>在 LLDB 中，为寄存器加上 $ 字符很重要，因此 LLDB 知道您需要的是寄存器的值，而不是源代码中与范围相关的变量。 是的，这与您在刚刚反汇编视图中看到的汇编不同！ 烦人吧？</p>\n<blockquote>\n<p>注：善于观察的你可能已经注意到了在 OC 代码中打断点，在 LLDB 的回溯内看不到 objc_msgSend 的影子。这是因为 objc_msgSend 方法簇执行了 jmp。意思就是说 objc_msgSend 扮演了中转的角色，一但 OC 代码开始执行，所有的关于 objc_msgSend 的栈中的回溯都将消失。这是一种叫做尾递归调用的优化。因为 mesgsend 开始执行证明之前的栈帧已经清空了。</p>\n</blockquote>\n<p>尝试打印出 RSI 寄存器，不出意外的话应该是方法名。 在 LLDB 控制台中输入以下内容：</p>\n<ul>\n<li>(lldb) po $rsi</li>\n</ul>\n<p>结果你会输出这个</p>\n<p><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">140735181830794</span><br></pre></td></tr></table></figure></p>\n<p>为什么是这样？ Objective-C 选择器基本上只是一个 char *。 这意味着，像所有 C 类型一样，LLDB 不知道如何格式化此数据。 因此，您必须将此引用显式转换为所需的数据类型。<br />\n将 RSI 寄存器强制转换为正确的类型使用如下指令</p>\n<ul>\n<li>po (char *)<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mi>s</mi><mi>i</mi><mtext>或者</mtext><mi>p</mi><mi>o</mi><mo stretchy=\"false\">(</mo><mi>S</mi><mi>E</mi><mi>L</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">rsi 或者  po (SEL)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">i</span><span class=\"mord cjk_fallback\">或</span><span class=\"mord cjk_fallback\">者</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">o</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathnormal\">L</span><span class=\"mclose\">)</span></span></span></span>rsi</li>\n</ul>\n<p>便可以得到方法名字</p>\n<p><figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;viewDidLoad&quot;</span></span><br></pre></td></tr></table></figure></p>\n<p>现在，该探讨带有参数的 Objective-C 方法了。 由于您已经断点了 viewDidLoad，因此可以放心地假设 NSView 实例已加载。 感兴趣的方法是 mouseUp：由 NSView 的父类 NSResponder 实现的选择器。<br />\n在 LLDB 中，在 NSResponder 的 mouseUp：选择器上创建一个断点，然后继续执行。 如果您不记得该怎么做，则需要以下命令：</p>\n<ul>\n<li>(lldb) b -[NSResponder mouseUp:]</li>\n<li>(lldb) continue</li>\n</ul>\n<p>现在，点击应用程序窗口。 确保单击 NSScrollView 的外部，因为 NSScrollView 它会拦截您的单击，并且不会命中 -[NSResponder mouseUp：] 断点。</p>\n<p>点击后，LLDB 就会在 mouseUp：断点处停止。 通过在 LLDB 控制台中键入以下内容，打印出 NSResponder 的引用：</p>\n<ul>\n<li>(lldb) po $rdi</li>\n</ul>\n<p>会出现如下的输出</p>\n<p><figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">&lt;NSView: 0x608000120140&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>但是，该方法是带参数的！ 在 LLDB 控制台中输入以下内容：</p>\n<ul>\n<li>(lldb) po $rdx</li>\n</ul>\n<p>输出</p>\n<p><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">“NSEvent: <span class=\"attribute\">type</span>=LMouseUp loc=(351.672,137.914) <span class=\"attribute\">time</span>=175929.4 <span class=\"attribute\">flags</span>=0 <span class=\"attribute\">win</span>=0x6100001e0400 <span class=\"attribute\">winNum</span>=8622 <span class=\"attribute\">ctxt</span>=0x0 <span class=\"attribute\">evNum</span>=10956 <span class=\"attribute\">click</span>=1 <span class=\"attribute\">buttonNumber</span>=0 <span class=\"attribute\">pressure</span>=0 deviceID:0x300000014400000 <span class=\"attribute\">subtype</span>=NSEventSubtypeTouch”</span><br></pre></td></tr></table></figure></p>\n<p>也可以看到参数类型</p>\n<ul>\n<li>po [$rdx class]</li>\n</ul>\n<p><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">NSEvent</span></span><br></pre></td></tr></table></figure></p>\n<p>太酷了，是吗？有时使用寄存器和断点很有用，以便获得内存中还存在的对象的引用。例如，如果您想将前部 NSWindow 更改为红色，但是在代码中没有对该视图的引用，又不想重新编译任何代码怎么办？ 您只需创建一个断点就可以轻松调试，从寄存器中获取引用并根据需要操纵该对象的实例。 您现在将尝试将主窗口更改为红色。”</p>\n<blockquote>\n<p>注：尽管 NSResponder 实现了 mouseDown: 方法，但 NSWindow 重写了它。你可以输出所有实现了 mouseDown: 的类，你就可以看出这个方法被那些类重写了，而不用去看源码。输出所有实现了 mouseDown: 方法的 OC 类的命令是：&lt;u&gt;image lookup -rn '\\ mouseDown:&lt;/u&gt;'</p>\n</blockquote>\n<p>首先使用 LLDB 控制台删除所有以前的断点：</p>\n<ul>\n<li>breakpoint delete</li>\n</ul>\n<p>像如下输出</p>\n<p><figure class=\"highlight n1ql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) breakpoint <span class=\"keyword\">delete</span></span><br><span class=\"line\">About <span class=\"keyword\">to</span> <span class=\"keyword\">delete</span> <span class=\"keyword\">all</span> breakpoints, <span class=\"keyword\">do</span> you want <span class=\"keyword\">to</span> <span class=\"keyword\">do</span> that?: [Y/n] Y</span><br><span class=\"line\"><span class=\"keyword\">All</span> breakpoints removed. (<span class=\"number\">3</span> breakpoints)</span><br><span class=\"line\">(lldb) </span><br></pre></td></tr></table></figure></p>\n<p>然后在 LLDB 控制台中键入以下内容：</p>\n<ul>\n<li>(lldb) breakpoint set -o -S &quot;-[NSWindow mouseDown:]</li>\n<li>(lldb) continue</li>\n</ul>\n<p>这句话的作用是设置一个单发断点，只会触发一次，然后点击应用程序触发断点，在 LLDB 控制台中键入以下内容：</p>\n<ul>\n<li>(lldb) po [$rdi setBackgroundColor:[NSColor redColor]]</li>\n<li>(lldb) continue</li>\n</ul>\n<p>之后就可以看到效果</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkuam4sxojj30qo0i8go0.jpg\" alt=\"\" /></p>\n<h2 id=\"swift和寄存器\"><a class=\"anchor\" href=\"#swift和寄存器\">#</a> Swift 和寄存器</h2>\n<p>在 Swift 中探索寄存器时，您将遇到两个问题，这使汇编调试比 Objective-C 困难。</p>\n<ul>\n<li>\n<p>首先，在 Swift 调试上下文内寄存器不可用。意味着你不得不获取到任何你想要的数据，并使用 OC 调试上下文打印出传入 Swift 函数的寄存器。记住你可以使用 expression -l objc -O 命令，或者使用在书中第八章（“Persisting and Customizing Commands”）的 cpo 命令。幸运的是，register read 命令依然是可以使用的。</p>\n</li>\n<li>\n<p>其次，Swift 相对于 OC 并不是动态的。事实上，有时候最好假设 Swift 像 C 语言一样。如果知道了一个内存地址，你应该显示地强转为你想要的类型。不然 Swift 调试器没有任何线索去解释内存地址。</p>\n</li>\n</ul>\n<p>话虽这么说，但是 Swift 使用了相同的寄存器调用规则。 但是有一个非常重要的区别。 当 Swift 调用一个函数时，它__不需要使用 objc_msgSend__，除非您当然标记了使用动态方法。 这意味着当 Swift 调用函数时，先前分配给选择器的 RSI 寄存器实际上就是函数的第二个参数。好了，足够的理论 - 是时候将其付诸实践了。</p>\n<p>在 Registers 项目中，导航到 ViewController.swift 并将以下函数添加到该类：</p>\n<p><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">executeLotsOfArguments</span>(<span class=\"params\">one</span>: <span class=\"type\">Int</span>, <span class=\"params\">two</span>: <span class=\"type\">Int</span>, <span class=\"params\">three</span>: <span class=\"type\">Int</span>,</span><br><span class=\"line\">                                <span class=\"params\">four</span>: <span class=\"type\">Int</span>, <span class=\"params\">five</span>: <span class=\"type\">Int</span>, <span class=\"params\">six</span>: <span class=\"type\">Int</span>,</span><br><span class=\"line\">                                <span class=\"params\">seven</span>: <span class=\"type\">Int</span>, <span class=\"params\">eight</span>: <span class=\"type\">Int</span>, <span class=\"params\">nine</span>: <span class=\"type\">Int</span>,</span><br><span class=\"line\">                                <span class=\"params\">ten</span>: <span class=\"type\">Int</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;arguments are: <span class=\"subst\">\\(one)</span>, <span class=\"subst\">\\(two)</span>, <span class=\"subst\">\\(three)</span>, <span class=\"subst\">\\(four)</span>, <span class=\"subst\">\\(five)</span>, <span class=\"subst\">\\(six)</span>, <span class=\"subst\">\\(seven)</span>, <span class=\"subst\">\\(eight)</span>, <span class=\"subst\">\\(nine)</span>, <span class=\"subst\">\\(ten)</span>&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在，在 viewDidLoad 中，使用适当的参数调用此函数：</p>\n<p><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">self</span>.<span class=\"title function_ invoke__\">executeLotsOfArguments</span>(<span class=\"attr\">one</span>: <span class=\"number\">1</span>, <span class=\"attr\">two</span>: <span class=\"number\">2</span>, <span class=\"attr\">three</span>: <span class=\"number\">3</span>, <span class=\"attr\">four</span>: <span class=\"number\">4</span>, <span class=\"attr\">five</span>: <span class=\"number\">5</span>, <span class=\"attr\">six</span>: <span class=\"number\">6</span>, <span class=\"attr\">seven</span>: <span class=\"number\">7</span>, <span class=\"attr\">eight</span>: <span class=\"number\">8</span>, <span class=\"attr\">nine</span>: <span class=\"number\">9</span>, <span class=\"attr\">ten</span>: <span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure></p>\n<p>在与 executeLotsOfArguments 声明相同的行上放置一个断点，以便调试器将在函数的开始处停止。 这很重要，否则如果函数已经开始执行，则寄存器可能会被破坏。然后删除您在 -[NSViewController viewDidLoad] 上设置的符号断点。生成并运行该应用程序，然后等待 executeLotsOfArguments 断点停止执行。我们先列出所有的寄存器。 在 LLDB 中，键入以下内容：</p>\n<ul>\n<li>register read -f d</li>\n</ul>\n<p>这将列出所有的寄存器，并使用 - f d 选项以十进制显示格式。 输出将类似于以下内容：</p>\n<p><figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) register read -f d</span><br><span class=\"line\">General Purpose Registers:</span><br><span class=\"line\">       <span class=\"built_in\">rax</span> = <span class=\"number\">10</span></span><br><span class=\"line\">       <span class=\"built_in\">rbx</span> = <span class=\"number\">7</span></span><br><span class=\"line\">       <span class=\"built_in\">rcx</span> = <span class=\"number\">4</span></span><br><span class=\"line\">       <span class=\"built_in\">rdx</span> = <span class=\"number\">3</span></span><br><span class=\"line\">       <span class=\"built_in\">rdi</span> = <span class=\"number\">1</span></span><br><span class=\"line\">       <span class=\"built_in\">rsi</span> = <span class=\"number\">2</span></span><br><span class=\"line\">       <span class=\"built_in\">rbp</span> = <span class=\"number\">140732785005232</span></span><br><span class=\"line\">       <span class=\"built_in\">rsp</span> = <span class=\"number\">140732785004720</span></span><br><span class=\"line\">        <span class=\"built_in\">r8</span> = <span class=\"number\">5</span></span><br><span class=\"line\">        <span class=\"built_in\">r9</span> = <span class=\"number\">6</span></span><br><span class=\"line\">       <span class=\"built_in\">r10</span> = <span class=\"number\">9</span></span><br><span class=\"line\">       <span class=\"built_in\">r11</span> = <span class=\"number\">8</span></span><br><span class=\"line\">       <span class=\"built_in\">r12</span> = <span class=\"number\">140668105198352</span></span><br><span class=\"line\">       <span class=\"built_in\">r13</span> = <span class=\"number\">105553138827696</span></span><br><span class=\"line\">       <span class=\"built_in\">r14</span> = <span class=\"number\">104</span></span><br><span class=\"line\">       <span class=\"built_in\">r15</span> = <span class=\"number\">8</span></span><br><span class=\"line\">       <span class=\"built_in\">rip</span> = <span class=\"number\">4430734802</span>  Registers<span class=\"string\">`Registers.ViewController.executeLotsOfArguments(one: Swift.Int, two: Swift.Int, three: Swift.Int, four: Swift.Int, five: Swift.Int, six: Swift.Int, seven: Swift.Int, eight: Swift.Int, nine: Swift.Int, ten: Swift.Int) -&gt; () + 178 at ViewController.swift:68:15</span></span><br><span class=\"line\"><span class=\"string\">    rflags = 514</span></span><br><span class=\"line\"><span class=\"string\">        cs = 43</span></span><br><span class=\"line\"><span class=\"string\">        fs = 0</span></span><br><span class=\"line\"><span class=\"string\">        gs = 0</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">(lldb) </span></span><br></pre></td></tr></table></figure><br />\n 如您所见，寄存器遵循 x64 调用规则。 RDI，RSI，RDX，RCX，R8 和 R9 保留您的前六个参数。</p>\n<blockquote>\n<p>注意：关于 LLDB，我一直没有告诉您的是，LLDB 可以以<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mi>r</mi><mi>g</mi><mi>X</mi><mtext>形式来引用寄存器，其中</mtext><mi>X</mi><mtext>是参数号。还记得</mtext><mi>R</mi><mi>D</mi><mi>I</mi><mtext>是第一个参数，而</mtext><mi>R</mi><mi>S</mi><mi>I</mi><mtext>是第二个参数吗</mtext><mo stretchy=\"false\">?</mo><mtext>在</mtext><mi>L</mi><mi>L</mi><mi>D</mi><mi>B</mi><mtext>中，可以通过</mtext></mrow><annotation encoding=\"application/x-tex\">arg{X}形式来引用寄存器，其中X是参数号。还记得RDI是第一个参数，而RSI是第二个参数吗?在LLDB中，可以通过</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span><span class=\"mord cjk_fallback\">形</span><span class=\"mord cjk_fallback\">式</span><span class=\"mord cjk_fallback\">来</span><span class=\"mord cjk_fallback\">引</span><span class=\"mord cjk_fallback\">用</span><span class=\"mord cjk_fallback\">寄</span><span class=\"mord cjk_fallback\">存</span><span class=\"mord cjk_fallback\">器</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">其</span><span class=\"mord cjk_fallback\">中</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord cjk_fallback\">是</span><span class=\"mord cjk_fallback\">参</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">号</span><span class=\"mord cjk_fallback\">。</span><span class=\"mord cjk_fallback\">还</span><span class=\"mord cjk_fallback\">记</span><span class=\"mord cjk_fallback\">得</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord cjk_fallback\">是</span><span class=\"mord cjk_fallback\">第</span><span class=\"mord cjk_fallback\">一</span><span class=\"mord cjk_fallback\">个</span><span class=\"mord cjk_fallback\">参</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">而</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord cjk_fallback\">是</span><span class=\"mord cjk_fallback\">第</span><span class=\"mord cjk_fallback\">二</span><span class=\"mord cjk_fallback\">个</span><span class=\"mord cjk_fallback\">参</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">吗</span><span class=\"mclose\">?</span><span class=\"mord cjk_fallback\">在</span><span class=\"mord mathnormal\">L</span><span class=\"mord mathnormal\">L</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord cjk_fallback\">中</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">可</span><span class=\"mord cjk_fallback\">以</span><span class=\"mord cjk_fallback\">通</span><span class=\"mord cjk_fallback\">过</span></span></span></span> arg1 引用第一个参数 (RDI)。随着示例的进行，您可以使用 $arg2 引用第二个参数 (RSI)，以此类推。这些方便值也可以在 ARM64 调用约定中使用，即使 ARM64 使用不同的寄存器。您应该记住寄存器调用规则，以便本书尽量减少使用这些寄存器辅助变量。</p>\n</blockquote>\n<p>您可能还会注意到其他参数存储在其他一些其他寄存器中。 确实如此，但这只是为其余参数设置堆栈的代码中的剩余部分。 请记住，第六个参数之后的参数将进入堆栈。</p>\n<h2 id=\"rax用于返回的寄存器\"><a class=\"anchor\" href=\"#rax用于返回的寄存器\">#</a> RAX，用于返回的寄存器</h2>\n<p>等等 -- 还有呢！到这里，你已经了解了函数中六个寄存器是如何调用的，但是返回值呢？</p>\n<p>幸运的是，只有一个指定的寄存器用于返回值：RAX。回到 executeLotsOfArguments 函数并改变函数的返回值，像这样：</p>\n<p><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">executeLotsOfArguments</span>(<span class=\"params\">one</span>: <span class=\"type\">Int</span>, <span class=\"params\">two</span>: <span class=\"type\">Int</span>, <span class=\"params\">three</span>: <span class=\"type\">Int</span>,</span><br><span class=\"line\">                                <span class=\"params\">four</span>: <span class=\"type\">Int</span>, <span class=\"params\">five</span>: <span class=\"type\">Int</span>, <span class=\"params\">six</span>: <span class=\"type\">Int</span>,</span><br><span class=\"line\">                                <span class=\"params\">seven</span>: <span class=\"type\">Int</span>, <span class=\"params\">eight</span>: <span class=\"type\">Int</span>, <span class=\"params\">nine</span>: <span class=\"type\">Int</span>,</span><br><span class=\"line\">                                <span class=\"params\">ten</span>: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;arguments are: <span class=\"subst\">\\(one)</span>, <span class=\"subst\">\\(two)</span>, <span class=\"subst\">\\(three)</span>, <span class=\"subst\">\\(four)</span>, <span class=\"subst\">\\(five)</span>, <span class=\"subst\">\\(six)</span>, <span class=\"subst\">\\(seven)</span>, <span class=\"subst\">\\(eight)</span>, <span class=\"subst\">\\(nine)</span>, <span class=\"subst\">\\(ten)</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Mom, what happened to the cat?&quot;</span></span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后 viewdidlaod 中调用</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> _ = self.execute<span class=\"constructor\">LotsOfArguments(<span class=\"params\">one</span>: 1, <span class=\"params\">two</span>: 2, <span class=\"params\">three</span>: 3, <span class=\"params\">four</span>: 4, <span class=\"params\">five</span>: 5, <span class=\"params\">six</span>: 6, <span class=\"params\">seven</span>: 7, <span class=\"params\">eight</span>: 8, <span class=\"params\">nine</span>: 9, <span class=\"params\">ten</span>: 10)</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>在 executeLotsOfArguments 中的某处创建一个断点。 再次生成并运行，然后等待函数停止执行。 接下来，在 LLDB 控制台中键入以下内容：</p>\n<ul>\n<li>(lldb) finish</li>\n</ul>\n<p>命令会结束完成函数的执行并停住调试器。这时，函数返回值会在 RAX 内。输入如下命令：</p>\n<ul>\n<li>(lldb) register read rax</li>\n</ul>\n<p>你将会看见如下输出</p>\n<p><figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">rax</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>x0000000100003760  <span class=\"string\">&quot;Mom, what happened to the cat?</span></span><br></pre></td></tr></table></figure><br />\n 了解 RAX 中的返回值非常重要，因为它将构成您将在后面的部分中编写的调试脚本的基础。</p>\n<h2 id=\"改变寄存器值\"><a class=\"anchor\" href=\"#改变寄存器值\">#</a> 改变寄存器值</h2>\n<p>为了巩固您对寄存器的理解，您将在一个已编译的应用程序中修改寄存器。<br />\n关闭 Xcode 和 Registers 项目。 打开终端窗口，然后启动 iPhone X Simulator。 通过键入以下内容来执行此操作：</p>\n<ul>\n<li>xcrun simctl list | grep &quot;iPhone X”</li>\n</ul>\n<p><figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Phone</span>: iPhone <span class=\"number\">12</span> Pro Max (<span class=\"number\">16</span>A6D554-<span class=\"number\">3</span>C10-<span class=\"number\">4</span>A67-<span class=\"number\">9039</span>-<span class=\"number\">31</span>B8BE33871F) (Shutdown)</span><br></pre></td></tr></table></figure></p>\n<p>UDID 就是你要找的。使用它并通过如下命令打开 iOS 模拟器（替换其中的 UDID 部分）：</p>\n<ul>\n<li>open /Applications/Xcode.app/Contents/Developer/Applications/Simulator.app --args -CurrentDeviceUDID 16A6D554-3C10-4A67-9039-31B8BE33871F</li>\n</ul>\n<p>保证模拟器已经启动而且在主屏幕上。你可以通过按下 Command + Shift + H 键回到主屏幕。一旦模拟器准备好了，回到终端窗口将 LLDB 绑定到 SpringBoard 程序上。</p>\n<ul>\n<li>lldb -n SpringBoard</li>\n</ul>\n<p>这样会将 LLDB 绑定到正在模拟器上运行的 SpringBoard 实例上！SpringBoard 就是在 iOS 上控制主屏幕的程序。</p>\n<p>一旦绑定，输入如下命令：</p>\n<ul>\n<li>(lldb) p/x @&quot;Yay! Debugging<br />\n 可以看到类似如下的输出：</li>\n</ul>\n<p><figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(__NSCFString *) $3 = <span class=\"number\">0x0000618000644080</span> @<span class=\"string\">&quot;Yay! Debugging!&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 注意下刚刚创建的这个 NSString 实例，因为很快你会用到它。现在，给 UILabel 的 setText: 方法设置一个断点：</p>\n<ul>\n<li>(lldb) b -[UILabel setText:]</li>\n<li>(lldb) breakpoint command add</li>\n</ul>\n<p>LLDB 会吐出一些输出且进入多行编辑模式。这个命令让你在刚刚打的断点处添加多个额外要执行的命令。输入如下，使用刚才的 NSString 地址替换下面的内存地址：</p>\n<p><figure class=\"highlight node-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">&gt;</span> <span class=\"language-javascript\">po $rdx = <span class=\"number\">0x0000618000644080</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span> <span class=\"language-javascript\"><span class=\"keyword\">continue</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span> <span class=\"language-javascript\"><span class=\"variable constant_\">DONE</span></span></span><br></pre></td></tr></table></figure><br />\n 回去重新看下你刚刚做的。你在 UILabel 的 setText: 方法上添加了一个断点。一旦遇到该方法，你就会用一个叫 Yay! Debugging! 的 NSString 实例替换 RDX--- 第三个参数。</p>\n<p>使用 continue 命令让调试器继续执行：</p>\n<ul>\n<li>(lldb) continue</li>\n</ul>\n<p>看看 SpringBoard 模拟器程序什么发生了改变。从下往上扫带出控制中心，观察改变的地方：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkujcb1fmaj30en0qk0xc.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkujaok2e0j30hf0v2aft.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkujb8rg0aj30k60tj787.jpg\" alt=\"\" /></p>\n<p>尽管这似乎是一个很酷的花招编程技巧，但它却展示了通过有限的汇编和寄存器的知识能够在程序内产生你之前没见过的大的变化。</p>\n<p>从调试的角度来看，这也很有用，因为您可以快速直观地验证 -[UILabel setText：] 在 SpringBoard 应用程序中的执行位置，并运行断点条件以查找设置特定 UILabel 文本的确切代码行。</p>\n<h2 id=\"寄存器和sdk\"><a class=\"anchor\" href=\"#寄存器和sdk\">#</a> 寄存器和 SDK</h2>\n<p>了解寄存器的工作方式以及应用程序的功能可以快速帮助您找到感兴趣的项目。举个简单的例子：通常，我会遇到一个 UIButton，并想知道 IBAction 和接收器，当我点击该按钮时会发生什么。在最高断点处，我可能会发疯…… 认识我自己，我通常在 UIView 或 UIViewController（也许是 UITableViewCell？）中包含 IBAction，并且通常使用某种名称为 “tapped” 的方法。<br />\n因此，也许下面的 LLDB 命令会起作用？</p>\n<ul>\n<li>(lldb) rb View(Controller|Cell)?\\s(?i).*tapped</li>\n</ul>\n<p>但是我错误地假设同事 / 其他开发人员正在使用与我相同的命名约定；这个想法行不通。相反，我知道，每当执行 IBAction 方法时，它都必须经过 UIApplication 单例，在该单例中，它将遍历响应者链来找到合适的接收者。为此，将调用 UIControl 的 - sendAction：to：forEvent：方法。<br />\n我可以在此方法上设置一个断点，并探索 sendAction：和 to：参数以查找 IBAction 正在执行的代码。<br />\n这个想法可以应用到您拥有和没有源代码的应用程序中。我经常发现，即使在我确实有源代码的应用程序中，使用此方法也更快，然后在应用程序中看到数千个 IBAction。</p>\n<p>... 但仅出于演示目的，让我们将其应用于 iOS Maps 应用程序。我对右上方按钮的名称和接收者感到好奇，该按钮可以直接定位用户的具体位置。<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkujmtqa2qj30dz0qoq82.jpg\" alt=\"\" /></p>\n<p>通过 LLDB 附加到 Maps 应用程序并为 -[UIControl sendAction：to：forEvent：] 设置断点后，很容易找到 UIButton 的名称和接收者。<br />\nsendAction：参数（RDX）将使用选择器，而 to：参数将是 IBAction 的接收器（RCX）。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkujqoz7vsj30x50j2q7u.jpg\" alt=\"\" /><br />\n用寄存器知识和轻按 UIButton 查找代码，这有多酷？</p>\n<h2 id=\"下一步\"><a class=\"anchor\" href=\"#下一步\">#</a> 下一步</h2>\n<p>好的，学了这么长时间，来休息下，看看你学到了什么：</p>\n<p>架构（X86）定义了一个调用规则，该规则规定了函数参数及其返回值的存储位置。</p>\n<ul>\n<li>在 Objective-C 中，RDI 寄存器是调用 NSObject 的引用，RSI 是选择器，RDX 是第一个参数，依此类推。</li>\n<li>在 Swift 中，RDI 是第一个参数，RSI 是第二个参数，依此类推，前提是 Swift 方法未使用动态分配。</li>\n<li>RAX 寄存器用于函数中的返回值，无论您使用的是 Objective-C 还是 Swift。</li>\n</ul>\n<p>您可以利用寄存器做很多事情。尝试浏览您没有源代码的应用；将为解决棘手的调试问题奠定良好的基础。</p>\n<p>尝试附加到 iOS Simulator 上的应用程序，并使用程序集，智能断点和断点命令绘制出 UIViewController 的生命周期。</p>\n",
            "tags": []
        },
        {
            "id": "https://oliverqueen.cn/2019-02-14-At-the-end-of-2018/",
            "url": "https://oliverqueen.cn/2019-02-14-At-the-end-of-2018/",
            "title": "At The End Of 2018",
            "date_published": "2019-02-14T03:19:59.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>今年的总结来的比去年稍微晚一些，本来打算像去年一样在最后一个工作日出炉的，但是因为年前事情比较多，而且再加上父母要来过年，又请了半天假回家收拾屋子，所以没有按时完成任务。总的来说今年算是我人生中比较重要的一年，不光是我自己，还有自己的妹子，甚至 2018 对于中国互联网也是一次历史性的转折。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1g076fg14tqj31hd0u0wi5.jpg\" alt=\"\" /></p>\n<p><span id=\"more\"></span></p>\n<p>写这篇文章之前我还看了下去年的年终总结，想看看当时立了哪些 flag，完成了哪些、辜负了哪些，最终的结论是勉勉强强完成百分之五十，不过虽然一半没有完成，但是今年还发生了一些其他的事情，总的来说收获不小，相比去年有过之而无不及，人总是要进步的嘛～</p>\n<h2 id=\"辞旧\"><a class=\"anchor\" href=\"#辞旧\">#</a> 辞旧</h2>\n<h4 id=\"大背景\"><a class=\"anchor\" href=\"#大背景\">#</a> 大背景</h4>\n<p>2018 年是不平凡的一年，尤其是对于互联网行业，都在说 2018 是互联网的寒冬，2018 是过去十年最难的一年，同时也是未来十年最好的一年。作为一个在深圳的互联网从业者来说确实感慨颇深，一个个熟悉的朋友 “被离职”，一家家曾经耳熟能详的公司 “跑路”、“优化”。再加上各大媒体为了眼球效应大肆渲染，确实搞得大家人心惶惶。不过还是有一些公司趁着这个机会疯狂找人，想弯道超车，由此可见互联网还是有无限的潜力的。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1g0780whl50j312w0np0u6.jpg\" alt=\"\" /></p>\n<h4 id=\"职业生涯\"><a class=\"anchor\" href=\"#职业生涯\">#</a> 职业生涯</h4>\n<p>今年对我影响最大应该算是从美图离职吧，不过这个真的跟互联网寒冬没有关系，完全是个人原因。其实到现在为止，美图在我心里依然占据很重要的一部分，从 2016 年 6 月 13 日到 2018 年 6 月 13 日，在美图的整整两年中我学到新的技术，认识到新的朋友，接触到新的圈子，更重要的是美图教会了我一种精神，一种上进，一种不服输的精神，总是想学更多的东西，想认识更多的人，总是有一种饥饿感。当然这一切也离不开我那些优秀的同事们。这也印证了那句话，你的圈子决定你成为一个生么样的人。美图公司给我留下的印象依然是站在图像处理领域的最高点，每一款产品都能让人眼前一亮，同时也一直在引领着 “美颜” 趋势的发展。</p>\n<p>5 月底的时候身边的同事陆续地走了，去了 BAT 或者国外发展，不管是继续求学还是继续工作，他们都有了新的目标，当时对于不服输的我来说其实影响很大，于是也去鹅厂试了下并且拿到了 offer。正好当时也觉得在美图带的时间也算比较久，而且对于个人的成长也似乎到了瓶颈，当时只是做一些业务需求，正好自己也想接触一些新的东西，所以就来了鹅厂。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1g0akxedwthj30zk0qodno.jpg\" alt=\"美图公司\" /></p>\n<p>现在想想当时的情况感觉还是挺不可思议的，鹅厂的面试流程一项以严 (hen) 谨 (man) 著称，之前看论坛上流程要几个月的大有人在，而我 5 月底还在纠结要不要来腾讯，而六月中旬就拿到了 offer，在这里还是要感谢我的现在的导师一直持续跟、催促进面试流程，才使得有这样的效率。历史总是惊人的相似，想起我当时来深圳的时候，2016 年的 5 月底我还在北京的出租房门前给我妈打着电话纠结是否要来深圳打拼，从北京到深圳，地理位置的巨大变化不说，包括圈子，工作，生活基本都要从头开始，但是过了不到一个月 6 月 13 号我已经做在了深圳美图的工位上，有的时候人生就是需要这样的而果断甚至是决绝吧。来到鹅厂算是去年一个很大的转折吧。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1g0al3b9ikhj30u01401l4.jpg\" alt=\"\" /></p>\n<h4 id=\"个人生活\"><a class=\"anchor\" href=\"#个人生活\">#</a> 个人生活</h4>\n<p>个人生活方面无非就是健身、旅游、读书之类除了工作之外的事情，其实去年立了 flag，说今年要去两个国家，结果只在五一时候跟妹子去了泰国，逛了三个城市。总结了原因，并不是时间或者是经济的原因，主要是 2018 互联网寒冬、人心惶惶、各种各样的负面消息层出不穷，谁也不敢放松太久，说白了还是为生活所迫吧🙂🙂🙂。</p>\n<p>国内的话也没去太多地方、去广州吃了早茶、去珠海看了情侣路，香港澳门就不算了，毕竟过年回家基本都能路过，也走过好多地方。今年地图上又打了不少点，看到这些还是蛮有成就感的</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1g0an2v5uoaj30sg0lcat1.jpg\" alt=\"\" /></p>\n<h4 id=\"广州\"><a class=\"anchor\" href=\"#广州\">#</a> 广州</h4>\n<p>广州主要是吃，特色小吃比较多，在广州能吃到正宗的广东风味，比深圳要强很多，奈何我不是吃货总的体验还是不错的小蛮腰那个岛上的夜景很好看。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1g0ancw9a8mj31400u04qr.jpg\" alt=\"\" /></p>\n<h4 id=\"曼谷\"><a class=\"anchor\" href=\"#曼谷\">#</a> 曼谷</h4>\n<p>作为泰国的首都，就像国内的一线城市一样，街道上车水马龙，周围都是高耸的写字楼，虽然不如深圳这样现代化，但是作为泰国的城市，现代化程度也是泰国中最好的，到了晚上会更加热闹些，夜景也很好看，大部分都是来旅游的中国游客，熙熙攘攘，好不热闹，第二张图是比较有名的火车头小吃街，东西很不错，都是慕名而来，里面隐藏了很多的网红店，物价在当地算是比较贵的了，但是和深圳比起来还是相当的便宜。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1g0andr8f63j31440u0kjl.jpg\" alt=\"\" /><br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1g0ane759vjj31400u0npf.jpg\" alt=\"\" /></p>\n<h4 id=\"芭提亚\"><a class=\"anchor\" href=\"#芭提亚\">#</a> 芭提亚</h4>\n<p>芭提亚最著名的就是人妖表演，但是我们没去看，因为对那些还是有点....，晚上感受了下夜生活，白天去了海边，不过说实话芭提亚还是和那种随便一拍就是壁纸的仙本那有一定差距的，海鲜也一般，但是仍然能能感受到这边的热情和奔放。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1g0anf4iohgj30u0140npf.jpg\" alt=\"\" /></p>\n<h4 id=\"清迈\"><a class=\"anchor\" href=\"#清迈\">#</a> 清迈</h4>\n<p>我们把清迈作为最后一站还是很合理的，一个很安逸清静的小镇，特别适合在长途旅行后放松心情，这里你会感觉到，明显生活会慢半拍，好多的寺庙，皇宫，也适合了解这边的历史。感觉这边的人和大象都很温顺，芭提亚也有大象，但是可能是因为接待了太多的游客，脾气会大些吧，😊😊😊。 这个城市非常适合拍照，一是景色优美，而是不用那么急急忙忙，给人一种很放松的感觉，我们这次的照片一多半都出自清迈。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1g0anfg2a3pj31400u04qt.jpg\" alt=\"\" /><br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1g0anftp4fzj31kh0u01l8.jpg\" alt=\"\" /></p>\n<h4 id=\"其他\"><a class=\"anchor\" href=\"#其他\">#</a> 其他</h4>\n<p>2018 年还发生了很多，妹子很不幸的成了互联网寒冬的受害者，不过后来在自己的努力下下又拿到了 Adelaide 的 offer</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1g0aqkv2f1yj31g40u04qp.jpg\" alt=\"\" /></p>\n<p>后来问了好多朋友，原来大部分人情况都差不多，互联网寒冬，国内形势严峻，都准备继续去国外求学，一是为了避险，二是为了提高自己。虽然出国前需要考虑的东西还是很多的，但是不管怎样妹子通过自己的努力拿到这样的成绩还是值得高兴的，至于后面是否选择留学，还是看实际的情况吧。</p>\n<p>还有就是今年的公租房差一点就排到了，带车位带学位，当天都带好了材料准备去认租了，结果临走前告诉我房子已选完，不用去了😭😭😭，可能还需要再等上一年，不过我也在公司内部申请了，希望能快点吧。</p>\n<p>关于读书，今年没有读几本书，但是我发现一个有趣的现象，发现微信里所关注的公众号不仅仅再是之前的搞笑类的了，而是更多的类似于 “互联网思维” 这样的公众号，慢慢的对这个时代敏感度提高，现在也养成了每天睡觉前都会把今天所有的大新闻读一遍，然后总结出来的习惯，也算是在 27 岁时候达到了老爸在七岁时对我的要求。</p>\n<p>今年最开心的应该就是爸妈来深圳过年了，一直想让他们来，之前一直请不下假，他们工作比我还忙，不过这次终于来了，带我爸去了他心心念的香港和澳门，之前是因为工作关系，没办法出境，这次终于突破层层阻碍踏上了特别行政区的土地。希望以后他们有更多的时间过来。我还跟我爸说，这次时间紧迫，没法去台湾了，我爸态度很坚决的说：“台湾一定要等回归了再去！”</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1g0as1s6q3wj30u0140u0x.jpg\" alt=\"\" /></p>\n<h2 id=\"迎新\"><a class=\"anchor\" href=\"#迎新\">#</a> 迎新</h2>\n<p>和去年一样，不想立太多的 flag，怕万一一个都做不到了丢人，毕竟白纸黑字都写在这里，其实做不到不是因为堕落，而是你真的不知道未来会发生什么，尤其是对于当代的互联网人来说唯一不变的就是一直在改变，而我们需要做的就是随机应变，顺应时代，拥抱变化，有的人会说，如果不设定一些目标，到时候无法量化自己收获，导致年终没什么可写，其实对于我来说立不立 flag 对我真的没那么重要，每天回到家，感到今天很充实就够了，就像老罗在 “时间的朋友” 里说的：你有你的计划，而世界另有计划。不过还是说下对未来的期望吧：</p>\n<ul>\n<li>\n<p>去一到两个国家</p>\n</li>\n<li>\n<p>坚持一周三次 5 公里<br />\n....</p>\n</li>\n</ul>\n<h2 id=\"最后\"><a class=\"anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>我喜欢写总结的感觉，因为这能让我把今年经历的所有重要的事情在脑子立过一遍，就会觉得没有白过，让每一年都过得有价值。</p>\n<p>最后希望每人看到我这篇文章的人都能不忘初心，我们明年再见...</p>\n<p>才疏学浅，文笔拙劣，于 2019.2.14 仓促执笔….</p>\n<p>\n        <div id=\"aplayer-CprHhaQl\" class=\"aplayer aplayer-tag-marker\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t  <script>\n\t\t\t\t  var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mutex\":true,\"music\":[{\"title\":\"大鱼\",\"author\":\"周深\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/bigfish.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M000004Y7V4s3ug4cC.jpg?max_age=2592000\",\"lrc\":\"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=004OQ5Mt0EmEzv\"}]};\n\t\t\t\t  options.element = document.getElementById(\"aplayer-CprHhaQl\");\n\t\t\t\t  var ap = new APlayer(options);\n\t\t\t    window.aplayers || (window.aplayers = []);\n\t\t\t\t  window.aplayers.push(ap);\n\t\t\t  </script></p>\n",
            "tags": [
                "总结",
                "回首2018展望2019"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-08-23-ChangeSvnToGit/",
            "url": "https://oliverqueen.cn/2018-08-23-ChangeSvnToGit/",
            "title": "SVN切换到Git",
            "date_published": "2018-08-23T12:47:19.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景：</h2>\n<p>SVN 和 Git 同样都是在特定时代下比较优秀的版本控制系统，但是随着时代的发展，SVN 越来越不能满足多人开发的需求，尤其是在多种多样，天马星空的业务场景面前，SVN 会显得力不从心。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNbRwgy1fujxnf8ilhj30zk0m8gm9.jpg\" alt=\"\" /></p>\n<p><span id=\"more\"></span></p>\n<p>最近在将公司的项目从 SVN 迁移到 git，踩了不少坑，所以来记录下:</p>\n<p>因为迁移的快慢和整个仓库的大小，电脑配置有关，所以我先说下这边的情况</p>\n<ul>\n<li>\n<p>仓库：<br />\n仓库大概是 3.5G 左右，包含了 14500 + 的提交次数，其中包含了超过 500M 的单个文件</p>\n</li>\n<li>\n<p>电脑：<br />\n电脑配置就看图吧 ：</p>\n<p><img data-src=\"https://image-1256056152.cos.ap-nanjing.myqcloud.com/wz0geut3a8.jpg\" alt=\"\" /></p>\n</li>\n</ul>\n<p>在以上两种情况下，排除掉采坑的时间，总耗时在 10 小时左右，当时中途我也用过一台联系 X1 的本尝试过，配置如下：</p>\n<p><img data-src=\"https://image-1256056152.cos.ap-nanjing.myqcloud.com/072709.jpg\" alt=\"\" /><br />\n后来联想这台电脑放弃了，因为总耗时已经超过 30 小时，</p>\n<h2 id=\"操作\"><a class=\"anchor\" href=\"#操作\">#</a> 操作：</h2>\n<h4 id=\"1生成作者文件\"><a class=\"anchor\" href=\"#1生成作者文件\">#</a> 1. 生成作者文件：</h4>\n<p>因为我们知道，在 SVN 上提交和在 Git 上提交对应提交者的信息展示是不同的，SVN 只会保存一个用户名，而 Git 会保存该用户的邮箱，所以我们迁移的第一步就要生成一个映射文件，将 SVN 上的用户名和其邮箱对应起来，就比如   <code>molier = molier &lt;123456@qq.com&gt;</code> , 转换的办法有很多，如果你团队里面的人不是很多的是时候，可以自己去提交记录中手动生成这样一个 TXT 文件<br />\n <figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">XXX</span> = XXX &lt;XXX<span class=\"variable\">@XXX</span>.com&gt;XXX = XXX &lt;XXX<span class=\"variable\">@XXX</span>.com&gt;....</span><br></pre></td></tr></table></figure><br />\n 但是如果，多人开发人数很多的时候，手动转很累，我们就需要一个 Atlassian 的工具包  <code>svn-migration-scripts.jar</code> ，通过命令拉取 SVN 仓库的用户并生成对应的开发者信息映射文件，需要 Java 运行时环境支持，大家可能还需要安装 JDK：</p>\n<p><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -jar svn-migration-scripts.jar authors https:<span class=\"regexp\">//</span>svn.example.com &gt; authors.txt</span><br></pre></td></tr></table></figure><br />\n 这样之后会在当前目录生成一个  <code>authors.txt</code>  文件</p>\n<h4 id=\"2转换仓库\"><a class=\"anchor\" href=\"#2转换仓库\">#</a> 2. 转换仓库</h4>\n<ul>\n<li>\n<p>整体转换:</p>\n<p>标准的 SVN 文件布局：<br />\n如果 SVN 仓库使用标准的了 /trunk, /branches 和 /tags 的目录结构，就可在运行命令时加上参数–stdlayout，使用如下命令<br />\n <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git svn clone --stdlayout --authors-file=authors.txt <span class=\"tag\">&lt;<span class=\"name\">svn-repo</span>&gt;</span>/<span class=\"tag\">&lt;<span class=\"name\">project</span>&gt;</span> <span class=\"tag\">&lt;<span class=\"name\">克隆到文件夹的名字</span>&gt;</span>非标准的的SVN文件布局:</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 如果 SVN 仓库是非标准的目录布局，那就需要分别显示指定参数–trunk, –branches, –tags。<br />\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git svn clone <span class=\"attribute\">--trunk</span>=/trunk <span class=\"attribute\">--branches</span>=/branches <span class=\"attribute\">--branches</span>=/bugfixes <span class=\"attribute\">--tags</span>=/tags <span class=\"attribute\">--authors-file</span>=authors.txt &lt;svn-repo&gt;/&lt;project&gt;&lt;克隆到文件夹的名字&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>部分转换:</p>\n<p>如果仓库非常庞大的话可以选择部分转换，也就只转换指定提交之后的提交，可以试用如下代码<br />\n <figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git svn <span class=\"keyword\">clone</span> <span class=\"title\">-r123456</span>:HEAD --stdlayout --<span class=\"attr\">authors-file=</span>authors.txt <span class=\"tag\">&lt;svn-repo&gt;</span> <span class=\"tag\">&lt;克隆到文件夹的名字&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 不过这里需要注意的是如果使用这种方式来转换那么一定要指定 SVN 的代码根部，而不能指定分支，因为 SVN 的提交编号都是按照时间顺序来往下依次排列，不同的分支也可能提交编号是连续的，所以如果只关心编号的话就不能再指定分支了。</p>\n<p>以上三步中所用到的  <code>authors.txt</code>  即为上一步所生成的， <code>作者 -&gt; 作者 &lt;作者邮箱&gt;</code>  的对应关系文件.</p>\n</li>\n</ul>\n<h2 id=\"坑点\"><a class=\"anchor\" href=\"#坑点\">#</a> 坑点</h2>\n<p>完成以上操作的话如果一切正常那么你就会获得一个新的 Git 仓库，然后就可以添加到远端，进行多人开发了，至于 git 的操作并不在本文的范围内，下面会讲一下遇到的坑以及解决办法。</p>\n<h4 id=\"坑点一时间久\"><a class=\"anchor\" href=\"#坑点一时间久\">#</a> 坑点一：时间久</h4>\n<p>转换仓库是比较耗时的，因为他会一个提交一个提交的转换，转换的速度和你的仓库提交次数和电脑配置成正比，我当时转了十几个小时比较正常，而且转换完之后他还有个自己整理文件的过程也是很耗时的，不过如果你选择部分转换的话也可能很快，假如你一共 15000 个提交，然后你从 14999 来转换可能几分钟就够了。当然最好的办法就是下班前开始执行，第二天来了基本就差不多了。不过别高兴的太早，请看坑点二。</p>\n<h4 id=\"坑点二垃圾过多导致暂停\"><a class=\"anchor\" href=\"#坑点二垃圾过多导致暂停\">#</a> 坑点二：垃圾过多导致暂停</h4>\n<p>因为是要遍历所有的历史提交，所以可能会有很多的无用文件 比如项目一开始代文件结构很乱，然后慢慢的经过重构，之类的优化步入正轨，这过程中必然会删掉大量的无用、冗余的文件，虽然这些文件已经不复存在了，但是提交记录会有，而且通过 git 的原理来看他还是会把这些东西一一保存下来，所以就会造成大量无用的文件越来越多，而 Git 是有一个缓冲区 (具体大小不确定) 当你无用文件把缓冲区沾满了，那么转换过程会停止会爆出如下错误<br />\n <figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Auto packing <span class=\"keyword\">the</span> repository <span class=\"keyword\">in</span> background <span class=\"keyword\">for</span> optimum performance.</span><br><span class=\"line\">See <span class=\"string\">&quot;git help gc&quot;</span> <span class=\"keyword\">for</span> manual housekeeping.error: The <span class=\"keyword\">last</span> gc run reported <span class=\"keyword\">the</span> following. </span><br><span class=\"line\">Please correct <span class=\"keyword\">the</span> root cause <span class=\"keyword\">and</span> remove .git/gc.<span class=\"built_in\">log</span>.</span><br><span class=\"line\">Automatic cleanup will <span class=\"keyword\">not</span> be performed <span class=\"keyword\">until</span> <span class=\"keyword\">the</span> <span class=\"built_in\">file</span> is removed.</span><br><span class=\"line\">warning: There are too many unreachable loose objects; </span><br><span class=\"line\">run <span class=\"string\">&#x27;git prune&#x27;</span> <span class=\"built_in\">to</span> remove them.gc <span class=\"comment\">--auto: command returned error: 255</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 大概意思是垃圾太多，转移暂停让你先清理垃圾，其实只要按照他说的 进到我们转了一半的仓库 进行  <code>git gc</code>  就可以，但是这样一来我们就需要一直守在电脑前，随时准备输入  <code>git gc</code>  而且假如你下班前开始跑结果第二天上班一看跑到一半就暂停了，白白浪费了一晚上的时间，真的会崩溃的。所以通过 google 找到了解决办法</p>\n<p><img data-src=\"https://image-1256056152.cos.ap-nanjing.myqcloud.com/073257.jpg\" alt=\"\" /></p>\n<p>也就是开始转换的时候先进入仓库输入  <code>git config gc.auto 0</code>  关闭 gc 功能，然后就可以一直跑到黑了，你大可以放心的运行命令然后下班回家。不过还有一点需要注意的是垃圾文件是否过多和你仓库大小没有太大关系，及时你仓库提交不多，但是每次提交都有很大改动的话也还是会出现这个问题，所以这里建议不管你仓库多大，都要先进行一下这个操作，以防万一。</p>\n<h4 id=\"坑点三大文件处理\"><a class=\"anchor\" href=\"#坑点三大文件处理\">#</a> 坑点三：大文件处理</h4>\n<p>git 和 SVN 不同，在 git 上提交的单个文件是有大小限制的，超过这个大小就不允许提交到仓库中，通常我们会用 git LFS 来解决，具体的安装，添加步骤网上大把的教程，就不在这里说，不过他只会告诉你大文件的大小和限制的大小，具体的大文件是哪个他不会告诉你，这里可以用以下命令查看<br />\n <figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git ls-tree -r -<span class=\"built_in\">t</span> -l --full-name HEAD | sort -<span class=\"built_in\">n</span> -k <span class=\"number\">4</span> | tail -<span class=\"built_in\">n</span> <span class=\"number\">10</span> //查找git 仓库中排名前十的大文件(升序)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 他会输出前十个最大的文件，然后你再按需处理。但是当你把大文件添加到 LFS 中后再次推送还是会爆出同样的错误，而且还是同样的文件，也就是说你根本没添加成功，其实并不是这样的，在添加 LFS 中只要你操作没错，就是添加成功了，他还会报错的原因是因为虽然你工程中的大文件已经添加，但是你的历史提交记录中是包含大文件的代码快照的，所以你需要将历史上所有包含大文件的提交记录重写，删掉大文件相关的东西，git 中重写 commit 的命令是：<br />\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">filter</span>-branch --force --<span class=\"built_in\">index</span>-<span class=\"built_in\">filter</span> <span class=\"string\">&#x27;git rm -rf --cached --ignore-unmatch 你大文件所在的目录&#x27;</span> --prune-<span class=\"built_in\">empty</span> --<span class=\"keyword\">tag</span>-name-<span class=\"built_in\">filter</span> <span class=\"keyword\">cat</span> -- --<span class=\"keyword\">all</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 这个过程也比较漫长，他会便利你所有的提交记录并一一修改，不过就是漫长的等待就可以了，等到完成之后我们需要将代码 push 到远端，因为我们修改了所有的 commit 我们需要强制 push 使用如下命令<br />\n <figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin <span class=\"keyword\">master</span> <span class=\"title\">--force</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"坑点四-打包时间过长\"><a class=\"anchor\" href=\"#坑点四-打包时间过长\">#</a> 坑点四：打包时间过长</h4>\n<p>再上一步我们执行完推送命令的时候，会先进行文件打包处理，这个过程也是非常漫长，而且非常消耗电脑资源的，按照我的电脑配置来说，这个过程一旦开始，电脑基本就是内存、cpu 全满的状态，鼠标也没法动，所以这个过程要有心理准备。漫长的等待之后就推送成功了。</p>\n",
            "tags": [
                "git",
                "代码版本控制"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-08-22-GitFlow/",
            "url": "https://oliverqueen.cn/2018-08-22-GitFlow/",
            "title": "GitFlow流程",
            "date_published": "2018-08-23T06:20:39.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"关于gitflow\"><a class=\"anchor\" href=\"#关于gitflow\">#</a> 关于 gitflow</h1>\n<h2 id=\"概念\"><a class=\"anchor\" href=\"#概念\">#</a> 概念：</h2>\n<p>Git Flow 是构建在 Git 之上的一个组织、管理软件开发活动的模型。Git Flow 是一套使用 Git 进行源代码管理时的一套行为规范和，通过利用 Git 创建和管理分支的能力，为每个分支设定具有特定的含义名称，并将软件生命周期中的各类活动归并到不同的分支上。实现了软件开发过程不同操作的相互隔离。这种软件开发的活动模型被称为 “Git Flow”。</p>\n<h2 id=\"原理\"><a class=\"anchor\" href=\"#原理\">#</a> 原理：</h2>\n<p>gitflow 的\b核心就 branch，通过在项目的不同阶段对 branch 的不同操作包括但不限于 create、marge、rebase、等来实现一个完整的高效率的工作流程。一般而言，软件开发模型有常见的瀑布模型、迭代开发模型、以及最近出现的敏捷开发模型等不同的模型。每种模型有各自应用场景。<strong>Git Flow 重点解决的是由于源代码在开发过程中的各种冲突导致开发活动混乱的问题。因此，Git flow 可以很好的于各种现有开发模型相结合使用，尤其是多人合作开发时提高效率</strong>。用一张图来了解 gitflow 的流程：从右向左看 从上到下看</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1ftk5pkvn7ij30vy16cwhl.jpg\" alt=\"\" /></p>\n<p><span id=\"more\"></span></p>\n<h2 id=\"branch\"><a class=\"anchor\" href=\"#branch\">#</a> Branch：</h2>\n<p>Branch 是 gitfolw 的核心。主要分为两大类 <strong>Main Branchs</strong> 和 <strong>Supporting branches</strong>, 其中 <strong>Main Branchs</strong> 中又包含了 <strong>Master</strong> 和 <strong>Develop</strong>，而 <strong>Supporting branches</strong> 中包含了 **Feature **、<strong>Release</strong>、<strong>Hotfix</strong> <strong>以及其他自定义分支</strong>，下面逐一讲解：</p>\n<h4 id=\"master\"><a class=\"anchor\" href=\"#master\">#</a> Master:</h4>\n<ul>\n<li>\n<p>描述：</p>\n<p>master 分支上存放的是最稳定的正式版的代码，并且该分支的代码应该是随时可在开发环境中使用的代码（Production Ready state）。当一个版本开发完毕后，产生了一份新的稳定的可供发布的代码时，master 分支上的代码要被更新，同时，每一次更新，都需要在 master 上打上对应的版本号 (tag)。</p>\n</li>\n<li>\n<p>生成及销毁：</p>\n<p>任何人不允许在 master 上进行代码的直接提交，只接受合入，Master 上的代码必须是要从经过多轮测试且已经发布一段时间 (根据 DAU 以及项目实际情况来定，个人建议 K 歌国际版可以定为一周) 且线上已经稳定的 <strong>release</strong> 分支合并进去，然后在 Master 上生成 tag (通常就是对应的版本号)</p>\n</li>\n<li>\n<p>命名：</p>\n<p>master</p>\n</li>\n</ul>\n<h4 id=\"develop\"><a class=\"anchor\" href=\"#develop\">#</a> Develop:</h4>\n<ul>\n<li>\n<p>描述：</p>\n<p>develop 分支是保存当前最新版本开发成果的分支。该分支上的代码允许有 BUG，但是必须保证编译通过，且该分支可以作为每天夜间测试的分支 (如果有夜间测试的话) 所以该分支也叫做 Nightly build。当 develop 分支上的代码已实现了软件需求说明书中所有的功能 (必须经过开发自测，但是不必经过 QA) 且相对稳定时候，就可以基于此分支来拉出新的 release 分支交付 QA 进行测试。</p>\n</li>\n<li>\n<p>生成及销毁：</p>\n<p>Develop 分支是由一个人 (通常是 Team Leader) 从 Master 中拉出，任何人不得在 Develop 上进行代码提交，只接受合入。Develop 上所有代码一定都是由 <strong>Supporting branches</strong> 中的 Branch 合并进来，且合入 Develop 的分支必须保证功能完整，可以独立运行，可允许包含一些 BUG (但是最好经过自测，不要有太大或者太明显的 BUG，比如一启动就 crash 之类的)。</p>\n</li>\n<li>\n<p>命名：</p>\n<p>develop</p>\n</li>\n<li>\n<p>流程：</p>\n</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1ftk7aszas4j30eu0mc74p.jpg\" alt=\"\" /></p>\n<h4 id=\"feature\"><a class=\"anchor\" href=\"#feature\">#</a> Feature:</h4>\n<ul>\n<li>\n<p>描述：</p>\n<p>Feature 分支通常叫做功能分支，也可以叫做个人分支，一般命名为 <strong>feature/XXXX</strong>, 该分支就是每一个开发人员进行开发的分支，比如做一些功能、需求之类的东西，这个分支上的代码变更最终合并回 develop 分支或者干脆被抛弃掉（例如实验性且效果不好的代码变更）。一般而言，feature 分支代码可以保存在开发者自己的代码库中而不强制提交到主代码库里。</p>\n</li>\n<li>\n<p>生成及销毁：</p>\n<p>每个开发者从通常会 Develop 分支中拉取自己的 feature，且开发者可以随意的在自己的 feature 上进行操作 包括但不限于 提交、回滚、删除。如果最终需要合并入 develop 那就要保证功能的完整性以及代码的稳定新，比如我在 feature 上做了 3 个需求但是由于时间关系我只做了两个，那也可以将 feature 合并入 develop，然后剩下的那一个需求等有时间了再去 feature 上做完之后再合入 develop。所以这里说的功能的完整性并不是值得要做完所有的功能，而是要保证你所要做的所有需求中的某一个或者某几个功能已经做完，不允许把做到一半的功合并入 develop。合并入 develop 尽量上删除远端的 feature 分支，本地的 feature 可以视情况而取舍。</p>\n</li>\n<li>\n<p>命名：</p>\n<p>feature 通常是从 develope 上拉取 所有通常用 <strong>dev_功能描述_英文名</strong> 来命名。比如 <strong>feature/dev_refresh_molierzhang</strong></p>\n</li>\n<li>\n<p>流程：</p>\n</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1ftk7br1fvqj307e0jugln.jpg\" alt=\"\" /></p>\n<h4 id=\"release\"><a class=\"anchor\" href=\"#release\">#</a> Release:</h4>\n<ul>\n<li>\n<p>描述：</p>\n<p>Release 分支通常叫做发布分支，也可以叫做测试 - 发布分支，一般命名为 <strong>Release/1.2.3</strong>（后面是版本号）, 该分支是为测试 - 发布新的产品版本而开辟的。因为包含测试流程，所以在这个分支上的代码允许做小的缺陷修正、准备发布版本所需的各项说明信息（版本号、发布时间、编译时间等等）。通过在 release 分支上进行这些工作可以让 develop 分支空闲出来以接受新的 feature 分支上的代码提交，进入新的软件开发迭代周期。<strong>注意：该分支上的代码一定是可编译可运行的，允许包含小 BUG</strong></p>\n</li>\n<li>\n<p>生成及销毁：</p>\n<p>当 develop 分支上的代码已经包含了该版本所有即将发布的功能和需求，并且已通过自测且已基本稳定，我们就可以考虑准备基于 develop 拉取 release 分支了。而所有在当前即将发布的版本之外的业务需求一定要确保不能混到 release 分支之内（避免由此引入一些不可控的系统缺陷）。成功的派生了 release 分支之后，develop 分支就可以为 “下一个版本” 服务了。所谓的 “下一个版本” 是在当前即将发布的版本之后发布的版本。开发人员可以在此分支上修改 BUG，进行提交、回滚等操作，但是与 feature 不同的是 release 分支是被多人操作的，不像 feature，所以一定要小心避免冲突。当现在 QA 测试没有问题，便从 release 上发布上线，且经过一段时间的验证没有问题后合入 master，并且删除 release 分支，其实根据 release 分支的特性我们可以使用 Git Hook 触发软件自动测试以及生产环境代码的自动更新工作。这些自动化操作将有利于减少新代码发布之后的一些事务性工作。</p>\n</li>\n<li>\n<p>命名：</p>\n<p>release/1.2.3 后面跟对应的版本号</p>\n</li>\n<li>\n<p>流程：</p>\n<p>同 feature</p>\n</li>\n</ul>\n<h4 id=\"hotfix\"><a class=\"anchor\" href=\"#hotfix\">#</a> Hotfix:</h4>\n<ul>\n<li>\n<p>描述：</p>\n<p>Hotfix 叫热修复分支，除了是计划外创建的以外，hotfix 分支与 release 分支十分相似，当已经发布的版本（Master 上代码）遇到了异常情况或者发现了严重到必须立即修复的软件缺陷的时候，就需要从 master 分支上指定的 tag 版本拉取 hotfix 分支来组织代码的紧急修复工作。这样做的显而易见的好处是不会打断正在进行的 develop 分支的开发工作，能够让团队中负责新功能开发的人与负责代码紧急修复的人并行、独立的开展工作。</p>\n</li>\n<li>\n<p>生成及销毁：</p>\n<p>由 Master 上拉取，进行修复，负责修改 BUG 的同事可以进行提交及其它操作，后续的热修复测试也在此分支上进行。通过测试验证没问题后有一个人 (通常为 teamleader)<strong> 合并入 Master 分支，且同时也要合并入 Develop 分支</strong></p>\n</li>\n<li>\n<p>命名：</p>\n<p>Hotfix/1.2.3 后面跟对应的版本号</p>\n</li>\n<li>\n<p>流程：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1ftk81yr4iej308j0bqwf3.jpg\" alt=\"\" /></p>\n</li>\n</ul>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>Git Flow 开发模型从源代码管理角度对通常意义上的软件开发活动进行了约束。应该说，为我们的软件开发提供了一个可供参考的管理模型。Git Flow 开发模型让开发代码仓库保持整洁，让小组各个成员之间的开发相互隔离，能够有效避免处于开发状态中的代码相互影响而导致的效率低下和混乱。</p>\n<p>所谓模型，在不同的开发团队，不同的文化，不同的项目背景情况下都有可能需要进行适当的裁剪或扩充。</p>\n<h2 id=\"效率工具\"><a class=\"anchor\" href=\"#效率工具\">#</a> 效率工具</h2>\n<p>推荐 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc291cmNldHJlZWFwcC5jb20v\">sourceTree</span> 和 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ2l0a3Jha2VuLmNvbS8=\">gitkarken</span> (用免费版即可，不用充钱) 前者对 gitsubmodel 的支持不太好，不过目前介于我们没有实现组件化所以暂时可以无视；后者完美支持 gitsubmodel，但是在拉取一些比较大的库的时候可能会卡死，前公司一个项目 30G+ 会有卡死情况出现，后者界面炫酷一些 iOS 的话 Xcdoe 自带 git 也可以试试。</p>\n",
            "tags": [
                "git",
                "效率工作"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-06-19-MusicAbout/",
            "url": "https://oliverqueen.cn/2018-06-19-MusicAbout/",
            "title": "关于实现唱吧清唱功能的理解",
            "date_published": "2018-06-19T06:44:56.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"简介\"><a class=\"anchor\" href=\"#简介\">#</a> 简介</h2>\n<h4 id=\"avfoundation\"><a class=\"anchor\" href=\"#avfoundation\">#</a> AVFoundation</h4>\n<p>在 iOS 上多媒体的处理主要依赖的是 AVFoundation 框架，而 AVFoundation 是基于 CoreAudio、CoreVideo、CoreMedia、CoreAnimation 之上高层框架，在 AVFoundation 框架之上苹果还提供给我们更高层一些处理媒体数据的框架。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fsgu5859czj30ol0et75h.jpg\" alt=\"\" /><br />\n<span id=\"more\"></span></p>\n<p>如 AVKit、iOS 的 UIKit、OS 的 AppKit。AVFoundation 提供了大量强大的工具集，可通过这个框架处理音视频编程，但是如同苹果中的的 Kit 一样，封装的越高级，个性化就会困难些，一些实际项目中的奇葩需求难以实现。本章所讲的内容是 AVFoundation 上层加下层的 AVAudioEngine 实现。</p>\n<h4 id=\"avaudioengine\"><a class=\"anchor\" href=\"#avaudioengine\">#</a> AVAudioEngine</h4>\n<p>AVAudioEngine 是 Objective-C 的音频 API 接口，具有低延迟 (low-latency) 和实时 (real-time) 的音频功能，并且具有如下特点：</p>\n<ul>\n<li>\n<p>读写所有 Core Audio 支持的格式音频文件</p>\n</li>\n<li>\n<p>播放和录音使用 (files) 和音频缓冲区 (buffers)</p>\n</li>\n<li>\n<p>动态配置音频处理模块 (audio processing blocks)</p>\n</li>\n<li>\n<p>可以进行音频挖掘处理 (tap processing)</p>\n</li>\n<li>\n<p>可以进行立体声音频信号混合和 3d 效果的混合</p>\n</li>\n<li>\n<p>音乐设备数字接口 MIDI 回放和控制，通过乐器的采样器</p>\n</li>\n</ul>\n<p>AVAudioEngine 的工作原理可以简单的分为三个部分:</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fsgusaq6ttj316208i41t.jpg\" alt=\"\" /></p>\n<p>从图中可以看出 AVAudioEngine 的每一步操作都是一个音频操作节点 (Node)，每个完整的操作都包含输入节点和输出节点以及经中间的若干个处理节点，包括但不限于，添加音效、混音、音频处理等。整体的流程和 GPUImage 的流程差不多，都是链式结构，通过节点来链接成一个完整的流水线，其中每个节点都有自己特有的属性，可以通过改变属性的值来改变经由该节点后的音频输出效果，用音效节点举例：一个声音流通过这个音效节点，假如这个节点可以给该段声音添加一个回响的效果，那么通过该节点特有的属性可以设置回想的间隔、干湿程度等，这样一来经过这个节点处理过的声音流就会变成我们想要的样子，然后他作为为一个输入了再次流入其他节点。上图的 Mixer 其实是包含若干个这样的音效节点</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fsgvxmt21cj310c0dpq4l.jpg\" alt=\"\" /></p>\n<h2 id=\"原理\"><a class=\"anchor\" href=\"#原理\">#</a> 原理</h2>\n<p>清唱的功能很简单，就是通过麦克风录制声音，然后添加音效或者做一些处理之后再输出，因为不要配乐，所以省略了一大部分操作 (添加配乐完整 K 歌在下期会讲到)，但是有一个问题就是耳返，也叫返送：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fsgv4t4pd6j30n602ujsg.jpg\" alt=\"\" /></p>\n<p>这个东西是必不可少的，因为有了耳返你就可以实时调整自己的声音，极大的降低了走调的风险和尴尬，一个很简单的例子，现在有不少人喜欢在水房唱歌或者是洗澡的时候唱歌，原因就是在水房或者是卫生间通常会有回音，而回音就是天然的耳返，所以在有回音的地方唱歌就会感觉自己的声音洪亮而且音准很好 (因为你可以实时的通过回音来调整自己的声调)。演唱会上唱歌的人的耳机中都是耳返。而且耳返要有一个要求就是，你所听到的你自己的声音一定要和观众或者是其他的人听到的一样，不然就不会有作用，我们平时自己说话自己能听到是因为声音通过骨传导到达我们的耳朵，而听众听到的是通过空气介质传播，所以是否有耳返直接决定了你演唱质量的好坏。</p>\n<p>使用 AVAudioEngine 来完成这个功能其实就是运用了他的实时音频的特点，他可以几乎在没有延迟的情况下同时创建音频的输入和输出，而且对这个做了高度的封装使我们能更加关心音效调整</p>\n<h2 id=\"实现\"><a class=\"anchor\" href=\"#实现\">#</a> 实现</h2>\n<h6 id=\"创建音频文件用来接收待录制的声音\"><a class=\"anchor\" href=\"#创建音频文件用来接收待录制的声音\">#</a> 创建音频文件用来接收待录制的声音：</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建音频文件。</span></span><br><span class=\"line\">   <span class=\"built_in\">NSString</span> * path = <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">   <span class=\"built_in\">NSString</span> * filePath = [path stringByAppendingPathComponent:<span class=\"string\">@&quot;123.caf&quot;</span>];</span><br><span class=\"line\">   <span class=\"built_in\">NSURL</span> * url = [<span class=\"built_in\">NSURL</span> fileURLWithPath:filePath];</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"创建avaudioengine并打通输入和输出节点\"><a class=\"anchor\" href=\"#创建avaudioengine并打通输入和输出节点\">#</a> 创建 AVAudioEngine，并打通输入和输出节点：</h6>\n<ul>\n<li>\n<p>创建 AVAudioEngine，并初始化。这里要弄成属性不然会被释放，没有效果</p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">AVAudioEngine</span> * engine;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">AVAudioMixerNode</span> * mixer;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">self.engine</span> = [[AVAudioEngine alloc] init]<span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"attr\">self.mixer</span> = [[AVAudioMixerNode alloc] init]<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>打通输入和输出节点：</p>\n<p><figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"variable\">_engine</span> connect:<span class=\"variable\">_engine</span>.inputNode <span class=\"keyword\">to</span>:<span class=\"variable\">_engine</span>.outputNode <span class=\"built_in\">format</span>:[<span class=\"variable\">_engine</span>.inputNode inputFormatForBus:AVAudioPlayerNodeBufferLoops]];</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 所使用的是如下方法。<br />\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*!\t@method connect:to:format:</span></span><br><span class=\"line\"><span class=\"comment\">\t@abstract</span></span><br><span class=\"line\"><span class=\"comment\">\t\tEstablish a connection between two nodes</span></span><br><span class=\"line\"><span class=\"comment\">\t@discussion</span></span><br><span class=\"line\"><span class=\"comment\">\t\tThis calls connect:to:fromBus:toBus:format: using bus 0 on the source node,</span></span><br><span class=\"line\"><span class=\"comment\">\t\tand bus 0 on the destination node, except in the case of a destination which is a mixer,</span></span><br><span class=\"line\"><span class=\"comment\">\t\tin which case the destination is the mixer&#x27;s nextAvailableInputBus.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)connect:(<span class=\"built_in\">AVAudioNode</span> *)node1 to:(<span class=\"built_in\">AVAudioNode</span> *)node2 format:(<span class=\"built_in\">AVAudioFormat</span> * __<span class=\"keyword\">nullable</span>)format;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>开启 AVAudioEngine:</p>\n<p>该方法可能会开启失败，需要开发者自定去处理</p>\n<p><figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[_engine startAndReturnError:nil]</span><span class=\"comment\">;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>以上步骤走完后并且开启成功你就会发现你从耳机里面可以实时的听到你的声音了。</p>\n</li>\n<li>\n<p>音效：</p>\n<p>正常来说光有耳返还不够，因为清唱虽然没有配乐伴奏，但是是支持用户调节音效的，类似于变声。这就用到 AVAudioEngine 中的 AVAudioUnitEffect 类。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fsgxpydeq8j30hw0cwq32.jpg\" alt=\"\" /></p>\n<ul>\n<li>\n<p>1.AVAudioUnitReverb: 混响，混响可以模拟咱们在一个空旷的环境，比如教堂、大房间等，这样咱们在说话的时候，就会有回音，并且声音也比较有立体感。其中该类别下面又分为<br />\n <figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_ENUM</span>(<span class=\"type\">NSInteger</span>, <span class=\"type\">AVAudioUnitReverbPreset</span>) &#123;</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetSmallRoom</span>       = 0,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetMediumRoom</span>      = 1,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetLargeRoom</span>       = 2,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetMediumHall</span>      = 3,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetLargeHall</span>       = 4,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetPlate</span>           = 5,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetMediumChamber</span>   = 6,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetLargeChamber</span>    = 7,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetCathedral</span>       = 8,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetLargeRoom2</span>      = 9,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetMediumHall2</span>     = 10,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetMediumHall3</span>     = 11,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetLargeHall2</span>      = 12</span><br><span class=\"line\">  &#125; <span class=\"type\">NS_ENUM_AVAILABLE</span>(10_10, 8_0);</span><br></pre></td></tr></table></figure><br />\n 从名字可以看出是在模拟不同环境下的音效，比如其中的大中小屋子，大厅等。</p>\n<p>该类别可以自定义的属性是 wetDryMix，就是可以让我们的声音更空灵。</p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">/*! @property wetDryMix</span></span><br><span class=\"line\"><span class=\"comment\">    @abstract</span></span><br><span class=\"line\"><span class=\"comment\">    Blend of the wet and dry signals</span></span><br><span class=\"line\"><span class=\"comment\">    Range:      0 (all dry) -&gt; 100 (all wet)</span></span><br><span class=\"line\"><span class=\"comment\">    Unit:       Percent</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"type\">float</span> wetDryMix;</span><br></pre></td></tr></table></figure></p>\n<p>可以通过如下方式创建 AVAudioUnitReverb<br />\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">AVAudioUnitReverb</span> <span class=\"operator\">*</span> reverd <span class=\"operator\">=</span> [[<span class=\"type\">AVAudioUnitReverb</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">reverd.wetDryMix <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">[reverd loadFactoryPreset:<span class=\"type\">AVAudioUnitReverbPresetLargeRoom</span>];</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>2.AVAudioUnitEQ: 均衡器，咱们可以使用均衡器来调节咱们音频的各个频段，比如，我想让我的低音更加浑厚，我就可以调节 EQ 的 20-150HZ 的频段，如果你想让你的声音更加明亮，那可以调节 500-1KHZ 的频段，这个调节涉及到一些专业方面的知识，如果只是想让用户去使用的话，可以用苹果给我们更封装好的几个效果即可，这个就类似于 photoshop 和美图秀秀的区别。</p>\n<p><figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_ENUM</span>(<span class=\"type\">NSInteger</span>, <span class=\"type\">AVAudioUnitEQFilterType</span>) &#123;</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeParametric</span>        = 0,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeLowPass</span>           = 1,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeHighPass</span>          = 2,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeResonantLowPass</span>   = 3,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeResonantHighPass</span>  = 4,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeBandPass</span>          = 5,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeBandStop</span>          = 6,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeLowShelf</span>          = 7,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeHighShelf</span>         = 8,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeResonantLowShelf</span>  = 9,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeResonantHighShelf</span> = 10,</span><br><span class=\"line\">  &#125; <span class=\"type\">NS_ENUM_AVAILABLE</span>(10_10, 8_0);</span><br></pre></td></tr></table></figure></p>\n<p>上面是一些苹果帮助我们定义好的滤波器，比如低通滤波器 衰弱高频、可以引发共鸣的 低通滤波器<br />\n不过一般在清唱的时候这个用处不大，这个效果主要用到在配合伴奏的时候，如果伴奏音调过高，可以使用该方法适当的提高人声音调或者降低伴奏的音调，</p>\n<p>可以通过如下方式使用，然后更改这个节点一些属性值。<br />\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AVAudioUnitEQ * <span class=\"keyword\">eq</span> <span class=\"operator\">=</span> [[AVAudioUnitEQ alloc] initWithNumberOfBands:<span class=\"number\">1</span>]<span class=\"comment\">;</span></span><br><span class=\"line\">AVAudioUnitEQFilterParameters * <span class=\"keyword\">filter</span> <span class=\"operator\">=</span> <span class=\"keyword\">eq</span>.bands.firstObject<span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"keyword\">filter</span>.filterType <span class=\"operator\">=</span> AVAudioUnitEQFilterTypeResonantHighShelf<span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"keyword\">filter</span>.bandwidth <span class=\"operator\">=</span> <span class=\"number\">10</span><span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"keyword\">filter</span>.gain <span class=\"operator\">=</span> <span class=\"number\">20</span><span class=\"comment\">;</span></span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>3.AVAudioUnitDistortion：失真，这个就是我们常说的电音，一般说唱或者摇滚，重金属之类的曲风会用到这个效果，同样苹果给我们提供了预设的几个效果，如果不是有专业的需求我们可以直接使用。</p>\n<p><figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  typedef <span class=\"type\">NS_ENUM</span>(<span class=\"type\">NSInteger</span>, <span class=\"type\">AVAudioUnitDistortionPreset</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetDrumsBitBrush</span>           = 0,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetDrumsBufferBeats</span>        = 1,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetDrumsLoFi</span>               = 2,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiBrokenSpeaker</span>      = 3,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiCellphoneConcert</span>   = 4,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDecimated1</span>         = 5,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDecimated2</span>         = 6,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDecimated3</span>         = 7,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDecimated4</span>         = 8,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDistortedFunk</span>      = 9,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDistortedCubed</span>     = 10,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDistortedSquared</span>   = 11,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiEcho1</span>              = 12,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiEcho2</span>              = 13,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiEchoTight1</span>         = 14,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiEchoTight2</span>         = 15,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiEverythingIsBroken</span> = 16,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetSpeechAlienChatter</span>      = 17,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetSpeechCosmicInterference</span> = 18,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetSpeechGoldenPi</span>          = 19,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetSpeechRadioTower</span>        = 20,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetSpeechWaves</span>             = 21</span><br><span class=\"line\">&#125; <span class=\"type\">NS_ENUM_AVAILABLE</span>(10_10, 8_0);</span><br></pre></td></tr></table></figure><br />\n 其实里面有些还是比较有感觉的，比如扭曲的立方体，或者外星人的喋喋不休等。有兴趣的可以说都试试</p>\n<p>使用方式同之前的效果一样</p>\n<p><figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AVAudioUnitDistortion * <span class=\"keyword\">dist </span>= [[AVAudioUnitDistortion alloc] init];</span><br><span class=\"line\">[<span class=\"keyword\">dist </span>loadFactoryPreset:AVAudioUnitDistortionPresetDrumsBitBrush];</span><br><span class=\"line\"><span class=\"keyword\">dist.preGain </span>= <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"keyword\">dist.wetDryMix </span>= <span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>4.AVAudioUnitDelay: 延迟，延迟就是 发出一个声音之后，过段时间再次发出，一直衰减到听不见。类似咱们的回声。可以通过里面的属性去细微的调节延迟的时间、速度等。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>添加音效：<br />\n主要流程就是链式关系</p>\n<p><strong>input (Mic 或者音频文件) -&gt; 效果器 -&gt;output</strong></p>\n<p>如果是多个音效</p>\n<p><strong>input (Mic 或者音频文件) -&gt; 效果器 1-&gt; 效果器 2-&gt;output</strong></p>\n<p>我们以 AVAudioUnitReverb 效果为例</p>\n<p><figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AVAudioUnitReverb * reverb = [[AVAudioUnitReverb alloc] init];</span><br><span class=\"line\">[reverb loadFactoryPreset:AVAudioUnitReverbPresetLargeRoom];</span><br><span class=\"line\">reverb.wetDryMix = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"comment\">//把混响附着到音频引擎</span></span><br><span class=\"line\">[<span class=\"variable\">_engine</span> attachNode:reverb];</span><br><span class=\"line\"><span class=\"comment\">//依次链接输入-&gt; 混响 -&gt; 输出</span></span><br><span class=\"line\">[<span class=\"variable\">_engine</span> connect:<span class=\"variable\">_engine</span>.inputNode <span class=\"keyword\">to</span>:reverb <span class=\"built_in\">format</span>:[<span class=\"variable\">_engine</span>.inputNode inputFormatForBus:AVAudioPlayerNodeBufferLoops]];</span><br><span class=\"line\">[<span class=\"variable\">_engine</span> connect:reverb <span class=\"keyword\">to</span>:<span class=\"variable\">_engine</span>.outputNode <span class=\"built_in\">format</span>:[<span class=\"variable\">_engine</span>.inputNode inputFormatForBus:AVAudioPlayerNodeBufferLoops]];</span><br><span class=\"line\"><span class=\"comment\">//启动引擎</span></span><br><span class=\"line\">[<span class=\"variable\">_engine</span> startAndReturnError:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 同理添加多个音效则需要严格按照 <strong>input (Mic 或者音频文件) -&gt; 效果器 1-&gt; 效果器 2-&gt;output</strong> 顺序来添加</p>\n<p>综上：完成了以上所有操作后你就可以实时在耳机中听到自己经过音效处理过的声音了，而且这样带着耳机唱歌效果会非常好，声音洪亮不易跑调。还可以针对不同的曲风调整自己的音效。</p>\n</li>\n</ul>\n<h6 id=\"声音混合-写入本地\"><a class=\"anchor\" href=\"#声音混合-写入本地\">#</a> 声音混合、写入本地：</h6>\n<p>我们需要把我们清唱的歌曲录制到本地，正常的录制时使用 AVAudioRecorder 来进行录制的，像这样</p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">AVAudioSession</span> * session = [<span class=\"built_in\">AVAudioSession</span> sharedInstance];</span><br><span class=\"line\">    [session setCategory:<span class=\"built_in\">AVAudioSessionCategoryPlayAndRecord</span> error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    [session setActive:<span class=\"literal\">YES</span> error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> * path = <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.filePath = [path stringByAppendingPathComponent:<span class=\"string\">@&quot;SoWeak&quot;</span>];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.recordFileUrl = [<span class=\"built_in\">NSURL</span> fileURLWithPath:<span class=\"keyword\">self</span>.filePath];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//设置参数</span></span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> *recordSetting = [[<span class=\"built_in\">NSDictionary</span> alloc] initWithObjectsAndKeys:</span><br><span class=\"line\">                                   <span class=\"comment\">//采样率  8000/11025/22050/44100/96000（影响音频的质量）</span></span><br><span class=\"line\">                                   [<span class=\"built_in\">NSNumber</span> numberWithFloat: <span class=\"number\">8000.0</span>],<span class=\"built_in\">AVSampleRateKey</span>,</span><br><span class=\"line\">                                   <span class=\"comment\">// 音频格式</span></span><br><span class=\"line\">                                   [<span class=\"built_in\">NSNumber</span> numberWithInt: kAudioFormatLinearPCM],<span class=\"built_in\">AVFormatIDKey</span>,</span><br><span class=\"line\">                                   <span class=\"comment\">//采样位数  8、16、24、32 默认为16</span></span><br><span class=\"line\">                                   [<span class=\"built_in\">NSNumber</span> numberWithInt:<span class=\"number\">16</span>],<span class=\"built_in\">AVLinearPCMBitDepthKey</span>,</span><br><span class=\"line\">                                   <span class=\"comment\">// 音频通道数 1 或 2</span></span><br><span class=\"line\">                                   [<span class=\"built_in\">NSNumber</span> numberWithInt: <span class=\"number\">2</span>], <span class=\"built_in\">AVNumberOfChannelsKey</span>,</span><br><span class=\"line\">                                   <span class=\"comment\">//录音质量</span></span><br><span class=\"line\">                                   [<span class=\"built_in\">NSNumber</span> numberWithInt:<span class=\"built_in\">AVAudioQualityHigh</span>],<span class=\"built_in\">AVEncoderAudioQualityKey</span>,</span><br><span class=\"line\">                                   <span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.recorder = [[<span class=\"built_in\">AVAudioRecorder</span> alloc] initWithURL:<span class=\"keyword\">self</span>.recordFileUrl settings:recordSetting error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.recorder) &#123;</span><br><span class=\"line\">        _recorder.meteringEnabled = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">        [_recorder prepareToRecord];</span><br><span class=\"line\">        [_recorder record];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>但是很明显这样录制声音需要开启 session 而声音的 session 是一个单利，如果这样开启了那么我们后面就不能用 AVAudioEngine 来进行音频采集了，也就没有之前的效果。所有根据以往的经验，AVAudioEngine 在开启引擎之后一定会有一个 delegate 或者是 block 回调出采集到的数据的。于是我们找到了 AudioNode 中的这个方法：<br />\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)installTapOnBus:(<span class=\"built_in\">AVAudioNodeBus</span>)bus bufferSize:(<span class=\"built_in\">AVAudioFrameCount</span>)bufferSize format:(<span class=\"built_in\">AVAudioFormat</span> * __<span class=\"keyword\">nullable</span>)format block:(<span class=\"built_in\">AVAudioNodeTapBlock</span>)tapBlock;</span><br></pre></td></tr></table></figure><br />\n 其中的 block 的 buffer 便是我们采集到的数据。</p>\n<p><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*!\t<span class=\"doctag\">@typedef</span> AVAudioNodeTapBlock</span></span><br><span class=\"line\"><span class=\"comment\">\t<span class=\"doctag\">@abstract</span> A block that receives copies of the output of an AVAudioNode.</span></span><br><span class=\"line\"><span class=\"comment\">\t<span class=\"doctag\">@param</span> buffer</span></span><br><span class=\"line\"><span class=\"comment\">\t\ta buffer of audio captured from the output of an AVAudioNode</span></span><br><span class=\"line\"><span class=\"comment\">\t<span class=\"doctag\">@param</span> when</span></span><br><span class=\"line\"><span class=\"comment\">\t\tthe time at which the buffer was captured</span></span><br><span class=\"line\"><span class=\"comment\">\t<span class=\"doctag\">@discussion</span></span></span><br><span class=\"line\"><span class=\"comment\">\t\tCAUTION: This callback may be invoked on a thread other than the main thread.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">typedef <span class=\"keyword\">void</span> (^AVAudioNodeTapBlock)(AVAudioPCMBuffer *buffer, AVAudioTime *when);</span><br></pre></td></tr></table></figure></p>\n<p>我们需要把 buffer 转成 AVAudioFile 然后通过 AVAudioFile 的 write 方法写入<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">初始化<span class=\"built_in\">AVAudioFile</span></span><br><span class=\"line\"><span class=\"built_in\">AVAudioFile</span> * audioFile = [[<span class=\"built_in\">AVAudioFile</span> alloc] initForWriting:url settings:@&#123;&#125; error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">然后在block中实现</span><br><span class=\"line\">[audioFile writeFromBuffer:buffer error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 这个时候写入成功然后播放本地录音文件发现只有自己的原生，并没有后面添加的音效，回音等效果。</p>\n<p>其实是因为我们虽然添加了音效但是我们没有把音效和原生混合在一起，即使我们实时听到的是没有问题的，但是当保存到本地之后如果没有做混合，系统会默认将最原始的声音写入本地，这里我们需要用到</p>\n<p><strong>AVAudioMixerNode</strong></p>\n<p>他是继承与 AVAudioNode 也属于一个特殊音频处理节点，使用方式和之前的音效节点一样，添加在所有的处理之后、输出之前即可，像这样</p>\n<p><strong>input (Mic 或者音频文件) -&gt; 效果器 1-&gt; 效果器 2-&gt;Mixer-&gt;output</strong></p>\n<p>不过唯一需要注意的是这个 mixer 最好也写成属性、不然会出问题。</p>\n<p>所以一个完整的带音效的清唱录制为：<br />\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建音频文件。</span></span><br><span class=\"line\">    <span class=\"type\">NSString</span> <span class=\"operator\">*</span> path <span class=\"operator\">=</span> <span class=\"type\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"type\">NSDocumentDirectory</span>, <span class=\"type\">NSUserDomainMask</span>, <span class=\"type\">YES</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"type\">NSString</span> <span class=\"operator\">*</span> filePath <span class=\"operator\">=</span> [path stringByAppendingPathComponent:@<span class=\"string\">&quot;123.caf&quot;</span>];</span><br><span class=\"line\">    <span class=\"type\">NSURL</span> <span class=\"operator\">*</span> url <span class=\"operator\">=</span> [<span class=\"type\">NSURL</span> fileURLWithPath:filePath];</span><br><span class=\"line\">    <span class=\"type\">AVAudioFile</span> <span class=\"operator\">*</span> audioFile <span class=\"operator\">=</span> [[<span class=\"type\">AVAudioFile</span> alloc] initForWriting:url settings:@&#123;&#125; error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.recordFileUrl <span class=\"operator\">=</span> url;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitReverb</span> <span class=\"operator\">*</span> reverd <span class=\"operator\">=</span> [[<span class=\"type\">AVAudioUnitReverb</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    reverd.wetDryMix <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">    [reverd loadFactoryPreset:<span class=\"type\">AVAudioUnitReverbPresetLargeRoom</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.engine attachNode:reverd];</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.engine attachNode:_mixer];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.engine connect:<span class=\"keyword\">self</span>.engine.inputNode to:reverd format:audioFile.processingFormat];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.engine connect:reverd to:_mixer format:audioFile.processingFormat];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.engine connect:_mixer to:<span class=\"keyword\">self</span>.engine.outputNode format:audioFile.processingFormat];</span><br><span class=\"line\"></span><br><span class=\"line\">    [_mixer installTapOnBus:<span class=\"number\">0</span> bufferSize:<span class=\"number\">4096</span> format:[_engine.inputNode inputFormatForBus:<span class=\"type\">AVAudioPlayerNodeBufferLoops</span>] block:<span class=\"operator\">^</span>(<span class=\"type\">AVAudioPCMBuffer</span> <span class=\"operator\">*</span> _Nonnull buffer, <span class=\"type\">AVAudioTime</span> <span class=\"operator\">*</span> _Nonnull when) &#123;</span><br><span class=\"line\">        [audioFile writeFromBuffer:buffer error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">        <span class=\"type\">NSLog</span>(@<span class=\"string\">&quot;我录制到的数据是 === %@&quot;</span>, buffer);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.engine startAndReturnError:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>通过如上方法可以完整的实现清唱功能，但是唱吧清唱使用的是 AudioUnit，AudioUnit 是 iOS 中音频的非常底层的实现，由 C 语言实现，因为唱吧中除了清唱之外还有很多非常复杂的音频处理功能，所以只有 AudioUnit 可以满足，但是对于清唱这个功能来说，两种实现方式达到了同样的效果，本文介绍的更加轻量级，不过关于 AudioUnit 也正在学习过程，后续会输出相应的文章。</p>\n",
            "tags": [
                "音频",
                "唱吧",
                "K歌",
                "AVFoundation"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-05-08-RX-Swift-Study-One/",
            "url": "https://oliverqueen.cn/2018-05-08-RX-Swift-Study-One/",
            "title": "关于RxSwift的一点理解",
            "date_published": "2018-05-08T02:12:00.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"hello-rxswift\"><a class=\"anchor\" href=\"#hello-rxswift\">#</a> Hello RxSwift!</h2>\n<p>这本书可以让你用 Swift 来编写响应式编程代码。但是到底什么是 RxSwift, 这里有很好的定义：</p>\n<p>&lt;font color=orange&gt;RxSwift 是由可被观察的事件的异步队列和可操作的功能性的运算符组成的库，并且他可以由调度者通过参数的方式进行调度。&lt;/font&gt; &lt;br&gt;</p>\n<p><img data-src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1525870736284&amp;di=9f373001bac8687d5fe11b3d7b40016f&amp;imgtype=0&amp;src=http%3A%2F%2Fcode4app.com%2Fdata%2Fattachment%2Fforum%2F201703%2F21%2F210007p6wy7buzq6hqhhdu.png\" alt=\"\" /></p>\n<p>听起来很复杂？其实不用担心，因为无论是你编写响应式编程，还是理解他们背后的思想和一些相关的东西，官方通常都是用一些很吓人的术语来解释。尤其是当你第一次接触，或者是之前从未有人向你介绍过这些的时候，你就会觉得很可怕。</p>\n<p><span id=\"more\"></span></p>\n<p>本书的目标就是带你逐步的去理解 RxSwift 的 API，并且去运用每一个 API，然后把它们运用到实际的 iOSApp 中。</p>\n<p>你将会从 RxSwift 中最基本的功能开始，然后循序渐进的由中级到高级。花一些时间去广泛的理解里面的概念，这样以来读完本书后你就会精通 RxSwift 额思想和使用。其实 Rx 是非常广的话题，以至于不能单单通过这一本书来讲完，因此我们通过这本书让你对 RX 有一个坚实的了解，这样你就能继续提高自己的 Rx 水平了</p>\n<p>其实我们并没有非常确信 RxSwift 的思想是什么，让我们在这个章节里面通过几个简单的例子来帮助我们理解响应式编程。</p>\n<p>&lt;font color=orange&gt;RxSwift 本质其实就是当你的数据或者对象发生变化时候他会把这个变化放在一个单独的管道 (队列) 里面，以此来达到简化异步并发的过程的目的 &lt;/font&gt;&lt;br&gt;</p>\n<p>这里打个比方一个按钮我点击了就会触发一个时间 那么我每点击一次就会生成一个 Action 我们用一个管道去装在这些 Action，每加一个 Action 就会把他放管道里面，我们可以理解为管道里面流动的 Actions，且管道与管道之间相互独立。同理我们可以吧 Button 改成一个 UITExtField，Action 就是每一次输入事件。</p>\n<p>作为一个 iOS 的开发者我相信这已经很好帮你去理解什么是 RxSwift 了吧，这应该是比你在一开始看到的那些专业术语好理解的多。</p>\n<p>如果你还是不清楚，那么你至少应该理解，RxSwift 可以很轻松的帮你编写异步操作的代码，你要知道编写异步操作的代码是比较难的，所以所任何一点点的帮助都是受大家所欢迎的。</p>\n<h3 id=\"异步编程的介绍\"><a class=\"anchor\" href=\"#异步编程的介绍\">#</a> 异步编程的介绍</h3>\n<p>如果你想用一种通俗简单的语言来描述异步编程，比如你在做一个 iSO 的 App，那么你一定想到如下几个东西：</p>\n<ul>\n<li>\n<p>接受 Button 的点击事件</p>\n</li>\n<li>\n<p>当 text field 的 Action 和键盘的弹出和收起动画之间的关系</p>\n</li>\n<li>\n<p>从网上下载大图片</p>\n</li>\n<li>\n<p>往硬盘里面存数据</p>\n</li>\n<li>\n<p>播放视频</p>\n</li>\n</ul>\n<p>以上的所有东西看似是发生在同一时刻其实真的是吗？我们思考一个问题：比如你在看视频，这时候你点击了 textfield 弹出键盘，大家都知道键盘由下往上弹出是有一个动画的，就算键盘已经出现到了屏幕上，只要动画没有做完你的视频就不会暂停，真的是这样吗，内部又是如何实现的？如下图:</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1fr41y6xhkij31kw0q0h80.jpg\" alt=\"\" /></p>\n<p>程序里面不同的部分不会阻塞彼此的执行，iOS 提供了几种 API，通过多核 CPU 来在不同的线程上进行不同的工作。</p>\n<p>其实编写真正并行的代码其实是很复杂的，打个比方假如两个线程同时访问同一个资源，就会产生资源争夺的问题，比如谁先访问，谁后访问。</p>\n<h3 id=\"uikit中的一些异步的api\"><a class=\"anchor\" href=\"#uikit中的一些异步的api\">#</a> UIKit 中的一些异步的 API</h3>\n<p>苹果在 iOS SDK 中提供了很多 api，帮助你编写异步代码。你在你的项目中使用过这些但是可能还没有考虑过它们，因为它们是编写移动应用程序的基础。毕竟苹果爸爸封装好的，我们拿来用就好了，干嘛想那么多。</p>\n<p>你一定用过以下几点</p>\n<ul>\n<li>\n<p>NotificationCenter</p>\n</li>\n<li>\n<p>delegate</p>\n</li>\n<li>\n<p>Grand Central Dispatch(GCD)</p>\n</li>\n<li>\n<p>Closures（Block）</p>\n</li>\n</ul>\n<p>由于大部分的类都是异步的，并且 UI 在内部也是异步的，所以很难去猜测整个程序的执行顺序，因此你的 APp 会因为一些外部的原因而表现不同，比如用户的输入不同、网络环境的不同、或者一些其他的东西。用户每次在打开你的 APp 其实代码的执行顺序都是不同的 (当然除了一些自动化测试的场景，那些条件都是预先设置好的。)</p>\n<p>其实写好异步代码并不是绝对不可能的，毕竟苹果给我提供了非常强大的 API，相比较于其他平台这要好很多。不过问题在于编写复杂的异步代码很难，部分原因是因为苹果给我们提供了大量的 SDK，而且他们并不统一。如果使用 delegate 我们需要遵循特制的格式，block，NotificationCenter 等等都是这样的，所以并没有一种通用的、贯穿所有异步方法的 API，这样就导致读懂并且书写这样的异步代码很难。可以看下下图:</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1fr4342v718j31kw0nlgzj.jpg\" alt=\"\" /></p>\n<p>我们来比较两个代码片段来总结下这章。一个是异步一个是同步。</p>\n<h4 id=\"同步代码\"><a class=\"anchor\" href=\"#同步代码\">#</a> 同步代码</h4>\n<p>对数组的每个元素进行操作你应该很熟悉了吧，其实就是循环遍历嘛。这是一个非常简单而又坚实的功能，因为它保证了两件事:</p>\n<ul>\n<li>\n<p>它是同步执行的。</p>\n</li>\n<li>\n<p>在循环遍历时候他是不可变的</p>\n</li>\n</ul>\n<p>花点时间想想这意味着什么。当你遍历一个数组的时候，你不需要检查所有的元素是否仍然存在，并且您不需要重新返回，以防另一个线程在集合的开始插入一个元素。您假定您总是在循环的开始时遍历整个集合。试试以下代码:</p>\n<p><figure class=\"highlight smali\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var<span class=\"built_in\"> array </span>= [1, 2, 3]</span><br><span class=\"line\">for number in<span class=\"built_in\"> array </span>&#123;</span><br><span class=\"line\">  print(number)</span><br><span class=\"line\"> <span class=\"built_in\"> array </span>= [4, 5, 6]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">print(array)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 最后的输出结果：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1fr43rz56omj304p02at8i.jpg\" alt=\"\" /></p>\n<p>数组在 for 循环中是不可变的吗？执行顺序是什么？</p>\n<h4 id=\"异步代码\"><a class=\"anchor\" href=\"#异步代码\">#</a> 异步代码</h4>\n<p>再考虑一个类似的代码，如下用户通过点击事件触发下面代码，每次点击都会输出数组下一个元素，然后用户重复点击直到把数组所有的元素输出完成：<br />\n<figure class=\"highlight smali\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var<span class=\"built_in\"> array </span>= [1, 2, 3]</span><br><span class=\"line\">var currentIndex = 0</span><br><span class=\"line\"></span><br><span class=\"line\">//this method is connected in IB to a button</span><br><span class=\"line\">@IBAction func printNext(_ sender: Any) &#123;</span><br><span class=\"line\">  print(array[currentIndex])</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"built_in\"> if </span>currentIndex != array.count-1 &#123;</span><br><span class=\"line\">    currentIndex += 1</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 试想一下如果放在我们现实的 App 中真的可以这么执行吗？这个可说不准，因为如果在用户的两次点击之间又有其他的线程对这个数组进行了操作 (增加、删除元素) 那么数据就会发生错乱。而且如果 currentIndex 被另一个线程改变了那么你也不会得到预期的结果。</p>\n<p>其实多线程最重要的就是数据争夺的问题，然而 RxSwift 很好的解决了这个问题</p>\n",
            "tags": [
                "Swift"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-03-30-AlamoFire/",
            "url": "https://oliverqueen.cn/2018-03-30-AlamoFire/",
            "title": "AlamoFire的使用(下载队列，断点续传)",
            "date_published": "2018-03-30T09:54:38.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>最近开始做了一个新项目，几乎没有时间来写自己的博客，大部分都在写 feature（BUG），自己研究的东西很少，本来之前说好每个月要写两篇文章也没能坚持下来，最近在项目中遇到了一些问题，就在这里总结下吧。一些小的技巧而已，大神可以忽略了。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Alamofire/Alamofire/master/alamofire.png\" alt=\"\" /><br />\n<span id=\"more\"></span></p>\n<h2 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景</h2>\n<p>新项目包含了上传下载网络请求相关功能，由于是 swift 编写所以自然而然选择了 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FsYW1vZmlyZS9BbGFtb2ZpcmU=\">AlamoFire</span> (好像也没得选) 来做底层，正常的网络请求 post、get 等都是直接傻瓜式调用 AlamoFire 的接口，本文主要将一些细节问题</p>\n<h2 id=\"设置通用超时时间\"><a class=\"anchor\" href=\"#设置通用超时时间\">#</a> 设置通用超时时间</h2>\n<p>使用 Alamofire 发起请求时候有这两个接口</p>\n<p><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Creates a `DataRequest` using the default `SessionManager` to retrieve the contents of the specified `url`,</span></span><br><span class=\"line\"><span class=\"comment\">/// `method`, `parameters`, `encoding` and `headers`.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - parameter url:        The URL.</span></span><br><span class=\"line\"><span class=\"comment\">/// - parameter method:     The HTTP method. `.get` by default.</span></span><br><span class=\"line\"><span class=\"comment\">/// - parameter parameters: The parameters. `nil` by default.</span></span><br><span class=\"line\"><span class=\"comment\">/// - parameter encoding:   The parameter encoding. `URLEncoding.default` by default.</span></span><br><span class=\"line\"><span class=\"comment\">/// - parameter headers:    The HTTP headers. `nil` by default.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - returns: The created `DataRequest`.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">request</span>(<span class=\"keyword\">_</span> <span class=\"params\">url</span>: <span class=\"type\">URLConvertible</span>, <span class=\"params\">method</span>: <span class=\"type\">Alamofire</span>.<span class=\"type\">HTTPMethod</span> <span class=\"operator\">=</span> <span class=\"keyword\">default</span>, <span class=\"params\">parameters</span>: <span class=\"type\">Parameters</span>? <span class=\"operator\">=</span> <span class=\"keyword\">default</span>, <span class=\"params\">encoding</span>: <span class=\"type\">ParameterEncoding</span> <span class=\"operator\">=</span> <span class=\"keyword\">default</span>, <span class=\"params\">headers</span>: <span class=\"type\">HTTPHeaders</span>? <span class=\"operator\">=</span> <span class=\"keyword\">default</span>) -&gt; <span class=\"type\">Alamofire</span>.<span class=\"type\">DataRequest</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Creates a `DataRequest` using the default `SessionManager` to retrieve the contents of a URL based on the</span></span><br><span class=\"line\"><span class=\"comment\">/// specified `urlRequest`.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - parameter urlRequest: The URL request</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - returns: The created `DataRequest`.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">request</span>(<span class=\"keyword\">_</span> <span class=\"params\">urlRequest</span>: <span class=\"type\">URLRequestConvertible</span>) -&gt; <span class=\"type\">Alamofire</span>.<span class=\"type\">DataRequest</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 而我们在调用的时候通常会直接这么用</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> req : URLRequest = <span class=\"constructor\">URLRequest(<span class=\"params\">url</span>: URL(<span class=\"params\">fileURLWithPath</span>: <span class=\"string\">&quot;32&quot;</span>)</span>, cachePolicy: .useProtocolCachePolicy, timeoutInterval: <span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第一种方法调用，后面参数直接用default</span></span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Alamofire</span>.</span></span>request(<span class=\"constructor\">URL(<span class=\"params\">fileURLWithPath</span>: <span class=\"string\">&quot;32&quot;</span>)</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第二中调用，使传入request</span></span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Alamofire</span>.</span></span>request(req)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> semaphore = <span class=\"constructor\">DispatchSemaphore(<span class=\"params\">value</span>: 0)</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>其中第一种方法我们不能传入超时时间，第二中方法我们可以通过传入的 URLRequest 来设置超时时间，但是我们通常一个项目中大部分的请求，可能除了某些特殊的下载请求之外所有的超时时间都是一样的，这样的话我们需要同样的代码写好多遍，这个时候有两个办法</p>\n<ul>\n<li>\n<p>对生成 Request 的方法做一个封装，通用的参数如超时时间、header、请求方式 写死在方法里面，对于会变动的参数如 URL 和可以通过参数传入.</p>\n</li>\n<li>\n<p>创建  <code>Alamofire.SessionManager</code>  通过 sessionManager 来设置超时时间等一些通用的东西</p>\n</li>\n</ul>\n<p><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> networkManager : SessionManager = &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">config</span> : URLSessionConfiguration = URLSessionConfiguration<span class=\"variable\">.default</span></span><br><span class=\"line\">        <span class=\"keyword\">config</span><span class=\"variable\">.timeoutIntervalForRequest</span> = <span class=\"number\">10</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> manager = Alamofire<span class=\"variable\">.SessionManager</span><span class=\"variable\">.init</span>(configuration: <span class=\"keyword\">config</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> manager</span><br><span class=\"line\">    &#125;()</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"断点续传\"><a class=\"anchor\" href=\"#断点续传\">#</a> 断点续传</h2>\n<p>Alamofire 支持断点续传下载，原理就是将下载一半的数据保存到本地，然后下次再启动时候通过 data 的拼接来进行继续下载。用法也很简单，只是调用接口而已，关键是看开发者如何自己去维护这个已下载的数据，比如是存内存还是存硬盘，要存多久，淘汰策略是什么之类的。其实就是两个步骤， 断点和续传</p>\n<h4 id=\"第一步-断点\"><a class=\"anchor\" href=\"#第一步-断点\">#</a> 第一步 断点</h4>\n<p>监听下载中断，中断后将已经下载的数据进行保留，我这边用一个属性来存，具体到项目实现大家可以采用自己存储方式，存到硬盘或者数据库之类的</p>\n<p><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Alamofire<span class=\"selector-class\">.download</span>(<span class=\"string\">&quot;http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4&quot;</span>, method: <span class=\"selector-class\">.get</span>, parameters: nil, encoding: URLEncoding<span class=\"selector-class\">.default</span>, headers: nil) &#123; (url, response) -&gt; (destinationURL: URL, options: DownloadRequest.DownloadOptions) <span class=\"keyword\">in</span></span><br><span class=\"line\">            return (<span class=\"built_in\">URL</span>(fileURLWithPath: <span class=\"built_in\">String</span>(describing : <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"selector-class\">.documentDirectory</span>, <span class=\"selector-class\">.userDomainMask</span>, false)<span class=\"selector-attr\">[0]</span>+<span class=\"string\">&quot;123.mp4&quot;</span>)), <span class=\"selector-attr\">[.createIntermediateDirectories, .removePreviousFile]</span>)</span><br><span class=\"line\">            &#125;<span class=\"selector-class\">.responseJSON</span> &#123; (response) <span class=\"keyword\">in</span></span><br><span class=\"line\"></span><br><span class=\"line\">                switch response<span class=\"selector-class\">.result</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                case <span class=\"selector-class\">.success</span>:</span><br><span class=\"line\">                    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;success&quot;</span>)</span><br><span class=\"line\">                case <span class=\"selector-class\">.failure</span>:</span><br><span class=\"line\">                    <span class=\"comment\">//意外中断后在此处处理下载完成的部分</span></span><br><span class=\"line\">                    self<span class=\"selector-class\">.tmpData</span> = response<span class=\"selector-class\">.resumeData</span></span><br><span class=\"line\"></span><br><span class=\"line\">                default:</span><br><span class=\"line\">                    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;failed&quot;</span>)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"第二步-续传\"><a class=\"anchor\" href=\"#第二步-续传\">#</a> 第二步 续传</h4>\n<p>当下载再次启动时候，需要在上一步数据的基础上继续下载，我们调用 Alamofire 这个方法<br />\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Creates a `DownloadRequest` using the default `SessionManager` from the `resumeData` produced from a</span></span><br><span class=\"line\"><span class=\"comment\">/// previous request cancellation to retrieve the contents of the original request and save them to the `destination`.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// If `destination` is not specified, the contents will remain in the temporary location determined by the</span></span><br><span class=\"line\"><span class=\"comment\">/// underlying URL session.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// On the latest release of all the Apple platforms (iOS 10, macOS 10.12, tvOS 10, watchOS 3), `resumeData` is broken</span></span><br><span class=\"line\"><span class=\"comment\">/// on background URL session configurations. There&#x27;s an underlying bug in the `resumeData` generation logic where the</span></span><br><span class=\"line\"><span class=\"comment\">/// data is written incorrectly and will always fail to resume the download. For more information about the bug and</span></span><br><span class=\"line\"><span class=\"comment\">/// possible workarounds, please refer to the following Stack Overflow post:</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">///    - http://stackoverflow.com/a/39347461/1342462</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - parameter resumeData:  The resume data. This is an opaque data blob produced by `URLSessionDownloadTask`</span></span><br><span class=\"line\"><span class=\"comment\">///                          when a task is cancelled. See `URLSession -downloadTask(withResumeData:)` for additional</span></span><br><span class=\"line\"><span class=\"comment\">///                          information.</span></span><br><span class=\"line\"><span class=\"comment\">/// - parameter destination: The closure used to determine the destination of the downloaded file. `nil` by default.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - returns: The created `DownloadRequest`.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">download</span>(<span class=\"params\">resumingWith</span> <span class=\"params\">resumeData</span>: <span class=\"type\">Data</span>, <span class=\"params\">to</span> <span class=\"params\">destination</span>: <span class=\"type\">Alamofire</span>.<span class=\"type\">DownloadRequest</span>.<span class=\"type\">DownloadFileDestination</span>? <span class=\"operator\">=</span> <span class=\"keyword\">default</span>) -&gt; <span class=\"type\">Alamofire</span>.<span class=\"type\">DownloadRequest</span></span><br></pre></td></tr></table></figure><br />\n 这个接口需要我们传入已存在的数据，然后基于我们传入的数据进行下载，它支持从新指定目的地路径，如果你有需要可以重新指定<br />\n <figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Alamofire.download(resumingWith: tmpData!)</span><br></pre></td></tr></table></figure><br />\n 同样他返回一个 request 的对象，我们可以通过点语法来拿到进度、response 等信息</p>\n<h2 id=\"批量下载\"><a class=\"anchor\" href=\"#批量下载\">#</a> 批量下载</h2>\n<p>当我们需要同时下载很多东西的时候，往往需要我们自己维护一个下载队列，比如下一个载素材列表之类的。Alamo 给我们提供了下载的接口，但是下载的线程队列需要我们自己去维护，其实就是一个多线程并发队列。</p>\n<h4 id=\"gcd\"><a class=\"anchor\" href=\"#gcd\">#</a> GCD</h4>\n<p>我们很自然而然的想到 GCD，但是 GCD 有一个问题无法控制最大并发数，而且对队列的管理也并不完善，比如我们要下载 100 个文件，如果同时下载的话开辟 100 个线程，那肯定是不行的，先不说移动设备是否支持 (最多 70 个左右)，即使支持了那这个开销太大。虽说 GCD 的话可以使用信号量进行线程控制，但是每个线程的暂停启动之类的又是问题，而且毕竟是曲线救国的方法。</p>\n<h4 id=\"operationqueue\"><a class=\"anchor\" href=\"#operationqueue\">#</a> OperationQueue</h4>\n<p>Operation 及 OperationQueue 是基于 GCD 封装的对象，作为对象可以提供更多操作选择，可以用方法或 block 实现多线程任务，同时也可以利用继承、类别等进行一些其他操作；但同时实现代码相对复杂一些。但是他毕竟不像 GCD 那样使用 C 语言实现，所以效率会相比 GCD 低一些。但是对线程的控制的灵活性要远高于 GCD，对于下载线程来说可以优先选择这个。</p>\n<h4 id=\"实现\"><a class=\"anchor\" href=\"#实现\">#</a> 实现</h4>\n<p>我们把每一个下载任务封装成一个 operation。注意 Operation 不能直接使用，我们需要使用他的子类，这里我选择使用  <code>BlockOperation</code>  他的闭包则是需要执行的下载任务，然后我们把他添加进 queue 中便开始执行了任务</p>\n<p><figure class=\"highlight roboconf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let op : BlockOperation = BlockOperation &#123; [<span class=\"attribute\">weak self] in</span></span><br><span class=\"line\"><span class=\"attribute\">            Alamofire.download(&quot;http</span>://clips<span class=\"variable\">.vorwaerts-gmbh</span><span class=\"variable\">.de</span>/big_buck_bunny<span class=\"variable\">.mp</span>4&quot;, method: <span class=\"variable\">.get</span>, parameters: nil, encoding: URLEncoding<span class=\"variable\">.default</span>, headers: nil) &#123; (url, response) -&gt; (destinationURL: URL, options: DownloadRequest<span class=\"variable\">.DownloadOptions</span>) in</span><br><span class=\"line\">                return (URL(fileURLWithPath: String(describing : NSSearchPathForDirectoriesInDomains(<span class=\"variable\">.documentDirectory</span>, <span class=\"variable\">.userDomainMask</span>, false)[0]+&quot;123<span class=\"variable\">.mp</span>4&quot;)), [<span class=\"variable\">.createIntermediateDirectories</span>, <span class=\"variable\">.removePreviousFile</span>])</span><br><span class=\"line\">                &#125;<span class=\"variable\">.downloadProgress</span> &#123; [weak self] (pro) in</span><br><span class=\"line\">                    let percent = Float(pro<span class=\"variable\">.completedUnitCount</span>) / Float(pro<span class=\"variable\">.totalUnitCount</span>)</span><br><span class=\"line\">                    if count == 0 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                        self?<span class=\"variable\">.downLoadLabel</span><span class=\"variable\">.snp</span><span class=\"variable\">.remakeConstraints</span> &#123; (make) in</span><br><span class=\"line\">                            make<span class=\"variable\">.width</span><span class=\"variable\">.equalTo</span>(300 * percent)</span><br><span class=\"line\">                            make<span class=\"variable\">.height</span><span class=\"variable\">.equalTo</span>(30)</span><br><span class=\"line\">                            make<span class=\"variable\">.top</span><span class=\"variable\">.equalTo</span>((self?<span class=\"variable\">.stopButton</span><span class=\"variable\">.snp</span><span class=\"variable\">.bottom</span>)!)<span class=\"variable\">.offset</span>(30)</span><br><span class=\"line\">                            make<span class=\"variable\">.left</span><span class=\"variable\">.equalToSuperview</span>()<span class=\"variable\">.offset</span>(30)</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; else &#123;</span><br><span class=\"line\">                        self?<span class=\"variable\">.downLoadLabel</span>2<span class=\"variable\">.snp</span><span class=\"variable\">.remakeConstraints</span> &#123; (make) in</span><br><span class=\"line\">                            make<span class=\"variable\">.width</span><span class=\"variable\">.equalTo</span>(300 * percent)</span><br><span class=\"line\">                            make<span class=\"variable\">.height</span><span class=\"variable\">.equalTo</span>(30)</span><br><span class=\"line\">                            make<span class=\"variable\">.top</span><span class=\"variable\">.equalTo</span>((self?<span class=\"variable\">.downLoadLabel</span><span class=\"variable\">.snp</span><span class=\"variable\">.bottom</span>)!)<span class=\"variable\">.offset</span>(30)</span><br><span class=\"line\">                            make<span class=\"variable\">.left</span><span class=\"variable\">.equalToSuperview</span>()<span class=\"variable\">.offset</span>(30)</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;<span class=\"variable\">.responseJSON</span> &#123; (response) in</span><br><span class=\"line\"></span><br><span class=\"line\">                    switch response<span class=\"variable\">.result</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    case <span class=\"variable\">.success</span>:</span><br><span class=\"line\">                        print(&quot;success&quot;)</span><br><span class=\"line\">                    case <span class=\"variable\">.failure</span>:</span><br><span class=\"line\">                        self?<span class=\"variable\">.tmpData</span> = response<span class=\"variable\">.resumeData</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    default:</span><br><span class=\"line\">                        print(&quot;failed&quot;)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        queue<span class=\"variable\">.addOperation</span>(op)</span><br></pre></td></tr></table></figure><br />\n 每一个 opeeation 对象我们都可以设置他的优先级、启动、暂停、等属性，简单的调用接口就可以，在此就不一一作解释了。然后我们需要对我们的 queue 进行设置，我们设置最大并发数，大家可以根据实际情况来设置，demo 中我只有两个下载任务，所以我就设置最大并发数为 1 这样就是一个一个下载。<br />\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"built_in\">queue</span> : OperationQueue = &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> que : OperationQueue = OperationQueue()</span><br><span class=\"line\">        que.maxConcurrentOperationCount = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> que</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 我们运行然后点击开始下载</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fpw0vlzbp6g308h0gnkjm.gif\" alt=\"\" /></p>\n<p>很奇怪我们发现他还是同时下载，我们又试了其他的个数，无论多少都是同时下载，最大线程数量完全不起作用，再反过来看下上面加入 queue 的任务。正常来说每一个 operation 都要等上一个 operation 完成后才会执行，而系统判断完成的标准就是上一个 operation 的闭包走完，我们闭包中放入的是一个下载任务，而 Alamofire 的下载都是异步执行，所以导致 operation 的闭包走完了，但是其实下载是异步在另一个线程执行的，实际上下载没有完成，知道原因我们对症下药，只需要保证 operation 闭包中的代码是同步执行的就 OK 了。而 Alamofire 是基于 URLSession 来实现的，并没有像 connection 那样提供同步的方法，所以我们使用信号量卡一下，像这样</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fpw1444jp0j31610qbgrr.jpg\" alt=\"\" /></p>\n<p>这样之后就会按照我们设置好的队列进行了</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fpw15riwhjg308h0gnb2i.gif\" alt=\"\" /></p>\n<p>有人会说下载同步进行会不会有影响，其实不会的首先我们实现同步的方式是信号量，本质上还是异步的只是我们阻塞的当前的下载线程，这个被阻塞线程一定不是主线程 (除非 Alamofire 的开发者把他回调到主线程下载，这个基本不可能)，而且当我们把这个下载任务加到一个 operation 中之后，就注定不会在主线程中了，没一个 operation 都会被系统分配到一个非主线程的地方去做，所以这样不会性能有任何影响。</p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>因为时间紧迫，暂时做了这么多，也遇到了这些问题，所以写出了总结下，本文还会继续更新，会慢慢的整个网络层分享出来。就是可能更新会慢，毕竟工作量有点饱和。多谢关注</p>\n<p>\n        <div id=\"aplayer-bwMrXBRX\" class=\"aplayer aplayer-tag-marker\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t  <script>\n\t\t\t\t  var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":0,\"mutex\":true,\"music\":[{\"title\":\"Thank You Very Much\",\"author\":\"Margaret\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/Thankyou.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M000000VbGX83hRicw.jpg?max_age=2592000\",\"lrc\":\"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=001Ii3g54dIYpO\"}]};\n\t\t\t\t  options.element = document.getElementById(\"aplayer-bwMrXBRX\");\n\t\t\t\t  var ap = new APlayer(options);\n\t\t\t    window.aplayers || (window.aplayers = []);\n\t\t\t\t  window.aplayers.push(ap);\n\t\t\t  </script></p>\n",
            "tags": [
                "swift",
                "网络请求"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-03-14-Simple-HotFix-Mtehod/",
            "url": "https://oliverqueen.cn/2018-03-14-Simple-HotFix-Mtehod/",
            "title": "简单的iOS线上热修复方案",
            "date_published": "2018-03-14T06:04:46.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"向大佬致敬\"><a class=\"anchor\" href=\"#向大佬致敬\">#</a> 向大佬致敬</h2>\n<p>总是喜欢把参考资料、致谢等写在文章最前面，毕竟是站在人家的肩膀上，向大佬致敬，写这篇文章的也是参考他的 然后加上一些自己的思考，主要目的还是自己再写一遍 Demo 和文档，以便加深记忆，也帮助自己更好的理解，有句话说：看懂的东西不一定就是学会了，自己能在不看资料的前提下写出来才算是略知一二。<br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fpcbkfx1z9j319e0kkdmp.jpg\" alt=\"\" /></p>\n<p>以下是 ** <span class=\"exturl\" data-url=\"aHR0cDovL2xpbWJveS5tZS90ZWNoLzIwMTgvMDMvMDQvaW9zLWxpZ2h0d2VpZ2h0LWhvdGZpeC5odG1s\">原文链接</span><strong>有兴趣的还可以看下</strong><span class=\"exturl\" data-url=\"aHR0cDovL2xpbWJveS5tZS8=\">大佬博客</span> **<br />\n<span id=\"more\"></span></p>\n<h2 id=\"工作原理分析\"><a class=\"anchor\" href=\"#工作原理分析\">#</a> 工作原理分析</h2>\n<p>要实现热修复其实原理就是我们可以动态的修改代码，在方法前、中、后插入自己想要的东西或者代码。其实这个需求并不难，iOS 的运行时机制可以满足我们的这个要求，但是如果是已经上架了的 APP, 已经打成了 Ipa 包我们该如何修改呢？这里就需要服务端去控制，通过下发不同的内容来达到我们想要的目的，但是这里有一个要求，服务端所下发的内容并不能是任意的，而是要通过下发的内容调起我们 App 内的 RunTime 机制然后进行偷梁换柱。满足这个要求的数据格式只有字符串化的 JS 代码，因为我们知道在 iOS 中 JS 代码是可以调用 OC 的代码。综上所述打到热修复整套流程所需的技术如下：</p>\n<ul>\n<li>\n<p>Runtime：</p>\n<p>可以在本站搜索 Runtime 关键字找到 Runtime 相关资料</p>\n</li>\n<li>\n<p>与服务器交互：</p>\n<p>现在大部分 APP 都具有于服务端交互的能力，就是我们常说的网络请求 AFNetWorking 等</p>\n</li>\n<li>\n<p>JS 与 OC 交互：</p>\n<p>大家可以参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9kMTk2ODllMGVkODM=\">这篇文章</span>，主要参考方式二，使用 JavaScriptCore 进行交互</p>\n</li>\n</ul>\n<p>进行了上述操作后每次用户启动，App 都会进行如下操作</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fpcce8vzimj30vg0t0wva.jpg\" alt=\"\" /></p>\n<p>这样一来如果开发在项目发布出去后发现有 Crash 那么可以立即通过服务器下发 JS 代码来制定 APp 每次执行新方法 (新方法的定义也是在下发的 JS 代码中)，可以避免一些问题。</p>\n<h2 id=\"实际使用\"><a class=\"anchor\" href=\"#实际使用\">#</a> 实际使用</h2>\n<h4 id=\"第三方\"><a class=\"anchor\" href=\"#第三方\">#</a> 第三方</h4>\n<p>这里用到一个第三方库<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3N0ZWlwZXRlL0FzcGVjdHM=\"> Aspects</span> 这个库可以理解为一个 iOS 中的 Runtime 库，我们不用写繁琐的代码，直接调用他的接口即可，</p>\n<p><figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class=\"line\">                           withOptions:(AspectOptions)options</span><br><span class=\"line\">                            usingBlock:(<span class=\"built_in\">id</span>)block</span><br><span class=\"line\">                                 <span class=\"keyword\">error</span>:(NSError **)<span class=\"keyword\">error</span>;</span><br></pre></td></tr></table></figure></p>\n<p>其中的枚举就是选择我们要插入方法的位置，其中包含</p>\n<p><figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_OPTIONS</span>(<span class=\"type\">NSUInteger</span>, <span class=\"type\">AspectOptions</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">AspectPositionAfter</span>   = 0,            /// <span class=\"type\">Called</span> after the original implementation (default)</span><br><span class=\"line\">    <span class=\"type\">AspectPositionInstead</span> = 1,            /// <span class=\"type\">Will</span> replace the original implementation.</span><br><span class=\"line\">    <span class=\"type\">AspectPositionBefore</span>  = 2,            /// <span class=\"type\">Called</span> before the original implementation.</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">AspectOptionAutomaticRemoval</span> = 1 &lt;&lt; 3 /// <span class=\"type\">Will</span> remove the hook after the first execution.</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 这个库据说是对上线没有影响。</p>\n<h4 id=\"配置工程\"><a class=\"anchor\" href=\"#配置工程\">#</a> 配置工程</h4>\n<p>用实际代码来证明下，这是我 Controller 中的一个代码，很明显会产生数组越界的 Crash，假如我们在上线后才发现了这个问题，这时候需要修复</p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;ViewController.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> crashMethod:<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)crashMethod:(<span class=\"built_in\">NSInteger</span>)argument</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argument == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSArray</span> * arr = @[<span class=\"string\">@&quot;1&quot;</span>];</span><br><span class=\"line\">        [arr objectAtIndex:<span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)didReceiveMemoryWarning &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> didReceiveMemoryWarning];</span><br><span class=\"line\">    <span class=\"comment\">// Dispose of any resources that can be recreated.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 导入上面说的那个第三方.h 和.m 然后自己建立一个桥接类，用来处理 JS 和 O 的交互，大概的结构就是这样</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fpcdbh9ahbj307k0duwfd.jpg\" alt=\"\" /></p>\n<p>其中交互类中暴露出如下接口</p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;Aspects.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;JavaScriptCore/JavaScriptCore.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Felix</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 初始化</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)fixIt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 开始执行JS代码</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param javascriptString 需要执行的JS</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)evalString:(<span class=\"built_in\">NSString</span> *)javascriptString;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>.m 文件的内容可以到大佬博客中参考这里不放出，不然篇幅太长。</p>\n<h4 id=\"开始使用\"><a class=\"anchor\" href=\"#开始使用\">#</a> 开始使用</h4>\n<p>因为我们最好用能控制代码里面的所有方法，所以我们要尽早的注册交互类，在 APpdelegate 中如下注册</p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Override point for customization after application launch.</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    [Felix fixIt];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *fixScriptString = <span class=\"string\">@&quot; \\</span></span><br><span class=\"line\"><span class=\"string\">    fixInstanceMethodReplace(&#x27;ViewController&#x27;, &#x27;crashMethod:&#x27;, function(instance, originInvocation, originArguments)&#123; \\</span></span><br><span class=\"line\"><span class=\"string\">    if (originArguments[0] == 0) &#123; \\</span></span><br><span class=\"line\"><span class=\"string\">    console.log(&#x27;crash！！！！！&#x27;); \\</span></span><br><span class=\"line\"><span class=\"string\">    &#125; else &#123; \\</span></span><br><span class=\"line\"><span class=\"string\">    runInvocation(originInvocation); \\</span></span><br><span class=\"line\"><span class=\"string\">    &#125; \\</span></span><br><span class=\"line\"><span class=\"string\">    &#125;); \\</span></span><br><span class=\"line\"><span class=\"string\">    \\</span></span><br><span class=\"line\"><span class=\"string\">    &quot;</span>;</span><br><span class=\"line\">    [Felix evalString:fixScriptString];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    如果是多个方法建议用循环执行</span></span><br><span class=\"line\"><span class=\"comment\">//    NSArray * hotFixStr = @[fixScriptString];</span></span><br><span class=\"line\"><span class=\"comment\">//    for (int i = 0; i &lt; hotFixStr.count; i ++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        [Felix evalString:hotFixStr[i]];</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 其中 JS 的代码就是我们所要修改的内容，可以看到当参数为 0 的时候输出 crash！！！然后不再继续执行了。实际项目中这段代码是由服务器动态返回的，如果我们要修改多个方法，就需要服务器返回 JS 字符串数组我们这边来进行循环处理即可。这时候在运行下代码不会崩溃，下面会输出一个 crash！！！！</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fpcdjfkqkmj30i4034t8s.jpg\" alt=\"\" /></p>\n<h2 id=\"思考\"><a class=\"anchor\" href=\"#思考\">#</a> 思考</h2>\n<p>这个方法相比较之前的 JSpatch 是非常轻量级的，而且也只是实现了简单的容错功能，并不能做一些复杂的操作，比如生成一个对象之类的，不过对于一般的控制已经可以满足了，毕竟在苹果爸爸这么严厉的管制下能有这样的方法也还不错啊。</p>\n<p>\n        <div id=\"aplayer-AtmiJQux\" class=\"aplayer aplayer-tag-marker\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t  <script>\n\t\t\t\t  var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":0,\"mutex\":true,\"music\":[{\"title\":\"不知归期的故人\",\"author\":\"房东的猫\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E4%B8%8D%E7%9F%A5%E5%BD%92%E6%9C%9F%E7%9A%84%E6%95%85%E4%BA%BA.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M000004NFJ230yX0Nz.jpg?max_age=2592000\",\"lrc\":\"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=000zreoj2VtcID\"}]};\n\t\t\t\t  options.element = document.getElementById(\"aplayer-AtmiJQux\");\n\t\t\t\t  var ap = new APlayer(options);\n\t\t\t    window.aplayers || (window.aplayers = []);\n\t\t\t\t  window.aplayers.push(ap);\n\t\t\t  </script></p>\n",
            "tags": [
                "热修复",
                "JSPath"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-02-12-At-The-End-Of-2017/",
            "url": "https://oliverqueen.cn/2018-02-12-At-The-End-Of-2017/",
            "title": "At The End Of 2017",
            "date_published": "2018-02-12T07:47:45.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>今天是 2017 年的最后一个工作日，准确的说是我最后一个工作日，公司的同事都走的差不多了，寥寥无几的办公室显得格外冷清，和安静，不过越是这样的环境越容易让我回忆、感慨，因此便有了这篇文章。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1fodqkq8305j31hc0u07fp.jpg\" alt=\"\" /></p>\n<p><span id=\"more\"></span></p>\n<p>我的一些朋友在元旦的时候就做了总结，而我选择在了这个时候，因为我觉得虽然是 12 月 31 日，但是我的工作并没有停止，旧的工作没有做完，新的工作还没时间规划，元旦也只是个小长假而已。虽然现在对于明年要做的事情也还是没有详细的定位，但是大致的方向应该算是有了。</p>\n<h2 id=\"辞旧\"><a class=\"anchor\" href=\"#辞旧\">#</a> 辞旧</h2>\n<p>只有辞旧才能迎新，说实话 2017 年收货真的不小，今年也是我在美图成长最快的一年。2016 年 6 月 12 日凌晨从北京匆匆赶来深圳，一天的时间紧紧张张，办了户口，办了社保转移之类的手续，下午又来到公司楼下踩点儿，防止第二天入职的时候找不到地方。13 号正式成为 Meitu 的一员，刚开始都是陌生的，也可以说是懵逼的，接触的东西多了就会发现自己欠缺的东西也多了，什么都想要学，从入职到 17 年其实都是在适应期，没有什么实质性的进步，不过真的是涨了见识，知道了很多东西。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1fodr6rjwo5j31kw0c5kjl.jpg\" alt=\"\" /></p>\n<p>记得来深圳之前一个前辈跟我说过：“当你去到一个新的城市一个新的公司大多数人都需要半年左右的适应期，适应期内会觉得和公司格格不入，各种不爽，等这一阶段过去了那就会突飞猛进。” 一开始我还不相信，但是现在真的知道了。半年的适应期过去了，2017 年逐渐步入正轨，这也是我在一开始说 2017 年是我个人成长最快的一年，不光是技术，还包括其他精神层面的一些东西。</p>\n<h4 id=\"学习相关\"><a class=\"anchor\" href=\"#学习相关\">#</a> 学习相关</h4>\n<h6 id=\"sdk\"><a class=\"anchor\" href=\"#sdk\">#</a> SDK</h6>\n<p>毕竟是做开发的，还是先从技术说起，这一年完成了 iOS 端的 DNS 解析耗时优化 SDK，也可以叫做 HttpDns。其实这个东西原理很简单 (这里就不在赘述，毕竟不是技术文章，想了解更多的可以在我的小站搜索 httpdns 字段)。但是做了很久，刚开始做的时候，我想应该是业内的前几名吧，我只看到过腾讯，阿里有过相关的文档，而阿里的也只是实现了简单的几个功能而已，腾讯的不开源，不过应该也不会有多深入。除此之外没有任何有用的文档，自己一点点摸索，一点点踩坑，项目接了好久都是有问题，也不稳定，那段时间真的很难，很痛苦。好在最后慢慢都克服了，当我把最终的文档放到网上，确实赢来了很多的阅读量，还被推上过头条，我想这就是对我付出努力的回报吧，着实很欣慰。唯一的遗憾就是由于涉及到一些业务的代码，无法做到开源。不过这将是我 2018 年的目标。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1fodsdsa6zkj30eq08ct8x.jpg\" alt=\"\" /></p>\n<h6 id=\"app\"><a class=\"anchor\" href=\"#app\">#</a> App</h6>\n<p>其实完整的 App 没有做，但是也主要维护了一个 App，刚接到代码看了下最早的代码是 2012 年，一些第三方库也比较老。老旧的代码，无法发挥新设备的性能，于是开始重构、优化，几年前写代码的人大部分离职了，只能自己看，看不懂了就用自己的方式重写。每次 App 上架后盯着崩溃的后台看，是否产生了新的问题、旧的问题是否修复，然后看 App Store 用户的评论，用户最关心什么，用户会产生哪些问题，都一一记录，修改，其实每当这个时候感觉还是挺幸福的，而且正好赶上 iPhone X 发布，新的屏幕适配早就做好了，就等着真机出来去看看，应该也是公司第一个完成适配的 App，虽然当时有些小问题还没有发现。后来看着产品越来越稳定心里也是很爽的。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1fodshg1fk6j31kw13hhdt.jpg\" alt=\"\" /></p>\n<h6 id=\"其他\"><a class=\"anchor\" href=\"#其他\">#</a> 其他</h6>\n<p>翻译过几篇文章、尽量保证每周在公司做一次技术分享 (感谢我的 leader 让我养成这个习惯)、建立了个人博客开始记录自己的生活、在一些技术论坛上有了属于自己的粉丝，不过我不是大佬，只是和大家沟通、讨论罢了。</p>\n<h4 id=\"生活相关\"><a class=\"anchor\" href=\"#生活相关\">#</a> 生活相关</h4>\n<h6 id=\"情感\"><a class=\"anchor\" href=\"#情感\">#</a> 情感</h6>\n<p>2017 年首先是换了一个工作的城市，其实是为了逃离北京的雾霾，也是为自己更好的发展，不得不承认南方的环境确实要比北方强一些，政府机关的办事效率也更高一些。三月份妹子为了我也来到了深圳，真的很感动，横跨了整个中国来找我，她虽然没什么怨言，但是我知道对于一个女孩子来说这意味着什么，有时候她开玩笑总是说我没有感情，其实我只是不善表达而已，作为一个军人家庭出身的孩子，我完美的受到了家庭的影响，说一不二，对她从来不惯，从来不哄，不能容忍她矫情，不能容忍她挑食，有时候严厉的真的像我的父亲对我一样，但是同样我也会对她绝对的忠诚，因为还是很爱她，不管以后如何，她已经是我生命中除了母亲之外最重要的人。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1fodsmhxyi2j31kw1c4qeh.jpg\" alt=\"\" /></p>\n<h6 id=\"旅游\"><a class=\"anchor\" href=\"#旅游\">#</a> 旅游</h6>\n<p>可能是因为沿海城市很方便的原因，这一年我们去了不少城市，走过不少地方，</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1fodt98c9ojj31kw0iab29.jpg\" alt=\"\" /></p>\n<p>其实还有很多地方，只是大部分照片没有传到 google 相册里，google 的相册我的初衷是用来保存 livephoto 的。那天看到妹子用一个本子记着我们一起去过的地方，我才发现我们走过不少地方。我当时想我可以做一个小 App 把这些地方记录下来，但是遭到拒绝，她说出去旅游就是为了放下工作，去寻找大自然中最原始，最纯净的东西，她不想因为这个增加我的工作量，而且用最原始的纸和笔更符合旅行的意义。</p>\n<p><strong>香港</strong></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1fodtibvhsbj31kw16rx6r.jpg\" alt=\"\" /></p>\n<p><strong>澳门</strong></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1fodtjh9f65j31kw0z9npe.jpg\" alt=\"\" /></p>\n<p><strong>上海</strong></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1fodtkpsycej31kw0kl4qr.jpg\" alt=\"\" /></p>\n<p><strong>西塘</strong></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1fodtlu9fq7j31kw15v4qu.jpg\" alt=\"\" /></p>\n<p><strong>Kota Kinabalu</strong></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1fodtmeey2yj31kw0tm4qu.jpg\" alt=\"\" /></p>\n<p><strong>Semporna</strong></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1fodtqde670j31kw15qhdy.jpg\" alt=\"\" /></p>\n<p>还有很多地方拍了很多照片，现在看下真的是很美好的回忆，后来我和妹子一直认为，以后即使再忙也一定要多出去走。这也是为什么我过年没有使用年假，因为年假基本会攒到出国。以后我的博客可能会开出相册模块，记录下更多的美好。</p>\n<h6 id=\"其他-2\"><a class=\"anchor\" href=\"#其他-2\">#</a> 其他</h6>\n<p>2017 年也有经常健身吧，因为南方空气潮湿湿气重，如果不让自己保持大汉淋漓的话很容易生病。坚持过几个月，但是后来因为工作忙，加班等借口还是没坚持下来，没有父亲的监督果然靠自己不行。说好的八块腹肌已经要九九归一了。不过也真的明白身在异乡什么时候最孤独，最无助，那就是生病的时候。</p>\n<p>我的 2017 差不多就这些东西，可能跟大佬们比起来真的是小打小闹，但是过得充实，心里踏实只有自己懂。</p>\n<h2 id=\"迎新\"><a class=\"anchor\" href=\"#迎新\">#</a> 迎新</h2>\n<p>2018 年在短短的休息之后就会到来，虽说没有做好万全的准备，但是至少不会手足无措。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1foducrbfzwj31hc0xc1jn.jpg\" alt=\"\" /></p>\n<h4 id=\"学习相关-2\"><a class=\"anchor\" href=\"#学习相关-2\">#</a> 学习相关</h4>\n<ul>\n<li>\n<p>还是学习为主，首先要做的就是把自己的 apple 的开发者账号续费，自己可以做一些练习、App 之类的东西，同时把各种证书、打包，持续集成这块整明白。毕竟现在用公司的证书不敢乱弄。</p>\n</li>\n<li>\n<p>自己从零到一做一个直播的 App 不管是绿色直播还是成人直播，一定要做出来保证完美运行。</p>\n</li>\n<li>\n<p>雅思词汇全掌握。</p>\n</li>\n<li>\n<p>壮大自己的博客。</p>\n</li>\n</ul>\n<h4 id=\"生活相关-2\"><a class=\"anchor\" href=\"#生活相关-2\">#</a> 生活相关</h4>\n<ul>\n<li>\n<p>去一到两个国家。</p>\n</li>\n<li>\n<p>五公里坚持下来。</p>\n</li>\n<li>\n<p>成都，重庆，云南....</p>\n</li>\n</ul>\n<h4 id=\"其他-3\"><a class=\"anchor\" href=\"#其他-3\">#</a> 其他</h4>\n<p>之所以没在迎新中写太多东西并不是因为没计划，而是有些东西不想在这里说出来，用老罗的话说就是万一实现不了，丢人。</p>\n<p>我记得看过一本书说 “伟大的人不是努力学习新知识的人，而是善于总结的人。” 我也不求变成伟大的人，只是希望自己的每一年都有所收货，希望自己做好迎接新一年的打算，希望过得踏实点。</p>\n<h2 id=\"最后\"><a class=\"anchor\" href=\"#最后\">#</a> 最后</h2>\n<p><strong>在这里给大家拜个早年：祝大家新年快乐，心想事成。新的一年我会与大家分享更多的东西</strong></p>\n<p>才疏学浅，文笔拙劣，于 2018.2.13 仓促执笔....</p>\n<p>\n        <div id=\"aplayer-lklUIqKn\" class=\"aplayer aplayer-tag-marker\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t  <script>\n\t\t\t\t  var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":0,\"mutex\":true,\"music\":[{\"title\":\"에필로그 (Epilogue)\",\"author\":\"이동준\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%8B%E1%85%A6%E1%84%91%E1%85%B5%E1%86%AF%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M000000RmZHf3qhLUL.jpg?max_age=2592000\",\"lrc\":\"https://歌词.lrc\"}]};\n\t\t\t\t  options.element = document.getElementById(\"aplayer-lklUIqKn\");\n\t\t\t\t  var ap = new APlayer(options);\n\t\t\t    window.aplayers || (window.aplayers = []);\n\t\t\t\t  window.aplayers.push(ap);\n\t\t\t  </script></p>\n",
            "tags": [
                "总结",
                "回味2017展望2018"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-02-11-%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98/",
            "url": "https://oliverqueen.cn/2018-02-11-%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98/",
            "title": "关于博客评论插件的讨论",
            "date_published": "2018-02-11T07:19:31.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"参考资料\"><a class=\"anchor\" href=\"#参考资料\">#</a> 参考资料</h2>\n<p>习惯把参考资料写在文章的前面，毕竟是踩在人家的肩膀上，先有他才有我这文章，前后顺序不能乱。他的这篇<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLnNodWliYS5jby9jb21tZW50LXN5c3RlbXMtcmVjb21tZW5kYXRpb24=\">文章</span>总结的很全，但是对于每一个评论还欠缺细致的描述，这篇文章下我会做些补充，</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1focjch8o98j30sg0lcta8.jpg\" alt=\"\" /></p>\n<p><span id=\"more\"></span></p>\n<h2 id=\"之前用的livere\"><a class=\"anchor\" href=\"#之前用的livere\">#</a> 之前用的 livere</h2>\n<p>关于博客的评论插件，在最开始的搭建博客之前就有过考虑和纠结，国内的评论界面浮夸流程繁琐，且服务不稳定，说倒就倒，比如多说；国外的又时刻面临着被墙的风险，自己搭建服务器虽说不难，但是也没有精力去搞这些。后来使用了 livere，韩国的产品，一开始被他简洁的界面方便的后台吸引，而且还支持各种移动 APP 登陆，微信、QQ 之类的。不过后来使用过程中缺点显现出来了。</p>\n<h4 id=\"缺点\"><a class=\"anchor\" href=\"#缺点\">#</a> 缺点</h4>\n<p>1：手机端适配不好，手机端无法进行微信登陆。&lt;br&gt;<br />\n2：评论无法导出，不过如果哪天他也要挂了说不定也会支持导出，毕竟实现不难。&lt;br&gt;<br />\n3：经常发评论时候当前页面卡死，其实已经发送成功了，但是界面一直卡在 loading。&lt;br&gt;<br />\n4：加载比较慢一些。&lt;br&gt;</p>\n<h2 id=\"其他的评论插件\"><a class=\"anchor\" href=\"#其他的评论插件\">#</a> 其他的评论插件</h2>\n<p>综上所述我决定换掉它，这种东西要趁早，不然等评论多了还需要朱转移操作。下面说下其他评论插件，因为之前放了大佬的文章，他总结的也很全面，我这边就挑几个大家耳熟能详的来说，而且只说缺点。</p>\n<h4 id=\"disqus\"><a class=\"anchor\" href=\"#disqus\">#</a> disqus</h4>\n<p>他唯一一个缺点就是被墙了，他要求每一个看你博客的读者都要科学上网才可以，对于我的博客来说，不仅仅是写一下技术文档，有时候会更新下照片、游记之类的，所以不想对读者有太高的要求。</p>\n<h4 id=\"搜狐畅言\"><a class=\"anchor\" href=\"#搜狐畅言\">#</a> 搜狐畅言</h4>\n<p>搜狐旗下的评论系统，比较靠谱，有搜狐做后盾也不会轻易说没就没，但是对于我来说他有着太强烈的中国元素，域名、网站需要备案，而且他的界面是在是夸张，又是盖章，又是浮窗的，有种 &quot;大扎好，我系渣渣辉&quot; 的感觉。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1foche9mncgj31hw0veb29.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1focku989hmj312s06044g.jpg\" alt=\"\" /></p>\n<p>过年了，放上了红灯了，红鞭炮，而且水印还去不掉。最最关键是你发评论要登录，如果是用微信登陆还必须要先关注他公众号.</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1fochbah9doj30ho0ngwo2.jpg\" alt=\"\" /></p>\n<p>关注成功后还需要你绑定手机号，虽然不是强制让你绑定，但是如果你不想绑那么好，你每点击一下就会弹出绑定手机号的窗口。对于我一个主打技术的博客来说确实不太适合，如果大家想写一写娱乐微博说不定适合你。</p>\n<h4 id=\"gitment\"><a class=\"anchor\" href=\"#gitment\">#</a> Gitment</h4>\n<p>基于 github 的 issue 实现的，唯一一点不好的就是使用 Gitment 评论一定要用 github 账号登陆，这点对于读者来说要求有点高吧。</p>\n<h4 id=\"valine\"><a class=\"anchor\" href=\"#valine\">#</a> Valine</h4>\n<p>比较优秀的一款轻量级评论插件，这个也是我最后纠结很久的，Valine 依赖于 Leancloud 的后端服务，我们需要去 leanclould 注册一个账号，里面分为免费版和商业版还有企业版。后两个价格对于我来说有点高，如果有钱的大佬可以无视。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1focgkj2vntj31kw0ry44z.jpg\" alt=\"\" /></p>\n<p>免费版有一定限制首先 API 请求每天 30000，你可以暂时理解为每天 30000 条评论吧 (实际不到这个数，你还要刷新之类的)，这个其实对于我来说已经够了，如果你是浏览量非常大的微博 那可能有点悬；10GB 的储存空间是我最担心的，永久 10G 总有一天就会满，到时候只能升级付费版，或者换一个评论平台，不过还好，因为他是支持 markdown 的，所以图片 GIf 的之类的都是通过链接形式，10G 应该够用一阵了。不过也正是因为这个 markdown 编辑也需要一定的语法基础，不会 markdown 的传图片还是麻烦事，多为读者考虑嘛。还有一个最致命的就是他没有管理员的概念，即使你是本文的作者，那你在下面评论或者和网友互动的时候也是没有任何显示的，就像普通评论一样，这个就有点不方便了。</p>\n<h4 id=\"hypercomments\"><a class=\"anchor\" href=\"#hypercomments\">#</a> Hypercomments</h4>\n<p>这个也是我最后选择的评论插件，同样也提供付费和免费的服务</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1focm2c591vj31kw152jyr.jpg\" alt=\"\" /></p>\n<p>免费版完全满足我的博客使用，没有发现以上一些第三方的缺点，同时界面也不错，唯一不足的就是新评论的邮件提醒不知道怎么调出来，我在后台配置了但是并没有提醒。综上所述整体还是比较稳定的。</p>\n<h2 id=\"最后\"><a class=\"anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>大概就这么多，顺便祝大家新年快乐，阖家幸福！</p>\n<p>\n        <div id=\"aplayer-HnDZkzfJ\" class=\"aplayer aplayer-tag-marker\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t  <script>\n\t\t\t\t  var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mutex\":true,\"music\":[{\"title\":\"Love Story\",\"author\":\"린 (LYn)\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%85%E1%85%B5%E1%86%AB-Love%20Story.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M0000048KLcQ4LDbZz.jpg?max_age=2592000\",\"lrc\":\"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=0028RAj0187nEg\"}]};\n\t\t\t\t  options.element = document.getElementById(\"aplayer-HnDZkzfJ\");\n\t\t\t\t  var ap = new APlayer(options);\n\t\t\t    window.aplayers || (window.aplayers = []);\n\t\t\t\t  window.aplayers.push(ap);\n\t\t\t  </script></p>\n",
            "tags": [
                "Hexo",
                "个人博客",
                "网站",
                "评论插件"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-02-08-%E5%85%B3%E4%BA%8EiPhone-X%E4%B8%8BHome%E9%94%AE%E7%9A%84%E9%9A%90%E8%97%8F%E5%92%8C%E5%BB%B6%E8%BF%9F%E5%93%8D%E5%BA%94/",
            "url": "https://oliverqueen.cn/2018-02-08-%E5%85%B3%E4%BA%8EiPhone-X%E4%B8%8BHome%E9%94%AE%E7%9A%84%E9%9A%90%E8%97%8F%E5%92%8C%E5%BB%B6%E8%BF%9F%E5%93%8D%E5%BA%94/",
            "title": "关于iPhone X下Home键的隐藏和延迟响应",
            "date_published": "2018-02-08T02:15:57.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"ios-11通用相关\"><a class=\"anchor\" href=\"#ios-11通用相关\">#</a> iOS 11 通用相关</h1>\n<h2 id=\"edge-protect\"><a class=\"anchor\" href=\"#edge-protect\">#</a> Edge Protect</h2>\n<p>iPhone X 刚出来的时候苹果第一时间更新了新设备的交互文档，其中针对了大家最关心的 “系统手势和 App 自带手势冲突” 的问题也给出了相应的解决办法:</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo8u9uqjehj31kw0t7h2q.jpg\" alt=\"\" /></p>\n<p>虽然苹果用黑体字写着强烈不建议开发者干涉系统的手势，但是为了增强用户体验还是开出了接口，苹果管这个叫做 &quot;edge protect&quot; 因为进入 App 后系统手势都是从边缘触发，引起冲突的地方也会是在边缘中。</p>\n<p><span id=\"more\"></span></p>\n<p>根据官方文档描述，在冲突区域第一次执行手势的时候会优先触发 App 的内部手势，当短时间内再次进行同样的操作则会触发系统手势。也就是将系统手势延迟到下一次执行。</p>\n<h2 id=\"api-discussion\"><a class=\"anchor\" href=\"#api-discussion\">#</a> API Discussion</h2>\n<p>根据官方文档找到对应的 API</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Override to return a child view controller or nil. If non-nil, that view controller&#x27;s screen edges deferring system gestures will be used. If nil, self is used. Whenever the return value changes, -setNeedsScreenEdgesDeferringSystemGesturesUpdate should be called.</span></span><br><span class=\"line\">- (nullable UIViewController *)childViewControllerForScreenEdgesDeferringSystemGestures <span class=\"constructor\">API_AVAILABLE(<span class=\"params\">ios</span>(11.0)</span>) <span class=\"constructor\">API_UNAVAILABLE(<span class=\"params\">watchos</span>, <span class=\"params\">tvos</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Controls the application&#x27;s preferred screen edges deferring system gestures when this view controller is shown. Default is UIRectEdgeNone.</span></span><br><span class=\"line\">- (UIRectEdge)preferredScreenEdgesDeferringSystemGestures <span class=\"constructor\">API_AVAILABLE(<span class=\"params\">ios</span>(11.0)</span>) <span class=\"constructor\">API_UNAVAILABLE(<span class=\"params\">watchos</span>, <span class=\"params\">tvos</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This should be called whenever the return values for the view controller&#x27;s screen edges deferring system gestures have changed.</span></span><br><span class=\"line\">- (void)setNeedsUpdateOfScreenEdgesDeferringSystemGestures <span class=\"constructor\">API_AVAILABLE(<span class=\"params\">ios</span>(11.0)</span>) <span class=\"constructor\">API_UNAVAILABLE(<span class=\"params\">watchos</span>, <span class=\"params\">tvos</span>)</span>;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"childviewcontrollerforscreenedgesdeferringsystemgestures\"><a class=\"anchor\" href=\"#childviewcontrollerforscreenedgesdeferringsystemgestures\">#</a> childViewControllerForScreenEdgesDeferringSystemGestures</h4>\n<p>该方法是用来控制子试图控制器是否允许开发者控制 edge protect 的开启或是关闭。如果实现了这个方法并且返回值不为空那么子 VC 的 edge protect 设置就会遵循父 VC 的设置，跟随父 VC 是否延迟执行系统手势。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo917ycqy6j319i0bqjtr.jpg\" alt=\"\" /></p>\n<h4 id=\"preferredscreenedgesdeferringsystemgestures\"><a class=\"anchor\" href=\"#preferredscreenedgesdeferringsystemgestures\">#</a> preferredScreenEdgesDeferringSystemGestures</h4>\n<p>该方法是设置 edge protect 的方法，返回值是一个边界的枚举</p>\n<p><figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_OPTIONS</span>(<span class=\"type\">NSUInteger</span>, <span class=\"type\">UIRectEdge</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeNone</span>   = 0,</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeTop</span>    = 1 &lt;&lt; 0,</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeLeft</span>   = 1 &lt;&lt; 1,</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeBottom</span> = 1 &lt;&lt; 2,</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeRight</span>  = 1 &lt;&lt; 3,</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeAll</span>    = <span class=\"type\">UIRectEdgeTop</span> | <span class=\"type\">UIRectEdgeLeft</span> | <span class=\"type\">UIRectEdgeBottom</span> | <span class=\"type\">UIRectEdgeRight</span></span><br><span class=\"line\">&#125; <span class=\"type\">NS_ENUM_AVAILABLE_IOS</span>(7_0);</span><br></pre></td></tr></table></figure></p>\n<p>因为不论我们从 shang、左、下、右边都可触发系统手势，所以方法保护了四个边框，将边界触发的手势延迟执行，这个方法从 iOS11 开始使用，不过枚举中虽然有左右的边界保护，但是系统手势中还不清楚左右滑动会触发什么效果，实验发现对于 VC 的左边界右滑动 pop 手势是无效的，也就是说这个 pop 手势一直有着最高的优先级。不过上下就很好理解，底部上拉出控制中心，顶部下拉是通知中心。</p>\n<ul>\n<li>\n<p>无限制</p>\n<p>当不做任何限制时候在顶部和底部很容易触发到系统的手势，他们会优先于 Tab.eView 的 scroll 手势执行，虽说屏幕大部分的界面还是执行 TableView 手势的，但是当用户误触到边界的时候还是会稍稍影响体验，尤其是在全屏模式下、相机、视频、游戏等</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo909u85fpg308k0goe8d.gif\" alt=\"\" /></p>\n</li>\n<li>\n<p>Edge Protent</p>\n<p>在对应的 ViewControll 中添加如下代码，我们这边开启的是所有边界限制其中包括了上、下边界。在下拉或者上拉的话会先触发 App 内部手势，同时出现一个小箭头然后在箭头消失之前再次滑动就会触发系统手势。<br />\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"built_in\">UIRectEdge</span>)preferredScreenEdgesDeferringSystemGestures</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">UIRectEdgeAll</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo90rfo0dig308k0go7wu.gif\" alt=\"\" /></p>\n</li>\n</ul>\n<h4 id=\"setneedsupdateofscreenedgesdeferringsystemgestures\"><a class=\"anchor\" href=\"#setneedsupdateofscreenedgesdeferringsystemgestures\">#</a> setNeedsUpdateOfScreenEdgesDeferringSystemGestures</h4>\n<p>这个方法是在应用内部动态控制 edge protect，我们可以在上个方法中返回一个 BOOL 变量，然后根据需要改变该变量的值，然后调用该方法进行刷新。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo912yvhsag308k0goe8h.gif\" alt=\"\" /></p>\n<h1 id=\"iphone-x使用相关\"><a class=\"anchor\" href=\"#iphone-x使用相关\">#</a> iPhone X 使用相关</h1>\n<p>iPhone X 在系统手势上面交互和其他设备还是有一定区别的，因为加入了 Home Indicator 的原因，引入了新的手势，同时对以往的手势也做了相应的调整。</p>\n<h2 id=\"iphone-x-edge-protect\"><a class=\"anchor\" href=\"#iphone-x-edge-protect\">#</a> iPhone X Edge Protect</h2>\n<p>在 iPhone X 中通知中心和控制中心全部都移动到了由顶部刘海处下拉和右上角下拉来触发。原本底部的所有手势都被 Home Indicator 占用。其实 Edge Protect 在这里依然适用，只是对于 Home Indicator 的手势有一个小插曲。正常来说他在底部，就应该受到 UIRectEdgeBottom 或者是 UIRectEdgeAll 控制，但是一开始苹果并没有这么做，不论怎么写代码，他都有着最高的优先级，在 iPhone X 刚发布我就试图去处理交互问题，因为海报工厂并没有传统的 UITabBarController，且里面所有的 tableView 都是直通到底，但是始终都无法延迟执行与 Home Indicator 相关的任何手势。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo920zedwnj308w0j9gxa.jpg\" alt=\"\" /></p>\n<p>后来看了其他游戏，视频类 App 在 iPhone X 上的表现也都是如此。腾讯的王者荣耀，网易的吃鸡都是一样。腾讯官方给出的解释是暂时开起引导式访问，也仍然不方便。后来在今年 1 月 25 日苹果推送了 iOS 11.2.5 的版本更新，然后王者荣耀也跟着进行了一波更新，在进入游戏时候就会发现，底部的 Home Indicator 当你一段时间不去触碰它的时候由黑色或者白色 (根据当前的屏幕显示的内容来决定) 变成非常透明的灰色，当你第一次进行操作会默认执行 App 内手势，同时激活 Home Indicator，短时间内进行第二次操作就可以返回桌面</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo935pn8dsg30go07s1l2.gif\" alt=\"\" /></p>\n<p>一开以为是有新的 API 出现，不过看了交互文档并没有新的东西，而且小版本的系统更新应该也不会出现新的东西。所以找到了之前的 edge protect 代码运行后确实可以达到效果。对于视频，游戏等 App，确实可以起到很好的防误触的效果。遗憾的是并没有太多的人使用这个功能。目前主流的大型游戏，包括 Gameloft 出品的游戏都没做相应的处理。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo943bx7sog308h0gox6z.gif\" alt=\"\" /></p>\n<h2 id=\"iphone-x-home-indicator-hidden\"><a class=\"anchor\" href=\"#iphone-x-home-indicator-hidden\">#</a> iPhone X Home Indicator Hidden</h2>\n<p>如果说上面的 Edge Protect 适合在游戏中使用，那么 Home Indicator Hidden 则更适合在非游戏环境下增强 App 的沉浸感，尤其是全屏视屏播放、录制的时候。同样三个 API，和 Edge protect 的用法完全一样。</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Override to return a child view controller or nil. If non-nil, that view controller&#x27;s home indicator auto-hiding will be used. If nil, self is used. Whenever the return value changes, -setNeedsHomeIndicatorAutoHiddenUpdate should be called.</span></span><br><span class=\"line\">- (nullable UIViewController *)childViewControllerForHomeIndicatorAutoHidden <span class=\"constructor\">API_AVAILABLE(<span class=\"params\">ios</span>(11.0)</span>) <span class=\"constructor\">API_UNAVAILABLE(<span class=\"params\">watchos</span>, <span class=\"params\">tvos</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Controls the application&#x27;s preferred home indicator auto-hiding when this view controller is shown.</span></span><br><span class=\"line\">- (BOOL)prefersHomeIndicatorAutoHidden <span class=\"constructor\">API_AVAILABLE(<span class=\"params\">ios</span>(11.0)</span>) <span class=\"constructor\">API_UNAVAILABLE(<span class=\"params\">watchos</span>, <span class=\"params\">tvos</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This should be called whenever the return values for the view controller&#x27;s home indicator auto-hiding have changed.</span></span><br><span class=\"line\">- (void)setNeedsUpdateOfHomeIndicatorAutoHidden <span class=\"constructor\">API_AVAILABLE(<span class=\"params\">ios</span>(11.0)</span>) <span class=\"constructor\">API_UNAVAILABLE(<span class=\"params\">watchos</span>, <span class=\"params\">tvos</span>)</span>;</span><br></pre></td></tr></table></figure><br />\n 上面写的是自动隐藏，也就是说系统会根据当时的使用情况来进行显示或者隐藏，而不是永久的隐藏掉，实际测试发当界面两秒内没有进行任何交互操作的时候 Home Indicator 会逐渐隐去，直达屏幕上出现了点击的操作，注意是点击，TableView 的滑动并不能触发显示，不过只是是隐藏，但是手势依然可以使用。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo94hujx35g308h0go4qy.gif\" alt=\"\" /></p>\n<p>如果是 feed 流界面搭配酷一点的 UI 就会提高沉浸感，比如这样：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo94p0bmoqg308h0gox6t.gif\" alt=\"\" /></p>\n<p>有的人可能会问如果说点击的手势会触发它再次显示那我获取 window 上的交互每次在它即将显示的时候通过<strong> setNeedsUpdateOfHomeIndicatorAutoHidden</strong> 在让他隐藏不就好了吗？这样一来既不影响系统手势也不会让它在显示出来，其实我自己试过不行的，毕竟苹果不会让你这样改。</p>\n<h2 id=\"坑点\"><a class=\"anchor\" href=\"#坑点\">#</a> 坑点</h2>\n<p>需要注意的是：prefersHomeIndicatorAutoHidden 和 preferredScreenEdgesDeferringSystemGestures 不可一起使用，如果一起使用的话后者是不生效的。</p>\n",
            "tags": [
                "UI",
                "屏幕适配",
                "iOS 11"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-25-%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%85%A8%E7%9A%84%E4%BD%BF%E7%94%A8HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/",
            "url": "https://oliverqueen.cn/2018-01-25-%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%85%A8%E7%9A%84%E4%BD%BF%E7%94%A8HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/",
            "title": "可能是最全的使用HEXO搭建个人博客教程",
            "date_published": "2018-01-25T07:43:15.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景</h2>\n<p>作为一个开发者不能没有博客，最近花了几天的时间搭建了这个博客，处理了很多细节，在这篇文章中我会把我从开始到现在以及后续的优化整理出来，帮助更多的人搭建、维护、更新、自己的博客。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79ly1fnsy5fhyhsj31hc0xchdt.jpg\" alt=\"\" /></p>\n<p>一开始我所有的博客都写在新浪微博，因为微博上更容易推广自己的文章，微博用户量大，但是后来微博的弊端慢慢的显示出来了，毕竟不是开发者的天地，我的博客中经常会插入大量的代码，而微博不支持 markdown 编辑，普通的编辑器对代码块的兼容性非常差，别说高亮了，有时候排版都会错乱，最后外观很不好看，如下图：</p>\n<p><span id=\"more\"></span></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79ly1fnsxwzb745j31i20tuad4.jpg\" alt=\"微博代码\" /></p>\n<p>而且微博的账号系统也存在一定的弊端，所以后来转向简书、掘金等技术平台，不得不承认相对于微博来说这些平台对开发者就要友好多了，不过后来又发现一个问题。因为我在写文章的时候使用的是本地的 markdown 编辑器，而这些平台对 markdown 语法的一些小细节并不严谨或者说统一如下图：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79ly1fnsy0p6no4j316q0nsn2v.jpg\" alt=\"简书VS掘金\" /></p>\n<p>两个平台的编辑器无法做到统一，以至于每次写完文章都需要针对两个平台做不同的修改。</p>\n<p>综上所述，最简单的也最一劳永逸的方法就是搭建自己的博客平台，而 HEXO 很好的帮我们解决了这个问题，其实对于一个开发者来说并不是什么难事，整个流程对于大部分有代码基础的开发者来说一上午时间就可以搞定，不过最难的也是最头痛的就是对细节的调整，对 UI 的修改、优化等，不过本文会对此逐一讲解。</p>\n<h2 id=\"环境配置\"><a class=\"anchor\" href=\"#环境配置\">#</a> 环境配置</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub2RlanMub3JnL2VuLw==\">Node.js</span></li>\n</ul>\n<p>cURL:</p>\n<p><code>$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh </code></p>\n<p>Wget:</p>\n<p><code>$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh </code></p>\n<p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p>\n<p><code>$ nvm install stable</code></p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXQtc2NtLmNvbS8=\">Git</span></li>\n</ul>\n<p>一般的开发者不会没有这个吧，我是安装 Xcode 就会有这个了，</p>\n<p>使用 Homebrew, MacPorts ：brew install git; 或下载 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zb3VyY2Vmb3JnZS5uZXQvZGlyZWN0b3J5Lw==\">安装程序</span> 安装</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iaXRidWNrZXQub3JnLw==\">bitbucket</span> 账号</li>\n</ul>\n<p>一般都会使用 HEXO+GitHub page 的形式搭建自己的博客，但是这里有个问题就是 GitHub 是开源的，任何人都能在上面看到你的源代码，虽然这并没有什么太大的影响，不过对于我来说感觉怪怪的，所以我就用了 bitbucket page 来处理我的博客，所有的东西都一样只不过这个是个私有库罢了（免费五个人）</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79ly1fnt1nn8k9uj30b308amye.jpg\" alt=\"\" /></p>\n<h2 id=\"开始建站\"><a class=\"anchor\" href=\"#开始建站\">#</a> 开始建站</h2>\n<h4 id=\"第一步创建仓库\"><a class=\"anchor\" href=\"#第一步创建仓库\">#</a> 第一步：创建仓库</h4>\n<p>进入 github/bitbucket（后续都以 github 为例）新建 repo，这里要注意 repo 的名字一定要满足 <code>your Account Name</code> /github.io。如果是 bitbucket 那就是 <code>your Account Name</code> /bitbucket.io，因为只有这样的仓库名称最后才能以静态页面展示。如图：XXX 的内容一定要与红色的框里的文本一致。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79ly1fntzjgvzvyj30q006nmy0.jpg\" alt=\"\" /></p>\n<h4 id=\"第二步创建本地文件夹\"><a class=\"anchor\" href=\"#第二步创建本地文件夹\">#</a> 第二步：创建本地文件夹</h4>\n<p>创建文件夹之后 CD 到你创建的文件夹中执行 hexo 的初始化相关命令</p>\n<p><figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$ </span>hexo init</span><br><span class=\"line\"><span class=\"variable\">$ </span>npm install</span><br></pre></td></tr></table></figure></p>\n<p>执行完毕之后你的文件夹里就有内容了，标准的目录结构是这样（只列出几个必要的文件夹及其子目录）</p>\n<p><figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── <span class=\"variable\">_config</span>.yml</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">├── source</span><br><span class=\"line\">|   ├── <span class=\"variable\">_drafts</span></span><br><span class=\"line\">|   └── <span class=\"variable\">_posts</span></span><br><span class=\"line\">└── themes</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>\n<p>_config.yml：<br />\n其中我们以后的大部分操作都会在 <code>_config.yml</code>  中进行，这个文件是我们的站点的配置文件。</p>\n</li>\n<li>\n<p>scaffolds：<br />\n模板文件，规定了我们创建一篇文章的时候最开始的样子，</p>\n</li>\n<li>\n<p>source：<br />\n可以暂时的理解成我们文章的存放处</p>\n</li>\n<li>\n<p>themes：<br />\n主题文件</p>\n</li>\n</ul>\n<h4 id=\"第三步部署到git\"><a class=\"anchor\" href=\"#第三步部署到git\">#</a> 第三步：部署到 Git</h4>\n<p>修改我们的的站点配置文件 <code>_config.yml</code>  中如下字段</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79ly1fntzzwn8dkj30w0058wga.jpg\" alt=\"\" /><br />\n其中：</p>\n<ul>\n<li>\n<p><code>type</code>  值对应的是你所部署的的服务器类型，我们这里填写 git 就可以。</p>\n</li>\n<li>\n<p><code>repo</code>  是你的仓库地址，也就是仓库克隆的地址，推荐用 https 的链接。</p>\n</li>\n<li>\n<p><code>branch</code>  不写默认是 master，通常我们写成 master 就可以。</p>\n</li>\n</ul>\n<p>以上配置完成后保存 然后回到终端执行 <code>npm install hexo-deployer-git --save</code>  安装一个插件，这样才能将你写好的文章部署到 github 服务器上并让别人浏览到。安装完成后在终端中依次执行如下代码 (为了简单后续统称为三步)</p>\n<ul>\n<li>\n<p><code>hexo clean</code>   清理缓存</p>\n</li>\n<li>\n<p><code>hexo generate</code>  进行渲染 简写  <code>hexo g</code></p>\n</li>\n<li>\n<p><code>hexo server</code>  部署到本地 (调试使用) 简写  <code>hexo s</code> 。然后浏览器输入  <code>http://localhost:4000</code>  就可以看到你博客的效果啦，不过这是本地调试用，其他人是看不到的。(调试完毕后记得  <code>control + C</code>  关闭本地端口，不然下次就进不去啦)</p>\n</li>\n<li>\n<p>调试完毕后使用  <code>hexo deploy</code>  简写为  <code>hexo d</code>  来部署到 git 服务器。</p>\n</li>\n</ul>\n<p>执行完以上操作后打开浏览器地址了输入 <code>http://你github名字.github.io</code>  就可以看看到效果啦，这回是所有人都能看到的，用手机也可以。至此第三步已经完成，最终的结果如下图：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79ly1fnu0jxw383j310l0gcdrk.jpg\" alt=\"\" /></p>\n<h4 id=\"第四步写文章\"><a class=\"anchor\" href=\"#第四步写文章\">#</a> 第四步：写文章</h4>\n<p>使用如下命令  <code>hexo new post “文章名字”</code>  就可新建文章啦，建立好的文章在  <code>source/_posts</code>  中，你可以用 markdown 语法编辑内容就可以。编辑完成后执行第三步中终端的操作就可以啦，刷新下浏览器就可看到你的新文章啦。如下图:</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79ly1fnu0ml6lp4j310n0g9tjv.jpg\" alt=\"\" /></p>\n<h2 id=\"个性化\"><a class=\"anchor\" href=\"#个性化\">#</a> 个性化</h2>\n<h4 id=\"一主题\"><a class=\"anchor\" href=\"#一主题\">#</a> 一：主题</h4>\n<h6 id=\"获取\"><a class=\"anchor\" href=\"#获取\">#</a> 获取</h6>\n<p>主题是我么个性化的基础和前提，我们想做任何个性化上的修改基本上都是在我们主题上的修改，先找到一个自己满意的主题是首要任务。关于主题网上有很多很多，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL3RoZW1lcy8=\">HEXO 官方的主题目录</span>也收录了好多来着世界各地开发者的主题。或者开发者也可以直接去网上搜索 HEXO theme 关键字来获取主题。</p>\n<h6 id=\"安装\"><a class=\"anchor\" href=\"#安装\">#</a> 安装</h6>\n<p>主题一般都是 repo，只要讲起 clone 到博客目录 themes/XXXX 下就可了，XXXX 对应的就是你给主题起的名字，像这样： <code>git clone https://github.com/huyingjie/hexo-theme-A-RSnippet.git themes/a-rsnippet</code>  这样就可以保证每次主题的作者有更新了我们就可以 pull 获取更新。不过这样有个问题后面我会在 HEXO 多终端同步一栏讲到，所以这里我们选择另一种方式去安装，就是直接把主题的 repo 下载下来<br />\n然后解压放到 themes 中。其实对于已经稳定的主题作者一般不会频繁更新，不稳定的主题我们也不会用，所以用后者安装也是一样的。</p>\n<p>然后我们回到刚才的站点配置文件中 <code>_config.yml</code>  修改如下字段，对应的名字就是你刚才那个主题文件夹的名字：我这边是 next，</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79ly1fnu5dr697rj312006a0tp.jpg\" alt=\"\" /></p>\n<p>然后保存，再去终端执行那三步，接着刷新网页就可以看到新的界面啦。下面是我换了 NEXT 主题刷新后的效果。因为该注意已经非常完善，所有后续用该主题做例子来讲</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79ly1fnu5ohsltng30go097e83.gif\" alt=\"\" /></p>\n<h4 id=\"二主题菜单\"><a class=\"anchor\" href=\"#二主题菜单\">#</a> 二：主题菜单</h4>\n<h6 id=\"添加按钮\"><a class=\"anchor\" href=\"#添加按钮\">#</a> 添加按钮</h6>\n<p>主题菜单也可以说是主题按钮。也就是上面顶部的两个，next 主题默认的两个是 Home、Archive，我们一般会加上 tag about category 等。这些都是需要在主题上进行修改，我们需要修改主题的配置文件，首先在主题的文件夹下找到 <code>_config.yml</code>  文件，没错和之前的站点配置文件同名，只不过他们的路径不同，大家千万不要弄混，站点配置文件是配置站点通用的东西，而主题配置文件是配置一些主题的元素。在主题配置文件找到 menu 字段</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79ly1fnu69gaksbj312s0cijtz.jpg\" alt=\"\" /></p>\n<p>可以看到主题作者注释掉了一部分按钮只保留了两个最基本的，这里需要注意前面的 Key 并不是代表的是按钮名字，因为该主题是支持多语言，所以这个 key 只是个标识，具体的按钮名字要去该路径下查找</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79ly1fnu6e4quu7j30fa0zkwgi.jpg\" alt=\"\" /></p>\n<p>其中每一个文件对应了不同的语言，我们以汉语为例，进入 <code>zh-Hans.yml</code>  中修改这些字段</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79ly1fnu6fypjr7j30ay054wes.jpg\" alt=\"\" /></p>\n<p>其中 key 就是之前我们在主题配置文件中的 key，而后面的 value 则是简体中文状态下按钮的名字。修改完成后我们保存执行那三步就可以看到我们新添加的按钮了。</p>\n<h6 id=\"添加页面\"><a class=\"anchor\" href=\"#添加页面\">#</a> 添加页面</h6>\n<p>添加按钮后我们需要点击按钮显示统一的页面。这时候我们需要添加页面。以 tag 页面为例，hexo 中添加页面的命令是 <code>hexo new page XXXXX</code>  后面 XXX 则是要添加页面的名称，我们这里写 tags。为了测试新建的 tag 页面我们对之前的页面添加个 tag。去 source/_post 中找一篇文章我们在开头添加如下字段，多标签以此类推</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79ly1fnu6nmt2ywj30v00f4jsi.jpg\" alt=\"\" /></p>\n<p>然后编辑我们刚才生成的 tag 页面 ( <code>source/tags/index.md</code> ) 指定其 type 为 tags</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79ly1fnu6q39ak4j310y09e3zb.jpg\" alt=\"\" /></p>\n<p>然后保存执行那三步就会有如下效果</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79ly1fnu6vtcn1og30gn07fhe0.gif\" alt=\"\" /></p>\n<p>点击对应的 tag 即可跳转到改 tag 所对应的文章。其他页面同理。</p>\n<h4 id=\"三添加阅读更多button\"><a class=\"anchor\" href=\"#三添加阅读更多button\">#</a> 三：添加阅读更多 button</h4>\n<p>我们在首页的时候其实就是我们的文章列表，但是这时候有个问题，如果我们某一篇或者某几篇文章很长，那首页是不是更长呢？其实在首页我们可以只显示文章部分内容，通过点击阅读更多按钮来进入文章详情。这个时候就需要截断文章。我们在文章的合适地方采用 <code>&lt;!--more--&gt;</code>  来截断，用默认文章来看</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79ly1fnu73u6xghj313o0hujuz.jpg\" alt=\"\" /></p>\n<p>然后执行那三步就会如下效果</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79ly1fnu75xee1rj31kw0iomzf.jpg\" alt=\"\" /></p>\n<p>点击阅读更多。</p>\n<h4 id=\"四更改主题背景\"><a class=\"anchor\" href=\"#四更改主题背景\">#</a> 四：更改主题背景</h4>\n<p>首先找到如下路径  <code>themes\\next\\source\\css_custom\\custom.styl</code>  会发现里面是空的，这个文件是 Next 主题为我们预留的做一些自定的 css 样式的地方，我们添加如下代码。</p>\n<p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//背景图片相关</span><br><span class=\"line\"><span class=\"keyword\">@media</span> screen <span class=\"keyword\">and</span> (<span class=\"attribute\">min-width</span>:<span class=\"number\">1200px</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-image</span>:<span class=\"built_in\">url</span>(<span class=\"string\">/images/bg.jpg</span>);</span><br><span class=\"line\">    <span class=\"attribute\">background-repeat</span>: no-repeat;</span><br><span class=\"line\">    <span class=\"attribute\">background-attachment</span>:fixed;</span><br><span class=\"line\">    <span class=\"attribute\">background-position</span>:<span class=\"number\">50%</span> <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: cover</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"selector-id\">#footer</span> <span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">color</span>:<span class=\"number\">#eee</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 这里大家应该就可以看出括号里面的图片路径就是我们的背景图片，我们只需把图片放入  <code>themes\\next\\source\\images</code>  中即可，记住图片名字要写对，要有后缀。同理括号里面我们可以直接放一个图片的链接比如  <code>https://tpc.googlesyndication.com/simgad/6893153702744595670</code>  做完这些操作保存，然后执行那三步即可看到效果，不过可能浏览器有缓存，可以清理下缓存再刷新看看。</p>\n<h4 id=\"五修改博客背景透明度\"><a class=\"anchor\" href=\"#五修改博客背景透明度\">#</a> 五：修改博客背景透明度</h4>\n<p>既然再上一步中修改了背景图片，如果被 NExt 本身的白色挡住确实不好看，我们可以尝试把本身的白色背景变成透明的，这样会美观很多，同样还是修改刚才的文件  <code>themes\\next\\source\\css_custom\\custom.styl</code>  在上一步的基础上我们可以添加如下代码<br />\n <figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//改变背景色和透明度</span><br><span class=\"line\"><span class=\"selector-class\">.main-inner</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">    <span class=\"attribute\">opacity</span>: <span class=\"number\">0.9</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 其中第一个属性为颜色值，第二个属性就是我们的透明度啦。适当修改，不然会适得其反连字都看不清啦。做完上两步就是我的这个博客的效果。</p>\n<h4 id=\"六修改作者头像为圆形\"><a class=\"anchor\" href=\"#六修改作者头像为圆形\">#</a> 六：修改作者头像为圆形，</h4>\n<p>我们默认是方形的头像，想修改为圆形的话同样是上两步的那个路径下添加如下代码<br />\n <figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.site-author-image</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">2px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> dashed <span class=\"number\">#fff</span>;</span><br><span class=\"line\">  <span class=\"attribute\">animation</span>: cycle <span class=\"number\">2s</span> <span class=\"number\">0.5s</span> forwards;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: border-radius <span class=\"number\">2s</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 保存 -&gt; 三步 即可看到效果</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcly1fnxgsh0p7bj308e06jq3t.jpg\" alt=\"\" /></p>\n<h4 id=\"七添加背景动画\"><a class=\"anchor\" href=\"#七添加背景动画\">#</a> 七：添加背景动画</h4>\n<p>背景动画使用 Js 来处理，会 JS 的同学可以自己写喜欢的动画，我这边就用了网上比较通用的动画。找到以下路径  <code>themes\\next\\layout\\_layout.swig</code>  在文章  <code>&lt;/body&gt;</code>  的上面添加如下代码<br />\n <figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script <span class=\"attribute\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span></span><br><span class=\"line\"><span class=\"attribute\">color</span>=<span class=\"string\">&quot;255,255,255&quot;</span> <span class=\"attribute\">opacity</span>=<span class=\"string\">&#x27;1&#x27;</span> <span class=\"attribute\">zIndex</span>=<span class=\"string\">&quot;-2&quot;</span> <span class=\"attribute\">count</span>=<span class=\"string\">&quot;100&quot;</span> <span class=\"attribute\">src</span>=<span class=\"string\">&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 然后 保存 -&gt; 三步即可看到效果 其中 src 为 JS 的路径，有兴趣的可以自定义效果。</p>\n<h4 id=\"八添加评论页面\"><a class=\"anchor\" href=\"#八添加评论页面\">#</a> 八：添加评论页面</h4>\n<p>HEXO 的评论页面官方推荐了 disqus，无奈已经被墙，即使开发时候自己有克服的方法但是也不能保证所有看你博客的人都有克服的方法。所有我们打算采用其他的的一些第三方来实现，首先先对市面上的几个产品做下对比：</p>\n<h6 id=\"比较\"><a class=\"anchor\" href=\"#比较\">#</a> 比较：</h6>\n<ul>\n<li>disqus</li>\n</ul>\n<p>比较大牌的评论系统，服务稳定，唯一的缺点是国内无法使用。暂不考虑</p>\n<ul>\n<li>\n<p>多说<br />\n国内比较出名的评论系统，已经关闭服务暂不考虑。</p>\n</li>\n<li>\n<p>gitment<br />\n 一款基于 github issue 的评论系统，风格很像 github，只是目前还不是太稳定，且界面无法自定，可能会于博客有些不协调。而且评论需要 github 账号</p>\n</li>\n<li>\n<p>livere<br />\n 中文名字叫来必力，是一款韩国的评论系统，在不带有任何民族情感的前提下来看确实棒子的东西还是不错的，也是我目前在使用的一款，我主要用它的原因有几点</p>\n<ul>\n<li>\n<p>支持很多种格式的评论导入，你可以很方便的吧之前在其他平台上的评论数据导入进来，支持多种 json 格式。</p>\n</li>\n<li>\n<p>简介的 UI 提供多种主题。</p>\n</li>\n<li>\n<p>国外的东西不受国内的限制。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"集成\"><a class=\"anchor\" href=\"#集成\">#</a> 集成：</h6>\n<p>先去<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saXZlcmUuY29t\"> livere 的官网</span>注册 m，具体过程我就不讲了，一步一步安她的来就行，之后他会给你一个安装代码，像这样：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcly1fnxhkvhulnj30pt0ikq5e.jpg\" alt=\"\" /></p>\n<p>里面主要的信息就是 data-uid。<br />\nNEXT 主题本身是已经集成了 livere 评论的，只不过被注释掉了。找到主题配置文件  <code>_config.yml</code>  找到如下代码</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcly1fnxhhj8slmj312o06kmyi.jpg\" alt=\"\" /></p>\n<p>打开注释填入你在 livere 中注册后它给你的 UID 即可。然后 保存 -&gt; 三步即可。</p>\n<h2 id=\"九多终端操作\"><a class=\"anchor\" href=\"#九多终端操作\">#</a> 九：多终端操作</h2>\n<h4 id=\"背景-2\"><a class=\"anchor\" href=\"#背景-2\">#</a> 背景</h4>\n<p>大家都知道 HEXO 是静态博客，所有的页面都是静态的通过本地文件渲染然后再部署上去，这就带来一个多终端部署的问题，比如公司电脑配置好了，想回家在进行写作，发现家里什么都没有还需要重新配置环境，不过这倒是次要，关键是如果不能保证两个终端的内容完全一样就会造成服务器上的数据会被最后一次部署覆盖，导致前几次的都被覆盖掉。</p>\n<h4 id=\"解决\"><a class=\"anchor\" href=\"#解决\">#</a> 解决</h4>\n<p>其实大家应该也看出 HEXO 整体的一套流程下来就是 git 的工作流程，不管你用 github 还是 bitbucket 都是遵循 gitflow 的，而 gitflow 就是一种多终端多人协同工作的解决方案。所以我们可以用它来解决多终端同步的问题。</p>\n<h4 id=\"流程\"><a class=\"anchor\" href=\"#流程\">#</a> 流程</h4>\n<p>我们先来了解下 hexo 的整体流程。我们正常的为文件夹结构如图：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79ly1fnyf572x8nj30bu0fqgn0.jpg\" alt=\"\" /></p>\n<h6 id=\"第一步hexo-g\"><a class=\"anchor\" href=\"#第一步hexo-g\">#</a> 第一步：hexo g</h6>\n<p>source 文件夹下存放着我们的文章，tag、归档之类的信息，也就是我们的博客的内容。当我们在终端执行  <code>hexo g</code>  的时候会被 source 中的文件按照某种规则方式渲染成静态的页面文件放到 public 中：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79ly1fnyf8eyhjdj30mw0e876h.jpg\" alt=\"\" /></p>\n<h6 id=\"第二步hexo-d\"><a class=\"anchor\" href=\"#第二步hexo-d\">#</a> 第二步：hexo d</h6>\n<p>然后我们执行  <code>hexo d</code>  这一步暂时我们可以认为就是对 public 中的文件进行 push 到我们的 git 仓库的过程。所以在我们的仓库中  <code>XXXXXX.bitbucket.io</code>  大家看到的文件只有 public 中的文件。</p>\n<h6 id=\"附加hexo-clean\"><a class=\"anchor\" href=\"#附加hexo-clean\">#</a> 附加：hexo clean</h6>\n<p>其实这一步是和 gitflow 没有关系的，但是既然讲到流程我这边也在说下，之前说过这步是用来清理缓存的，其实他的作用是运行在第一步之前，将整个 public 文件删除，然后我们再执行  <code>hexo g</code>  重新渲染进 public，之后再  <code>hexo d</code>  进行部署，这样就避免之前的内容对我们造成影响。</p>\n<h4 id=\"具体操作\"><a class=\"anchor\" href=\"#具体操作\">#</a> 具体操作</h4>\n<p>通过上一步流程我们知道如果 git 服务器上只有 public 是不够的，我们需要有我们整个博客文件夹下的所有文件才能进行多终端操作。所有这边有两个方法：</p>\n<ul>\n<li>\n<p>新建另一个仓库我们暂时命名为 MyProject，把我们所有的文件传到这个 Git 仓库上，当我们换另一台电脑时候我们直接拉这个新仓库的代码然后进行写作 -&gt; 三步走最后在将所有文件推到 MyProject 以后所有的 git 操作都在这个仓库中进行。</p>\n</li>\n<li>\n<p>git 给我们提供了多分支操作，我们可以做 xxxx.github.io 这个仓库中创建一个新的分支暂时命名为 hexo 分支，这个分支的作用和上一个方法里 MyProject 的作用以及里面的文件一模一样，只不过我们这个方法就省的我们再创建一个仓库了。以后所有的 git 操作都去这个分支进行，本地的文件一直保持在这个分支就行，不过有一点需要注意的就是，即使所有的操作都在 hexo 分支下进行也必须保证 master 分支为主分支 (default branch)，不然你就打不开你的博客了。</p>\n</li>\n</ul>\n<p>以上两种都是属于基本的 git 操作，本文不再赘述。不过有一点这里要强调下，还记一开始我跟大家说的主题的是推荐大家直接去主题所在的 repo 下载 zip 然后解压拖进博客目录里面吗？如果你不是拖拽进来的而是 clone 下来的话在这一步你会涉及到 git 的 add submodule 操作。其实操作不难，具体的命令网上也是大把。不过如果你像我一样使用 bitbucket 的话可能发现无法进行 submodule 操作，不知道这个是 bitbucket 的 BUG 还是什么其他原因，同样的命令使用 github 托管博客的时候是没有问题的，而 bitbucket 就不行，当你使用另一台电脑的进行拉去的时候执行  <code>git submodule init</code>  操作的时候他会提示找不到。至今未解决，如果哪位大神有什么方法及时联系我。</p>\n<h2 id=\"十绑定个人域名\"><a class=\"anchor\" href=\"#十绑定个人域名\">#</a> 十：绑定个人域名</h2>\n<h4 id=\"font-colorred注意bitbucket-从2015年开始关闭了个人博客自定义域名的功能也就是说如果你是按照上面操作把个人博客部署在bitbucket中的话就无法使用自己的域名关于这一点bitbucket文档已经有明显的说明font\"><a class=\"anchor\" href=\"#font-colorred注意bitbucket-从2015年开始关闭了个人博客自定义域名的功能也就是说如果你是按照上面操作把个人博客部署在bitbucket中的话就无法使用自己的域名关于这一点bitbucket文档已经有明显的说明font\">#</a> &lt;font color=red&gt; 注意：bitbucket 从 2015 年开始关闭了个人博客自定义域名的功能，也就是说如果你是按照上面操作把个人博客部署在 bitbucket 中的话就无法使用自己的域名，关于这一点 bitbucket 文档已经有明显的说明 &lt;/font&gt;</h4>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo7pq9gdqzj31a20psaf0.jpg\" alt=\"\" /></p>\n<h4 id=\"准备工作\"><a class=\"anchor\" href=\"#准备工作\">#</a> 准备工作</h4>\n<p>在 github 上创建仓库，仓库的名字为 <span class=\"exturl\" data-url=\"aHR0cDovL3VzZXJuYW1lLmdpdGh1Yi5pbw==\">username.github.io</span>。然后修改站点配置文件中部署地址（repo 对应的字段），将原本的 bitbucket 的仓库地址改为 github 的地址</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo7pve5iwgj312u0a0401.jpg\" alt=\"\" /></p>\n<p>之后进行保存然后三步走，部署成功后你的博客就从 bitbucket 上迁移到 github 中了，这样一来，你整体的博客仓库还是在 bitbucket 中的私有库中，但是 public 文件夹中的公开文件已经被你部署到 github 的仓库中。该保密的信息仍然保密，同时也不影响你绑定自己的域名，一举两得。正常情况下按照上面步骤完成后的博客地址是 <span class=\"exturl\" data-url=\"aHR0cDovL3h4eC5naXRodWIuaW8=\">xxx.github.io</span>，下面就开始绑定自己的域名。</p>\n<h4 id=\"域名购买\"><a class=\"anchor\" href=\"#域名购买\">#</a> 域名购买</h4>\n<p>这个渠道有很多，我就不再一一赘述，我这边以<span class=\"exturl\" data-url=\"aHR0cHM6Ly93YW53YW5nLmFsaXl1bi5jb20vZG9tYWluL3NlYXJjaHJlc3VsdC8/a2V5d29yZD1uaWh5YW8mYW1wO3N1ZmZpeD0uY24mYW1wO2RvbWFpbnR5cGU9emglMkNlbiMvP2tleXdvcmQ9dGVzdCZhbXA7c3VmZml4PWNu\">阿里云的万网域名购买</span>为例，找到合适自己的域名</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo7pjuuq4mj313u0hkqdt.jpg\" alt=\"\" /></p>\n<h4 id=\"域名解析\"><a class=\"anchor\" href=\"#域名解析\">#</a> 域名解析</h4>\n<p>购买域名并且按照他的步骤实名认证之后，需要把域名解析到我们的博客中，在阿里云的控制台找到域名右侧对应的解析按钮。点击然后添加解析</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo7q32hh49j31800h5ae1.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo7q3yyhfij31780anq46.jpg\" alt=\"\" /></p>\n<p>然后按照如下填写添加解析，记得把记录值替换成你自己的博客地址</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo7q5sss5oj30kr0bkq3n.jpg\" alt=\"\" /></p>\n<p>之后记得启用该记录，不过如果你像我一样是阿里云购买并且配置的话是不需要启用的，默认帮你启用。</p>\n<h4 id=\"仓库配置\"><a class=\"anchor\" href=\"#仓库配置\">#</a> 仓库配置</h4>\n<p>然后回到你的 github 仓库，进入你的仓库设置页面，找到如下字段，在红框处添加你的域名，然后保存即可</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo7qbo2111j30t10i7goa.jpg\" alt=\"\" /></p>\n<h4 id=\"博客配置\"><a class=\"anchor\" href=\"#博客配置\">#</a> 博客配置</h4>\n<p>回到你的博客目录，在 source 目录下创建一个 &lt;font color=red&gt; 不带任何后缀的 &lt;/font &gt; 文件，命名为 CNAME，里面填写你的域名，我是这样，只添加你的域名不要添加其他东西。然后保存 执行三步之后就可以通过你的域名访问你的博客啦，如果不能访问可能是因为运营商 DNS 缓存问题。等几分钟就可以了。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo7qe2vzuzj30s202ydfw.jpg\" alt=\"\" /></p>\n<h2 id=\"十一实现https协议\"><a class=\"anchor\" href=\"#十一实现https协议\">#</a> 十一：实现 https 协议</h2>\n<p>按照以上步骤完成后可以通过域名访问，但是有个问题就是如果你用谷歌浏览器或者 Safari，他就会提示你网站不被信任，只有你点击仍要继续才会展示你的博客，并且地址栏里面还是有个红色的 ×，虽说不影响使用和阅读，但是还是感觉别扭，这次我们来讲如何将自己的博客协议改为 Https。这里有几种方法：</p>\n<ul>\n<li>\n<p>购买证书</p>\n</li>\n<li>\n<p>使用免费 CA 证书。腾讯云阿里云都有提供。不过有时间限制</p>\n</li>\n<li>\n<p>使用 CDN 进行反向代理</p>\n</li>\n</ul>\n<p>如果使用上两步的话基本上证书的服务商都会告诉你如何配置，他们的文档讲的一定比我的详细，不过主要原因是我们使用的 github Page 是不支持上传证书的，所以这里主要说下第三步，通过 CDN 配置反向代理，这里就需要用到一个国外的 CDN 服务提供商<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20v\"> Cloudflare</span>:</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo7utpfih2j30wz07mju7.jpg\" alt=\"\" /></p>\n<h4 id=\"原理\"><a class=\"anchor\" href=\"#原理\">#</a> 原理</h4>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20v\">Cloudflare</span> 提供 DNS 解析服务，而且速度很快，在阿里云半个小时才能生效的解析在它这里瞬间就生效，它提供了免费的 https 服务 (但不是应用 SSL 证书)。实现模式就是，用户到 CDN 服务器的连接为 https，而 CDN 服务器到 GithubPage 服务器的连接为 http，就是在 CDN 服务器那里加上反向代理。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo7v9apbogj30t004ydg6.jpg\" alt=\"\" /></p>\n<p>用户看到的小锁其实是用户连接到 Cloudflare 的证书，而由 Cloudflare 到 github 是没有 https 的，不过对于我们静态博客已经够了。</p>\n<h4 id=\"配置\"><a class=\"anchor\" href=\"#配置\">#</a> 配置</h4>\n<h6 id=\"第一步\"><a class=\"anchor\" href=\"#第一步\">#</a> 第一步：</h6>\n<p>还是先去官网注册，然后添加你的域名，注意添加的是你购买的域名。</p>\n<h6 id=\"第二步\"><a class=\"anchor\" href=\"#第二步\">#</a> 第二步：</h6>\n<p>进入 DNS 解析界面填入如下解析，因为我们使用 clouldflare 做 DNS 解析所以一会我们需要把我们购买域名的那个地方的解析删掉。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo7vibz0a6j30rv0kagns.jpg\" alt=\"\" /></p>\n<p>其中前两个是使你的域名指向 github 的服务器地址，github 文档中给的就是这个两个地址，<span class=\"exturl\" data-url=\"aHR0cDovL3huLS1DTkFNRWdpdGh1YnVzZXJuYW1lLWZ2ODNhejlncDJkMjA0YmphNWZ5MDJsMGw1YjZvZTNwNmF2dXYyeWYzNThsY2E3ODM1cDJnbWIuZ2l0aHViLmlv\">最后那个 CNAME 记录指向的是你的 github 仓库域名 username.github.io</span>。一定要严格按照这个来配置。</p>\n<h6 id=\"第三步\"><a class=\"anchor\" href=\"#第三步\">#</a> 第三步：</h6>\n<p>记录下 cloudflare 给你的 DNS 解析服务器，就在上一步那个页面下边，用这个记录去把你域名购买处（我的是阿里云）的 DNS 解析服务器替换掉，同时删掉阿里云里面的 DNS 解析记录，因为我们以后就靠 clouleflare 来解析 DNS 啦。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo7vnm5itzj30qy03c74a.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo7vqjin22j316i0ib77n.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo7vse0wewj316u09tmys.jpg\" alt=\"\" /></p>\n<h6 id=\"第四步\"><a class=\"anchor\" href=\"#第四步\">#</a> 第四步：</h6>\n<p>回到 clouldflare 上面选择 crypto 选项然后下面选择 full 或者是 Flexible</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo7vwnoasij30wx0f8myk.jpg\" alt=\"\" /></p>\n<p>选项中几个的区别如下图</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo7vxck29zj30k00cv0sp.jpg\" alt=\"\" /></p>\n<p>最后那个是需要证书支持的。然后滚动到下面打开 always use HTTPS 开关</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo7vy66223j30rn06dwet.jpg\" alt=\"\" /></p>\n<h6 id=\"第五步\"><a class=\"anchor\" href=\"#第五步\">#</a> 第五步：</h6>\n<p>以上步骤配置好之后基本就完成了，但是如果直接有人在地址栏里面输入 http://XXXXX 进入你的博客的话你这边还是会出现非 Https 的效果，所以我们这里要做一个强制跳转。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo7w1ksr94j30uu0ir76a.jpg\" alt=\"\" /></p>\n<p>这样就万无一失了。</p>\n<h6 id=\"坑点\"><a class=\"anchor\" href=\"#坑点\">#</a> 坑点：</h6>\n<p>我之前按照以上步骤操作完成后发现首页虽然是 https 了也不显示红叉了，但是也没有显示绿色的小锁，而是一个叹号，但是有些博文页面可以正常显示 https 绿锁。后来发现是因为当前页面中有非 https 的链接导致，比如图片图床不是 https 的，或者评论插件不支持 https，不过我博客中使用的来必力评论是支持 https，只是我当时的图床无都是 http 所以只能是显示叹号了，后来把所有图片图床换成 https 的就好啦。</p>\n<h2 id=\"十二为博客添加音乐\"><a class=\"anchor\" href=\"#十二为博客添加音乐\">#</a> 十二：为博客添加音乐</h2>\n<p>HEXO 博客添加的音乐的地方有两个。一个个首页侧边栏，另一个是每个页面里面。但是个人觉得添加侧边栏里面并不好，因为添加侧边栏的话用户只有在浏览你首页的时候才能听到音乐，而且期间不能点击任何站内链接，否则音乐就会中断，试想下，一般首页都是文章列表，点击文章里面之后才是正文，所以用户在首页停留的时间很短，基本上找到自己想看的文章就会马上点进去看，所以这里放音乐没有太大意义；而页面内插入音乐会更好点，读者可以一边浏览文章一边听音乐，这也正是我们想要的。不过解决前者问题的办法也不是没有，比如点击链接的话直接开另一个浏览器标签来打开新页面也可以做到不中断音乐，但是总觉得有点小题大做了。总不能读者看个你的博客而占用了一堆标签。</p>\n<h4 id=\"网易云音乐外链\"><a class=\"anchor\" href=\"#网易云音乐外链\">#</a> 网易云音乐外链</h4>\n<p>这个是最简单的方法，通过网易云音乐官网生成播放器外链。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1fordugrc80j315s0swthy.jpg\" alt=\"\" /></p>\n<p>可以自己配置一些属性，然后自动生成配置代码，放到你的博客里面就行啦，粘贴到你文章中想要的地方</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1forduyu7laj31hm0zkaft.jpg\" alt=\"\" /></p>\n<p>优点缺点截图上也有，不过网上也说这样的方式会影响 SEO，具体什么原理也不太清楚。总之简单便捷，不过网易的 logo 去不掉。</p>\n<h4 id=\"aplayer\"><a class=\"anchor\" href=\"#aplayer\">#</a> <span class=\"exturl\" data-url=\"aHR0cHM6Ly9hcGxheWVyLmpzLm9yZy9kb2NzLyMvP2lkPW9wdGlvbnM=\">aplayer</span> 添加音乐</h4>\n<p>这个算是 HEXO 最常用也是最出名名的播放器了，还有 Dpleyer 是用来视屏播放的，暂时我们不说。首先需要安装 aplayer 依赖，终端中切换到你的博客根目录执行  <code>npm install aplayer --save</code>  安装成功后就可以了。参数就不给大家一一讲解了，官方文档都有，我这里只提供一个例子。</p>\n<h6 id=\"页面中添加音乐\"><a class=\"anchor\" href=\"#页面中添加音乐\">#</a> 页面中添加音乐</h6>\n<p><figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% aplayerlist %&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;autoplay&quot;</span>: true,</span><br><span class=\"line\">    <span class=\"string\">&quot;showlrc&quot;</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;mutex&quot;</span>: true,</span><br><span class=\"line\">    <span class=\"string\">&quot;music&quot;</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;title&quot;</span>: <span class=\"string\">&quot;에필로그 (Epilogue)&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;author&quot;</span>: <span class=\"string\">&quot;이동준&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;url&quot;</span>: <span class=\"string\">&quot;https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%8B%E1%85%A6%E1%84%91%E1%85%B5%E1%86%AF%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3.mp3&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;pic&quot;</span>: <span class=\"string\">&quot;https://y.gtimg.cn/music/photo_new/T002R300x300M000000RmZHf3qhLUL.jpg?max_age=2592000&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;lrc&quot;</span>: <span class=\"string\">&quot;https://歌词.lrc&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;% endaplayerlist %&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 以上代码插到文章中任意一个你想的地方就可以</p>\n<p>pic 就是歌曲显示图片的链接。大家可以看到 music 是个数组，所以想添加列表的话就在数组中再添加个歌曲字典就好了。建议歌词 lrc 要用 URL 形式，不然 txt 格式可能要编辑死。。好多人问歌曲的 MP3 外链从哪里来。这个其实很简单，首先把歌曲下载下来然后上传到七牛云就可以在七牛云生成外链啦，七牛云有免费的存储空间，只存歌曲的话足够啦。歌词 URL</p>\n<h6 id=\"侧边栏中添加音乐\"><a class=\"anchor\" href=\"#侧边栏中添加音乐\">#</a> 侧边栏中添加音乐</h6>\n<p>其实之前讲过，不建议在侧边栏中添加，但是这里还是简单介绍下。首先要做的是在 <code>node_modules</code>  目录下找到  <code>APlayer.min.js</code>  文件，将其复制到  <code>theme/next/source/js/src/</code>  目录下。然后打开  <code>theme/next/layout/_custom/</code>  文件夹下的  <code>sidebar.swig</code>  文件，向其中添加以下代码：</p>\n<p><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">&quot;player1&quot;</span> class=<span class=\"string\">&quot;aplayer&quot;</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">&quot;/js/src/APlayer.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script type=<span class=\"string\">&quot;text/javascript&quot;</span>&gt;</span><br><span class=\"line\">var ap = new APlayer(&#123;</span><br><span class=\"line\">    element: document.getElementById(<span class=\"string\">&#x27;player1&#x27;</span>),                       <span class=\"regexp\">//</span> Optional, player element</span><br><span class=\"line\">    narrow: false,                                                     <span class=\"regexp\">//</span> Optional, narrow style</span><br><span class=\"line\">    autoplay: false,                                                    <span class=\"regexp\">//</span> Optional, autoplay song(s), not supported by mobile browsers</span><br><span class=\"line\">    showlrc: <span class=\"number\">0</span>,                                                        <span class=\"regexp\">//</span> Optional, show lrc, can be <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, see: <span class=\"comment\">###With lrc</span></span><br><span class=\"line\">    mutex: true,                                                       <span class=\"regexp\">//</span> Optional, pause other players when this player playing</span><br><span class=\"line\">    theme: <span class=\"string\">&#x27;#e6d0b2&#x27;</span>,                                                  <span class=\"regexp\">//</span> Optional, theme color, default: <span class=\"comment\">#b7daff</span></span><br><span class=\"line\">    mode: <span class=\"string\">&#x27;random&#x27;</span>,                                                    <span class=\"regexp\">//</span> Optional, play mode, can be `random` `single` `circulation`(loop) `order`(no loop), default: `circulation`</span><br><span class=\"line\">    preload: <span class=\"string\">&#x27;metadata&#x27;</span>,                                               <span class=\"regexp\">//</span> Optional, the way to load music, can be <span class=\"string\">&#x27;none&#x27;</span> <span class=\"string\">&#x27;metadata&#x27;</span> <span class=\"string\">&#x27;auto&#x27;</span>, default: <span class=\"string\">&#x27;auto&#x27;</span></span><br><span class=\"line\">    listmaxheight: <span class=\"string\">&#x27;513px&#x27;</span>,                                             <span class=\"regexp\">//</span> Optional, max height of play list</span><br><span class=\"line\">    music: [</span><br><span class=\"line\">    &#123;                                                           <span class=\"regexp\">//</span> Required, music info, see: <span class=\"comment\">###With playlist</span></span><br><span class=\"line\">        title: <span class=\"string\">&#x27;Sometimes When We Touch&#x27;</span>,                                          <span class=\"regexp\">//</span> Required, music title</span><br><span class=\"line\">        author: <span class=\"string\">&#x27;Oliveia&#x27;</span>,                                              <span class=\"regexp\">//</span> Required, music author</span><br><span class=\"line\">        url: <span class=\"string\">&#x27;https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/SometimesWhenWeTouch.mp3&#x27;</span>,  <span class=\"regexp\">//</span> Required, music url</span><br><span class=\"line\">        pic: <span class=\"string\">&#x27;https://y.gtimg.cn/music/photo_new/T002R300x300M000003LIDEL0NQInJ.jpg?max_age=2592000&#x27;</span>,  <span class=\"regexp\">//</span> Optional, music picture</span><br><span class=\"line\">        lrc: <span class=\"string\">&#x27;https://歌词.lrc&#x27;</span>                   <span class=\"regexp\">//</span> Optional, lrc, see: <span class=\"comment\">###With lrc</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;title&quot;</span>: <span class=\"string\">&quot;大鱼&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;author&quot;</span>: <span class=\"string\">&quot;周深&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;url&quot;</span>: <span class=\"string\">&quot;https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/bigfish.mp3&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;pic&quot;</span>: <span class=\"string\">&quot;https://y.gtimg.cn/music/photo_new/T002R300x300M000004Y7V4s3ug4cC.jpg?max_age=2592000&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;lrc&quot;</span>: <span class=\"string\">&quot;https://歌词.lrc&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 只是换成了 JS 的语法，其实原理，参数都一样。然后执行三步走就可以看到啦，注意有浏览器缓存，所以多刷新几次就会有了。</p>\n<h6 id=\"歌词-音乐外链相关\"><a class=\"anchor\" href=\"#歌词-音乐外链相关\">#</a> 歌词、音乐外链相关</h6>\n<p>歌曲说过大家可以用七牛的免费存储功能，但是会发现一个问题七牛的歌曲外链不支持 https，这会导致配置有 ssl 证书的人掉绿锁，其实如果有这个需求的大家可以放弃七牛，改用腾讯云，这样就 OK 啦，一样的操作。</p>\n<p>好多人问歌词的 URL 好难找啊，去哪里找呢，大家可以看下这个 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL21ldG93b2xmL01ldGluZ0pT\">MeetingJS</span> 这个其实是基于 Aplayer 的一个小封装，目的是简化 Aplayer 的接入成本，但是因为之前我介绍了接入步骤所以这里我们只用它的歌词 API 就可以。 <code>ttps://demo.meting.api.meto.moe/action/metingapi?server=tencent&amp;type=lrc&amp;id=004OQ5Mt0EmEzv</code>  其中要改的只有两个参数 seaver 是音乐平台包含百度、网易、QQ 音乐等平台</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1forkjr7da0j31be0ns43n.jpg\" alt=\"\" /></p>\n<p>id 字段对应的是歌曲的 ID 这个你只要打开个歌曲网页链接里面应该都包含 id。文章结尾的播放就是这么加入的</p>\n<h2 id=\"最后\"><a class=\"anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>整篇文章只有开始一小部分在讲解如何搭建博客，后续的基本都是交给大家如何优化，调整一些细节问题如 UI、用户体验之类的，当然我们能做的远远不止这些，如果有什么问题欢迎与我探讨。下面的留言我都会看的。此外当本人对 HEXO 有新的看法或者玩法的话该文章会不断的更新，希望大家关注我的<a href=\"https://oliverqueen.cn/\">小站</a>，感谢。</p>\n<p>\n        <div id=\"aplayer-xocJHJbr\" class=\"aplayer aplayer-tag-marker\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t  <script>\n\t\t\t\t  var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mutex\":true,\"music\":[{\"title\":\"凉城\",\"author\":\"任然\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/liangcheng.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M0000008nl2Y1HlxUm.jpg?max_age=2592000\",\"lrc\":\"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=002SKEeh1VzObP\"},{\"title\":\"Love Story\",\"author\":\"린 (LYn)\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%85%E1%85%B5%E1%86%AB-Love%20Story.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M0000048KLcQ4LDbZz.jpg?max_age=2592000\",\"lrc\":\"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=0028RAj0187nEg\"},{\"title\":\"大鱼\",\"author\":\"周深\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/bigfish.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M000004Y7V4s3ug4cC.jpg?max_age=2592000\",\"lrc\":\"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=004OQ5Mt0EmEzv\"}]};\n\t\t\t\t  options.element = document.getElementById(\"aplayer-xocJHJbr\");\n\t\t\t\t  var ap = new APlayer(options);\n\t\t\t    window.aplayers || (window.aplayers = []);\n\t\t\t\t  window.aplayers.push(ap);\n\t\t\t  </script></p>\n",
            "tags": [
                "Hexo",
                "个人博客",
                "网站"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-24-%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%85%A8%E7%9A%84iOS%E7%AB%AFHttpDns%E9%9B%86%E6%88%90%E6%96%B9%E6%A1%88/",
            "url": "https://oliverqueen.cn/2018-01-24-%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%85%A8%E7%9A%84iOS%E7%AB%AFHttpDns%E9%9B%86%E6%88%90%E6%96%B9%E6%A1%88/",
            "title": "可能是最全的iOS端HttpDns集成方案",
            "date_published": "2018-01-24T05:54:36.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"科普片\"><a class=\"anchor\" href=\"#科普片\">#</a> 科普片</h1>\n<h5 id=\"1-dns劫持的危害\"><a class=\"anchor\" href=\"#1-dns劫持的危害\">#</a> 1、DNS 劫持的危害</h5>\n<p>不知道大家有没有发现这样一个现象，在打开一些网页的时候会弹出一些与所浏览网页不相关的内容比如这样奇 (se) 怪 (qing) 的东西</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6jm5b190j30h60ugqkg.jpg\" alt=\"图一\" /></p>\n<p>或者这样<br />\n<span id=\"more\"></span></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6jmr1afuj30ww0ue4qp.jpg\" alt=\"图二\" />，</p>\n<p>其实造成这样的原因就是 DNS 劫持，在我们正常浏览的网页链接里面被恶意插入一些奇怪的东西。不止是这些，DNS 劫持还会对我们的个人信息安全造成很大的伤害，钓鱼网站之类的，也许我们所访问的网站根本不是我们需要的网站，或者根本打不开网页，有时还会消耗我们过多的流量。</p>\n<h5 id=\"2-什么是dns解析\"><a class=\"anchor\" href=\"#2-什么是dns解析\">#</a> 2、什么是 DNS 解析</h5>\n<p>现在假如我们访问一个网站 www.baidu.com 从按下回车到百度页面显示到我们的电脑上会经历如下几个步骤</p>\n<ul>\n<li>1：计算机会向我们的运营商 (移动、电信、联通等) 发出打开 www.baidu.com 的请求。</li>\n<li>2：运营商收到请求后会到自己的 DNS 服务器中找 www.baidu.com 这个域名所对应的服务器的 IP 地址 (也就是百度的服务器的 IP 地址)，这里比如是 180.149.132.47。</li>\n<li>3：运营商用第二步得到的 IP 地址去找到百度的服务器请求得到数据后返回给我们。</li>\n</ul>\n<p>其中第二步就是我们所说的 DNS 解析过程，域名和 IP 地址的关系其实就是我们的身份证号和姓名的关系，都是来标记一个人或者是一个网站的，只是 IP 地址 \\ 身份证号只是一串没有意义的数字，辨识度低，又不好记，所以就会在 IP 上加上一个域名以便区分，或是做的更加个性化，但是如果真的要来准确的区分还是要靠身份证号码或者是 IP 的，所以 DNS 解析就应运而生了。</p>\n<h5 id=\"3什么是dns劫持\"><a class=\"anchor\" href=\"#3什么是dns劫持\">#</a> 3：什么是 DNS 劫持</h5>\n<p>DNS 劫持，是指在 DNS 解析过程中拦截域名解析的请求，然后做一些自己的处理，比如返回假的 IP 地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能反应或访问的是假网址。根本原因就是以下两点：</p>\n<ul>\n<li>1：恶意攻击，拦截运营商的解析过程，把自己的非法东西嵌入其中。</li>\n<li>2：运营商为了利益或者一些其他的因素，允许一些第三方在自己的链接里打打广告之类的。</li>\n</ul>\n<h5 id=\"4防止dns劫持\"><a class=\"anchor\" href=\"#4防止dns劫持\">#</a> 4：防止 DNS 劫持</h5>\n<p>了解了 DNS 劫持的相关资料后我们就知道了，防止 NDS 劫持就要从第二步入手，因为 DNS 解析过程是运营商来操作的，我们不能去干涉他们，不然我们也就成了劫持者了，所以我们要做的就是在我们请求之前对我们的请求链接做一些修改，<span class=\"exturl\" data-url=\"aHR0cDovL3huLS13d3ctb3Q5ZHg4c3k0bm9qa284Y2c2azl1bmtwMWF3ODBkb3N5YS5iYWlkdS5jb20=\">将我们原本的请求链接 www.baidu.com</span> 修改为 180.149.132.47，然后请求出去，这样的话就运营商在拿到我们的请求后发现我们直接用的就是 IP 地址就会直接给我们放行，而不会去走他自己 DNS 解析了，也就是说我们把运营商要做的事情自己先做好了。不走他的 DNS 解析也就不会存在 DNS 被劫持的问题，从根本是解决了。</p>\n<h1 id=\"技术篇\"><a class=\"anchor\" href=\"#技术篇\">#</a> 技术篇</h1>\n<h5 id=\"5项目中的实际操作\"><a class=\"anchor\" href=\"#5项目中的实际操作\">#</a> 5：项目中的实际操作</h5>\n<h6 id=\"51dnspod相关\"><a class=\"anchor\" href=\"#51dnspod相关\">#</a> 5.1：DNSPOD 相关</h6>\n<p>我们知道要要把项目中请求的接口替换成成 IP 其实很简单，URL 是字符串，域名替换 IP，无非就是一个字符串替换而已，的确这块其实没有什么技术含量，而且现在像阿里云 (没开源)，七牛云 (开源)，等一些比较大的平台在这方面也都有了比较成熟的解决方案，一个 SDK，传个普通的 URL 进去就会返回一个域名被替换成 IP 的 URL 出来，也比较好用，这里要说一下 IP 地址的来源，如何拿到一个域名所对应的 IP 呢？这里就是需要用到另一个服务 ——HTTPDNS，国内比较有名的就是 DNSPOD，包括阿里，七牛等也是使用他们的 DNS 服务来解析，就是这个</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6jnbe2zhj30sa0i8dwv.jpg\" alt=\"DNSPOD logo\" /></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6jnt2uw9j31kw0icava.jpg\" alt=\"简介\" /></p>\n<p>他会给我们提供一个接口，我们使用 HTTP 请求的方式去请求这个接口，参数带上我们的域名，他们就会把域名对应的 IP 列表返回回来。类似这样：<br />\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///这个请求URL的结构是固定的119.29.29.29是DNSPOD固定的服务器地址，ttl参数的意思是返回结果是否带ttl是个BOOL，dn就是我们需要解析的域名，id就是我们在dnspod上注册时候他给我们的一个KEY</span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *url = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@&quot;http://119.29.29.29/d?ttl=1&amp;dn=www.baidu.com&amp;id=KEY&quot;</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSMutableURLRequest</span> * request = [<span class=\"built_in\">NSMutableURLRequest</span> requestWithURL:[<span class=\"built_in\">NSURL</span> URLWithString:url] cachePolicy:<span class=\"built_in\">NSURLRequestUseProtocolCachePolicy</span> timeoutInterval:<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSData</span> * data = [<span class=\"built_in\">NSURLConnection</span> sendSynchronousRequest:request returningResponse:<span class=\"literal\">nil</span> error:&amp;networkError];</span><br></pre></td></tr></table></figure></p>\n<p>这里使用同步还是异步都是可以的，具体根据你们业务需求。</p>\n<h6 id=\"52项目中的使用\"><a class=\"anchor\" href=\"#52项目中的使用\">#</a> 5.2：项目中的使用</h6>\n<p>其实 dnspod 最难的部分是接入的部分，因为不同的 APP 不同的网络环境会导致各种各样的问题，如果你是一个新的项目那么接入难度会大大降低，因为你完全可以自己封装一套网络请求，把 DNS 解析相关的逻辑都封装到自己的网络请求中，这样你就可以得到 APP 所有的网络层的控制权，想干什么就干什么，但是如果是在一个已经比较完善的 APP 中加入 DNS 防劫持的话那就是比较困难，因为你不能拿到所有网络请求的控制权这篇文章中我主要使用是 NSURLProtocol + Runtime hook 方式来处理这些东西的，NSURLProtocol 属于 iOS 黑魔法的一种可以拦截任何从 APP 的 URL Loading System 系统中发出的请求，其中包括如下</p>\n<ul>\n<li>File Transfer Protocol (ftp://)</li>\n<li>Hypertext Transfer Protocol (http://)</li>\n<li>Hypertext Transfer Protocol with encryption (https://)</li>\n<li>Local file URLs (file:///)</li>\n<li>Data URLs (data://)</li>\n</ul>\n<p>如果你的请求不在以上列表中就不能进行拦截了，比如 WKWebview，AVPlayer (比较特殊，虽然请求也是 http/https 但是就是不走这套系统，苹果爸爸就是这样～) 等，其实对于正常来说光用已经 NSURLProtocol 足够了。<br />\n  NSURLProtocol 这个类我们不能直接使用，我们需要自己创建一个他的子类然后在我们的子类中操作他们像这样<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 注册自定义protocol</span></span><br><span class=\"line\">[<span class=\"built_in\">NSURLProtocol</span> registerClass:[CustomURLProtocol <span class=\"keyword\">class</span>]];</span><br><span class=\"line\"> <span class=\"built_in\">NSURLSessionConfiguration</span> *configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">configuration.protocolClasses = @[[CustomURLProtocol <span class=\"keyword\">class</span>]];</span><br></pre></td></tr></table></figure><br />\n 在这个类中我们可以拦截到请求，然后进行处理。这个类中有四个非常重要的方法<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"type\">BOOL</span>)canInitWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLRequest</span> *)canonicalRequestForRequest:(<span class=\"built_in\">NSURLRequest</span> *)request;</span><br><span class=\"line\">- (<span class=\"type\">void</span>)startLoading;</span><br><span class=\"line\"><span class=\"comment\">//对于拦截的请求，NSURLProtocol对象在停止加载时调用该方法</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)stopLoading;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"boolcaninitwithrequestnsurlrequest-request\"><a class=\"anchor\" href=\"#boolcaninitwithrequestnsurlrequest-request\">#</a> + (BOOL)canInitWithRequest:(NSURLRequest *)request;</h6>\n<p>通过返回值来告诉 NSUrlProtocol 对进来的请求是否拦截，比如我只拦截 HTTP 的，或者是某个域名的请求之类</p>\n<h6 id=\"nsurlrequest-canonicalrequestforrequestnsurlrequest-request\"><a class=\"anchor\" href=\"#nsurlrequest-canonicalrequestforrequestnsurlrequest-request\">#</a> + (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request;</h6>\n<p>如果上面的方法返回 YES 那么 request 会传到这里，这个地方通常不做处理 直接返回 request</p>\n<h6 id=\"-voidstartloading\"><a class=\"anchor\" href=\"#-voidstartloading\">#</a> - (void)startLoading;</h6>\n<p>这个地方就是对我们拦截的请求做一些处理，我们文中所做的 IP 对域名的替换就在这里进行，处理完之后将请求转发出去，比如这样<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)startLoading &#123;</span><br><span class=\"line\"><span class=\"comment\">///其中customRequest是处理过的请求(域名替换后的)</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLSession</span> *session = [<span class=\"built_in\">NSURLSession</span> sessionWithConfiguration:[[<span class=\"built_in\">NSURLSessionConfiguration</span> alloc] init] delegate:<span class=\"keyword\">self</span> delegateQueue:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:customRequest];</span><br><span class=\"line\">    [task resume];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 你可以在 - startLoading 中使用任何方法来对协议对象持有的 request 进行转发，包括 NSURLSession、 NSURLConnection 甚至使用 AFNetworking 等网络库，只要你能在回调方法中把数据传回 client，帮助其正确渲染就可以，比如这样：<br />\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session dataTask:(<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTask didReceiveResponse:(<span class=\"built_in\">NSURLResponse</span> *)response completionHandler:(<span class=\"type\">void</span> (^)(<span class=\"built_in\">NSURLSessionResponseDisposition</span>))completionHandler &#123;</span><br><span class=\"line\">    [[<span class=\"keyword\">self</span> client] URLProtocol:<span class=\"keyword\">self</span> didReceiveResponse:response cacheStoragePolicy:<span class=\"built_in\">NSURLCacheStorageAllowed</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    completionHandler(<span class=\"built_in\">NSURLSessionResponseAllow</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session dataTask:(<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class=\"built_in\">NSData</span> *)data &#123;</span><br><span class=\"line\">    [[<span class=\"keyword\">self</span> client] URLProtocol:<span class=\"keyword\">self</span> didLoadData:data];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\nclient 在后面会有讲解。</p>\n<h6 id=\"-voidstoploading\"><a class=\"anchor\" href=\"#-voidstoploading\">#</a> - (void)stopLoading;</h6>\n<p>请求完毕后调用<br />\n大概的执行流程是这样</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6jtpp3z0j30ze1by122.jpg\" alt=\"流程\" /></p>\n<p>在 NSURLProtocol 中有一个贯穿始终的变量<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*!</span></span><br><span class=\"line\"><span class=\"comment\">    @method client</span></span><br><span class=\"line\"><span class=\"comment\">    @abstract Returns the NSURLProtocolClient of the receiver.</span></span><br><span class=\"line\"><span class=\"comment\">    @result The NSURLProtocolClient of the receiver.  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">readonly</span>, <span class=\"keyword\">retain</span>) <span class=\"type\">id</span> &lt;<span class=\"built_in\">NSURLProtocolClient</span>&gt; client;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 你可以认为是这个是请求的发送者，打个比方，A 想给 B 发送一个消息，由于距离遥远于是 A 去了邮局，A 把消息内容告诉了邮局，并且 A 在邮局登记了自己名字方便 B 有反馈的时候邮局来通知 A 查收。这个例子中邮局就是 NSURLProtocol，A 在邮局登记的名字就是 client。所有的 client 都实现了 NSURLProtocolClient 协议，协议的作用就是在 HTTP 请求发出以及接受响应时向其它对象传输数据：<br />\n<figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@protocol NSURLProtocolClient &lt;NSObject&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">- <span class=\"params\">(void)</span>URLProtocol:<span class=\"params\">(NSURLProtocol *)</span>protocol didReceiveResponse:<span class=\"params\">(NSURLResponse *)</span>response cacheStoragePolicy:<span class=\"params\">(NSURLCacheStoragePolicy)</span>policy;</span><br><span class=\"line\"></span><br><span class=\"line\">- <span class=\"params\">(void)</span>URLProtocol:<span class=\"params\">(NSURLProtocol *)</span>protocol didLoadData:<span class=\"params\">(NSData *)</span>data;</span><br><span class=\"line\"></span><br><span class=\"line\">- <span class=\"params\">(void)</span>URLProtocolDidFinishLoading:<span class=\"params\">(NSURLProtocol *)</span>protocol;</span><br><span class=\"line\">...</span><br><span class=\"line\">@<span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure><br />\n 当然这个协议中还有很多其他的方法，比如 HTTPS 验证、重定向以及响应缓存相关的方法，你需要在合适的时候调用这些代理方法，对信息进行传递。<br />\n到此正常情况下的 DNS 的解析过程已经结束，如果你发现按照如上操作之后并没有达到预期效果那么请往下看，(通常情况下完成以上操作 原有的 URL 的就会变成 http://123.456.789.123/XXX/XXX/XXX 的格式。如果发现请求不成功就往下看吧)</p>\n<h5 id=\"6遇到的坑点\"><a class=\"anchor\" href=\"#6遇到的坑点\">#</a> 6：遇到的坑点</h5>\n<h6 id=\"61我们知道运营商本来是根据域名来确定一个url的我们将域名改为ip之后虽然不用运营商帮我们解析了但是运营商在收到一串数字的时候也是懵逼状态我们还是需要将域名传给他们但是不能用正常的方式传我们需要把原来的域名加到http请求的header中的host字段下根据http协议的规定如果在url中无法找到域名的话就会去header中找这样一来我们既把域名告诉了运营商同时也直接制定了ip地址这个是必须配置的不然的话是请求不成功的\"><a class=\"anchor\" href=\"#61我们知道运营商本来是根据域名来确定一个url的我们将域名改为ip之后虽然不用运营商帮我们解析了但是运营商在收到一串数字的时候也是懵逼状态我们还是需要将域名传给他们但是不能用正常的方式传我们需要把原来的域名加到http请求的header中的host字段下根据http协议的规定如果在url中无法找到域名的话就会去header中找这样一来我们既把域名告诉了运营商同时也直接制定了ip地址这个是必须配置的不然的话是请求不成功的\">#</a> 6.1：我们知道运营商本来是根据域名来确定一个 URL 的，我们将域名改为 IP 之后虽然不用运营商帮我们解析了，但是运营商在收到一串数字的时候也是懵逼状态，我们还是需要将域名传给他们，但是不能用正常的方式传，我们需要把原来的域名加到 http 请求的 Header 中的 host 字段下，根据 Http 协议的规定，如果在 URL 中无法找到域名的话就会去 Header 中找，这样一来我们既把域名告诉了运营商同时也直接制定了 IP 地址，这个是必须配置的，不然的话是请求不成功的。</h6>\n<p><figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mutableRequest <span class=\"built_in\">set</span>Value:<span class=\"literal\">self</span>.request.URL.host <span class=\"keyword\">for</span>HTTPHeaderField:@<span class=\"string\">&quot;HOST&quot;</span>];</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"加上header再去请求就没问题了不过有些特殊的情况下会需要带上cookie同样也是加到header中\"><a class=\"anchor\" href=\"#加上header再去请求就没问题了不过有些特殊的情况下会需要带上cookie同样也是加到header中\">#</a> 加上 Header 再去请求就没问题了，不过有些特殊的情况下会需要带上 cookie，同样也是加到 Header 中</h6>\n<p><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">mutableRequest setValue:YOUR Cookie forHTTPHeaderField:@<span class=\"string\">&quot;Cookie&quot;</span></span>];</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"62关于afnetworking的问题现在大部分网络请求是基于afnetworking的这里有一个坑我们知道我们注册customprotocol的时候是这样\"><a class=\"anchor\" href=\"#62关于afnetworking的问题现在大部分网络请求是基于afnetworking的这里有一个坑我们知道我们注册customprotocol的时候是这样\">#</a> 6.2：关于 AfNetworking 的问题，现在大部分网络请求是基于 Afnetworking 的，这里有一个坑，我们知道我们注册 CustomProtocol 的时候是这样</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 注册自定义protocol</span></span><br><span class=\"line\">[<span class=\"built_in\">NSURLProtocol</span> registerClass:[CustomURLProtocol <span class=\"keyword\">class</span>]];</span><br><span class=\"line\"> <span class=\"built_in\">NSURLSessionConfiguration</span> *configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">configuration.protocolClasses = @[[CustomURLProtocol <span class=\"keyword\">class</span>]];</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"在系统的configuration加入我们的customprotocolprotocolclasses是一个数组里面可以放很多各种不同的customprotocol我们看一下afnetworking的初始化方法\"><a class=\"anchor\" href=\"#在系统的configuration加入我们的customprotocolprotocolclasses是一个数组里面可以放很多各种不同的customprotocol我们看一下afnetworking的初始化方法\">#</a> 在系统的 configuration 加入我们的 CustomProtocol，protocolClasses 是一个数组里面可以放很多各种不同的 CustomProtocol，我们看一下 afnetworking 的初始化方法。</h6>\n<p><figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AFHTTPSessionManager * sessionManager <span class=\"operator\">=</span> [AFHTTPSessionManager manager]<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure></p>\n<h6 id=\"我相信大家通常都会这么来创建但是这里我要说下manager并不是一个单利最后都会调到一个方法\"><a class=\"anchor\" href=\"#我相信大家通常都会这么来创建但是这里我要说下manager并不是一个单利最后都会调到一个方法\">#</a> 我相信大家通常都会这么来创建，但是这里我要说下 manager 并不是一个单利，最后都会调到一个方法</h6>\n<p><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">-</span> (instancetype)initWithSessionConfiguration:(<span class=\"type\">NSURLSessionConfiguration</span> <span class=\"operator\">*</span>)configuration &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> <span class=\"operator\">=</span> [<span class=\"keyword\">super</span> <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"operator\">!</span><span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"operator\">!</span>configuration) &#123;</span><br><span class=\"line\">        configuration <span class=\"operator\">=</span> [<span class=\"type\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.sessionConfiguration <span class=\"operator\">=</span> configuration;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.operationQueue <span class=\"operator\">=</span> [[<span class=\"type\">NSOperationQueue</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.operationQueue.maxConcurrentOperationCount <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.session <span class=\"operator\">=</span> [<span class=\"type\">NSURLSession</span> sessionWithConfiguration:<span class=\"keyword\">self</span>.sessionConfiguration delegate:<span class=\"keyword\">self</span> delegateQueue:<span class=\"keyword\">self</span>.operationQueue];</span><br><span class=\"line\">    .</span><br><span class=\"line\">    .</span><br><span class=\"line\">    .</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h6 id=\"大家注意第二个判断如果没有传入configuration的话他会创建一个默认的这样以至于我们之前在configuration的protocolclasses中注册类全部被这个新的configuration替换掉了所以无法解析-这里我采取的办法就是runtime-hook因为hook第三方的代码并不是一个很好的办法所以我直接hook-nsurlsession的sessionwithconfiguration方法因为通过观察afnetworking的源码最终都是走到这里的-hook之后把自己的configuration换进去像这样\"><a class=\"anchor\" href=\"#大家注意第二个判断如果没有传入configuration的话他会创建一个默认的这样以至于我们之前在configuration的protocolclasses中注册类全部被这个新的configuration替换掉了所以无法解析-这里我采取的办法就是runtime-hook因为hook第三方的代码并不是一个很好的办法所以我直接hook-nsurlsession的sessionwithconfiguration方法因为通过观察afnetworking的源码最终都是走到这里的-hook之后把自己的configuration换进去像这样\">#</a> 大家注意第二个判断，如果没有传入 configuration 的话他会创建一个默认的，这样以至于我们之前在 configuration 的 protocolClasses 中注册类全部被这个新的 configuration 替换掉了，所以无法解析。这里我采取的办法就是 runtime hook，因为 hook 第三方的代码并不是一个很好的办法，所以我直接 hook NSURLSession 的 sessionWithConfiguration 方法，因为通过观察 Afnetworking 的源码最终都是走到这里的。Hook 之后把自己的 configuration 换进去，像这样</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">NSURLSession</span> *)swizzle_sessionWithConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionConfiguration</span> *newConfiguration = configuration;</span><br><span class=\"line\">    <span class=\"comment\">// 在现有的Configuration中插入我们自定义的protocol</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (configuration) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSMutableArray</span> *protocolArray = [<span class=\"built_in\">NSMutableArray</span> arrayWithArray:configuration.protocolClasses];</span><br><span class=\"line\">        [protocolArray insertObject:[CustomProtocol <span class=\"keyword\">class</span>] atIndex:<span class=\"number\">0</span>];</span><br><span class=\"line\">        newConfiguration.protocolClasses = protocolArray;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newConfiguration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">        <span class=\"built_in\">NSMutableArray</span> *protocolArray = [<span class=\"built_in\">NSMutableArray</span> arrayWithArray:configuration.protocolClasses];</span><br><span class=\"line\">        [protocolArray insertObject:[CustomProtocol <span class=\"keyword\">class</span>] atIndex:<span class=\"number\">0</span>];</span><br><span class=\"line\">        newConfiguration.protocolClasses = protocolArray;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> swizzle_sessionWithConfiguration:newConfiguration];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"然后就完美解决了-不过要注意下系统的是有两个方法的\"><a class=\"anchor\" href=\"#然后就完美解决了-不过要注意下系统的是有两个方法的\">#</a> 然后就完美解决了。不过要注意下系统的是有两个方法的</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Customization of NSURLSession occurs during creation of a new session.</span></span><br><span class=\"line\"><span class=\"comment\"> * If you only need to use the convenience routines with custom</span></span><br><span class=\"line\"><span class=\"comment\"> * configuration options it is not necessary to specify a delegate.</span></span><br><span class=\"line\"><span class=\"comment\"> * If you do specify a delegate, the delegate will be retained until after</span></span><br><span class=\"line\"><span class=\"comment\"> * the delegate has been sent the URLSession:didBecomeInvalidWithError: message.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLSession</span> *)sessionWithConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLSession</span> *)sessionWithConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration delegate:(<span class=\"keyword\">nullable</span> <span class=\"type\">id</span> &lt;<span class=\"built_in\">NSURLSessionDelegate</span>&gt;)delegate delegateQueue:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSOperationQueue</span> *)queue;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"这两个方法不能确定最终会走那个所以为了保险起见都hook下hook的方式是一样的\"><a class=\"anchor\" href=\"#这两个方法不能确定最终会走那个所以为了保险起见都hook下hook的方式是一样的\">#</a> 这两个方法不能确定最终会走那个，所以为了保险起见都 hook 下，hook 的方式是一样的</h6>\n<h6 id=\"63avplayer请求avplayer是我们ios系统中系统自带的播放视频的框架用到地方也很多但是这个是比较坑的因为avplayer虽然也有httphttpsfile请求这个概念但是avplayer所有的请求都不会走url-loading-system也就是说所有由avplayer发出的请求都不能被我们的customprotocol拦截这时候大家也许会问不对呀我们正常调试的时候可以被拦截到的啊-其实苹果官方上是说avplayer在真机调试和模拟器调试时候走的完全不是一套策略也就是说在模拟器运行时候是完全正常的可以被拦截到也可以被解析但是在真机上面就恰恰相反了因为我们最后还是以真机为准所以我们采取的办法还是hook因为我们需要在媒体url传给avplayer前就要将相关东西配置好域名替换啊加host啊之类的所以我们要找avplayer的入口先看初始化方法我发现项目中使用一个avurlasset来初始化avplayer那么avurlasset又是什么呢继续查到avurlasset的初始化方法可以发现这个方法\"><a class=\"anchor\" href=\"#63avplayer请求avplayer是我们ios系统中系统自带的播放视频的框架用到地方也很多但是这个是比较坑的因为avplayer虽然也有httphttpsfile请求这个概念但是avplayer所有的请求都不会走url-loading-system也就是说所有由avplayer发出的请求都不能被我们的customprotocol拦截这时候大家也许会问不对呀我们正常调试的时候可以被拦截到的啊-其实苹果官方上是说avplayer在真机调试和模拟器调试时候走的完全不是一套策略也就是说在模拟器运行时候是完全正常的可以被拦截到也可以被解析但是在真机上面就恰恰相反了因为我们最后还是以真机为准所以我们采取的办法还是hook因为我们需要在媒体url传给avplayer前就要将相关东西配置好域名替换啊加host啊之类的所以我们要找avplayer的入口先看初始化方法我发现项目中使用一个avurlasset来初始化avplayer那么avurlasset又是什么呢继续查到avurlasset的初始化方法可以发现这个方法\">#</a> 6.3：AVPlayer 请求，AVPlayer 是我们 iOS 系统中系统自带的播放视频的框架，用到地方也很多，但是这个是比较坑的，因为 AVPlayer 虽然也有 http/https/file…… 请求这个概念，但是 AVPlayer 所有的请求都不会走 URL Loading System，也就是说所有由 AVPlayer 发出的请求都不能被我们的 CustomProtocol 拦截，这时候大家也许会问，不对呀，我们正常调试的时候可以被拦截到的啊。其实苹果官方上是说 AVPlayer 在真机调试和模拟器调试时候走的完全不是一套策略，也就是说在模拟器运行时候是完全正常的，可以被拦截到也可以被解析，但是在真机上面就恰恰相反了，因为我们最后还是以真机为准，所以我们采取的办法还是 hook，因为我们需要在媒体 URL 传给 AVPlayer 前就要将相关东西配置好，域名替换啊，加 host 啊之类的，所以我们要找 AVPlayer 的入口，先看初始化方法，我发现项目中使用一个 AVURLAsset 来初始化 AVPlayer，那么 AVURLAsset 又是什么呢？继续查到 AVURLAsset 的初始化方法，可以发现这个方法：</h6>\n<p><figure class=\"highlight smali\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*!</span><br><span class=\"line\">  @method\t\tinitWithURL:options:</span><br><span class=\"line\">  @abstract\t\tInitializes an<span class=\"built_in\"> instance </span>of AVURLAsset for inspection of a media resource.</span><br><span class=\"line\">  @param\t\tURL</span><br><span class=\"line\">\t\t\t\tAn<span class=\"built_in\"> instance </span>of NSURL that references a media resource.</span><br><span class=\"line\">  @param\t\toptions</span><br><span class=\"line\">\t\t\t\tAn<span class=\"built_in\"> instance </span>of NSDictionary that contains keys for specifying options for the initialization of the AVURLAsset. See AVURLAssetPreferPreciseDurationAndTimingKey<span class=\"built_in\"> and </span>AVURLAssetReferenceRestrictionsKey above.</span><br><span class=\"line\">  @result\t\tAn<span class=\"built_in\"> instance </span>of AVURLAsset.</span><br><span class=\"line\">*/</span><br><span class=\"line\">- (instancetype)initWithURL:(NSURL *)URL options:(nullable NSDictionary&lt;NSString *, id&gt; *)options NS_DESIGNATED_INITIA<span class=\"class\">LIZER;</span></span><br></pre></td></tr></table></figure></p>\n<h6 id=\"其中url就是我们传给avplayer播放的url找到目标就hook下就可以了具体过程就不多说了还是字符串替换但是有一点需要注意的是我之前上文说过做完ip对域名的替换之后还需要设置下request的host但是这个地方只有一个url并没有request该如何处理呢其实这个方法里面的opinion参数就是处理这个的可以添加cookie之类的类似与httpheader的东西可以添加这几个key\"><a class=\"anchor\" href=\"#其中url就是我们传给avplayer播放的url找到目标就hook下就可以了具体过程就不多说了还是字符串替换但是有一点需要注意的是我之前上文说过做完ip对域名的替换之后还需要设置下request的host但是这个地方只有一个url并没有request该如何处理呢其实这个方法里面的opinion参数就是处理这个的可以添加cookie之类的类似与httpheader的东西可以添加这几个key\">#</a> 其中 URL 就是我们传给 AVPlayer 播放的 URL，找到目标就 Hook 下就可以了，具体过程就不多说了还是字符串替换，但是有一点需要注意的是，我之前上文说过做完 IP 对域名的替换之后还需要设置下 request 的 Host，但是这个地方只有一个 URL 并没有 Request 该如何处理呢？其实这个方法里面的 opinion 参数就是处理这个的，可以添加 cookie 之类的类似与 httpheader 的东西，可以添加这几个 Key</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">AVF_EXPORT</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">AVURLAssetPreferPreciseDurationAndTimingKey</span> <span class=\"built_in\">NS_AVAILABLE</span>(<span class=\"number\">10</span>_7, <span class=\"number\">4</span>_0);</span><br><span class=\"line\"><span class=\"built_in\">AVF_EXPORT</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">AVURLAssetReferenceRestrictionsKey</span> <span class=\"built_in\">NS_AVAILABLE</span>(<span class=\"number\">10</span>_7, <span class=\"number\">5</span>_0);</span><br><span class=\"line\"><span class=\"built_in\">AVF_EXPORT</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">AVURLAssetHTTPCookiesKey</span> <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0);</span><br><span class=\"line\"><span class=\"built_in\">AVF_EXPORT</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">AVURLAssetAllowsCellularAccessKey</span> <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">10</span>_0);</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"但是并没有发现和host相关的key其实这个key是有的就是avurlassethttpheaderfieldskey只是因为这个key没暴露出来-这个地方不太确定是不是苹果的私有api网上查了大量的资料也没有个说法甚至我亲自去苹果开发者去问苹果也没有给任何答复各种说法都有具体使用的话就是\"><a class=\"anchor\" href=\"#但是并没有发现和host相关的key其实这个key是有的就是avurlassethttpheaderfieldskey只是因为这个key没暴露出来-这个地方不太确定是不是苹果的私有api网上查了大量的资料也没有个说法甚至我亲自去苹果开发者去问苹果也没有给任何答复各种说法都有具体使用的话就是\">#</a> 但是并没有发现和 Host 相关的 Key，其实这个 key 是有的就是 AVURLAssetHTTPHeaderFieldsKey 只是因为这个 Key 没暴露出来。这个地方不太确定是不是苹果的私有 API，网上查了大量的资料也没有个说法，甚至我亲自去苹果开发者去问，苹果也没有给任何答复，各种说法都有，具体使用的话就是</h6>\n<p><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"variable language_\">self</span> <span class=\"symbol\">swizzle_initWithURL:</span>videoURL <span class=\"symbol\">options:</span>@&#123;AVURLAssetHTTPHeaderFieldsKey : @&#123;@<span class=\"string\">&quot;Host&quot;</span><span class=\"symbol\">:host</span>&#125;&#125;]</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"这样使用是没有任何问题的但是毕竟是没有暴露出来的方法我们不能这样明目张胆的使用其实对于字符串来说还是比较好规避的只要不要明文出现这个key就可以我在这里使用了一个加密吧key变成密文然后这个地方通过解密获取就像这样\"><a class=\"anchor\" href=\"#这样使用是没有任何问题的但是毕竟是没有暴露出来的方法我们不能这样明目张胆的使用其实对于字符串来说还是比较好规避的只要不要明文出现这个key就可以我在这里使用了一个加密吧key变成密文然后这个地方通过解密获取就像这样\">#</a> 这样使用是没有任何问题的，但是毕竟是没有暴露出来的方法，我们不能这样明目张胆的使用，其实对于字符串来说还是比较好规避的，只要不要明文出现这个 KEY 就可以，我在这里使用了一个加密，吧 key 变成密文然后这个地方通过解密获取，就像这样：</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//加密后的KEY</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">NSString</span> * headerKey = <span class=\"string\">@&quot;35905FF45AFA4C579B7DE2403C7CA0CCB59AA83D660E60C9D444AFE13323618F&quot;</span>;</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\"><span class=\"comment\">//getRequestHeaderKey方法为解密方法</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> swizzle_initWithURL:videoURL options:@&#123;[<span class=\"keyword\">self</span> getRequestHeaderKey] : @&#123;<span class=\"string\">@&quot;Host&quot;</span>:host&#125;&#125;];</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"这样之后就大功告成了avplayer可以在dns被劫持的情况下播放了\"><a class=\"anchor\" href=\"#这样之后就大功告成了avplayer可以在dns被劫持的情况下播放了\">#</a> 这样之后就大功告成了，AVPlayer 可以在 DNS 被劫持的情况下播放了，</h6>\n<h6 id=\"64post请求这块也算是一个大坑我们知道http的post请求会包含一个body体里面包含我们需要上传的参数等一些资料对于post请求我们的nsurlprotocol是可以正常拦截的但是我们拦截之后发现无论怎么样我们获得的body体都为nil后来查了一些资料发下又是苹果爸爸在做手脚-nsurlprotocol在拦截nsurlsession的post请求时不能获取到request中的httpbody这个貌似早就国外的论坛上传开了但国内好像还鲜有人知据苹果官方的解释是body是nsdata类型即可能为二进制内容而且还没有大小限制所以可能会很大为了性能考虑索性就拦截时就不拷贝了内流满面脸-为了解决这个问题我们可以通过把body数据放到header中不过header的大小好像是有限制的我试过2m是没有问题不过超过10m就直接request-timeout了-而且当body数据为二进制数据时这招也没辙了因为header里都是文本数据另一种方案就是用一个nsdictionary或nscache保存没有请求的body数据用url为key最后方法就是别用nsurlsession老老实实用古老的nsurlconnection算了-你以为这么就结束了吗并没有后来查了大量的资料发现既然post请求的httpbody没有苹果复制下来那我们就不用httpbody我们再往底层去看就会发现httpbodystream这个东西我们可以通过他来获取请求的body体具体代吗如下\"><a class=\"anchor\" href=\"#64post请求这块也算是一个大坑我们知道http的post请求会包含一个body体里面包含我们需要上传的参数等一些资料对于post请求我们的nsurlprotocol是可以正常拦截的但是我们拦截之后发现无论怎么样我们获得的body体都为nil后来查了一些资料发下又是苹果爸爸在做手脚-nsurlprotocol在拦截nsurlsession的post请求时不能获取到request中的httpbody这个貌似早就国外的论坛上传开了但国内好像还鲜有人知据苹果官方的解释是body是nsdata类型即可能为二进制内容而且还没有大小限制所以可能会很大为了性能考虑索性就拦截时就不拷贝了内流满面脸-为了解决这个问题我们可以通过把body数据放到header中不过header的大小好像是有限制的我试过2m是没有问题不过超过10m就直接request-timeout了-而且当body数据为二进制数据时这招也没辙了因为header里都是文本数据另一种方案就是用一个nsdictionary或nscache保存没有请求的body数据用url为key最后方法就是别用nsurlsession老老实实用古老的nsurlconnection算了-你以为这么就结束了吗并没有后来查了大量的资料发现既然post请求的httpbody没有苹果复制下来那我们就不用httpbody我们再往底层去看就会发现httpbodystream这个东西我们可以通过他来获取请求的body体具体代吗如下\">#</a> 6.4：POST 请求这块也算是一个大坑，我们知道 http 的 post 请求会包含一个 body 体，里面包含我们需要上传的参数等一些资料，对于 POST 请求我们的 NSURLProtocol 是可以正常拦截的，但是我们拦截之后发现无论怎么样我们获得的 body 体都为 nil！后来查了一些资料发下又是苹果爸爸在做手脚。NSURLProtocol 在拦截 NSURLSession 的 POST 请求时不能获取到 Request 中的 HTTPBody，这个貌似早就国外的论坛上传开了，但国内好像还鲜有人知，据苹果官方的解释是 Body 是 NSData 类型，即可能为二进制内容，而且还没有大小限制，所以可能会很大，为了性能考虑，索性就拦截时就不拷贝了（内流满面脸）。为了解决这个问题，我们可以通过把 Body 数据放到 Header 中，不过 Header 的大小好像是有限制的，我试过 2M 是没有问题，不过超过 10M 就直接 Request timeout 了。。。而且当 Body 数据为二进制数据时这招也没辙了，因为 Header 里都是文本数据，另一种方案就是用一个 NSDictionary 或 NSCache 保存没有请求的 Body 数据，用 URL 为 key，最后方法就是别用 NSURLSession，老老实实用古老的 NSURLConnection 算了。。。你以为这么就结束了吗？并没有，后来查了大量的资料发现，既然 post 请求的 httpbody 没有苹果复制下来，那我们就不用 httpbody，我们再往底层去看就会发现 HTTPBodyStream 这个东西我们可以通过他来获取请求的 body 体具体代吗如下</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark -</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark 处理POST请求相关POST  用HTTPBodyStream来处理BODY体</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSMutableURLRequest</span> *)handlePostRequestBodyWithRequest:(<span class=\"built_in\">NSMutableURLRequest</span> *)request &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableURLRequest</span> * req = [request mutableCopy];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([request.HTTPMethod isEqualToString:<span class=\"string\">@&quot;POST&quot;</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!request.HTTPBody) &#123;</span><br><span class=\"line\">            uint8_t d[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">            <span class=\"built_in\">NSInputStream</span> *stream = request.HTTPBodyStream;</span><br><span class=\"line\">            <span class=\"built_in\">NSMutableData</span> *data = [[<span class=\"built_in\">NSMutableData</span> alloc] init];</span><br><span class=\"line\">            [stream open];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ([stream hasBytesAvailable]) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">NSInteger</span> len = [stream read:d maxLength:<span class=\"number\">1024</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (len &gt; <span class=\"number\">0</span> &amp;&amp; stream.streamError == <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">                    [data appendBytes:(<span class=\"type\">void</span> *)d length:len];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            req.HTTPBody = [data <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">            [stream close];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> req;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h6 id=\"这样之后的req就是携带了body体的request啦可以愉快地做post请求啦\"><a class=\"anchor\" href=\"#这样之后的req就是携带了body体的request啦可以愉快地做post请求啦\">#</a> 这样之后的 req 就是携带了 body 体的 request 啦，可以愉快地做 post 请求啦。</h6>\n<h6 id=\"65wkwebview是新出的浏览器控件这里就不多说了wkwebview不走url-loading-system所以也不会被拦截不过也是有办法的但是因为这次项目中没有用到所以没有过多的去研究后续我会写一篇关于这个博客不是很难依旧是runtime大法\"><a class=\"anchor\" href=\"#65wkwebview是新出的浏览器控件这里就不多说了wkwebview不走url-loading-system所以也不会被拦截不过也是有办法的但是因为这次项目中没有用到所以没有过多的去研究后续我会写一篇关于这个博客不是很难依旧是runtime大法\">#</a> 6.5：WKWebview 是新出的浏览器控件，这里就不多说了，WKWebview 不走 URL Loading System，所以也不会被拦截，不过也是有办法的，但是因为这次项目中没有用到，所以没有过多的去研究，后续我会写一篇关于这个博客，不是很难，依旧是 runtime 大法。</h6>\n<h6 id=\"66sni环境这个可是坑了我好久好久的东西所以我会放在最后去说sni环境因为涉及到证书验证所以是在https的基础上来说的sniserver-name-indication是为了解决一个服务器使用多个域名和证书的扩展-一句话简述它的工作原理就是在连接到服务器建立ssl链接之前先发送要访问站点的域名hostname这样服务器根据这个域名返回一个合适的证书-其实关于sni环境在这里就不过多解释阿里云文档有很明白的解释同时他也有安卓和ios在sni环境下的处理文档我们发现安卓部分写的很详细可是已到了ios这边就这样了\"><a class=\"anchor\" href=\"#66sni环境这个可是坑了我好久好久的东西所以我会放在最后去说sni环境因为涉及到证书验证所以是在https的基础上来说的sniserver-name-indication是为了解决一个服务器使用多个域名和证书的扩展-一句话简述它的工作原理就是在连接到服务器建立ssl链接之前先发送要访问站点的域名hostname这样服务器根据这个域名返回一个合适的证书-其实关于sni环境在这里就不过多解释阿里云文档有很明白的解释同时他也有安卓和ios在sni环境下的处理文档我们发现安卓部分写的很详细可是已到了ios这边就这样了\">#</a> 6.6：SNI 环境，这个可是坑了我好久好久的东西，所以我会放在最后去说，SNI 环境因为涉及到证书验证所以是在 https 的基础上来说的，SNI（Server Name Indication）是为了解决一个服务器使用多个域名和证书的扩展。一句话简述它的工作原理就是，在连接到服务器建立 SSL 链接之前先发送要访问站点的域名（Hostname），这样服务器根据这个域名返回一个合适的证书。其实关于 SNI 环境在这里就不过多解释，**<span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vZG9jdW1lbnRfZGV0YWlsLzMwMTQzLmh0bWw=\"> 阿里云文档</span> ** 有很明白的解释，同时他也有安卓和 iOS 在 SNI 环境下的处理文档，我们发现安卓部分写的很详细，可是已到了 iOS 这边就这样了：</h6>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6juzsqdqj31kw0bbn5v.jpg\" alt=\"阿里云文档截图\" /></p>\n<h6 id=\"三行文字加三个链接就完事了-其实在遇到这个坑的时候我也查过很多相关资料无非就是这三行话加这三个链接复制来复制去没有实质性的进展大部分公司或者是项目没有这么重的httpdns需求所以也就不会有这个环境即使遇到了也就直接关闭httpdns了后来只能自己去用cfnetwork一点点实现-具体代码就不跟大家粘贴了因为涉及到一些公司内部的代码不过我会把我主要的参考资料发给大家-这里有个小技巧因为都在说cfnetwork是比较底层的网络实现好多东西需要开发者自行处理比如一些变量的释放之类的所以我们能少用尽量少用因为cfnetwork是为snihttps环境服务所以我们在拦截判断的时候可以区分是用上层的网络请求转发还是用底层的cfnetwork来转发\"><a class=\"anchor\" href=\"#三行文字加三个链接就完事了-其实在遇到这个坑的时候我也查过很多相关资料无非就是这三行话加这三个链接复制来复制去没有实质性的进展大部分公司或者是项目没有这么重的httpdns需求所以也就不会有这个环境即使遇到了也就直接关闭httpdns了后来只能自己去用cfnetwork一点点实现-具体代码就不跟大家粘贴了因为涉及到一些公司内部的代码不过我会把我主要的参考资料发给大家-这里有个小技巧因为都在说cfnetwork是比较底层的网络实现好多东西需要开发者自行处理比如一些变量的释放之类的所以我们能少用尽量少用因为cfnetwork是为snihttps环境服务所以我们在拦截判断的时候可以区分是用上层的网络请求转发还是用底层的cfnetwork来转发\">#</a> 三行文字加三个链接就完事了。其实在遇到这个坑的时候我也查过很多相关资料，无非就是这三行话加这三个链接复制来复制去，没有实质性的进展，大部分公司或者是项目没有这么重的 Httpdns 需求，所以也就不会有这个环境，即使遇到了也就直接关闭 httpdns 了，后来只能自己去用 CFNetwork 一点点实现。具体代码就不跟大家粘贴了因为涉及到一些公司内部的代码，不过我会把我 **<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0RhdmUxOTkxL2FsaWNsb3VkLWlvcy1kZW1vL2Jsb2IvbWFzdGVyL2h0dHBkbnNfaW9zX2RlbW8vaHR0cGRuc19pb3NfZGVtby9DRkh0dHBNZXNzYWdlVVJMUHJvdG9jb2wubQ==\"> 主要的参考资料</span> ** 发给大家。这里有个小技巧，因为都在说 CFNetwork 是比较底层的网络实现，好多东西需要开发者自行处理比如一些变量的释放之类的，所以我们能少用尽量少用，因为 Cfnetwork 是为 SNI (https) 环境服务，所以我们在拦截判断的时候可以区分是用上层的网络请求转发还是用底层的 cfnetwork 来转发，</h6>\n<p><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span>.request.<span class=\"type\">URL</span>.scheme isEqualToString:@<span class=\"string\">&quot;https&quot;</span>] ) &#123;</span><br><span class=\"line\"><span class=\"comment\">//使用CFnetwork</span></span><br><span class=\"line\">        curRequest <span class=\"operator\">=</span> req;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.task <span class=\"operator\">=</span> [[<span class=\"type\">CustomCFNetworkRequestTask</span> alloc] initWithURLRequest:originalRequest swizzleRequest:curRequest delegate:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.task) &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span>.task startLoading];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//使用普通网络请求</span></span><br><span class=\"line\">        <span class=\"type\">NSURLSessionConfiguration</span> <span class=\"operator\">*</span>configuration <span class=\"operator\">=</span> [<span class=\"type\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.session <span class=\"operator\">=</span> [<span class=\"type\">NSURLSession</span> sessionWithConfiguration:configuration delegate:<span class=\"keyword\">self</span> delegateQueue:[<span class=\"type\">NSOperationQueue</span> mainQueue]];</span><br><span class=\"line\">        <span class=\"type\">NSURLSessionTask</span> <span class=\"operator\">*</span>task <span class=\"operator\">=</span> [<span class=\"keyword\">self</span>.session dataTaskWithRequest:req];</span><br><span class=\"line\">        [task resume];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"我是这么做的\"><a class=\"anchor\" href=\"#我是这么做的\">#</a> 我是这么做的。</h6>\n<h6 id=\"67在nsurlprotocol中的那几个类方法中是可以发送同步请求的但是在实例方法发送同步请求就会卡死所以实例方法中不能有任何的阻塞进行同步操作-不然就卡死\"><a class=\"anchor\" href=\"#67在nsurlprotocol中的那几个类方法中是可以发送同步请求的但是在实例方法发送同步请求就会卡死所以实例方法中不能有任何的阻塞进行同步操作-不然就卡死\">#</a> 6.7：在 NSURLProtocol 中的那几个类方法中是可以发送同步请求的，但是在实例方法发送同步请求就会卡死，所以实例方法中不能有任何的阻塞，进行同步操作。不然就卡死。</h6>\n<h5 id=\"7总结\"><a class=\"anchor\" href=\"#7总结\">#</a> 7：总结</h5>\n<p>完成了以上的步骤之后你回发现在 DNS 坏掉的情况下手机里面除了微信 QQ (他们也做了 DNS 解析) 之外其他应用都不能上网了但是你的 App 依然可以正常浏览网络数据。这就是我最近在做的时候遇到的一些问题，有什么问题及时与我交流吧</p>\n",
            "tags": [
                "网络",
                "底层",
                "httpdns"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-24-%E5%9C%A8iOS%E5%B7%A5%E7%A8%8B%E4%B8%ADCocoapods%E7%9A%84%E4%BD%BF%E7%94%A8/",
            "url": "https://oliverqueen.cn/2018-01-24-%E5%9C%A8iOS%E5%B7%A5%E7%A8%8B%E4%B8%ADCocoapods%E7%9A%84%E4%BD%BF%E7%94%A8/",
            "title": "在iOS工程中Cocoapods的使用",
            "date_published": "2018-01-24T04:42:28.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>我们在开发 iOS 程序的时候，往往都会根据需要导入很多的第三方框架，但是不同的框架完成的功能不同，所以导入的方式也不同，并不是把它直接拖进工程中就完事了，我们需要配置各种环境，链接各种库文件等等。有的时候我们并不能一个不漏的完成导入，而一旦出了问题，尤其是那些需要框架比较多的工程 (比如早期的百度地图框架)，将很难解决，而且，如果遇到了第三方库升级，更新了方法那么我们还需要把之前的旧版本删掉，再重复一下前面的工作，这将是非常的繁琐，极大地影响了开发的效率。这个时候我们就需要用到 cocoapods 来管理我们的第三方了，在我们有了 CocoaPods 这个工具之后，只需要将用到的第三方开源库放到一个名为 Podfile 的文件中，<br />\n<span id=\"more\"></span><br />\n 然后在命令行执行 $ pod install 命令。CocoaPods 就会自动将这些第三方开源库的源码下载下来，并且为我的工程设置好相应的系统依赖和编译参数，不管是导入还是更新或者移除，都是一句命令就搞定的。网上也有类似的教程，但是有些很旧，有些写的不详细，导致新手在使用的时候整的一头雾水，我就来说下。<br />\n### 第一步 ：<br />\n首先安装 cocoapods 要在 ruby 环境下进行，虽然我们的 mac 系统都是自带了 ruby，但是为了保险起见我们还是要先更新一下 ruby 环境：在这里我们直接使用   sudo gem update --system   命令来更新，网上有的说使用 gem update --system 前面少了 sudo，其实加 sudo 的目的就是用管理员的权限去执行这句更新命令，不加的话容易出现这个错误</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6jyxwn6cj30ta06kn1a.jpg\" alt=\"\" /></p>\n<p>意思是你没有权限去执行这个命令，等出现了 RubyGems system software updated 这句话的时候就证明升级成功了。</p>\n<p>### 第二步：<br />\n安装 cocoapods 时候我们要访问 cocoapods.org 这个网站，不用想这个网站已经被墙了，所以我们可以用淘宝的 ruby 的镜像来访问该网站。首先我们输入 gem sources -l 来看一下我们现在有什么，我目前里面只有一个</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6jzdqmrlj30ma03ydjy.jpg\" alt=\"\" /></p>\n<p>也就是我们需要的，不过可能有些人的里面不止一个，会有其他的东西，这时候我们先用 gem sources --remove XXXXXXXXXXXXXXX 来把其他的 source 删除掉，只保留这一个，如果没有的话就手动添加用这个命令 gem sources -a <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ydWJ5LnRhb2Jhby5vcmcv\">https://ruby.taobao.org/</span> 来将我们需要的源添加进去，最后再用那个查看命令 最后只有确保像我里面一样只有那一个就好，要注意的是 https  网上好多教程写的是 http，那个已经作废了</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6jzxkmf5j31kw0ask74.jpg\" alt=\"\" /></p>\n<h3 id=\"第三步\"><a class=\"anchor\" href=\"#第三步\">#</a> 第三步：</h3>\n<p>安装是 cocoapods 使用 sudo gem install cocoapods 命令来安装 cocoapods，你输入完这个命令回车后会提示你输入密码，这时候是没有光标提示的，也不会移动，凭感觉输入对之后就回车吧，然后就是等，时间长短是根据你的网速来的。安装完成后终端就进入待命阶段了。<br />\n### 第四步：<br />\n使用 search 命令来搜索类库，这个是支持模糊搜索的，记不清全名，打一部分名也行，不过那样的就要从搜出来的东西里找你想要的类库了。比如我想找 afnetworking 我就输入 pod search afn 回车后就会输出所有以 afn 开头的类库名字，像这样</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k0kkcjjj311u0wq4qp.jpg\" alt=\"\" /></p>\n<p>搜出很多，其中第三就是我们想要的，afnetworking，用红圈圈起来是一会编辑 podfile 时候需要用的，可以先把他复制下来省的手打，后面的小数代表的是类库的版本，一般是最新的显示在这里，下面的 version 是历史版本，如果有需要可以直接导入它的历史版本，就是把后面的版本号替换下就好。</p>\n<h6 id=\"值得注意的是如果你不是第一次安装cocoapods-那么之前的缓存会对你有影响search先清理下缓存-使用这个命之后就可以了-rm-~librarycachescocoapodssearch_indexjson\"><a class=\"anchor\" href=\"#值得注意的是如果你不是第一次安装cocoapods-那么之前的缓存会对你有影响search先清理下缓存-使用这个命之后就可以了-rm-~librarycachescocoapodssearch_indexjson\">#</a> 值得注意的是如果你不是第一次安装 cocoapods， 那么之前的缓存会对你有影响 search 先清理下缓存 使用这个命之后就可以了 rm ~/Library/Caches/CocoaPods/search_index.json</h6>\n<p>### 第五步：<br />\n进入你的工程目录，这里建议直接右键你工程中.xcodeproj 文件选择在终端中打开，然后 在终端中输入命令 cd ..  就会跳到.xcodeproj 所在的目录，也就是我们需要的目录，很多新手在这个地方容易出错。然后输入命令 vim Podfile 熟悉 Linux 的用户都知道这是创建一个 Podfile 文件并打开编辑，按 “i” 进入编辑模式，将第五部粘贴的东西拷贝进来，然后依次操作 esc 键  -&gt;  &quot;:&quot;  -&gt;  输入 wq</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k16wn0yj311s0wqth2.jpg\" alt=\"\" /></p>\n<p>然后输入命令来安装 pod update --verbose --no-repo-update 等待过后就安装完成啦，其实使用 pod install 也可以，只是后者需要更新一个仓库，这是相当耗时的，我们可以使用前者来避免更新仓库就好，很快就结束了。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k1nkijrj311u0wq1g6.jpg\" alt=\"\" /></p>\n<p>安装成功！以后打卡工程就直接打开这个文件就好啦</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k1y1x80j306q0cb0sy.jpg\" alt=\"\" /></p>\n<p>其中 podfile 文件中显示了我们这个工程中所以集成的第三方，</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k27zcbxj30ln0bfmxn.jpg\" alt=\"\" /></p>\n<p>想修改版本的话就把后面的版本号改成你所需要的版本号就好，想删除的话就把这行删掉，想添加的话就用第五部的搜索命令去搜索然后同样把搜索结果中以 pod 开头的那句话复制进来就好。注意以上所有的增删改操作完成之后需要在去终端中相应的目录下使用 pod install --verbose --no-repo-update 命令来更新，这样才会真正的生效。</p>\n<h3 id=\"第六步\"><a class=\"anchor\" href=\"#第六步\">#</a> 第六步：</h3>\n<p>关于 cocoapods 的更新。有的时候在 pod install 的时候会出现 [!] The 'master' repo requires CocoaPods 0.32.1 - 这样的错误，是由于你 cocoapods 版本过低的原因，这时候需要进行更新，跟新的过程其实就是把以上所有的从新走一遍就相当于安装遍就好了。</p>\n<h5 id=\"值得注意1\"><a class=\"anchor\" href=\"#值得注意1\">#</a> 值得注意 1</h5>\n<p>经常遇到的错误比如下面这个</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k2hpy06j30ej01gt8q.jpg\" alt=\"\" /></p>\n<p>通常出现在 OS X 10.11 系统上 这是由于从这个系统开始苹果开始使用无根安装，这时你再用这个方法就会报这个错，这时只需</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k2pt7n9j30hy02zwev.jpg\" alt=\"\" /></p>\n<p>这个命令就可以成功升级啦</p>\n<h5 id=\"值得注意2\"><a class=\"anchor\" href=\"#值得注意2\">#</a> 值得注意 2</h5>\n<p>有的时候大家在 pod search 的时候搜不到，但是明明有这个类库别人都可以都到课时就是自己搜不到，其实原因是这样的：pod search 只会搜索你本地缓存的框架，如果你想搜索到最新的第三方框架或者某个框架的最新版本，必须先使用 pod repo update（推荐）或者 pod setup 将远程仓库的框架信息更新到本地。其实，从 pod search 的响应速度飞快，也可以猜出它并没有连接服务器，仅仅是搜索了本地的框架信息 [呵呵]<br />\n    此外，如果你的框架更新比较慢，可以尝试执行下面 2 条指令更换镜像服务器<br />\n 1：pod repo remove master<br />\n2：pod repo add master <span class=\"exturl\" data-url=\"aHR0cDovL2dpdC5vc2NoaW5hLm5ldC9ha3VhbmRldi9TcGVjcy5naXQ=\">http://git.oschina.net/akuandev/Specs.git</span><br />\n    更换镜像完毕后，以后执行 pod repo update 的速度就会快很多。在说明一点上面两条指令如果第二条无法执行提示 403 错误像这样</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k2xgrwuj30i101h3yg.jpg\" alt=\"\" /></p>\n<p>那么在执行完第一条之后直接 pod search 命令就好 这样他会自动找合适的配置了，因为第二条那个网址可能会变。</p>\n<h3 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结：</h3>\n<p>关于使用 cocoapods 在自己的项目中集成第三方就这些内容。有什么不懂的欢迎来找我交流，本人才疏学浅，如果那里写的不对请及时批评指正，免得误导新人。 新浪微博小耗子上桌子也是我，大家也可以去看下微博多多关注 谢谢！</p>\n",
            "tags": [
                "Cocoapods",
                "架构"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-24-%E8%87%AA%E5%AE%9A%E4%B9%89AlertView/",
            "url": "https://oliverqueen.cn/2018-01-24-%E8%87%AA%E5%AE%9A%E4%B9%89AlertView/",
            "title": "自定义AlertView",
            "date_published": "2018-01-24T04:37:20.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"customalertview\"><a class=\"anchor\" href=\"#customalertview\">#</a> CustomAlertView</h1>\n<p>一个自定义的 AlertView，用户可以根据自己的需求来设置。</p>\n<h2 id=\"使用方法\"><a class=\"anchor\" href=\"#使用方法\">#</a> 使用方法</h2>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k50sh34j30hy084abf.jpg\" alt=\"初始化方法\" /></p>\n<p>类似于系统的初始化方法，如果没有值的话就传 nil 就好，不要传空字符串。最后一个参数传 title 数组就好了。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k5axspej30r702rmy0.jpg\" alt=\"使用\" /></p>\n<p>然后调用 showInViewWithAction 方法显示出来<br />\n<span id=\"more\"></span></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k5idk8ij30mp041aai.jpg\" alt=\"显示\" /></p>\n<p>最后一个参数是 button 的点击事件，根据 tag 值来区分不同的 button 点击，只有取消 button 的 tag 是 0，其他的是 1.2.3... 依次往下排列就好</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k5q4o6nj30kr0ox78u.jpg\" alt=\"可自定义的一些属性\" /></p>\n<p>这些属性可以自定义，这里就不细说了，大家可以使试试。</p>\n<h2 id=\"样式截图\"><a class=\"anchor\" href=\"#样式截图\">#</a> 样式截图</h2>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k5zfyi2j30dc0notac.jpg\" alt=\"样式截图\" /></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k66fmogg308o0figvd.gif\" alt=\"使用截图\" /></p>\n<p>大概就这么多，很简单的有问题随时联系我吧。</p>\n",
            "tags": [
                "UI",
                "AlertView"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-24-NSURLProtocol%E5%AF%B9WKWebView%E7%9A%84%E5%A4%84%E7%90%86/",
            "url": "https://oliverqueen.cn/2018-01-24-NSURLProtocol%E5%AF%B9WKWebView%E7%9A%84%E5%A4%84%E7%90%86/",
            "title": "NSURLProtocol对WKWebView的处理",
            "date_published": "2018-01-24T04:24:06.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>之前写过一篇<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5qaWFuc2h1LmNvbS9wL2NkNGMxYmYxZmQ1Zg==\">文章</span>是关于基于 NSURLProtocol 做的 DNS 解析，其中对 NSURLProtocol 也有了简单的介绍，我们都知道他可以拦截所有基于 URL Loading System 中的请求，但是对于 WKWebview 里面所发出的请求即使他是 http/https 也无能为力，先来简单的了解下 WKWebView.<br />\n<span id=\"more\"></span></p>\n<h5 id=\"wkwebview\"><a class=\"anchor\" href=\"#wkwebview\">#</a> WKWebview</h5>\n<p>iOS8 以后，苹果推出了新框架 Webkit，提供了替换 UIWebView 的组件 WKWebView。各种 UIWebView 的问题没有了，速度更快了，占用内存少了，一句话，WKWebView 是 App 内部加载网页的最佳选择！我们做开发最关系的是内存问题，基本上网上所有的资料都在说 WKWebview 的内存占用会更少，但是到底少了多少我这边做了下测试，同样是加载 163 的首页</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k80vn82j3087036wem.jpg\" alt=\"使用UIWebView的内存\" /><br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k8agxuoj308002smx3.jpg\" alt=\"使用WKWebview的内存\" /></p>\n<p>从上图看出内存大概能优化百分之八十左右，而且从网页的滑动上也确实有所改善。这么明显的性能提升但是苹果并没有完全放弃 UIWebView 也一定有他的道理，就拿本文要讲的 NSURLProtocol 拦截请求来说，WKWebview 的兼容并不 UIWebView 好，还需要开发者做一些操作。</p>\n<h5 id=\"webkit源码分析\"><a class=\"anchor\" href=\"#webkit源码分析\">#</a> WebKit 源码分析</h5>\n<p>由于 WKWebview 是基于 webkit 内核来做的，所以我们在使用的时候需要导入一个这样的东西。<br />\n#import &lt;WebKit/WebKit.h&gt;<br />\n 通过这个我们可以猜到 WKWebview 中所有的请求以及一些逻辑肯定走的都是 webkit 里面的东西，所以他对于网页的加载之之类的操作也不会走系统本省的 URL Loading System，这么说来他的请求不能被 NSURLProtocol 拦截也是理所当然的了。不过 WKWebview 是否真的和 NSURLProtocol 一点关系都没有还需要去研究，幸好 webkit 是开源的，github 上很容易找到<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL1dlYktpdC93ZWJraXQ=\">源码</span>（大小大概是 1G 多点的 zip，花了我将近一天时间来看）。拉下代码直接搜索 NSURLProtocol，看看有没有有关的信息<br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k8kigkxj30i80t0tg8.jpg\" alt=\"搜索结果\" /></p>\n<p>看来的确是有和 NSURLProtocol 有关系，后面通过断点的调用栈中也找到了<br />\n + [NSURLProtocol canInitWithRequest:]<br />\n 这样的字样，再通过网上查一些资料也证实了我的猜想，其实 WKWebview 在一开始时候是会调用到 NSURLProtocol 中的入口方法 canInitWithRequest 的，但是就没有然后了，也就是说 WKWebview 是和 NSURLProtocol 有一定关联，只是在 NSURLProtocol 的入口处返回 NO 所以导致 NSURLProtocol 不接管 WKWebview 的请求。我们点进 webkit 源码中的 CustomProtocol 可以看到，整体的结构我们都差不多，但是我注意到每个 CustomProtocol 的入口函数都有这样一个判断：<br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k8wgu6tj30yg04x40p.jpg\" alt=\"入口函数1\" /></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k93edfij30rw05ijsb.jpg\" alt=\"入口函数2\" /><br />\n (粉色的可以暂时认定为是它内部的一个 custom 字符串) 通过这个可以猜想，WKWebview 并不是不走 NSURLProtocol，而是需要满足他的一个规则，他才会在入口函数这里返回 YES 来给你放行，这个规则便是你所请求的 URL 的 Scheme 要和它内部配置的 CustomScheme 相同。不过这里有一个疑问，苹果在使用 webkit 时候为什么会把 http/https 这样大众化的 scheme 过滤掉，看来他是不建议开发者来使用 NSURLProtocol。接下来我们来看这个 CustomScheme，既然苹果内部规定好的那么一定能通过某种方式来注册一个自己的 scheme，实在不行就 hook 嘛。通过翻他的源码发现最终都指向一句代码</p>\n<pre><code>[WKBrowsingContextController registerSchemeForCustomProtocol:testScheme];\n</code></pre>\n<p>方法实现为<br />\n + (void) registerSchemeForCustomProtocol:(NSString *) scheme<br />\n{<br />\nWebProcessPool::registerGlobalURLSchemeAsHavingCustomProtocolHandlers(scheme);<br />\n}<br />\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void WebProcessPool::<span class=\"built_in\">registerGlobalURLSchemeAsHavingCustomProtocolHandlers</span>(const String&amp; urlScheme)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!urlScheme)</span><br><span class=\"line\">        return;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">globalURLSchemesWithCustomProtocolHandlers</span>()<span class=\"selector-class\">.add</span>(urlScheme);</span><br><span class=\"line\">    for (auto* processPool : allProcessPools())</span><br><span class=\"line\">        processPool-&gt;<span class=\"built_in\">registerSchemeForCustomProtocol</span>(urlScheme);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 通过方法名字可以看出这个就是那个向 webkit 注册 CustomScheme 的方法，只要我们在注册完我们自己的 CustomProtocol 之后在调用该方法应该就可以了。通过他的源码也进一步印证了我的猜想 (他也是这么写的)<br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k9nobq7j30yg04tmzt.jpg\" alt=\"webkit源码\" /></p>\n<h5 id=\"具体实施\"><a class=\"anchor\" href=\"#具体实施\">#</a> 具体实施</h5>\n<p>找到了方法就要去实施，不过因为 registerSchemeForCustomProtocol 是 WKBrowsingContextController 的类方法，所以只能用 WKBrowsingContextController 去调用，但是在 webkit 的头文件发现 WKBrowsingContextController 并没有开放出来，所以我们采用 NSClassFromString 和 NSSelectorFromString 方法来拿到类和对应的方法，整体代码如下<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注册自己的protocol</span></span><br><span class=\"line\">[<span class=\"built_in\">NSURLProtocol</span> registerClass:[CustomProtocol <span class=\"keyword\">class</span>]];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建WKWebview</span></span><br><span class=\"line\"><span class=\"built_in\">WKWebViewConfiguration</span> * config = [[<span class=\"built_in\">WKWebViewConfiguration</span> alloc] init];</span><br><span class=\"line\"><span class=\"built_in\">WKWebView</span> * wkWebView = [[<span class=\"built_in\">WKWebView</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, [<span class=\"built_in\">UIScreen</span> mainScreen].bounds.size.width, [<span class=\"built_in\">UIScreen</span> mainScreen].bounds.size.height) configuration:config];</span><br><span class=\"line\">[wkWebView loadRequest:webViewReq];</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:wkWebView];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注册scheme</span></span><br><span class=\"line\">Class cls = <span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@&quot;WKBrowsingContextController&quot;</span>);</span><br><span class=\"line\">SEL sel = <span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@&quot;registerSchemeForCustomProtocol:&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> ([cls respondsToSelector:sel]) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过http和https的请求，同理可通过其他的Scheme 但是要满足ULR Loading System</span></span><br><span class=\"line\">    [cls performSelector:sel withObject:<span class=\"string\">@&quot;http&quot;</span>];</span><br><span class=\"line\">    [cls performSelector:sel withObject:<span class=\"string\">@&quot;https&quot;</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n  实现效果。我将网页中所有的图片替换成了柴犬图片</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6ka7rv18g307o0ds7wl.gif\" alt=\"效果\" /></p>\n<h5 id=\"值得注意\"><a class=\"anchor\" href=\"#值得注意\">#</a> 值得注意</h5>\n<ul>\n<li>关于私有 API</li>\n</ul>\n<p>因为 WKBrowsingContextController 和 registerSchemeForCustomProtocol 应该是私有的所以使用时候需要对字符串做下处理，用加密的方式或者其他就可以了，实测可以过审核的。</p>\n<ul>\n<li>关于 post 请求<br />\n大家会发现拦截不了 post 请求 (拦截到的 post 请求 body 体为空)，这个其实和 WKWebview 没有关系，这个是苹果为了提高效率加快流畅度所以在 NSURLProtocol 拦截之后索性就不复制 body 体内的东西，因为 body 的大小没有限制，开发者可能会把很大的数据放进去那就不好办了。我们可以采取 httpbodystream 的方式拿到 body，这个在之前的<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5qaWFuc2h1LmNvbS9wL2NkNGMxYmYxZmQ1Zg==\">文章</span>也有提过</li>\n</ul>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark -</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark 处理POST请求相关POST  用HTTPBodyStream来处理BODY体</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSMutableURLRequest</span> *)handlePostRequestBodyWithRequest:(<span class=\"built_in\">NSMutableURLRequest</span> *)request &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableURLRequest</span> * req = [request mutableCopy];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([request.HTTPMethod isEqualToString:<span class=\"string\">@&quot;POST&quot;</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!request.HTTPBody) &#123;</span><br><span class=\"line\">            uint8_t d[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">            <span class=\"built_in\">NSInputStream</span> *stream = request.HTTPBodyStream;</span><br><span class=\"line\">            <span class=\"built_in\">NSMutableData</span> *data = [[<span class=\"built_in\">NSMutableData</span> alloc] init];</span><br><span class=\"line\">            [stream open];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ([stream hasBytesAvailable]) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">NSInteger</span> len = [stream read:d maxLength:<span class=\"number\">1024</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (len &gt; <span class=\"number\">0</span> &amp;&amp; stream.streamError == <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">                    [data appendBytes:(<span class=\"type\">void</span> *)d length:len];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            req.HTTPBody = [data <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">            [stream close];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> req;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n",
            "tags": [
                "webview",
                "hook"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-24-iOS-Runtime%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%90%8C%E7%B1%BB%E7%9A%84Method-Swizzling/",
            "url": "https://oliverqueen.cn/2018-01-24-iOS-Runtime%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%90%8C%E7%B1%BB%E7%9A%84Method-Swizzling/",
            "title": "iOS Runtime简单介绍，以及不同类的Method Swizzling",
            "date_published": "2018-01-24T04:18:50.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h5 id=\"runtime介绍\"><a class=\"anchor\" href=\"#runtime介绍\">#</a> Runtime 介绍：</h5>\n<p>runtime 顾名思义就是运行时，其实我们的 App 从你按下 command+R 开始一直到 App 运行起来经历了大致两个阶段，1：编译时，2：运行时。还记得一道很经典的面试题<br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kbsn9yxj30kk03et8z.jpg\" alt=\"\" /></p>\n<p>这里给大家解释下：首先， * testObject 是告诉编译器，testObject 是一个指向某个 Objective-C 对象的指针。因为不管指向的是什么类型的对象，<br />\n<span id=\"more\"></span><br />\n 一个指针所占的内存空间都是固定的，所以这里声明成任何类型的对象，最终生成的可执行代码都是没有区别的。这里限定了 NSString 只不过是告诉编译器，请把 testObject 当做一个 NSString 来检查，如果后面调用了非 NSString 的方法，会产生警告。接着，你创建了一个 NSData 对象，然后把这个对象所在的内存地址保存在 testObject 里。那么运行时 (从这段代码执行开始，到程序结束)，testObject 指向的内存空间就是一个 NSData 对象。你可以把 testObject 当做一个 NSData 对象来用。 所以编译时是 NSString，运行时是 NSData。<br />\nruntime 是什么：<br />\n在 runtime 中，所有的类在 OC 中都会被定义成一个结构体，像这样<br />\n类在 runtime 中的表示<br />\n struct objc_class {<br />\n    Class isa;// 指针，顾名思义，表示是一个什么，  // 实例的 isa 指向类对象，类对象的 isa 指向元类<br />\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> !__OBJC2__</span></span><br><span class=\"line\">        Class super_class;  <span class=\"comment\">//指向父类</span></span><br><span class=\"line\">        <span class=\"type\">const</span> <span class=\"type\">char</span> *name;  <span class=\"comment\">//类名</span></span><br><span class=\"line\">        <span class=\"type\">long</span> version;     <span class=\"comment\">//类的版本信息，默认初始化为 0。我们可以在运行期对其进行修改（class_setVersion）或获取（class_getVersion）。</span></span><br><span class=\"line\">        <span class=\"type\">long</span> info;   <span class=\"comment\">/*供运行期使用的一些位标识。有如下一些位掩码：</span></span><br><span class=\"line\"><span class=\"comment\">                        CLS_CLASS (0x1L) 表示该类为普通 class ，其中包含实例方法和变量；</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法；</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_INITIALIZED (0x4L) 表示该类已经被运行期初始化了，这个标识位只被 objc_addClass 所设置；</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_POSING (0x8L) 表示该类被 pose 成其他的类；（poseclass 在ObjC 2.0中被废弃了）；</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_MAPPED (0x10L) 为ObjC运行期所使用</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_FLUSH_CACHE (0x20L) 为ObjC运行期所使用</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_GROW_CACHE (0x40L) 为ObjC运行期所使用</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_NEED_BIND (0x80L) 为ObjC运行期所使用</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_METHOD_ARRAY (0x100L) 该标志位指示 methodlists 是指向一个 objc_method_list 还是一个包含 objc_method_list 指针的数组；*/</span></span><br><span class=\"line\">        <span class=\"type\">long</span> instance_size  <span class=\"comment\">//该类的实例变量大小（包括从父类继承下来的实例变量）；</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">objc_ivar_list</span> *ivars <span class=\"comment\">//成员变量列表</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">objc_method_list</span> **methodLists; <span class=\"comment\">//方法列表</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">objc_cache</span> *cache;<span class=\"comment\">//缓存   一种优化，调用过的方法存入缓存列表，下次调用先找缓存</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">objc_protocol_list</span> *protocols <span class=\"comment\">//协议列表</span></span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><br />\n 相关的定义<br />\n /// 描述类中的一个方法<br />\n typedef struct objc_method *Method;</p>\n<p>/// 实例变量<br />\n typedef struct objc_ivar *Ivar;</p>\n<p>/// 类别 Category<br />\ntypedef struct objc_category *Category;</p>\n<p>/// 类中声明的属性<br />\n typedef struct objc_property *objc_property_t;</p>\n<p>ObjC 为每个类的定义生成两个 objc_class ，一个即普通的 class，另一个即 metaclass。我们可以在运行期创建这两个 objc_class 数据结构，然后使用 objc_addClass 动态地创建新的类定义。</p>\n<h5 id=\"runtime能干什么\"><a class=\"anchor\" href=\"#runtime能干什么\">#</a> runtime 能干什么：</h5>\n<ul>\n<li>：1：获取一个类中的列表比如方法列表、属性列表、协议列表、成员变量列表像如下这样 其中获取到的属性、方法都是可以获取 public 和 private 的。</li>\n</ul>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unsigned <span class=\"built_in\">int</span> count;</span><br><span class=\"line\">    Class clas = <span class=\"literal\">[WKW<span class=\"identifier\">ebViewController</span> <span class=\"identifier\">class</span>]</span>; <span class=\"comment\">//是我自己的类，之所以不用系统的类是因为系统的类方法属性太多了</span></span><br><span class=\"line\"></span><br><span class=\"line\">    objc_property_t<span class=\"operator\"> * </span>propertyList = <span class=\"keyword\">class</span><span class=\"constructor\">_copyPropertyList(<span class=\"params\">clas</span>, &amp;<span class=\"params\">count</span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">        const <span class=\"built_in\">char</span> *propertyName = property<span class=\"constructor\">_getName(<span class=\"params\">propertyList</span>[<span class=\"params\">i</span>])</span>;</span><br><span class=\"line\">        <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;  %@  属性(包括私有) --------&gt;&gt;&gt;&gt;&gt;    %@&quot;</span>,<span class=\"params\">clas</span>,[NSString <span class=\"params\">stringWithUTF8String</span>:<span class=\"params\">propertyName</span>])</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;-------------------------------------------------------------------------------------------------------------- &quot;</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Method<span class=\"operator\"> * </span>methodList = <span class=\"keyword\">class</span><span class=\"constructor\">_copyMethodList(<span class=\"params\">clas</span>, &amp;<span class=\"params\">count</span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">        Method methodName = methodList<span class=\"literal\">[<span class=\"identifier\">i</span>]</span>;</span><br><span class=\"line\">        <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;  %@ 方法(包括私有)  --------&gt;&gt;&gt;&gt;&gt;    %@&quot;</span>,<span class=\"params\">clas</span>,NSStringFromSelector(<span class=\"params\">method_getName</span>(<span class=\"params\">methodName</span>)</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;-------------------------------------------------------------------------------------------------------------- &quot;</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    Ivar *ivarList = <span class=\"keyword\">class</span><span class=\"constructor\">_copyIvarList(<span class=\"params\">clas</span>, &amp;<span class=\"params\">count</span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i&lt;count; i++) &#123;</span><br><span class=\"line\">        Ivar myIvar = ivarList<span class=\"literal\">[<span class=\"identifier\">i</span>]</span>;</span><br><span class=\"line\">        const <span class=\"built_in\">char</span> *ivarName = ivar<span class=\"constructor\">_getName(<span class=\"params\">myIvar</span>)</span>;</span><br><span class=\"line\">        <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;%@ 成员变量(包括私有) --------&gt;&gt;&gt;&gt;&gt; %@&quot;</span>,<span class=\"params\">clas</span>, [NSString <span class=\"params\">stringWithUTF8String</span>:<span class=\"params\">ivarName</span>])</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;-------------------------------------------------------------------------------------------------------------- &quot;</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//获取协议列表</span></span><br><span class=\"line\">    __unsafe_unretained Protocol **protocolList = <span class=\"keyword\">class</span><span class=\"constructor\">_copyProtocolList([<span class=\"params\">self</span> <span class=\"params\">class</span>], &amp;<span class=\"params\">count</span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i&lt;count; i++) &#123;</span><br><span class=\"line\">        Protocol *myProtocal = protocolList<span class=\"literal\">[<span class=\"identifier\">i</span>]</span>;</span><br><span class=\"line\">        const <span class=\"built_in\">char</span> *protocolName = protocol<span class=\"constructor\">_getName(<span class=\"params\">myProtocal</span>)</span>;</span><br><span class=\"line\">        <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;%@ 协议 --------&gt;&gt;&gt;&gt;&gt; %@&quot;</span>,<span class=\"params\">clas</span>, [NSString <span class=\"params\">stringWithUTF8String</span>:<span class=\"params\">protocolName</span>])</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br />\n 输出后的结果是<br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kc7w3zcj30pk0ajdks.jpg\" alt=\"image.png\" /><br />\n 其中也包括了私有方法。</p>\n<ul>\n<li>2：拦截方法调用<br />\n有的时候我们用一个类或者一个实例变量去调用一个方法，由于操作失误或者是其他原因，导致这个所被调用的方法并不存在，报出这样的错误，然后闪退！<br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kcfrky6j30tr0120sy.jpg\" alt=\"image.png\" /></li>\n</ul>\n<p>这个时候如果我们想避免这些崩溃，我们就需要在运行时对其做一些手脚。iOS 中方法调用的流程：其实调用方法就是发送消息，所有调用方法的代码例如   [obj aaa]  在运行时 runtime 会将这段代码转换为 objc_msgSend (obj, [@selector]);（本质就是发送消息）然后 obj 会通过其中 isa 指针去该类的缓存中 (cache) 查找对应函数的 Method, 如果没有找到，再去该类的方法列表（methodList）中查找，如果没有找到再去该类的父类找，如果找到了，就先将方法添加到缓存中，以便下次查找，然后通过 method 中的指针定位到指定方法执行。如果一直没有找到，便会走完如下四个方法之后崩溃。</p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    如果调用的是不存在的实例方法则会在奔溃前进入该方法，防止崩溃可以在此处做处理</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+(<span class=\"type\">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 如果调用的是不存在的类方法则会在奔溃前进入该方法，防止崩溃可以在此处做处理</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+(<span class=\"type\">BOOL</span>)resolveClassMethod:(SEL)sel &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 这个方法会把你所调用的不存在的方法重定向到一个声明了该方法的类中，只需要你返回一个有该方法的</span></span><br><span class=\"line\"><span class=\"comment\"> 类就可以，如果你重定向的这个类仍然不具有该方法那么会继续崩溃</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">-(<span class=\"type\">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 将你不存在的方法打包成NSInvocation对象，做完你自己的处理之后</span></span><br><span class=\"line\"><span class=\"comment\"> 调用invokeWithTarget让某个target来处理该方法</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">-(<span class=\"type\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)anInvocation &#123;</span><br><span class=\"line\">    [anInvocation invokeWithTarget:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>3：动态添加方法<br />\n因为我们调用了一个不存在的方法导致崩溃，那么我们在判断出不存在后就动态添加上一个方法吧 这样不就不会蹦了吗？我们先写一个方法用来给我们做出提示</li>\n</ul>\n<p><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- <span class=\"params\">(void)</span> errorMethod &#123;</span><br><span class=\"line\">    NSLog<span class=\"params\">(@<span class=\"string\">&quot;no method!!!!!!!&quot;</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 如果调用了没有的方法，那么就把这个方法添加进去，然后把被调用的方法的指针指向这个 error1：，那么一旦调用了没有的方法就会走这个。我们来看代码</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+(BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class=\"line\">    Method errorMethod =  <span class=\"keyword\">class</span><span class=\"constructor\">_getInstanceMethod([<span class=\"params\">self</span> <span class=\"params\">class</span>], @<span class=\"params\">selector</span>(<span class=\"params\">errorMethod</span>)</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">[NSS<span class=\"identifier\">tringFromSelector</span>(<span class=\"identifier\">sel</span>) <span class=\"identifier\">isEqualToString</span>:@&quot;<span class=\"identifier\">testMethod</span>&quot;]</span>) &#123;</span><br><span class=\"line\">        BOOL isAdd =  <span class=\"keyword\">class</span><span class=\"constructor\">_addMethod([<span class=\"params\">self</span> <span class=\"params\">class</span>], <span class=\"params\">sel</span>, <span class=\"params\">method_getImplementation</span>(<span class=\"params\">errorMethod</span>)</span>, <span class=\"keyword\">method</span><span class=\"constructor\">_getTypeEncoding(<span class=\"params\">errorMethod</span>)</span>);</span><br><span class=\"line\">        <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;tinajia  = %d&quot;</span>,<span class=\"params\">isAdd</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//Do something</span></span><br><span class=\"line\">    return YES;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>主要用到</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    添加方法</span></span><br><span class=\"line\"><span class=\"comment\">     @param class] 在哪个类里添加</span></span><br><span class=\"line\"><span class=\"comment\">     @param sel 添加的方法的名字</span></span><br><span class=\"line\"><span class=\"comment\">     @param errorMethod 添加的方法的实现IMP指</span></span><br><span class=\"line\"><span class=\"comment\">     @param types 方法的标示符</span></span><br><span class=\"line\"><span class=\"comment\">     @return 是否添加成功</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">BOOL isAdd =  <span class=\"keyword\">class</span><span class=\"constructor\">_addMethod([<span class=\"params\">self</span> <span class=\"params\">class</span>], <span class=\"params\">sel</span>, <span class=\"params\">method_getImplementation</span>(<span class=\"params\">errorMethod</span>)</span>, <span class=\"keyword\">method</span><span class=\"constructor\">_getTypeEncoding(<span class=\"params\">errorMethod</span>)</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>然后运行下：</p>\n<p><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">WKWebViewController</span> <span class=\"operator\">*</span> vc<span class=\"operator\">=</span> [[<span class=\"type\">WKWebViewController</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">[vc performSelector:<span class=\"meta\">@selector</span>(testMethod)];</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>我调用了并不存在的 testMethod 方法并没有崩溃并且方法已经成功添加了</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kexyuzgj30f801mwel.jpg\" alt=\"image.png\" /></p>\n<ul>\n<li>\n<p>4：动态交换方法（也叫 iOS 黑魔法，慎用）<br />\n没什么好例子，用一个网上说的例子 (引用别人的东西，懒得复制了，就截了图)</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kg3i5z6j30hv0fj0z9.jpg\" alt=\"\" /></p>\n<p>其实本质即使 SEL 和 IMP 的交换，原理是这样的：在 iOS 中每一个类中都有一个叫 dispatch table 的东西，里面存放在 SEL 和他所对应的 IMP 指针，之前也说过方法调用就是通过 sel 找 IMP 指针然后指针定位调用方法。方法交换就是对这个 dispatch table 进行操作。让 A 的 SEL 去对应 B 的 IMP，B 的 SEL 对应 A 的 IMP，如图</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kgrq52oj30f80betcz.jpg\" alt=\"\" /></p>\n<p>这样就达到方法交换的目的，下面看代码：</p>\n</li>\n</ul>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)changeMethod &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  如果是类方法 要使用 !</span></span><br><span class=\"line\">    <span class=\"comment\">//  如果是系统的集合类的属性要用元类 比如 __NSSetM = NSMutableSet</span></span><br><span class=\"line\">    <span class=\"comment\">//  Class  class = NSClassFromString(@&quot;__NSSetM&quot;);</span></span><br><span class=\"line\">    <span class=\"comment\">//  Class metaClass = objc_getMetaClass([NSStringFromClass(class) UTF8String]);</span></span><br><span class=\"line\">    Class systemClass = <span class=\"constructor\">NSClassFromString(<span class=\"params\">__NSSetM</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    SEL sel_System = <span class=\"constructor\">NSSelectorFromString(<span class=\"params\">addObject</span>:)</span>;</span><br><span class=\"line\">    SEL sel_Custom = @selector(swizzle_addObject:);</span><br><span class=\"line\"></span><br><span class=\"line\">    Method method_System = <span class=\"keyword\">class</span><span class=\"constructor\">_getInstanceMethod(<span class=\"params\">systemClass</span>, <span class=\"params\">sel_System</span>)</span>;</span><br><span class=\"line\">    Method method_Custom = <span class=\"keyword\">class</span><span class=\"constructor\">_getInstanceMethod([<span class=\"params\">self</span> <span class=\"params\">class</span>], <span class=\"params\">sel_Custom</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    IMP imp_System = <span class=\"keyword\">method</span><span class=\"constructor\">_getImplementation(<span class=\"params\">method_System</span>)</span>;</span><br><span class=\"line\">    IMP imp_Custom = <span class=\"keyword\">method</span><span class=\"constructor\">_getImplementation(<span class=\"params\">method_Custom</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">method</span><span class=\"constructor\">_exchangeImplementations(<span class=\"params\">method_System</span>, <span class=\"params\">method_Custom</span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)swizzle_addObject:(id) obj &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj) &#123;</span><br><span class=\"line\">        <span class=\"literal\">[<span class=\"identifier\">self</span> <span class=\"identifier\">swizzle_addObject</span>:<span class=\"identifier\">obj</span>]</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>主要代码  method_exchangeImplementations (method1, method2); 这两个参数很简单，就是两个需要交换的方法。<br />\n最后我调用了 m1 但是实际上走了 m2。</p>\n<h5 id=\"动态交换方法的原理以及交换过程中指针的变化\"><a class=\"anchor\" href=\"#动态交换方法的原理以及交换过程中指针的变化\">#</a> 动态交换方法的原理以及交换过程中指针的变化</h5>\n<p>在通常的方法交换中我们通常有两种情景，一种是我会针对被交换的类建一个 category，然后 hook 的方法会写在 category 中。另一种是自己创建一个 Tool 类里面放些常用的工具方法其中包含了方法交换。可能大家普遍选择第一种方法，但是如果你需要 hook 的类非常多的 (我实际项目中就遇到这样的问题) 那你就需要针对不同的类创建 category，就会导致文件过多，且每一个文件中只有一个 hook 方法，这样一来左侧一堆文件，所以我用了第二种方法，但是在使用过程中出现一个问题，先看下我的代码结构</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6khw8c97j30740ag74v.jpg\" alt=\"image.png\" /></p>\n<p>我要 hook 的是 ViewController 中的 viewDidLoad 方法，我建立了两个类一个是 ViewController 的 category，另一个是 Tool 类，为了一会区别演示不同类 hook 的不同 (两个类中 hook 的代码完全一样)</p>\n<ul>\n<li>ViewController 中将要被替换的系统方法</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kir8y63j309a02rglq.jpg\" alt=\"被替换的方法(系统方法)\" /></p>\n<ul>\n<li>Category 中将要用来替换的自定义方法</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kj5dcykj308z02lwep.jpg\" alt=\"用来替换的方法(自定义方法)\" /></p>\n<ul>\n<li>然后在 ViewController 中的 load 中做方法替换</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kjlzvdqj30f90b43zw.jpg\" alt=\"进行方法替换\" /></p>\n<p>运行一下的输出结果想必大家已经猜到了先执行 custom 再执行 system，这是通常情况下大家的做法。<br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kjxsheej30d701h3yl.jpg\" alt=\"结果\" /></p>\n<p>下面再来看下如果我将替换方法写在不同类中会怎样，调用 Tool 中的交换方法</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kka2s8uj30dx0anwfp.jpg\" alt=\"执行Tool中的交换方法\" /></p>\n<p>然后直接看结果了，因为代码都是一模一样的我直接复制过去的</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kliitupj30yd08w422.jpg\" alt=\"结果\" /></p>\n<p>发生了 crash，原因是 ViewController 中没有 swizzel_viewDidLoad_custom 这个方法，为什么不同类的交换会出现这种问题，我们用个图来说明下</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6km0wogkj30yg0pz43q.jpg\" alt=\"image.png\" /></p>\n<p>解决的办法是我们在交换方法之前要先像其中添加方法，也就是说把 customMethod 添加到 SystemClass 中，但是注意要把 customMethod 的实现指向 syetemMethod 的实现。这样一来就可以达到 SystemClass 调用 customMethod 却执行 systemMethod 的代码的效果，实现以上要求我们需要在交换之前执行这个方法。</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span><span class=\"constructor\">_addMethod(<span class=\"params\">systemClass</span>, <span class=\"params\">sel_Custom</span>, <span class=\"params\">imp_System</span>, <span class=\"params\">method_getTypeEncoding</span>(<span class=\"params\">method_System</span>)</span>)</span><br></pre></td></tr></table></figure></p>\n<p>其中第一个参数是需要往哪个类添加；第二个参数是要添加的方法的方法名；第三个参数是所添加的方法的方法实现，第四个是方法的标识符。经过就该之后我们的代码是这样</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">之前的都一样就省略</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">class</span><span class=\"constructor\">_addMethod(<span class=\"params\">systemClass</span>, <span class=\"params\">sel_Custom</span>, <span class=\"params\">imp_System</span>, <span class=\"params\">method_getTypeEncoding</span>(<span class=\"params\">method_System</span>)</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">class</span><span class=\"constructor\">_replaceMethod(<span class=\"params\">systemClass</span>, <span class=\"params\">sel_System</span>, <span class=\"params\">imp_Custom</span>, <span class=\"params\">method_getTypeEncoding</span>(<span class=\"params\">method_System</span>)</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">method</span><span class=\"constructor\">_exchangeImplementations(<span class=\"params\">method_System</span>, <span class=\"params\">method_Custom</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>我们来看下执行完 add 操作之后此时的方法和类的对应关系 (红色的为 add 的修改)</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kmhkzidj30yg0g378f.jpg\" alt=\"关系\" /></p>\n<p>因为 SystemClass 中本身不包含 customMethod 所以 add 一定是成功的，也就是说会进入判断执行 replace 方法。</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span><span class=\"constructor\">_replaceMethod(<span class=\"params\">systemClass</span>, <span class=\"params\">sel_System</span>, <span class=\"params\">imp_Custom</span>, <span class=\"params\">method_getTypeEncoding</span>(<span class=\"params\">method_System</span>)</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>第一个参数：需要修改的方法的所在的类；第二个参数：需要替换其实现的方法名；第三个参数：需要把哪个实现替换给他；第四个参数：方法标识符。此时看下我们做完 replace 之后的类与方法名以及他们实现的关系 (红色的为 replace 的修改)。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kn9m5btj30yg0ifgqa.jpg\" alt=\"关系\" /></p>\n<p>此时大家已经看出来了，虽然没有执行 exchange 方法，但是我已经达到了方法交换的目的。系统执行 systemMethod 时候会走 customMethod 的实现但是因为在 customMethod 方法中我会递归执行 [self customMethod]，所以又会走到 systemMethod 的实现，因为之前进行了方法添加，所以此时 A 类中有了 customMethod 方法，不会再发生之前的 crash。达到一个不同类进行 Method Swizzling 的目的。</p>\n<h5 id=\"综上来看一个完整严谨的methodswizzling应该在交换前先add并且add方法的参数不能错\"><a class=\"anchor\" href=\"#综上来看一个完整严谨的methodswizzling应该在交换前先add并且add方法的参数不能错\">#</a> 综上来看一个完整严谨的 MethodSwizzling 应该在交换前先 add，并且 add 方法的参数不能错</h5>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)changeMethod &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Class systemClass = <span class=\"constructor\">NSClassFromString(@<span class=\"string\">&quot;你的类&quot;</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    SEL sel_System = @selector(系统方法);</span><br><span class=\"line\">    SEL sel_Custom = @selector(你自己的方法);</span><br><span class=\"line\"></span><br><span class=\"line\">    Method method_System = <span class=\"keyword\">class</span><span class=\"constructor\">_getInstanceMethod(<span class=\"params\">systemClass</span>, <span class=\"params\">sel_System</span>)</span>;</span><br><span class=\"line\">    Method method_Custom = <span class=\"keyword\">class</span><span class=\"constructor\">_getInstanceMethod([<span class=\"params\">self</span> <span class=\"params\">class</span>], <span class=\"params\">sel_Custom</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    IMP imp_System = <span class=\"keyword\">method</span><span class=\"constructor\">_getImplementation(<span class=\"params\">method_System</span>)</span>;</span><br><span class=\"line\">    IMP imp_Custom = <span class=\"keyword\">method</span><span class=\"constructor\">_getImplementation(<span class=\"params\">method_Custom</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">class</span><span class=\"constructor\">_addMethod(<span class=\"params\">systemClass</span>, <span class=\"params\">sel_Custom</span>, <span class=\"params\">imp_System</span>, <span class=\"params\">method_getTypeEncoding</span>(<span class=\"params\">method_System</span>)</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">class</span><span class=\"constructor\">_replaceMethod(<span class=\"params\">systemClass</span>, <span class=\"params\">sel_System</span>, <span class=\"params\">imp_Custom</span>, <span class=\"params\">method_getTypeEncoding</span>(<span class=\"params\">method_System</span>)</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">method</span><span class=\"constructor\">_exchangeImplementations(<span class=\"params\">method_System</span>, <span class=\"params\">method_Custom</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h5 id=\"以上代码无论是写在工具类中还是category中都是没有问题的\"><a class=\"anchor\" href=\"#以上代码无论是写在工具类中还是category中都是没有问题的\">#</a> 以上代码无论是写在工具类中还是 category 中都是没有问题的。</h5>\n",
            "tags": [
                "底层",
                "runtime"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-24-iOS%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/",
            "url": "https://oliverqueen.cn/2018-01-24-iOS%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/",
            "title": "iOS端自动内存泄漏检测工具",
            "date_published": "2018-01-24T03:41:50.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h4 id=\"产生的背景\"><a class=\"anchor\" href=\"#产生的背景\">#</a> 产生的背景</h4>\n<p>在移动设备上内存是一块公用的区域，如果一个 App 没有做好内存管理那么一定会导致性能急剧下降甚至会崩溃。<br />\nFacebook 的 iOS 端有许多的地方都共享着一块内存，如果任何一个地方占用太多的内存的话就会影响到整个 App，比如一个地发生了内存泄漏，就会出现这种情况。我们把一组内存分配我们的一个对象，但是当我们使用完之后忘记释放他，这就通常就会引起内存泄漏，这就意味着系统永远不能回收这块内存也就导致这块内存一直不能分配给别的对象。在 Facebook 里我们有许多许多的工程师在代码的不同部分工作，内存泄漏时不可避免的，当一旦有内存泄漏发生我们就需要立即找到并且修复。虽然现在有好多检测内存泄漏的工具但是这些工具并不完善，他们仍然需要开发者去做一些工作：<br />\n<span id=\"more\"></span></p>\n<ul>\n<li>1：打开 Xcode 并且 Build</li>\n<li>2：运行 instrument</li>\n<li>3：使用 App 尽可能的去复现</li>\n<li>4：寻找内存泄漏的来源</li>\n<li>5：解决问题</li>\n</ul>\n<p>这意味着需要大量的体力活，并且都是些重复无聊的工作，这也导致了我们不能在开发周期就定位并且修复问题。</p>\n<p>将这个过程自动化可以让我们在不需要太多的开发者的情况下更快的去找到内存泄漏。为了解决这个问题我们已经建立一套工具使我们能够自动的去完成这些过程，并且这套工具已经解决了我们自己代码的一些问题，今天我们很激动的宣布我们把他们发布了出来<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL0ZCUmV0YWluQ3ljbGVEZXRlY3Rvcg==\"> FBRetainCycleDetector</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL0ZCQWxsb2NhdGlvblRyYWNrZXI=\">FBAllocationTracker</span>, and <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL0ZCTWVtb3J5UHJvZmlsZXI=\">FBMemoryProfiler</span>.</p>\n<h4 id=\"循环引用\"><a class=\"anchor\" href=\"#循环引用\">#</a> 循环引用</h4>\n<p>Objective-C 使用引用计数来管理内存的，内存中的一个对象可以引用其他的对象，只要有一个对象使用它，那么他就会一直被留在内存中。我们也可以说一个对象持有另一个对象。</p>\n<p>  一般来说这都没问题。但是有一种情会使我们陷入僵局。当两个 obj 不在相互持有，而是通过另一个 obj 来互相持有，这样就会陷入一个循环引用的状态就像下面这张图</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fnrkogrtqbj30kg0cndhd.jpg\" alt=\"循环引用\" /></p>\n<p>一个 View Controller 持有一个 Viw View 中持有 delegate delegate 中持有 ViewController。这样就形成一个环状，谁也无法释放。</p>\n<p>  循环引用会导致一些列的的问题，如果一个对象在 RAM 中无限的占用空间，充其量也只是浪费一点点内存。如果这些泄漏的对象正在做一些其他的事情那么就会导致 App 的其他的地方再也无法使用这块内存。更严重的如果循环引用过多，就会浪费掉大量的内存最终导致程序的 crash。</p>\n<p>  在我们进行人工调试的时候我们已经找出了大量的很明显的循环引用，我们能很好地定位他，但是在运行之后我们就很难发现他们，但是我们这 SDK 能很轻松的做这些事。</p>\n<h4 id=\"在runtime下的循环引用检测\"><a class=\"anchor\" href=\"#在runtime下的循环引用检测\">#</a> 在 Runtime 下的循环引用检测</h4>\n<p>  在 OC 中找循环引用其实就类似于在一个节点为对象，链接线为引用关系的有向无环图中寻找一个环。打个比方如果 A 引用 B 那么 A 到 B 就会有箭头指向可以看这个<br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kvv1735j30yg0mv0ug.jpg\" alt=\"image.png\" /> 我们发现这张图在箭头处发生循环引用</p>\n<p>  这个是一个很简单的引用关系我们必须确保我们能像左侧那样的来引用对象，其实对于每一个对象我们都获取他所有引用 (持有的) 对象，有的是强引用有的是弱引用，但是循环引用只发生在强引用上，对于每个对象我们需要搞清楚如何找到引用关系。</p>\n<p>  幸运的是 OC 给我提供了强大的 Runtime，这足够让我们去挖掘其中的关系，图中的一个点可能是 block 或者是 Object 中的其中一个，让我们来分别讨论下</p>\n<h4 id=\"objects\"><a class=\"anchor\" href=\"#objects\">#</a> Objects</h4>\n<p>  Runtime 中有很多工具去帮助我们了解其中的东西，首先我们搞懂到所有实例变量的引用关系<br />\n <figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const <span class=\"built_in\">char</span> *<span class=\"keyword\">class</span><span class=\"constructor\">_getIvarLayout(Class <span class=\"params\">cls</span>)</span>;</span><br><span class=\"line\">const <span class=\"built_in\">char</span> *<span class=\"keyword\">class</span><span class=\"constructor\">_getWeakIvarLayout(Class <span class=\"params\">cls</span>)</span>;</span><br></pre></td></tr></table></figure><br />\n 对于一个给定的对象，实例变量布局图告诉我们了他都引用了哪些对象，他会给我提供一个索引，这个索引相当于一个偏移量，该对象加上这个偏移量就是他所引用的对象的地址。运行时会给我们提供一个 “弱引用” 的布局图，也就是该对象所有弱引用的对象，强引用和弱引用之间的区别我们可以猜想为就是强引用的布局图。</p>\n<p>  对于 objective-c++ 来说我们可以用结构体来定义一个对象，这些对象不会再实例变量的布局图中被获取到，不过 Runtime 给我提供了 “类型编码” 来处理这个问题，对于每个实例变量，类型编码描述了变量是如何构造的。如果它是一个 struct，类型编码可以描述出它包含的字段和类型。我们解析类型编码以找到哪些实例变量是 objective-c 的对象。然后我们可以像在布局图中那样计算他的偏移量然后拿到他所引用的对象的地址。</p>\n<p>  还有一些我们不会深入讨论的边缘案例。这些都是不同的集合，我们必须列举它们来获取它们的保留对象，这可能会产生一些副作用。</p>\n<h4 id=\"blocks\"><a class=\"anchor\" href=\"#blocks\">#</a> Blocks</h4>\n<p>  block 和对象有一点不同。运行时不允许我们轻松地查看它们的布局，但是我们仍然可以进行猜测。在处理 block 时，我们使用了 Mike Ash 在他的项目<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL21pa2Vhc2gvQ2lyY2xl\"> Circle</span> 中提出的想法：也正是这个项目激发 FBRetainCycleDetector 的项目。</p>\n<p> $emsp; 我们可以使用<span class=\"exturl\" data-url=\"aHR0cDovL2NsYW5nLmxsdm0ub3JnL2RvY3MvQmxvY2stQUJJLUFwcGxlLmh0bWw=\"> application binary interface for blocks</span> (ABI)，他可以向我们展示一个 block 在内存中是什么样子的，如果我们知道了我们所研究的 block 的表现形式我们就可以用一个假的结构体来模仿实现 block 的功能，之后我们就能知道了哪些对象被 block 引用并且一直在那里，但是不幸的是我们并不知道这些事强引用还是弱引用。</p>\n<p>  为了做到这些我们使用黑盒的方法，首先我们创建一个假的对象来模仿我们所研究的 Block，因为是我们自己创建的假对象，所以我们可以完全的操作他，我们给这个假装的 block 上面装上释放探测器，释放探测器是监听发给他们的释放消息的一个对象，如果一个所有者想放弃对对象们所有权的时候，释放探测器会给他所有强引用的对象发出消息，当我们释放我们的假对象时，我们可以检查哪些探测器收到了这样的消息。便知道了哪些 block 是被强引用的。这样一来我们可以找到我们原始 block 所持有的真是的对象，如下图所示</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fnrkpskc4zj30kg0fd76k.jpg\" alt=\"block\" /></p>\n<h4 id=\"自动化\"><a class=\"anchor\" href=\"#自动化\">#</a> 自动化</h4>\n<p>  员工在进行持续执行时，这个工具就会非常出色。自动化在客户端上是非常容易的，我们使用定时器来建立一个循环引用检测，用来周期性的扫描一部分内存去寻找循环引用，不过还是有点问题，我们第一次运行检测器的时候我们发现他不快速的扫描完整个内存空间，所以我们需要给他提供一个候选检测对象，为了做到这一点，我们建立了 FBAllocationTracker，他可以追踪任何一个 Nsobject 对象的创建和销毁，他同样可以在任何给定的时刻以最小的性能开销来获取任何类的实例对象。</p>\n<p>  在客户端上实现了这样的自动化操作意味着我们可以更加简单的在 NSTimer 上使用 FBRetainCycleDetector 和添加用了追踪实例的 FBAllocationTracker，现在让我们来看下后端到底发生了什么，循环引用可以有多个对象来组成，如果创建了许多的引用环并且有一个泄漏了那么事情将会变得非常复杂。如下如所示 A-&gt;B 就是一个坏的引用环导致了 A-&gt;B-&gt;C-&gt;D 和 A-&gt;B-&gt;C-&gt;E</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fnrkrd6o9oj30kg0j6acn.jpg\" alt=\"引用环\" /></p>\n<p>遇到这样的问题就会给我们的 SDK 带来两个问题：</p>\n<ul>\n<li>\n<p>如果这两个环是由于一个不良引用引起我们就直接标记一处不良引用就可以了，不用标记两处，这样会给开发者一个错误信号。</p>\n</li>\n<li>\n<p>如果这两个环是虽然由一个不良引用引起但是会导致两个不同的错误，那么我们就需要将这个两个循环引用都标记出来</p>\n</li>\n</ul>\n<p>因此我们需要建立一个循环引用群，我们通过下面这些启发写了一种算法。</p>\n<ul>\n<li>1：把给定日期中所检测出的所有循环引用收集起来。</li>\n<li>2：找到每个循环引用环中 Facebook 特定的类名。</li>\n<li>3：找到每个环中最小的那个环。</li>\n<li>4：把最小周期放到一个组中。</li>\n<li>5：仅仅只像开发者报告最小的周期。</li>\n</ul>\n<p>有了这些最后一部分就是找出谁可能会意外的引入一个循环引用，我们通过 “git/hg blame” 来做到这些。猜测这可能是导致出现问题的最新修改。最后一个提交代码的人会收到一个通知。整个系统可以如下展示</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fnrkrs9hmvj30kg0660ua.jpg\" alt=\"系统图\" /></p>\n<h4 id=\"手工配置\"><a class=\"anchor\" href=\"#手工配置\">#</a> 手工配置</h4>\n<p>  尽管自动化帮助简化了寻找循环引用的过程，并减少了开发人员的工作，但是手动配置仍然很重呀。我们开发的另一款工具允许任何人查看应用程序的内存使用情况，甚至不用将手机插入电脑。FBMemoryProfiler 可以很容易地添加到任何应用中，让你手动配置你的工程，并在应用中运行循环引用检测，它可以通过使用 FBAllocationTracker 和 fbretaincycle 检测器来完成。</p>\n<p>原文链接 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlLmZhY2Vib29rLmNvbS9wb3N0cy81ODM5NDYzMTUwOTQzNDcvYXV0b21hdGljLW1lbW9yeS1sZWFrLWRldGVjdGlvbi1vbi1pb3Mv\">https://code.facebook.com/posts/583946315094347/automatic-memory-leak-detection-on-ios/</span></p>\n",
            "tags": [
                "翻译",
                "优化",
                "国外文献"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-24-%E8%BD%AC-%E5%A6%82%E4%BD%95%E6%8E%8C%E6%8F%A1%E6%89%80%E6%9C%89%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/",
            "url": "https://oliverqueen.cn/2018-01-24-%E8%BD%AC-%E5%A6%82%E4%BD%95%E6%8E%8C%E6%8F%A1%E6%89%80%E6%9C%89%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/",
            "title": "(转)如何掌握所有的程序语言",
            "date_published": "2018-01-24T03:38:59.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>觉得作者写的很好就转载下，原文链接：<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy55aW53YW5nLm9yZy9ibG9nLWNuLzIwMTcvMDcvMDYvbWFzdGVyLXBs\">http://www.yinwang.org/blog-cn/2017/07/06/master-pl</span></p>\n<p>对的，我这里要讲的不是如何掌握一种程序语言，而是所有的……<br />\n 很多编程初学者至今还在给我写信请教，问我该学习什么程序语言，怎么学习。由于我知道标题问题的答案，所以总感觉这个问题是如此 “低级”，一直没来得及回复 😛 可是逐渐的，我发现原来不只是小白们有这个问题，就连美国大公司的很多资深工程师，其实也没搞明白。<br />\n今天休闲活动进入第二个星期，稍微闲下来一点，我想来统一回答一下这个搁置已久的 “初级问题”。这个话题貌似曾经写过，然而现在我想把它重新写一遍。因为通过跟很多人的交流，我对自己头脑中的（未转化为语言的）想法，有了更精确的表达。<br />\n如果你存在以下的种种困惑，那么这篇文章也许会对你有所帮助：<br />\n你是编程初学者，不知道该选择什么程序语言来入门。<br />\n你是资深的程序员或者团队领导，对新出现的种种语言感到困惑，不知道该 “投资” 于那种语言。<br />\n你的团队为使用哪种程序语言争论不休，发生各种宗教斗争。<br />\n你追逐潮流采用了某种时髦的语言，结果两个月之后发现深陷泥潭，痛苦不堪……<br />\n<span id=\"more\"></span></p>\n<p>虽然我已经不再过问这些世事，然而无可置疑的现实是，程序语言仍然是很重要的话题，这个情况短时间内不会改变。程序员的岗位往往会要求熟悉某些语言，甚至某些奇葩的公司要求你 “深入理解 OOP 或者 FP 设计模式”。对于在职的程序员，程序语言至今仍然是可以争得面红耳赤的宗教话题。它的宗教性之强，以至于我在批评和调侃某些语言（比如 Go 语言）的时候，有些人会本能地以为我是另外一种语言（比如 Java）的粉丝 😛<br />\n其实呢，我并不是任何一种语言的粉丝，我甚至不是 Yin 语言的粉丝 😉 对于任何从没见过的语言，我都是直接拿起来就用，而不需要经过学习的过程。看了这篇文章，也许你会明白我为什么可以达到这个效果。理解了这里面的东西，每个程序员都应该可以做到这一点。嗯，但愿吧。。。 😛<br />\n重视语言特性，而不是语言<br />\n很多人在乎自己或者别人是否 “会” 某种语言，对 “发明” 了某种语言的人倍加崇拜，为各种语言的孰优孰劣争得面红耳赤。这些问题对于我来说都是不存在的。虽然我写文章批评过不少语言的缺陷，在实际工作中我却很少跟人争论这些。如果有其它人在我身边争论，我甚至会戴上耳机，都懒得听他们说什么 😉 为什么呢？我发现归根结底的原因，是因为我重视的是 “语言特性”，而不是整个的 “语言”。我能用任何语言写出不错的代码，就算再糟糕的语言也差不了多少。<br />\n任何一种 “语言”，都是各种 “语言特性” 的组合。打个比方吧，一个程序语言就像一台电脑。它的牌子可能叫 “联想”，或者 “IBM”，或者 “Dell”，或者 “苹果”。那么，你可以说苹果一定比 IBM 好吗？你不能。你得看看它里面装的是什么型号的处理器，有多少个核，主频多少，有多少 L1 cache，L2 cache……，有多少内存和硬盘，显示器分辨率有多大，显卡是什么 GPU，网卡速度，等等各种 “配置”。有时候你还得看各个组件之间的兼容性。<br />\n这些配置对应到程序语言里面，就是所谓 “语言特性”。举一些语言特性的例子：<br />\n变量定义<br />\n算术运算<br />\n for 循环语句，while 循环语句<br />\n函数定义，函数调用<br />\n递归<br />\n静态类型系统<br />\n类型推导<br />\n lambda 函数<br />\n面向对象<br />\n垃圾回收<br />\n指针算术<br />\n goto 语句</p>\n<p>这些语言特性，就像你在选择一台电脑的时候，看它里面是什么配置。选电脑的时候，没有人会说 Dell 一定是最好的，他们只会说这个型号里面装的是 Intel 的 i7 处理器，这个比 i5 的好，DDR3 的内存 比 DDR2 的快这么多，SSD 比磁盘快很多，ATI 的显卡是垃圾…… 如此等等。<br />\n程序语言也是一样的道理。对于初学者来说，其实没必要纠结到底要先学哪一种语言，再学哪一种。曾经有人给我发信问这种问题，纠结了好几个星期，结果一个语言都还没开始学。有这纠结的时间，我都可以把他纠结过的语言全部掌握了。<br />\n初学者往往不理解，每一种语言里面必然有一套 “通用” 的特性。比如变量，函数，整数和浮点数运算，等等。这些是每个通用程序语言里面都必须有的，一个都不能少。你只要通过 “某种语言” 学会了这些特性，掌握这些特性的根本概念，就能随时把这些知识应用到任何其它语言。你为此投入的时间基本不会浪费。所以初学者纠结要 “先学哪种语言”，这种时间花的很不值得，还不如随便挑一个语言，跳进去。<br />\n很多初学者不了解，一个高明的程序员如果开始用一种新的程序语言，他往往不是去看这个语言的大部头手册或者书籍，而是先有一个需要解决的问题。手头有了问题，他可以用两分钟浏览一下这语言的手册，看看这语言大概长什么样。然后，他直接拿起一段例子代码来开始修改捣鼓，想法把这代码改成自己正想解决的问题。在这个简短的过程中，他很快的掌握了这个语言，并用它表达出心里的想法。<br />\n在这个过程中，他会问这样的问题：<br />\n这个语言的 “变量定义” 是什么语法，需要 “声明类型” 吗，还是可以用 “类型推导”？<br />\n它的 “类型” 是什么语法？是否支持 “泛型”？泛型的 “variance” 如何表达？<br />\n这个语言的 “函数” 是什么语法，“函数调用” 是什么语法，可否使用 “缺省参数”？<br />\n……</p>\n<p>注意到了吗？上面每一个引号里面的内容，都是一种语言特性（或者叫概念）。这些概念可以存在于任何的语言里面，虽然语法可能不一样，它们的本质都是一样的。比如，有些语言的参数类型写在变量前面，有些写在后面，有些中间隔了一个冒号，有些没有。<br />\n这些实际问题都是随着写实际的代码，解决手头的问题，自然而然带出来的，而不是一开头就抱着语言手册看得仔仔细细。因为掌握了语言特性的人都知道，自己需要的特性，在任何语言里面一定有对应的表达方式。如果没有直接的方式表达，那么一定有某种 “绕过方式”。如果有直接的表达方式，那么它只是语法稍微有所不同而已。所以，他是带着问题找特性，就像查字典一样，而不是被淹没于大部头的手册里面，昏昏欲睡一个月才开始写代码。<br />\n掌握了通用的语言特性，剩下的就只剩某些语言 “特有” 的特性了。研究语言的人都知道，要设计出新的，好的，无害的特性，是非常困难的。所以一般说来，一种好的语言，它所特有的新特性，终究不会超过一两种。如果有个语言号称自己有超过 5 种新特性，那你就得小心了，因为它们带来的和可能不是优势，而是灾难！<br />\n同样的道理，最好的语言研究者，往往不是某种语言的设计者，而是某种关键语言特性的设计者（或者支持者）。举个例子，著名的计算机科学家 Dijkstra 就是 “递归” 的强烈支持者。现在的语言里面都有递归，然而你可能不知道，早期的程序语言是不支持递归的。直到 Dijkstra 强烈要求 Algol 60 委员会加入对递归的支持，这个局面才改变了。Tony Hoare 也是语言特性设计者。他设计了几个重要的语言特性，却没有设计过任何语言。另外大家不要忘了，有个语言专家叫王垠，他是早期 union type 的支持者和实现者，也是 checked exception 特性的支持者，他在自己的<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy55aW53YW5nLm9yZy9ibG9nLWNuLzIwMTcvMDUvMjMva290bGlu\">博文</span>里指出了 checked exception 和 union type 之间的关系 😛<br />\n很多人盲目的崇拜语言设计者，只要听到有人设计（或者美其民曰 “发明”）了一个语言，就热血沸腾，佩服的五体投地。他们却没有理解，其实所有的程序语言，不过是像 Dell，联想一样的 “组装机”。语言特性的设计者，才是像 Intel，AMD，ARM，Qualcomm 那样核心技术的创造者。<br />\n合理的入门语言<br />\n所以初学者要想事半功倍，就应该从一种 “合理” 的，没有明显严重问题的语言出发，掌握最关键的语言特性，然后由此把这些概念应用到其它语言。哪些是合理的入门语言呢？我个人觉得这些语言都可以用来入门：<br />\nScheme<br />\nC<br />\nJava<br />\nPython<br />\nJavaScript</p>\n<p>那么相比之下，我不推荐用哪些语言入门呢？<br />\nShell<br />\nPowerShell<br />\nAWK<br />\nPerl<br />\nPHP<br />\nBasic<br />\nGo</p>\n<p>总的说来，你不应该使用所谓 “<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy55aW53YW5nLm9yZy9ibG9nLWNuLzIwMTMvMDMvMjkvc2NyaXB0aW5nLWxhbmd1YWdl\">脚本语言</span>” 作为入门语言，特别是那些源于早期 Unix 系统的脚本语言工具。PowerShell 虽然比 Unix 的 Shell 有所进步，然而它仍然没有摆脱脚本语言的根本问题 —— 他们的设计者不知道他们自己在干什么 😛<br />\n采用脚本语言学编程，一个很严重的问题就是使得学习者抓不住关键。脚本语言往往把一些系统工具性质的东西（比如正则表达式，Web 概念）加入到语法里面，导致初学者为它们浪费太多时间，却没有理解编程最关键的概念：变量，函数，递归，类型……<br />\n 不推荐 Go 语言的原因类似，虽然 Go 语言不算脚本语言，然而他的设计者显然不明白自己在干什么。所以使用 Go 语言来学编程，你不能专注于最关键，最好的语言特性。<br />\n掌握关键语言特性，忽略次要特性<br />\n为了达到我之前提到的 “融会贯通”，一通百通的效果，初学者应该专注于语言里面最关键的特性，而不是被次要的内容分心。我发现很多编程培训班和野鸡大学的编程入门课，往往一来就教学生如何使用 printf 打印 “Hello World！”，进而要他们记忆 printf 的各种 “格式字符” 的意义，要他们实现各种复杂格式的打印输出，甚至要求打印到文本文件里，然后再读出来……<br />\n 可是殊不知，这种输出输入操作其实根本不算是语言的一部分，而且对于掌握编程的核心概念来说，都是次要的。有些人的 Java 课程进行了好几个星期，居然还在布置各种 printf 的作业。学生写出几百行的 printf，却不理解 “变量” 和 “函数” 是什么，甚至连算术语句和循环语句都不知道怎么用！这就是为什么很多初学者感觉编程很难，我连 % d<br />\n，%f<br />\n，%.2f<br />\n 的含义都记不住，还怎么学编程！<br />\n然而这些野鸡大学的 “教授” 头衔是如此的洗脑，以至于被他们教过的学生（比如我女朋友）到我这里请教，居然骂我净教一些没用的东西，学了连 printf 的作业都没法完成 😛 你别跟我讲 for 循环，函数什么的了…… 可不可以等几个月，等我背熟了 printf 的用法再学那些啊？<br />\n所以你就发现一旦被坏老师教过，这个程序员基本就毁了。就算遇到好的老师，她也很难纠正过来。<br />\n自己动手实现语言特性<br />\n在基本学会了各种语言特性，能用它们来写代码之后，下一步的进阶就是去实现它们。只有实现了各种语言特性，你才能完完全全的拥有它们，成为它们的主人。否则你就只是它们的使用者，你会永远做语言创造者们的仆人。<br />\n有个大师说得好，完全理解一种语言最好的方法就是自己动手实现它，也就是自己写一个解释器来实现它的语义。但我觉得这句话应该稍微修改一下：完全理解一种 “语言特性” 最好的方法就是自己亲自实现它。<br />\n注意我在这里把 “语言” 改为了 “语言特性”。你并不需要实现整个语言来达到这个目的，因为我们最终使用的语言特性。只要你自己实现了一种语言特性，你就能理解这个特性在任何语言里的实现方式和用法。<br />\n举个例子，学习 SICP 的时候，大家都会亲自用 Scheme 实现一个面向对象系统。用 Scheme 实现的面向对象系统，跟 Java，C++，Python 之类的语言语法相去甚远，然而它却能帮助你理解任何这些 OOP 语言里面的 “面向对象” 这一概念。它甚至能帮助你理解各种面向对象实现的差异，这种效果是你直接学习 OOP 语言也得不到的。<br />\n类似的特性还包括类型推导，类型检查，惰性求值，如此等等。我实现过几乎所有的语言特性，所以任何语言在我的面前都是可以被任意拆卸组装玩弄的玩具，而不再是凌驾于我之上，高高在上的神圣。<br />\n总结<br />\n写了这么多，重要的话重复三遍：语言特性，语言特性，语言特性，语言特性！不管是初学者还是资深程序员，应该专注于语言特性，而不是整个语言的 “品牌”。只有这样才能达到融会贯通，拿起任何语言几乎立即就会用，并且写出高质量的代码</p>\n",
            "tags": [
                "杂谈"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-24-%E8%AE%B0%E4%B8%80%E6%AC%A1Runtime-Hook%E7%9A%84%E9%97%AE%E9%A2%98/",
            "url": "https://oliverqueen.cn/2018-01-24-%E8%AE%B0%E4%B8%80%E6%AC%A1Runtime-Hook%E7%9A%84%E9%97%AE%E9%A2%98/",
            "title": "记一次Runtime Hook的问题",
            "date_published": "2018-01-24T03:35:57.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h4 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景</h4>\n<p>项目中遇到一个问题，需要引入两个 SDK，我们暂且命名为 A 和 B，由于业务需要这两个 SDK 都需要对一个系统函数 C 进行 hook, 但是有一个前提，由于 B 所做的是一个统计相关的 SDK，所以 B 要监控 App 内的所有代码这其中也包括了 SDK A 所做的一些操作，所以我们必须确保 B 在 hook C 函数时候  A 已经对 C 函数 hook 完毕，其实这就涉及到 hook 顺序的问题。<br />\n<span id=\"more\"></span></p>\n<h4 id=\"研究\"><a class=\"anchor\" href=\"#研究\">#</a> 研究</h4>\n<p>先看下代码，我用 hookMethod 来模仿系统方法。<br />\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>) TEST_HOOK_TWICE &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> changeOrginalSelectorName:<span class=\"string\">@&quot;hookedMethod&quot;</span> inClass:<span class=\"string\">@&quot;RootViewController&quot;</span> withCustomSelectorName:<span class=\"string\">@&quot;swizzle_hookedMethod1&quot;</span> isClassMethod:<span class=\"literal\">NO</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> changeOrginalSelectorName:<span class=\"string\">@&quot;hookedMethod&quot;</span> inClass:<span class=\"string\">@&quot;RootViewController&quot;</span> withCustomSelectorName:<span class=\"string\">@&quot;swizzle_hookedMethod2&quot;</span> isClassMethod:<span class=\"literal\">NO</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> hookedMethod];</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)hookedMethod &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;原始方法&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)swizzle_hookedMethod1 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;1&quot;</span>);</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> swizzle_hookedMethod1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)swizzle_hookedMethod2 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;2&quot;</span>);</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> swizzle_hookedMethod2];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 然后看下没有 hook 之前的样子</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6ll1zt21j30j80jk3zc.jpg\" alt=\"原本的样子\" /></p>\n<p>然后我们执行代码<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一步：交换A中的方法和系统方法</span></span><br><span class=\"line\"> [<span class=\"keyword\">self</span> changeOrginalSelectorName:<span class=\"string\">@&quot;hookedMethod&quot;</span> inClass:<span class=\"string\">@&quot;RootViewController&quot;</span> withCustomSelectorName:<span class=\"string\">@&quot;swizzle_hookedMethod1&quot;</span> isClassMethod:<span class=\"literal\">NO</span>];</span><br><span class=\"line\"><span class=\"comment\">//第二步：交换B中的方法和系统方法</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> changeOrginalSelectorName:<span class=\"string\">@&quot;hookedMethod&quot;</span> inClass:<span class=\"string\">@&quot;RootViewController&quot;</span> withCustomSelectorName:<span class=\"string\">@&quot;swizzle_hookedMethod2&quot;</span> isClassMethod:<span class=\"literal\">NO</span>];</span><br><span class=\"line\"><span class=\"comment\">//第三步：调用系统方法</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> hookedMethod];</span><br></pre></td></tr></table></figure><br />\n 然后我们一步一步来看，先看调用第一步之后是什么样子的 (红色箭头为第一步之后的样子)</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6llhzf0uj30ki0k2q3z.jpg\" alt=\"第一步之后\" /></p>\n<p>然后看第二步调用完之后的样子 (绿色是第二步调用)</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6lm7mfshj30jo0iu75m.jpg\" alt=\"第二部之后的样子\" /></p>\n<p>接下来我们调用系统方法也就是第三步，然后我们看下流程是怎样的 (每个方法实现里面都会递归调用下自身，为了是 hook 时候不改变原有逻辑)</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6lmi43vmj30yg03v756.jpg\" alt=\"调用顺序\" /></p>\n<p>这样一来就很明显 如果想想监控住所有的代码那就需要在 A IMP 这步，因为之前的 Hook 顺序是先 A -&gt; B -&gt; System 这样一来只要我们改一下顺序改为 B -&gt; A -&gt; System 就可以让 B SDK 监控到所有的代码。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6ln0wmlyj30yg07ign0.jpg\" alt=\"调用顺序\" /></p>\n",
            "tags": [
                "底层",
                "runtime",
                "Hook"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-23-iOS%E4%B8%AD%E4%BD%BF%E7%94%A8OpenGL%E5%AE%9E%E7%8E%B0%E5%A2%9E%E9%AB%98%E5%8A%9F%E8%83%BD/",
            "url": "https://oliverqueen.cn/2018-01-23-iOS%E4%B8%AD%E4%BD%BF%E7%94%A8OpenGL%E5%AE%9E%E7%8E%B0%E5%A2%9E%E9%AB%98%E5%8A%9F%E8%83%BD/",
            "title": "iOS中使用OpenGL实现增高功能",
            "date_published": "2018-01-23T13:23:49.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"功能效果\"><a class=\"anchor\" href=\"#功能效果\">#</a> 功能效果</h3>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6lpd4q64g308u0fqnpe.gif\" alt=\"demo示例\" /><br />\n<span id=\"more\"></span></p>\n<h3 id=\"功能分析\"><a class=\"anchor\" href=\"#功能分析\">#</a> 功能分析</h3>\n<ul>\n<li>\n<p>功能：渲染一张传入的图片 -&gt; 手动选择编辑区域 -&gt; 通过滑块来编辑区域的增高或者缩短</p>\n</li>\n<li>\n<p>OpenGL 原理：</p>\n<ul>\n<li>\n<p>因为 OpenGL 只能绘制三角形，所以在处理图像或者图形的时候我们需要将被处理的对象用三角行来分割转换为三角形和顶点的组成的对象。</p>\n</li>\n<li>\n<p>OpenGL 里面坐标是以左下角为原点 X 轴向上为正，Y 轴向右为正</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"功能实现\"><a class=\"anchor\" href=\"#功能实现\">#</a> 功能实现</h3>\n<ul>\n<li>渲染图片拆分图片：\n<ul>\n<li>拆分方法 1：通过图形看出是一个矩形，而矩形是可以分成两个三角形和四个顶点，通过此可以用 GL 渲染出图片。</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6lpjw6g3j30dw0ee7ft.jpg\" alt=\"拆分三角形\" /></p>\n<p>这样拆分之后虽然可以正常渲染，但是带来的问题是我的四个顶点都是死的，也就是四个顶点必须是画布的四个顶点，改变顶点的坐标后只能导致整张画布的变动，而不是某一个区域的变动，拉伸的话也是整张图片的拉伸，所以想要实现局部处理的话这种分割方式不可行。</p>\n<ul>\n<li>拆分方法 2：将整张图片先拆分为三个矩形，然后再把每个矩形拆分成两个三角形，得到 6 个三角形，8 个顶点，如下图：</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6lprpvrrj30dw0eddrh.jpg\" alt=\"拆分2\" /></p>\n<p>这样一来就可以保证中间的矩形的高度可以任意变化而上下两部分的高度不变只改变位置，也就是说我们这个 DEMO 中所做的任何拉伸操作都是对中间矩形的操作，换而言之就是改变最上面的矩形和最下面的矩形之间的距离来达到对中间区域的拉伸和压缩的目的。根据拆分的方式我们用顶点的坐标创建一个数组<br />\n <figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">//</span>顶点数组</span><br><span class=\"line\">GLfloat vertices[] = &#123;   </span><br><span class=\"line\">    -1.2, -1.2,     <span class=\"string\">//</span>左下</span><br><span class=\"line\">    1.2, -1.2,      <span class=\"string\">//</span>右下</span><br><span class=\"line\">    -1.2, -0.4,     <span class=\"string\">//</span>小矩形左下</span><br><span class=\"line\">    1.2, -0.4,      <span class=\"string\">//</span>小矩形右下</span><br><span class=\"line\">    -1.2,  0.4,     <span class=\"string\">//</span>小矩形左上</span><br><span class=\"line\">    1.2,  0.4,      <span class=\"string\">//</span>小矩形右上</span><br><span class=\"line\">    -1.2,  1.2,     <span class=\"string\">//</span>左上</span><br><span class=\"line\">    1.2,  1.2,      <span class=\"string\">//</span>右上</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"string\">//</span>填充纹理的数组</span><br><span class=\"line\">GLfloat texCoords[] = &#123;     </span><br><span class=\"line\">    0, 0,        <span class=\"string\">//</span>左下                  <span class=\"string\">//</span>下标为 0 1</span><br><span class=\"line\">    1, 0,        <span class=\"string\">//</span>右下                  <span class=\"string\">//</span>下标为2 3</span><br><span class=\"line\">    0, 1.0/3.0,  <span class=\"string\">//</span>小矩形左下             <span class=\"string\">//</span>下标为4 5</span><br><span class=\"line\">    1, 1.0/3.0,  <span class=\"string\">//</span>小矩形右下             <span class=\"string\">//</span>下标为6 7</span><br><span class=\"line\">    0, 2.0/3.0,  <span class=\"string\">//</span>小矩形左上角           <span class=\"string\">//</span>下标为8 9</span><br><span class=\"line\">    1, 2.0/3.0,  <span class=\"string\">//</span>小矩形右上角           <span class=\"string\">//</span>下标为10 11</span><br><span class=\"line\">    0, 1,        <span class=\"string\">//</span>左上                  <span class=\"string\">//</span>下标为12 13</span><br><span class=\"line\">    1, 1,        <span class=\"string\">//</span>右上                  <span class=\"string\">//</span>下标为14 15</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>手动选择区域：通过添加带有自定义手势的 UIView 来实现拖动修改选择区域。</li>\n</ul>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*****************CustomPanView代码******************</span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">CustomPanViewDelegate</span> &lt;<span class=\"title\">NSObject</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  开始拖拽</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param customPanView 自身</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param centerY       自身所在的y坐标</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)beginDragWithCoustomPanView:(<span class=\"built_in\">UIView</span> *)customPanView centerY:(<span class=\"built_in\">CGFloat</span>)centerY;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CustomPanView</span> : <span class=\"title\">UIView</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"type\">id</span>&lt;CustomPanViewDelegate&gt; delegate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*****************CustomPanViewDelegate代码******************</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark -</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark 拖拽View的代理方法</span></span><br><span class=\"line\">-(<span class=\"type\">void</span>)beginDragWithCoustomPanView:(<span class=\"built_in\">UIView</span> *)customPanView centerY:(<span class=\"built_in\">CGFloat</span>)centerY &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 限制范围：裁剪区不能大于图片区域</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (customPanView.center.y &gt;= imageBottom) &#123;</span><br><span class=\"line\">        customPanView.center = <span class=\"built_in\">CGPointMake</span>(customPanView.center.x, imageBottom);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (customPanView.center.y &lt;= imageTop) &#123;</span><br><span class=\"line\">        customPanView.center = <span class=\"built_in\">CGPointMake</span>(customPanView.center.x, imageTop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    获取两条线的坐标</span></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> topY = _topView.center.y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> bottomY = _bottomView.center.y;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    根据两条线的坐标刷新裁剪区域UI</span></span><br><span class=\"line\">    [_cutLabel setFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, topY &lt; bottomY ? topY : bottomY, SCREEN_WIDTH, fabs(bottomY - topY))];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    算出裁剪起始坐标和结束坐标</span></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> fromPoint = topY &lt; bottomY ? (imageBottom - bottomY) / imageHeight : (imageBottom - topY) / imageHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> toPoint = topY &lt; bottomY ? (imageBottom - topY) / imageHeight : (imageBottom - bottomY) / imageHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//将中间的矩形的顶点坐标和坐标联系裁剪区域联系起来。</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> sendFromePoint:fromPoint endPoint:toPoint];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_cutLabel.frame.size.height &lt; <span class=\"number\">30</span>) &#123;  <span class=\"comment\">//隐藏文字</span></span><br><span class=\"line\">        _cutLabel.text = <span class=\"string\">@&quot;&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        _cutLabel.text = <span class=\"string\">@&quot;编辑区域&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.slider setValue:<span class=\"number\">0.0</span> animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    tmpHeight = <span class=\"number\">0.0</span>f;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 使用一个 Delegate 将拖移后的 Y 坐标返回，因为是竖直运动的所以我们只关心 Y 轴坐标。</p>\n<ul>\n<li>改变大小：通过将 UISliderBar 的 ValueChange 和顶点坐标关联来实现改变顶点坐标，之后调用 GLKView 的 display 的方法来刷新 UI，将变化的过程展现出来。</li>\n</ul>\n<p><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)action:(UISlider *)sender &#123;</span><br><span class=\"line\">    <span class=\"regexp\">//</span>判断是否是向右滑动</span><br><span class=\"line\">    isRightDirection = sender.value &gt;= judgeDirection ? YES : NO;</span><br><span class=\"line\">    <span class=\"regexp\">//</span>所改变的高度</span><br><span class=\"line\">    changeHeight = sender.value - tmpHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"regexp\">//</span>遍历数组</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (int i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">16</span>; i ++) &#123;</span><br><span class=\"line\">        <span class=\"regexp\">//</span>将Y坐标筛选出来</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i % <span class=\"number\">2</span> != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"regexp\">//</span>下半部分矩形</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt;= <span class=\"number\">7</span>) &#123;</span><br><span class=\"line\">                <span class=\"regexp\">//</span>下半部分矩形Y轴做减法减去变化的高度</span><br><span class=\"line\">                vertices[i] = verticesCopy[i] - changeHeight;</span><br><span class=\"line\">                <span class=\"regexp\">//</span>上半部分矩形</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">9</span>) &#123;</span><br><span class=\"line\">                <span class=\"regexp\">//</span>上半部分矩形Y轴做加法加上变化的高度</span><br><span class=\"line\">                vertices[i] = verticesCopy[i] + changeHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"regexp\">//</span>缩小时候如果编辑区域已经成为一条线了就不能在缩小了</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vertices[<span class=\"number\">11</span>] &gt; vertices[<span class=\"number\">7</span>]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        [self.glView display];</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>通过 glReadPixels 来从内存中读取像素数据，GLubyte -&gt; CGImageRef -&gt; UIimage 然后最相关的保存或者其他操作。</li>\n</ul>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#pragma mark -</span><br><span class=\"line\">#pragma mark 获取处理后的图片</span><br><span class=\"line\">- (UIImage *) createImage &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> imageY = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> imgHeight = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isRightDirection) &#123; <span class=\"comment\">// 判断slider滑动方向</span></span><br><span class=\"line\"></span><br><span class=\"line\">        imageY = fabs(imageTop - fabs(changeHeight<span class=\"operator\"> * </span>perOpengleseCoordinate))<span class=\"operator\"> * </span>screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">        imgHeight = fabs(imageHeight + <span class=\"number\">2</span><span class=\"operator\"> * </span>fabs(changeHeight<span class=\"operator\"> * </span>perOpengleseCoordinate))<span class=\"operator\"> * </span>screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        imageY = fabs(imageTop + fabs(changeHeight<span class=\"operator\"> * </span>perOpengleseCoordinate))<span class=\"operator\"> * </span>screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">        imgHeight = fabs(imageHeight - <span class=\"number\">2</span><span class=\"operator\"> * </span>fabs(changeHeight<span class=\"operator\"> * </span>perOpengleseCoordinate))<span class=\"operator\"> * </span>screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> imageWidth = SCREEN_WIDTH<span class=\"operator\"> * </span>screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> dataLength = imageWidth<span class=\"operator\"> * </span>imgHeight<span class=\"operator\"> * </span><span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    GLubyte *data = (GLubyte*)malloc(dataLength<span class=\"operator\"> * </span>sizeof(GLubyte));</span><br><span class=\"line\"></span><br><span class=\"line\">    gl<span class=\"constructor\">PixelStorei(GL_PACK_ALIGNMENT, 4)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    gl<span class=\"constructor\">ReadPixels(0, <span class=\"params\">imageY</span>, <span class=\"params\">imageWidth</span>, <span class=\"params\">imgHeight</span>, GL_RGBA, GL_UNSIGNED_BYTE, <span class=\"params\">data</span>)</span>;  <span class=\"comment\">//从内存中读取像素</span></span><br><span class=\"line\">    CGDataProviderRef <span class=\"built_in\">ref</span> = <span class=\"constructor\">CGDataProviderCreateWithData(NULL, <span class=\"params\">data</span>, <span class=\"params\">dataLength</span>, NULL)</span>;</span><br><span class=\"line\">    CGColorSpaceRef colorspace = <span class=\"constructor\">CGColorSpaceCreateDeviceRGB()</span>;</span><br><span class=\"line\">    CGImageRef iref = <span class=\"constructor\">CGImageCreate(<span class=\"params\">imageWidth</span>, <span class=\"params\">imgHeight</span>, 8, 32, <span class=\"params\">imageWidth</span> <span class=\"operator\">*</span> 4, <span class=\"params\">colorspace</span>, <span class=\"params\">kCGBitmapByteOrder32Big</span> | <span class=\"params\">kCGImageAlphaPremultipliedLast</span>,<span class=\"params\">ref</span>, NULL, <span class=\"params\">true</span>, <span class=\"params\">kCGRenderingIntentDefault</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"constructor\">UIGraphicsBeginImageContext(CGSizeMake(<span class=\"params\">imageWidth</span>, <span class=\"params\">imgHeight</span>)</span>);</span><br><span class=\"line\">    CGContextRef cgcontext = <span class=\"constructor\">UIGraphicsGetCurrentContext()</span>;</span><br><span class=\"line\">    <span class=\"constructor\">CGContextSetBlendMode(<span class=\"params\">cgcontext</span>, <span class=\"params\">kCGBlendModeCopy</span>)</span>;</span><br><span class=\"line\">    <span class=\"constructor\">CGContextDrawImage(<span class=\"params\">cgcontext</span>, CGRectMake(0, 0, <span class=\"params\">imageWidth</span>, <span class=\"params\">imgHeight</span>)</span>, iref);</span><br><span class=\"line\"></span><br><span class=\"line\">    CGImageRef imageMasked = <span class=\"constructor\">CGBitmapContextCreateImage(<span class=\"params\">cgcontext</span>)</span>;</span><br><span class=\"line\">    UIImage<span class=\"operator\"> * </span>image = <span class=\"literal\">[UII<span class=\"identifier\">mage</span> <span class=\"identifier\">imageWithCGImage</span>:<span class=\"identifier\">imageMasked</span> <span class=\"identifier\">scale</span>:<span class=\"identifier\">screenScale</span> <span class=\"identifier\">orientation</span>:UII<span class=\"identifier\">mageOrientationUp</span>]</span>;</span><br><span class=\"line\">    <span class=\"constructor\">UIGraphicsEndImageContext()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    free(data);</span><br><span class=\"line\">    <span class=\"constructor\">CFRelease(<span class=\"params\">ref</span>)</span>;</span><br><span class=\"line\">    <span class=\"constructor\">CFRelease(<span class=\"params\">colorspace</span>)</span>;</span><br><span class=\"line\">    <span class=\"constructor\">CGImageRelease(<span class=\"params\">iref</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    return image;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n",
            "tags": [
                "底层",
                "OpenGL",
                "UI"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-23-%E5%85%B3%E4%BA%8E%E7%89%A9%E7%90%86%E6%95%88%E6%9E%9C%E7%9A%84%E5%8A%A8%E7%94%BB%E5%BC%95%E6%93%8EUIDynamic%E4%BB%8B%E7%BB%8D/",
            "url": "https://oliverqueen.cn/2018-01-23-%E5%85%B3%E4%BA%8E%E7%89%A9%E7%90%86%E6%95%88%E6%9E%9C%E7%9A%84%E5%8A%A8%E7%94%BB%E5%BC%95%E6%93%8EUIDynamic%E4%BB%8B%E7%BB%8D/",
            "title": "关于物理效果的动画引擎UIDynamic介绍",
            "date_published": "2018-01-23T13:18:42.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>这几天事情超多，实在很难静下心来研究一个东西，但是这个类我也是关注好久了，早就想总结下写出来， 可能这篇文章并不会像之前额那样那么详细，按理说写动画相关的东西应该是配 gif 的，但是真的是没有心思再去搞那些东西，代码并不难，大家可以照着代码写一下看下效果。<br />\n        为了实现动力 UI，需要注册一套 UI 行为的体系，之后 UI 便会按照预先的设定进行运动了。我们应该了解的新的基本概念有如下四个：<br />\nUIDynamicItem：用来描述一个力学物体的状态，其实就是实现了 UIDynamicItem 委托的对象，或者抽象为有面积有旋转的质点； 简单的说就是一个控件，就是你想往谁上面加动画，这个就是谁。<br />\nUIDynamicBehavior：动力行为的描述，用来指定 UIDynamicItem 应该如何运动，即定义适用的物理规则。一般我们使用这个类的子类对象来对一组 UIDynamicItem 应该遵守的行为规则进行描述；简单的说就是动画效果，这个类是动画效果的一个父类，它的子类大家可以用运行时的方法输出一下看一下，或者一会看我介绍，一个子类是一个效果，各种效果比如重力啊碰撞啊，链接啊之类的。<br />\nUIDynamicAnimator；动画的播放者，动力行为（UIDynamicBehavior）的容器，添加到容器内的行为将发挥作用；<br />\nReferenceView：等同于力学参考系，如果你的初中物理不是语文老师教的话，我想你知道这是啥.. 只有当想要添加力学的 UIView 是 ReferenceView 的子 view 时，动力 UI 才发生作用。下面看下我们给一个 button 加一个重力下坠的动画 使用 self.View 做参考系来建立动画<br />\n<span id=\"more\"></span><br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6m073lu9j30ft02n74g.jpg\" alt=\"\" /></p>\n<p>然后</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6m0h0bvej307900s0si.jpg\" alt=\"\" /></p>\n<p>你可以吧这里航代码写到 button 的点击事件中，这样你一点就会下坠。很简单吧。<br />\n        再看下一个碰撞</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6m1auc65j30mx02ht92.jpg\" alt=\"\" /></p>\n<p>我这里写碰撞动画的时候用了两个 button，其实大家可以猜到我是让两个 button 来碰撞的，碰撞的过程中也是会走代理方法的，开始碰撞啊，碰撞结束啊之类的。最后那句话的意思是吧他的参考系 (这里是的 self.view) 的边界作为碰撞边界，就是说这段代码运行后这两个 这两控件撞到屏幕 self.view 的边框会发生物理的碰撞反弹效果。想这样 (点我开始那个按钮)</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6m1l2ecwg308r0fl75h.gif\" alt=\"\" /></p>\n<p>除了重力和碰撞，iOS SDK 还预先帮我们实现了一些其他的有用的物理行为，它们包括<br />\n UIAttachmentBehavior 描述一个 view 和一个锚相连接的情况，也可以描述 view 和 view 之间的连接。attachment 描述的是两个点之间的连接情况，可以通过设置来模拟无形变或者弹性形变的情况（再次希望你还记得这些概念，简单说就是木棒连接和弹簧连接两个物体）。当然，在多个物体间设定多个；UIAttachmentBehavior，就可以模拟多物体连接了.. 有了这些，似乎可以做个老鹰捉小鸡的游戏了 - -…<br />\nUISnapBehavior 将 UIView 通过动画吸附到某个点上。初始化的时候设定一下 UISnapBehavior 的 initWithItem:snapToPoint: 就行，因为 API 非常简单，视觉效果也很棒，估计它是今后非游戏 app 里会被最常用的效果之一了；<br />\nUIPushBehavior 可以为一个 UIView 施加一个力的作用，这个力可以是持续的，也可以只是一个冲量。当然我们可以指定力的大小，方向和作用点等等信息。<br />\nUIDynamicItemBehavior 其实是一个辅助的行为，用来在 item 层级设定一些参数，比如 item 的摩擦，阻力，角阻力，弹性密度和可允许的旋转等等</p>\n<p>其实流程很简单创建 animator  然后创建 behivator   设置 behivator 属性 然后 animator addBehivator 。就是这个么流程。写代码要学会举一反三触类旁通。    这篇博客写的比较急，但是总体上来说功能没问题，细节上有什么问题，大家找我一起交流</p>\n",
            "tags": [
                "UI",
                "动画"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-23-%E5%85%B3%E4%BA%8E%E8%A7%86%E5%9B%BE%E5%9C%A8%E5%88%87%E5%9C%86%E8%A7%92%E6%97%B6%E5%80%99%E7%9A%84%E5%AF%BC%E8%87%B4%E7%9A%84%E6%80%A7%E8%83%BD%E4%B8%8B%E9%99%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A2%E8%AE%A8/",
            "url": "https://oliverqueen.cn/2018-01-23-%E5%85%B3%E4%BA%8E%E8%A7%86%E5%9B%BE%E5%9C%A8%E5%88%87%E5%9C%86%E8%A7%92%E6%97%B6%E5%80%99%E7%9A%84%E5%AF%BC%E8%87%B4%E7%9A%84%E6%80%A7%E8%83%BD%E4%B8%8B%E9%99%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A2%E8%AE%A8/",
            "title": "关于视图在切圆角时候的导致的性能下降的一些探讨",
            "date_published": "2018-01-23T13:08:48.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>iOS 中有的时候我们控件要做成圆形 或者是切成圆角，这个时候我们一般都会使用.layer.cornerRadius  -&gt;  clipsToBounds = YES 的属性来切，这样完全能达到我们的效果，但是如果一个界面上需要切圆角的控件很多，并且列表很长的时候，尤其是像 tableView 那样如果每一个 cell 上都有大量的控件需要切，那么就会非常卡顿，帧数严重下降 。其实原因就是这样设置会触发离屏渲染，比较消耗性能。注意：png 图片 UIImageView 处理圆角是不会产生离屏渲染的。（ios9.0 之后不会离屏渲染，ios9.0 之前还是会离屏渲染）。这里先说下离屏渲染：<br />\n ###### iOS 的渲染机制：<br />\n   CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。GPU 屏幕渲染有以下两种方式：<br />\nOn-Screen Rendering<br />\n 意为当前屏幕渲染，指的是 GPU 的渲染操作是在当前用于显示的屏幕缓冲区中进行。<br />\nOff-Screen Rendering<br />\n 意为离屏渲染，指的是 GPU 在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。<br />\n<span id=\"more\"></span><br />\n 由以上可以看出离屏渲染需要重新开辟新的缓存空间，必定要更加消耗资源。<br />\n通过查资料目前知道了设置了以下属性时，都会触发离屏绘制：<br />\nshouldRasterize（光栅化）<br />\nmasks（遮罩）<br />\nshadows（阴影）<br />\nedge antialiasing（抗锯齿）<br />\ngroup opacity（不透明）<br />\n复杂形状设置圆角等<br />\n渐变<br />\n我用一个现有的小 DEMO 来测试下，因为这个 demo 中没有切圆角，但是有阴影，一样可以出发离屏渲染，所以效果是一样的，在 tableView 中的自定义 cell 类中我设置了阴影如图：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6makjj7sj30f2025aac.jpg\" alt=\"\" /></p>\n<p>使用 Instruments 测试得到当前帧数在二三十左右</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6maqxgt6j30uf03874d.jpg\" alt=\"\" /></p>\n<p>同时屏幕是也出现了黄色图层</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mb1epsnj30dx0ou40r.jpg\" alt=\"\" /></p>\n<p>所有黄色的高亮的图层都进行了离屏渲染，也表示这些图层存在着问题，影响性能。而且帧数过低也会直接影响我们对 APP 的体验。</p>\n<h6 id=\"如何避免离屏渲染\"><a class=\"anchor\" href=\"#如何避免离屏渲染\">#</a> 如何避免离屏渲染：</h6>\n<ul>\n<li>\n<p>方法一：使用光栅化，.layer.shouldRasterize = YES;   -&gt;  .layer.rasterizationScale=[UIScreen mainScreen].scale; 设置光栅化，可以使离屏渲染的结果缓存到内存中存为位图，使用的时候直接使用缓存，节省了一直离屏渲染损耗的性能。但是如果 layer 及 sublayers 常常改变的话，它就会一直不停的渲染及删除缓存重新创建缓存，所以这种情况下建议不要使用光栅化，这样也是比较损耗性能的。</p>\n</li>\n<li>\n<p>方法二：最简单的方法，就是图片不作处理，直接覆盖一张中间为圆形透明的图片（推荐使用）这种方法 GPU 计算多层的混合渲染 blending 也是会消耗一点性能的，但比第一种方法还是好上很多的</p>\n</li>\n<li>\n<p>方法三：Core Graphics 绘制圆角。这种方式 GPU 损耗最低，可以用 UIimageView 添加个点击手势当做 UIButton 使用。<br />\nUIGraphicsBeginImageContextWithOptions(avatarImageView.bounds.size, NO, [UIScreen mainScreen].scale);<br />\n[[UIBezierPath bezierPathWithRoundedRect:avatarImageView.bounds cornerRadius:50] addClip];[image drawInRect:avatarImageView.bounds];<br />\navatarImageView.image = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();<br />\n 这段方法可以写在 SDWebImage 的 completed 回调里，在主线程异步绘制。也可以封装到 UIImageView 里，写了个 DSRoundImageView。后台线程异步绘制，不会阻塞主线程。目前这种方法只用在 imageView 上，其他地方呢不知道怎么用，不过这种方法会耗费大量的 CPU 资源和占用内存，本人不太建议使用。</p>\n</li>\n</ul>\n<p>最后给大家测试下，因为我之前的 demo 没有切圆角，而是使用的阴影，所以我就用第一种方法给大家测一下。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mbdmx1bj30lu04ywfj.jpg\" alt=\"\" /></p>\n<p>然后运行，打开 Instruments，然后看屏幕</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mbm7cn6j30e40ox76i.jpg\" alt=\"\" /></p>\n<p>图层都是绿色没问题，我们再来看帧数，几乎到 60 ，效果很明显。<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mbsz37rj30j602k747.jpg\" alt=\"\" /></p>\n<p>由此可见以后大家再切圆角的时候多注意下，刚才就研究了这么多，有什么问题及时与我交流吧。。。</p>\n",
            "tags": [
                "UI",
                "性能优化"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-23-CFNetwork%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/",
            "url": "https://oliverqueen.cn/2018-01-23-CFNetwork%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/",
            "title": "CFNetwork的介绍和使用",
            "date_published": "2018-01-23T13:04:15.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"cfnetwork背景简介\"><a class=\"anchor\" href=\"#cfnetwork背景简介\">#</a> CFNetwork 背景简介</h3>\n<p>CFNetwork 是 ISO 中一个比较底层的网络框架，C 语言编写，可以控制一些更底层的东西，如各种常用网络协议、socket 通讯等，我们通常使用的 NSURL 则更倾向于 API 数据请求等，虽然框架也提供了一些操作，但是远不如 CFNetwork 丰富。CFNetwork 已经接近于 UNIX 系统的 socket 通信了，使用 CFHttpMessageRef 进行 HTTP 连接的好处就是控制的粒度更细了，例如你可以设置 SSL 连接的 PeerName，证书验证的方式，还可以控制每个响应包的接收。不过 CFNetwork 本质上还是应用层上的封装的通用 API。使用者可以不用关心底层协议的实际细节。下图是 CFNetwork 在 iOS 系统中的位置 (图片来源于官方文档)。</p>\n<p><span id=\"more\"></span><br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mit8tsij30bn06lwen.jpg\" alt=\"image.png\" /></p>\n<p>由上图可以看出目前 iOS 的网络编程分四层：</p>\n<ul>\n<li>\n<p>WebKit：属于 Cocoa 层，苹果很多地方用到的页面渲染引擎 WKWebview；</p>\n</li>\n<li>\n<p>NSURL：也属于 Cocoa 层，对各类 URL 请求的封装 (NSURLRequest)；</p>\n</li>\n<li>\n<p>CFNetwork：属于 Core Foundation 层，基于 C 的封装，同样的还有 CFNetServices (write/readstream)；</p>\n</li>\n<li>\n<p>BSD sockets：属于 OS 层，也是基于 C 的封装；</p>\n</li>\n</ul>\n<h3 id=\"cfnetwork结构\"><a class=\"anchor\" href=\"#cfnetwork结构\">#</a> CFNetwork 结构</h3>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mlt3gwcj30od0a474w.jpg\" alt=\"image.png\" /><br />\n 上图也是官方文档的图片，描述了 CFNetwork 的结构，下面逐一讲解。</p>\n<h5 id=\"cfsocket-api\"><a class=\"anchor\" href=\"#cfsocket-api\">#</a> CFSocket API</h5>\n<p>Socket 是网络通讯的底层基础，两个 socket 端口可以互发数据。我们通常使用的是 BSD socket，CFSocket 则是 BSD socket 的抽象，基本上实现了几乎所有 BSD socket 的功能，并且还融入了 run loop。</p>\n<h5 id=\"cfstream-api\"><a class=\"anchor\" href=\"#cfstream-api\">#</a> CFStream API</h5>\n<p>CFStream API 提供了数据读写的方法，即读写流，使用它可以为内存、文件、网络（使用 socket）的数据建立 stream，我们进行网络请求就是对数据的读写，CFStream 提供 API 对两种 CFType 对象提供抽象：CFReadStream and CFWriteStream。它同时也是 CFHTTP 和 CFFTP 的基础。stream 有一个很重要的特性就是一旦数据流被提供或者被消耗，就不能从流中重新取出。比如这样</p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint8_t d[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">//循环条件：流中是否有可用数据(被读过的数据不可用了)</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> ([<span class=\"keyword\">self</span>.inputStream hasBytesAvailable]) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//读取相应长度的数据数据</span></span><br><span class=\"line\">    <span class=\"built_in\">NSInteger</span> len = [<span class=\"keyword\">self</span>.inputStream read:d maxLength:<span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"comment\">//如果读取到数据，便将数据快拼接</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &gt; <span class=\"number\">0</span> &amp;&amp; !<span class=\"keyword\">self</span>.inputStream.streamError) &#123;</span><br><span class=\"line\">        [data appendBytes:(<span class=\"type\">void</span> *)d length:len];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"cfftp-api\"><a class=\"anchor\" href=\"#cfftp-api\">#</a> CFFTP API</h5>\n<p>对用 FTP 协议通信的封装，能下载、上传文件和目录到 FTP 服务器。CFFTP 建立的连接可以是同步或者异步，此次不做详解。</p>\n<h5 id=\"cfhttp-api\"><a class=\"anchor\" href=\"#cfhttp-api\">#</a> CFHTTP API</h5>\n<p>是 HTTP 协议的抽象，主要对象是 CFHTTPMessageRef (类似于我们通常的 NSURLRequest) 我们需要像构建 NSURLRequest 那样来构建 CFHTTPMessageRef，同样包含一下几个元素</p>\n<ul>\n<li>\n<p>必须元素</p>\n<ul>\n<li>\n<p>请求方法 (类型为 CFStringRef)：POST、GET、DELETE 等..</p>\n</li>\n<li>\n<p>请求的 URL 地址 (类型为 CFURLRef)：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmFpZHUuY29t\">https://www.baidu.com</span></p>\n</li>\n<li>\n<p>请求的 HTTP 版本 (类型为 CFStringRef)：通常使用 kCFHTTPVersion1_1</p>\n</li>\n<li>\n<p>kCFAllocatorDefault：用于创建消息引用的指定默认的系统内存分配器。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>可选参数</p>\n<ul>\n<li>body 体 (类型为 CFDataRef)</li>\n</ul>\n</li>\n</ul>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">CFHTTPMessageSetBody</span>(<span class=\"built_in\">CFHTTPMessageRef</span> message, <span class=\"built_in\">CFDataRef</span> bodyData) <span class=\"built_in\">CF_AVAILABLE</span>(<span class=\"number\">10</span>_1, <span class=\"number\">2</span>_0);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>消息头部，如 User-Agent 等；</li>\n</ul>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CFHTTPMessageSetHeaderFieldValue</span>(<span class=\"built_in\">CFHTTPMessageRef</span> message, <span class=\"built_in\">CFStringRef</span> headerField, <span class=\"built_in\">CFStringRef</span> __<span class=\"keyword\">nullable</span> value) <span class=\"built_in\">CF_AVAILABLE</span>(<span class=\"number\">10</span>_1, <span class=\"number\">2</span>_0);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"cfnetwork请求过程\"><a class=\"anchor\" href=\"#cfnetwork请求过程\">#</a> CFNetwork 请求过程</h3>\n<h5 id=\"1构造并创建cfhttpmessageref对象\"><a class=\"anchor\" href=\"#1构造并创建cfhttpmessageref对象\">#</a> 1：构造并创建 CFHTTPMessageRef 对象</h5>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//构造的方式上一步已讲</span></span><br><span class=\"line\"><span class=\"built_in\">CFHTTPMessageCreateRequest</span>(<span class=\"built_in\">CFAllocatorRef</span> __<span class=\"keyword\">nullable</span> alloc, <span class=\"built_in\">CFStringRef</span> requestMethod, <span class=\"built_in\">CFURLRef</span> url, <span class=\"built_in\">CFStringRef</span> httpVersion) <span class=\"built_in\">CF_AVAILABLE</span>(<span class=\"number\">10</span>_1, <span class=\"number\">2</span>_0);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"2使用cfhttpmessageref对象创建输入流\"><a class=\"anchor\" href=\"#2使用cfhttpmessageref对象创建输入流\">#</a> 2：使用 CFHTTPMessageRef 对象创建输入流</h5>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一个参数传默认</span></span><br><span class=\"line\"><span class=\"built_in\">CFReadStreamCreateForHTTPRequest</span>(<span class=\"built_in\">CFAllocatorRef</span> __<span class=\"keyword\">nullable</span> alloc, <span class=\"built_in\">CFHTTPMessageRef</span> request) <span class=\"built_in\">CF_DEPRECATED</span>(<span class=\"number\">10</span>_2, <span class=\"number\">10</span>_11, <span class=\"number\">2</span>_0, <span class=\"number\">9</span>_0, <span class=\"string\">&quot;Use NSURLSession API for http requests&quot;</span>);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"3适配sni环境一个-ip-地址上可以为不同域名分配使用不同的-ssl-证书这同时意味着共享-ip-的虚拟主机也可实现-ssltls-连接\"><a class=\"anchor\" href=\"#3适配sni环境一个-ip-地址上可以为不同域名分配使用不同的-ssl-证书这同时意味着共享-ip-的虚拟主机也可实现-ssltls-连接\">#</a> 3：适配 SNI 环境（一个 IP 地址上可以为不同域名分配使用不同的 SSL 证书；这同时意味着，共享 IP 的虚拟主机也可实现 SSL/TLS 连接。）</h5>\n<p>因为配置 sni 环境的所有配置都是基于输入流来操作，所以我们构建完成输入流之后来处理 sni，像这样<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span>.inputStream setProperty:<span class=\"built_in\">NSStreamSocketSecurityLevelNegotiatedSSL</span> forKey:<span class=\"built_in\">NSStreamSocketSecurityLevelKey</span>];</span><br><span class=\"line\"><span class=\"comment\">//请求的URL的Host</span></span><br><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *sslProperties = @&#123; (__bridge <span class=\"type\">id</span>) kCFStreamSSLPeerName : host &#125;;</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.inputStream setProperty:sslProperties forKey:(__bridge_transfer <span class=\"built_in\">NSString</span> *) kCFStreamPropertySSLSettings];</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"4打开输入流\"><a class=\"anchor\" href=\"#4打开输入流\">#</a> 4：打开输入流</h5>\n<p>打开输入流分为两步</p>\n<ul>\n<li>设置代理：[self.inputStream setDelegate:weakSelf]</li>\n<li>加入当前的 runloop：<br />\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[_inputStream <span class=\"symbol\">removeFromRunLoop:</span><span class=\"keyword\">self</span>.runloop <span class=\"symbol\">forMode:</span>[<span class=\"keyword\">self</span> runloopMode]];</span><br></pre></td></tr></table></figure></li>\n<li>调用 Open 方法</li>\n</ul>\n<h5 id=\"5收到代理数据回调\"><a class=\"anchor\" href=\"#5收到代理数据回调\">#</a> 5：收到代理数据回调</h5>\n<p><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- <span class=\"params\">(void)</span>stream:<span class=\"params\">(NSStream *)</span>aStream handleEvent:<span class=\"params\">(NSStreamEvent)</span>eventCode;</span><br></pre></td></tr></table></figure><br />\n 其中分为几个状态<br />\n <figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_OPTIONS</span>(<span class=\"type\">NSUInteger</span>, <span class=\"type\">NSStreamEvent</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventNone</span> = 0,</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventOpenCompleted</span> = 1UL &lt;&lt; 0,</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventHasBytesAvailable</span> = 1UL &lt;&lt; 1,</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventHasSpaceAvailable</span> = 1UL &lt;&lt; 2,</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventErrorOccurred</span> = 1UL &lt;&lt; 3,</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventEndEncountered</span> = 1UL &lt;&lt; 4</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br />\n 通常我们会关心 NSStreamEventOpenCompleted、NSStreamEventHasBytesAvailable、NSStreamEventErrorOccurred、<br />\n由于数据是以流的形式回来，我们需要在在 NSStreamEventHasBytesAvailable 下取出数据然后做数据拼接，拼接好完整的数据才可使用，像这样<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"built_in\">NSStreamEventHasBytesAvailable</span>:</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">UInt8</span> buffer[BUFFER_SIZE]; <span class=\"comment\">//设置缓存区</span></span><br><span class=\"line\">    <span class=\"built_in\">NSInteger</span> numBytesRead = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSInputStream</span> *inputstream = (<span class=\"built_in\">NSInputStream</span> *) aStream;</span><br><span class=\"line\">    <span class=\"comment\">// Read data</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        numBytesRead = [inputstream read:buffer maxLength:<span class=\"keyword\">sizeof</span>(buffer)];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numBytesRead &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span>.resultData appendBytes:buffer length:numBytesRead];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (numBytesRead &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">break</span>;</span><br></pre></td></tr></table></figure><br />\n 循环结束后我们的 resultData 就是完整的返回数据了。</p>\n",
            "tags": [
                "网络",
                "底层"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-23-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Http%E8%AF%B7%E6%B1%82%E3%80%81DNS%E5%8A%AB%E6%8C%81%E4%B8%8E%E8%A7%A3%E6%9E%90/",
            "url": "https://oliverqueen.cn/2018-01-23-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Http%E8%AF%B7%E6%B1%82%E3%80%81DNS%E5%8A%AB%E6%8C%81%E4%B8%8E%E8%A7%A3%E6%9E%90/",
            "title": "深入理解Http请求、DNS劫持与解析",
            "date_published": "2018-01-23T10:12:18.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景</h3>\n<p>前段时间在处理 iOS 端的 HTTPDNS 相关 SDK，在接入和测试环节发现大家对 HTTP 的整体请求流程包括 HTTP 劫持原理以及 HTTPDNS 的工作原理并不是太清楚，所以写下这边文章帮助大家深入 web 请求过程：如何发起请求，HTTP 协议解析，DNS 域名解析。</p>\n<h3 id=\"http发起一个请求过程\"><a class=\"anchor\" href=\"#http发起一个请求过程\">#</a> HTTP 发起一个请求过程</h3>\n<p>当我们在手机端请求一个 @&quot;<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5iYWlkdS5jb20=\">www.baidu.com</span>&quot; 的域名的时候</p>\n<ul>\n<li>\n<p>1. 请求到达运营商的 DNS 服务器并由其把这个域名解析成对应的 IP 地址。</p>\n</li>\n<li>\n<p>2. 根据 IP 地址在互联网上找到对应的服务器，向这个服务器发起一个 get\\post 请求。</p>\n</li>\n<li>\n<p>3. 由这个服务器找到对应的资源原路返回给访问的用户。<br />\n<span id=\"more\"></span></p>\n</li>\n</ul>\n<p>这里只是一个大概的流程实际每一步都有复杂的结构和逻辑例如：服务器可能有很多台，到底指定哪台服务器来处理请求，需要一个负载均衡设备来平均分配所有用户的请求。请求的数据是存储在分布式缓存中还是一个静态文件中，或是在数据库里。当数据返回浏览器时，浏览器解析数据发现还有一些静态资源（如 CSS、JS 或者图片）时又会发起另外的 HTTP 请求，而这些请求很可能会在 CDN 上，那么 CDN 服务器上又会处理这个用户的请求。</p>\n<h3 id=\"http劫持\"><a class=\"anchor\" href=\"#http劫持\">#</a> HTTP 劫持</h3>\n<p>我们使用 HTTPDNS 的主要目的就是解决 HTTP 劫持问题。HTTP 的劫持分两种第一种是 DNS 劫持，第二种是内容劫持，后者是基于前者的基础上发展出来，是比较高级的劫持手段，目前无解，下面来分开讲解：</p>\n<h6 id=\"1dns劫持\"><a class=\"anchor\" href=\"#1dns劫持\">#</a> 1：DNS 劫持</h6>\n<ul>\n<li>\n<p>劫持流程<br />\n DNS 劫持又称<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOUYlOUYlRTUlOTAlOEQlRTUlOEElQUIlRTYlOEMlODE=\">域名劫持</span>，是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的 IP 地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能访问或访问的是假网址。其实本质就是对 DNS 解析服务器做手脚，或者是使用伪造的 DNS 解析服务器可以通过下图来展示</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mqqoqxrj30yg0gt7oj.jpg\" alt=\"DNS劫持原理\" /></p>\n<p>从图中可以看出红色的是劫持的流程，劫持后将你的请求转发到一个虚假的服务器。</p>\n</li>\n<li>\n<p>解决办法</p>\n<ul>\n<li>\n<p>DNS 的劫持过程是通过攻击运营商的解析服务器来达到目的。我们可以不用运营商的 DNS 解析而使用自己的解析服务器或者是提前在自己的 App 中将解析好的域名以 IP 的形式发出去就可以绕过运营商 DNS 解析，这样一来也避免了 DNS 劫持的问题。</p>\n</li>\n<li>\n<p>HttpDNS 是使用 HTTP 协议向 DNS 服务器的 80 端口进行请求，代替传统的 DNS 协议向 DNS 服务器的 53 端口进行请求，绕开了运营商的 Local DNS，从而避免了使用运营商 Local DNS 造成的劫持和跨网问题</p>\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"2内容劫持\"><a class=\"anchor\" href=\"#2内容劫持\">#</a> 2：内容劫持</h6>\n<ul>\n<li>\n<p>劫持流程<br />\n内容劫持网上很少有提到，这也是在做 httpDNS SDK 所遇到的一个问题，其实内容劫持一开始的出发点是好的，是运营商为了加快用户的访问速度同时减少自己的流量损耗而做的一个缓存机制，用户在像服务器请求数据的时候运营商会把用户的请求转移到这个缓存池中，如果缓存中有就直接返回，没有的话再去像服务器请求然后拦截并缓存服务端给用户的回调数据，这样一来可以极大的降低运营商像服务器请求的次数，也能加快用户的访问，所以出发点是好，但是一些非法的商家对缓存池内部做一些处理就是直接对返回的内容进行修改，这样一来我们就会接受到错误的数据</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mtjymehj30yg0h3tob.jpg\" alt=\"内容劫持\" /></p>\n<p>黄色线条就是比价危险的了，因为回调的数据很可能已经被篡改过。</p>\n</li>\n<li>\n<p>解决办法：<br />\n现在暂时无法通过 HTTPdns 和其他手段解决，不过这样的劫持不是很多。</p>\n</li>\n</ul>\n<h3 id=\"dns解析过程\"><a class=\"anchor\" href=\"#dns解析过程\">#</a> DNS 解析过程</h3>\n<p>如果是 iOS 设备请直接跳到第三步骤</p>\n<ul>\n<li>\n<p>1. 系统会检查浏览器缓存中有没有这个域名对应的解析过的 IP 地址，如果缓存中有，这个解析过程就将结束。浏览器缓存是受这个域名的失效时间和缓存的空间大小控制的。</p>\n</li>\n<li>\n<p>2. 如果用户的浏览器缓存中没有，浏览器会查找操作系统缓存中即为本地的 Host 文件。</p>\n</li>\n<li>\n<p>3. 如果本地 Host 文件中没有那么操作系统会把这个域名发送给这里设置的 LocalDNS，也就是本地区的域名服务器。这个 DNS 通常都提供给你本地互联网接入的一个 DNS 解析服务。这个专门的域名解析服务器性能都会很好，它们一般都会缓存域名解析结果，当然缓存时间是受域名的失效时间控制的，一般缓存空间不是影响域名失效的主要因素。大约 90% 的域名解析都到这里就已经完成了，所以 LDNS 主要承担了域名的解析工作。</p>\n</li>\n<li>\n<p>4. 如果 LDNS 仍然没有命中，就直接到 Root Server 域名服务器请求解析</p>\n</li>\n<li>\n<p>5. 根域名服务器返回给本地域名服务器一个所查询的域的主域名服务器（gTLD Server）地址。gTLD 是国际顶级域名服务器，<span class=\"exturl\" data-url=\"aHR0cDovL3huLS1idnMuY29t\">如.com</span>，.cn、.org 等。全球只有 13 台左右。</p>\n</li>\n<li>\n<p>6. 本地域名服务器（Local DNS Server）再向上一步返回的 gTLD 服务器发送请求。</p>\n</li>\n<li>\n<p>7. 接受请求的 gTLD 服务器查找并返回此域名对应的 Name Server 域名服务器的地址，这个 Name Server 通常就是你注册的域名服务器，例如你在某个域名服务提供商申请的域名，那么这个域名解析任务就由这个域名提供商的服务器来完成</p>\n</li>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cDovLzguTmFtZQ==\">8.Name</span> Server 域名服务器会查询存储的域名和 IP 的映射关系表，正常情况下都根据域名得到目标 IP 记录，连同一个 TTL 值返回给 DNS Server 域名服务器。</p>\n</li>\n<li>\n<p>9. 返回该域名对应的 IP 和 TTL 值，Local DNS Server 会缓存这个域名和 IP 的对应关系，缓存的时间由 TTL 值控制。</p>\n</li>\n<li>\n<p>10. 把解析的结果返回给用户，用户根据 TTL 值缓存在本地系统缓存中，域名解析过程结束。<br />\n以上的流程可以简化为下图</p>\n</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mu9fg86j30yg0k41hd.jpg\" alt=\"DNS解析\" /></p>\n<p>绿色的为非 iOS 设备的操作流程</p>\n<h3 id=\"cdn工作机制\"><a class=\"anchor\" href=\"#cdn工作机制\">#</a> CDN 工作机制</h3>\n<h6 id=\"cdn简介\"><a class=\"anchor\" href=\"#cdn简介\">#</a> CDN 简介</h6>\n<p>CDN，全称 Content Delivery Network，根本的作用是将网站的内容发布到最接近用户的网络 “边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。他 - 有别于镜像，它比镜像更智能，可以这样做一个比喻：CDN = 镜像（Mirror） + 缓存（cache） + 整体负载均衡（GSLB），因而，CDN 可以明显提高 Internet 中信息流动的效率。目前 CDN 都以缓存网站中的静态数据为主，如 CSS、JS、图片和静态网页等数据。用户在从主站服务器请求到动态内容后再从 CDN 上下载这些静态数据，从而加速网页数据内容的下载速度，如淘宝有 90% 以上的数据都是由 CDN 来提供的。这里引用一个网上比较形象的例子：<strong>A 家的网速 100M 的，但他只用了 10M 的速度，B 家的网速是 10M 的，但是他需要 15M 的速度才行。怎么办呢。 C 是一家 CDN 服务商，在 A 家有个节点（就像 A 是一个赞助商一样）B 在 C 家买了 CDN 加速服务。当 B 的速度不够的时候，CDN 加速就会选择有节余的节点来帮 B，提高 B 的速度。这样 B 的速度就能达到或超过 15M ，A 没浪费，B 速度有了，C 赚了钱，皆大欢喜。 当 C 的节点在全国都有，非常多的时候。那么你用 C 家的 CDN 加速服务，你就会健步如飞了</strong>。</p>\n<h6 id=\"cdn工作流程\"><a class=\"anchor\" href=\"#cdn工作流程\">#</a> CDN 工作流程</h6>\n<p>一个用户访问某个静态文件（如 CSS），<span class=\"exturl\" data-url=\"aHR0cDovL3huLS13d3ctaTY4ZG0wYjE5Y2c3a3NwaTIwZDk3dm9rbzAwYjI2OWc0ZDlkNXJ4YS5iYWlkdS5jb20=\">这个静态文件的域名假如是 www.baidu.com</span>，而这个域名最终会被指向 CDN 全局中 CDN 负载均衡服务器，再由这个负载均衡服务器来最终分配是哪个地方的访问用户，返回给离这个访问用户最近的 CDN 节点。之后用户就直接去这个 CDN 节点访问这个静态文件了，如果这个节点中请求的文件不存在，就会再回到源站去获取这个文件，然后再返回给用户。</p>\n<h6 id=\"负载均衡\"><a class=\"anchor\" href=\"#负载均衡\">#</a> 负载均衡</h6>\n<p>负载均衡就是对工作任务进行平衡、分摊到多个操作单元上执行，如图片服务器、应用服务器等，共同完成工作任务。它可以提高服务器响应速度及利用效率，避免软件或者硬件模块出现单点失效，解决网络拥塞问题，实现地理位置无关性，为用户提供较一致的访问质量。<br />\nCDN 整体的工作流程可以大概归为下图：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mup956fj30yg0f5wx0.jpg\" alt=\"image.png\" /></p>\n<h3 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h3>\n<p>以上就是 Http 请求的一些理解，如果有不对的地方及时与我来沟通。</p>\n",
            "tags": []
        },
        {
            "id": "https://oliverqueen.cn/2018-01-23-%E5%9C%A8iOS11%E4%B8%8Bapp%E5%9B%BE%E6%A0%87%E5%8F%98%E7%A9%BA%E7%99%BD%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/",
            "url": "https://oliverqueen.cn/2018-01-23-%E5%9C%A8iOS11%E4%B8%8Bapp%E5%9B%BE%E6%A0%87%E5%8F%98%E7%A9%BA%E7%99%BD%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/",
            "title": "在iOS11下app图标变空白的问题解决",
            "date_published": "2018-01-23T10:07:50.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景：</h2>\n<p>最近在做项目的时候发现运行在模拟器上图标丢失，变成了苹果默认的白板图标。因为一开始只在模拟器上出现，而且也确认没有人动过图标文件，所以没有在意，后来慢慢的该问题出现在真机上，一开始是只有 iPhone X，然后就是 iPhone 8，慢慢的变成不管是模拟器还是真机，所有 iOS11 系统的图标都没有了。接下来影响到的机型和系统越来越多。<br />\n<span id=\"more\"></span></p>\n<h2 id=\"尝试\"><a class=\"anchor\" href=\"#尝试\">#</a> 尝试：</h2>\n<p>1：一开始想到的是可能有人误改了图标文件，于是删除了 images.xcassest 中的 AppIcon 文件，从新生成→添加图标，但是依然未解决。（✘）</p>\n<p>2：想到是图片格式 / 尺寸的问题，于是所有图片按照规定重新生成，但是仍然无济于事。（✘）</p>\n<p>3：因为设置图标的方法除了在 images.xcassest 中的 AppIcon 文件中设置还可以在 info.plist 设置、或者直接在工程里面放一个 icon.png 的图片来设</p>\n<p>置，所以都检查了一便发现也不是这个原因（✘）</p>\n<p>3：重置手机。(✘)</p>\n<h2 id=\"解决\"><a class=\"anchor\" href=\"#解决\">#</a> 解决：</h2>\n<p>google 了下发现好多国外的开发遇到这个问题，并且都是使用 xcode9.X.X 版本，所以怀疑是苹果的 BUG</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mw7fbitj30yg0b0dip.jpg\" alt=\"image.png\" /></p>\n<p>不过这个问题并不是谁都会出现也不是所有使用 xcode9 + iOS11 的设备都会出现</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mwjg45nj30yg09kq41.jpg\" alt=\"image.png\" /></p>\n<p>后来经过大家的讨论终于有人说这个其实是 cocoapods 的 BUG，暂时并不能通过更新 cocoapods 更新来解决，因为最新版的 cocoapods</p>\n<p>也存在这个问题，解决方法如下：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mwrgqg2j30yg0bqdl4.jpg\" alt=\"image.png\" /></p>\n<p>在你的 podfile 中加入以下代码就可以了</p>\n<p><figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">post_install <span class=\"keyword\">do</span> |installer|</span><br><span class=\"line\">    copy_pods_resources_path = <span class=\"string\">&quot;Pods/Target Support Files/Pods-工程名/Pods-工程名-resources.sh&quot;</span></span><br><span class=\"line\">    string_to_replace = <span class=\"string\">&#x27;--compile &quot;<span class=\"subst\">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class=\"subst\">$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;</span>&quot;&#x27;</span></span><br><span class=\"line\">    assets_compile_with_app_icon_arguments = <span class=\"string\">&#x27;--compile &quot;<span class=\"subst\">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class=\"subst\">$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;</span>&quot; --app-icon &quot;<span class=\"subst\">$&#123;ASSETCATALOG_COMPILER_APPICON_NAME&#125;</span>&quot; --output-partial-info-plist &quot;<span class=\"subst\">$&#123;BUILD_DIR&#125;</span>/assetcatalog_generated_info.plist&quot;&#x27;</span></span><br><span class=\"line\">    text = File.read(copy_pods_resources_path)</span><br><span class=\"line\">    <span class=\"keyword\">new</span><span class=\"type\">_contents</span> = text.gsub(string_to_replace, assets_compile_with_app_icon_arguments)</span><br><span class=\"line\">    File.open(copy_pods_resources_path, <span class=\"string\">&quot;w&quot;</span>) &#123;|file| file.puts <span class=\"keyword\">new</span><span class=\"type\">_contents</span> &#125;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure></p>\n<p>像这样：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mx84vaxj30yg07f42t.jpg\" alt=\"image.png\" /></p>\n",
            "tags": [
                "xcode",
                "cocoapods",
                "podfile"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-23-IOS%E4%B8%8B%E4%B8%89%E7%A7%8DDNS%E8%A7%A3%E6%9E%90%E6%96%B9%E5%BC%8F%E5%88%86%E6%9E%90%EF%BC%88LocalDns%EF%BC%89/",
            "url": "https://oliverqueen.cn/2018-01-23-IOS%E4%B8%8B%E4%B8%89%E7%A7%8DDNS%E8%A7%A3%E6%9E%90%E6%96%B9%E5%BC%8F%E5%88%86%E6%9E%90%EF%BC%88LocalDns%EF%BC%89/",
            "title": "IOS下三种DNS解析方式分析（LocalDns）",
            "date_published": "2018-01-23T10:02:29.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景</h3>\n<p>最近在做 iOS 的 DNS 解析，顺便研究了下 iOS 端本地的 DNS 解析方式（localDNS）, 也就是不依赖 Http 请求，而是用原始的 API 进行解析，虽然有 HttpDNS 但是考虑到成本、第三方服务稳定性的问题，LocalDNS 仍然是一个很重要的部分，在 iOS 系统下，localDNS 的解析方式有三种，下面主要对三种方式进行下利弊分析及简单的原理介绍。</p>\n<h3 id=\"方式一\"><a class=\"anchor\" href=\"#方式一\">#</a> 方式一</h3>\n<p>这个也是我一开始在项目中使用的方式。<br />\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>：<span class=\"keyword\">struct</span> <span class=\"title class_\">hostent</span>\t*<span class=\"built_in\">gethostbyname</span>(<span class=\"type\">const</span> <span class=\"type\">char</span> *);</span><br><span class=\"line\"><span class=\"number\">2</span>：<span class=\"keyword\">struct</span> <span class=\"title class_\">hostent</span>\t*<span class=\"built_in\">gethostbyname2</span>(<span class=\"type\">const</span> <span class=\"type\">char</span> *, <span class=\"type\">int</span>);</span><br></pre></td></tr></table></figure><br />\n 两个函数作用完全一样，返回值一样，但是第一个只能用于 IPV4 的网络环境，而第二个则 IPV4 和 IPV6 都可使用，可以通过第二个参数传入当前的网络环境。<br />\n<!---more---></p>\n<h6 id=\"使用方式\"><a class=\"anchor\" href=\"#使用方式\">#</a> 使用方式：</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CFAbsoluteTime</span> start = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"type\">char</span>   *ptr, **pptr;</span><br><span class=\"line\">   <span class=\"keyword\">struct</span> hostent *hptr;</span><br><span class=\"line\">   <span class=\"type\">char</span>   str[<span class=\"number\">32</span>];</span><br><span class=\"line\">   ptr = <span class=\"string\">&quot;www.meitu.com&quot;</span>;</span><br><span class=\"line\">   <span class=\"built_in\">NSMutableArray</span> * ips = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>((hptr = gethostbyname(ptr)) == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span>(pptr=hptr-&gt;h_addr_list; *pptr!=<span class=\"literal\">NULL</span>; pptr++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> * ipStr = [<span class=\"built_in\">NSString</span> stringWithCString:inet_ntop(hptr-&gt;h_addrtype, *pptr, str, <span class=\"keyword\">sizeof</span>(str)) encoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\">        [ips addObject:ipStr?:<span class=\"string\">@&quot;&quot;</span>];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">CFAbsoluteTime</span> end = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;22222 === ip === %@ === time cost: %0.3fs&quot;</span>, ips,end - start);</span><br></pre></td></tr></table></figure></p>\n<p>使用 gethostbyname 方法后会得到一个 struct, 也就是上文的 struct hostent *hptr：<br />\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hostent</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span>\t*h_name;\t<span class=\"comment\">/* official name of host */</span></span><br><span class=\"line\">\t<span class=\"type\">char</span>\t**h_aliases;\t<span class=\"comment\">/* alias list */</span></span><br><span class=\"line\">\t<span class=\"type\">int</span>\th_addrtype;\t<span class=\"comment\">/* host address type */</span></span><br><span class=\"line\">\t<span class=\"type\">int</span>\th_length;\t<span class=\"comment\">/* length of address */</span></span><br><span class=\"line\">\t<span class=\"type\">char</span>\t**h_addr_list;\t<span class=\"comment\">/* list of addresses from name server */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\th_addr\th_addr_list[0]\t<span class=\"comment\">/* address, for backward compatibility */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">/* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */</span></span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"参数解析\"><a class=\"anchor\" href=\"#参数解析\">#</a> 参数解析：</h6>\n<ul>\n<li>\n<p>hostent-&gt;h_name<br />\n 表示的是主机的规范名。<span class=\"exturl\" data-url=\"aHR0cDovL3huLS13d3ctdWMwZXA5NmIuYmFpZHUueG4tLWNvbXd3dy1rcDJqNzRvZXN1NDJ5NjAzYjJsNWFnbXMuYS5zaGlmZW4uY29t\">例如 www.baidu.com 的规范名其实是 www.a.shifen.com</span>。</p>\n</li>\n<li>\n<p>hostent-&gt;h_aliases<br />\n 表示的是主机的别名 www.baidu.com 的别名就是他自己。有的时候，有的主机可能有好几个别名，这些，其实都是为了易于用户记忆而为自己的网站多取的名字。</p>\n</li>\n<li>\n<p>hostent-&gt;h_addrtype<br />\n 表示的是主机 ip 地址的类型，到底是 ipv4 (AF_INET)，还是 pv6 (AF_INET6)</p>\n</li>\n<li>\n<p>hostent-&gt;h_length<br />\n 表示的是主机 ip 地址的长度</p>\n</li>\n<li>\n<p>hostent-&gt;h_addr_lisst<br />\n 表示的是主机的 ip 地址，注意，这个是以网络字节序存储的。不要直接用 printf 带 % s 参数来打这个东西，会有问题的哇。所以到真正需要打印出这个 IP 的话，需要调用 <code>const char *inet_ntop(int af, const void *src, char *dst, socklen_t cnt) </code> ，来把它转成 char。详细使用见上文</p>\n</li>\n</ul>\n<h6 id=\"缺点\"><a class=\"anchor\" href=\"#缺点\">#</a> 缺点：</h6>\n<ul>\n<li>\n<p>在进行网络切换的时候小概率卡死，自测十次有一两次左右。</p>\n</li>\n<li>\n<p>在本地的 LocalDns 被破坏的时候会必卡死 30 秒，然后返回 nil 。</p>\n</li>\n<li>\n<p>缓存是个玄学东西，他会对自己解析出来的 IP 进行缓存（可能是运营商缓存）缓存时间不确定，有可能我即使切换了无数个网络，但是从早到晚同一个域名总是解析出同样的 IP，</p>\n</li>\n<li>\n<p>网上说的比较多的问题</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6myoq10ej30po01w0tb.jpg\" alt=\"image.png\" /></p>\n</li>\n</ul>\n<h3 id=\"方式二\"><a class=\"anchor\" href=\"#方式二\">#</a> 方式二</h3>\n<p>除了经常用到的 gethostbyname (3) 和 gethostbyaddr (3) 函数以外，Linux (以及其它 UNIX/UNIX-like 系统) 还提供了一套用于在底层处理 DNS 相关问题的函数 (这里所说的底层仅是相对 gethostbyname 和 gethostbyaddr 两个函数而言). 这套函数被称为地址解析函数 (resolver functions)。曾经尝试过这个方式...<br />\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span>\t\tres_query <span class=\"constructor\">__P((<span class=\"params\">const</span> <span class=\"params\">char</span> <span class=\"operator\">*</span>, <span class=\"params\">int</span>, <span class=\"params\">int</span>, <span class=\"params\">u_char</span> <span class=\"operator\">*</span>, <span class=\"params\">int</span>)</span>);</span><br><span class=\"line\">函数原型为：</span><br><span class=\"line\"><span class=\"built_in\">int</span> res<span class=\"constructor\">_query(<span class=\"params\">const</span> <span class=\"params\">char</span> <span class=\"operator\">*</span><span class=\"params\">dname</span>, <span class=\"params\">int</span> <span class=\"params\">class</span>, <span class=\"params\">int</span> <span class=\"params\">type</span>, <span class=\"params\">unsigned</span> <span class=\"params\">char</span> <span class=\"operator\">*</span><span class=\"params\">answer</span>, <span class=\"params\">int</span> <span class=\"params\">anslen</span>)</span></span><br></pre></td></tr></table></figure><br />\n 这个方式需要在项目中添加 <code>libresolv.tbd</code>  库，因为要依赖于库中的函数去解析。 <code>res_query</code>  用来发出一个指定类 (由参数 class 指定) 和类型 (由参数 type 指定) 的 DNS 询问. dname 是要查询的主机名。返回信息被存储在 answser 指向的内存区域中。信息的长度不能大于 anslen 个字节。这个函数会创建一个 DNS 查询报文并把它发送到指定的 DNS 服务器。</p>\n<h6 id=\"使用方式-2\"><a class=\"anchor\" href=\"#使用方式-2\">#</a> 使用方式</h6>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CFAbsoluteTime start = <span class=\"constructor\">CFAbsoluteTimeGetCurrent()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    unsigned <span class=\"built_in\">char</span> auResult<span class=\"literal\">[<span class=\"number\">512</span>]</span>;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> nBytesRead = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    nBytesRead = res<span class=\"constructor\">_query(<span class=\"string\">&quot;www.meitu.com&quot;</span>, <span class=\"params\">ns_c_in</span>, <span class=\"params\">ns_t_a</span>, <span class=\"params\">auResult</span>, <span class=\"params\">sizeof</span>(<span class=\"params\">auResult</span>)</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ns_msg handle;</span><br><span class=\"line\">    ns<span class=\"constructor\">_initparse(<span class=\"params\">auResult</span>, <span class=\"params\">nBytesRead</span>, &amp;<span class=\"params\">handle</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSMutableArray *ipList = nil;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> msg_count = ns<span class=\"constructor\">_msg_count(<span class=\"params\">handle</span>, <span class=\"params\">ns_s_an</span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg_count &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ipList = <span class=\"literal\">[[NSM<span class=\"identifier\">utableArray</span> <span class=\"identifier\">alloc</span>]</span> initWithCapacity:msg_count];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> rrnum = <span class=\"number\">0</span>; rrnum &lt; msg_count; rrnum++) &#123;</span><br><span class=\"line\">            ns_rr rr;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ns<span class=\"constructor\">_parserr(&amp;<span class=\"params\">handle</span>, <span class=\"params\">ns_s_an</span>, <span class=\"params\">rrnum</span>, &amp;<span class=\"params\">rr</span>)</span><span class=\"operator\"> == </span><span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">char</span> ip1<span class=\"literal\">[<span class=\"number\">16</span>]</span>;</span><br><span class=\"line\">                strcpy(ip1, inet<span class=\"constructor\">_ntoa(<span class=\"operator\">*</span>(<span class=\"params\">struct</span> <span class=\"params\">in_addr</span> <span class=\"operator\">*</span>)</span>ns<span class=\"constructor\">_rr_rdata(<span class=\"params\">rr</span>)</span>));</span><br><span class=\"line\">                NSString *ipString = <span class=\"literal\">[[NSS<span class=\"identifier\">tring</span> <span class=\"identifier\">alloc</span>]</span> initWithCString:ip1 encoding:NSASCIIStringEncoding];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!<span class=\"literal\">[<span class=\"identifier\">ipString</span> <span class=\"identifier\">isEqualToString</span>:@&quot;&quot;]</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">//将提取到的IP地址放到数组中</span></span><br><span class=\"line\">                    <span class=\"literal\">[<span class=\"identifier\">ipList</span> <span class=\"identifier\">addObject</span>:<span class=\"identifier\">ipString</span>]</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        CFAbsoluteTime <span class=\"keyword\">end</span> = <span class=\"constructor\">CFAbsoluteTimeGetCurrent()</span>;</span><br><span class=\"line\">        <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;11111 === ip === %@ === time cost: %0.3fs&quot;</span>, <span class=\"params\">ipList</span>,<span class=\"params\">end</span> - <span class=\"params\">start</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"参数解析-2\"><a class=\"anchor\" href=\"#参数解析-2\">#</a> 参数解析</h6>\n<p>由于该逻辑是 Linux 底层提供的代码，苹果用宏做了一次封装，具体的函数含义还需要对 Linux 内核的理解，这里放一篇<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcmVuaGFvL2FyY2hpdmUvMjAxMS8xMS8xNC8yMjQ4NTI4Lmh0bWw=\">参考资料</span></p>\n<h6 id=\"优点\"><a class=\"anchor\" href=\"#优点\">#</a> 优点：</h6>\n<ul>\n<li>在 LocalDns 被破坏掉的情况下能及时响应不会延迟。</li>\n<li>没有缓存，缓存由开发者控制</li>\n</ul>\n<h6 id=\"缺点-2\"><a class=\"anchor\" href=\"#缺点-2\">#</a> 缺点</h6>\n<ul>\n<li>在进行网络切换时候 3G/4G 切 wify 高概率出现卡死<br />\n这一个缺点是比较致命的，所以没有再继续使用。</li>\n</ul>\n<h3 id=\"方式三\"><a class=\"anchor\" href=\"#方式三\">#</a> 方式三</h3>\n<p>苹果原生的 DNS 解析</p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Boolean <span class=\"built_in\">CFHostStartInfoResolution</span> (<span class=\"built_in\">CFHostRef</span> theHost, <span class=\"built_in\">CFHostInfoType</span> info, <span class=\"built_in\">CFStreamError</span> *error);</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"使用方法\"><a class=\"anchor\" href=\"#使用方法\">#</a> 使用方法：</h6>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Boolean result,bResolved;</span><br><span class=\"line\">CFHostRef hostRef;</span><br><span class=\"line\">CFArrayRef addresses = NULL;</span><br><span class=\"line\">NSMutableArray<span class=\"operator\"> * </span>ipsArr = <span class=\"literal\">[[NSM<span class=\"identifier\">utableArray</span> <span class=\"identifier\">alloc</span>]</span> init];</span><br><span class=\"line\"></span><br><span class=\"line\">CFStringRef hostNameRef = <span class=\"constructor\">CFStringCreateWithCString(<span class=\"params\">kCFAllocatorDefault</span>, <span class=\"string\">&quot;www.meitu.com&quot;</span>, <span class=\"params\">kCFStringEncodingASCII</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">hostRef = <span class=\"constructor\">CFHostCreateWithName(<span class=\"params\">kCFAllocatorDefault</span>, <span class=\"params\">hostNameRef</span>)</span>;</span><br><span class=\"line\">CFAbsoluteTime start = <span class=\"constructor\">CFAbsoluteTimeGetCurrent()</span>;</span><br><span class=\"line\">result = <span class=\"constructor\">CFHostStartInfoResolution(<span class=\"params\">hostRef</span>, <span class=\"params\">kCFHostAddresses</span>, NULL)</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (result<span class=\"operator\"> == </span>TRUE) &#123;</span><br><span class=\"line\">    addresses = <span class=\"constructor\">CFHostGetAddressing(<span class=\"params\">hostRef</span>, &amp;<span class=\"params\">result</span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bResolved = result<span class=\"operator\"> == </span>TRUE ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(bResolved)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> sockaddr_in* remoteAddr;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"constructor\">CFArrayGetCount(<span class=\"params\">addresses</span>)</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        CFDataRef saData = (CFDataRef)<span class=\"constructor\">CFArrayGetValueAtIndex(<span class=\"params\">addresses</span>, <span class=\"params\">i</span>)</span>;</span><br><span class=\"line\">        remoteAddr = (<span class=\"keyword\">struct</span> sockaddr_in*)<span class=\"constructor\">CFDataGetBytePtr(<span class=\"params\">saData</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(remoteAddr != NULL)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取IP地址</span></span><br><span class=\"line\">            <span class=\"built_in\">char</span> ip<span class=\"literal\">[<span class=\"number\">16</span>]</span>;</span><br><span class=\"line\">            strcpy(ip, inet<span class=\"constructor\">_ntoa(<span class=\"params\">remoteAddr</span>-&gt;<span class=\"params\">sin_addr</span>)</span>);</span><br><span class=\"line\">            NSString<span class=\"operator\"> * </span>ipStr = <span class=\"literal\">[NSS<span class=\"identifier\">tring</span> <span class=\"identifier\">stringWithCString</span>:<span class=\"identifier\">ip</span> <span class=\"identifier\">encoding</span>:NSUTF8S<span class=\"identifier\">tringEncoding</span>]</span>;</span><br><span class=\"line\">            <span class=\"literal\">[<span class=\"identifier\">ipsArr</span> <span class=\"identifier\">addObject</span>:<span class=\"identifier\">ipStr</span>]</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">CFAbsoluteTime <span class=\"keyword\">end</span> = <span class=\"constructor\">CFAbsoluteTimeGetCurrent()</span>;</span><br><span class=\"line\"><span class=\"constructor\">NSLog(@<span class=\"string\">&quot;33333 === ip === %@ === time cost: %0.3fs&quot;</span>, <span class=\"params\">ipsArr</span>,<span class=\"params\">end</span> - <span class=\"params\">start</span>)</span>;</span><br><span class=\"line\"><span class=\"constructor\">CFRelease(<span class=\"params\">hostNameRef</span>)</span>;</span><br><span class=\"line\"><span class=\"constructor\">CFRelease(<span class=\"params\">hostRef</span>)</span>;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"参数解析-3\"><a class=\"anchor\" href=\"#参数解析-3\">#</a> 参数解析：</h6>\n<p><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/<span class=\"emphasis\">*</span></span><br><span class=\"line\"><span class=\"emphasis\"> *</span>  CFHostStartInfoResolution()</span><br><span class=\"line\"><span class=\"bullet\"> *</span>  </span><br><span class=\"line\"> <span class=\"emphasis\">*  Discussion:</span></span><br><span class=\"line\"><span class=\"emphasis\"> *</span>\tPerforms a lookup for the given host.  It will search for the</span><br><span class=\"line\"><span class=\"bullet\"> *</span>\trequested information if there is no other active request.</span><br><span class=\"line\"><span class=\"bullet\"> *</span>\tPreviously cached information of the given type will be released.</span><br><span class=\"line\"><span class=\"bullet\"> *</span>  </span><br><span class=\"line\"> <span class=\"emphasis\">*  Mac OS X threading:</span></span><br><span class=\"line\"><span class=\"emphasis\"> *</span>\tThread safe</span><br><span class=\"line\"><span class=\"bullet\"> *</span>  </span><br><span class=\"line\"> <span class=\"emphasis\">*  Parameters:</span></span><br><span class=\"line\"><span class=\"emphasis\"> *</span></span><br><span class=\"line\"><span class=\"bullet\"> *</span>\ttheHost:  //需要被解决的CFHostRef的对象</span><br><span class=\"line\"><span class=\"bullet\"> *</span>\t  The CFHostRef which should be resolved. Must be non-NULL. If</span><br><span class=\"line\"><span class=\"bullet\"> *</span>\t  this reference is not a valid CFHostRef, the behavior is</span><br><span class=\"line\"><span class=\"bullet\"> *</span>\t  undefined.</span><br><span class=\"line\"><span class=\"bullet\"> *</span></span><br><span class=\"line\"> <span class=\"emphasis\">*\tinfo: 返回值的类型 数组/Data/string..</span></span><br><span class=\"line\"><span class=\"emphasis\"> *</span>\t  The enum representing the type of information to be retrieved.</span><br><span class=\"line\"><span class=\"bullet\"> *</span>\t  If the value is not a valid type, the behavior is undefined.</span><br><span class=\"line\"><span class=\"bullet\"> *</span></span><br><span class=\"line\"> <span class=\"emphasis\">*\terror: 错误</span></span><br><span class=\"line\"><span class=\"emphasis\"> *</span>\t  A reference to a CFStreamError structure which will be filled</span><br><span class=\"line\"><span class=\"bullet\"> *</span>\t  with any error information should an error occur.  May be set</span><br><span class=\"line\"><span class=\"bullet\"> *</span>\t  to NULL if error information is not wanted.</span><br><span class=\"line\"><span class=\"bullet\"> *</span>  </span><br><span class=\"line\"> <span class=\"emphasis\">*  Result: 解析结果成功还是失败</span></span><br><span class=\"line\"><span class=\"emphasis\"> *</span>\tReturns TRUE on success and FALSE on failure.  In asynchronous</span><br><span class=\"line\"><span class=\"bullet\"> *</span>\tmode, this function will return immediately.  In synchronous</span><br><span class=\"line\"><span class=\"bullet\"> *</span>\tmode, it will block until the resolve has completed or until the</span><br><span class=\"line\"><span class=\"bullet\"> *</span>\tresolve is cancelled.</span><br><span class=\"line\"><span class=\"bullet\"> *</span>  </span><br><span class=\"line\"> <span class=\"emphasis\">*/</span></span><br><span class=\"line\"><span class=\"emphasis\">CFN_EXPORT <span class=\"strong\">__nullable CFArrayRef</span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">CFHostGetAddressing(CFHostRef theHost, Boolean * __</span>nullable hasBeenResolved) CF_AVAILABLE(10_3, 2_0);</span></span><br></pre></td></tr></table></figure></p>\n<h6 id=\"优点-2\"><a class=\"anchor\" href=\"#优点-2\">#</a> 优点：</h6>\n<ul>\n<li>在网络切换时候不会卡顿。</li>\n</ul>\n<h6 id=\"缺点-3\"><a class=\"anchor\" href=\"#缺点-3\">#</a> 缺点：</h6>\n<ul>\n<li>在本地 DNS 被破坏的情况下会出现卡死的现象 (卡 30s)</li>\n</ul>\n<h3 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结：</h3>\n<p>以上三个方法除了第二个方法会在网络切换时候卡死不可用之外，其他两个方法都是可选择的，关于那个本地 LocalDns 破坏会卡死的问题看来是无法避免，不过开发者可以自行通过 ping 等方式来判断 LocalDns 的正确性，在被破坏的情况下使用 httpDns 来进行解析即可。具体的 demo 可以到<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3poYW5nbmluZ2hhby9Mb2NhbERucw==\">这里</span>查看</p>\n",
            "tags": [
                "DNS解析",
                "LocalDNS"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-19-test-source/",
            "url": "https://oliverqueen.cn/2018-01-19-test-source/",
            "title": "Welcome To My Site",
            "date_published": "2018-01-19T06:37:12.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>Test<br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79ly1fnygnuhm3rj31kw0zk1ky.jpg\" alt=\"你好\" /><br />\n welcome !!!<br />\n<span id=\"more\"></span></p>\n",
            "tags": [
                "欢迎页"
            ]
        },
        {
            "id": "https://oliverqueen.cn/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%F0%9F%98%8A/",
            "url": "https://oliverqueen.cn/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%F0%9F%98%8A/",
            "title": "位运算的简单理解😊",
            "date_published": "2018-01-19T06:20:39.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"1背景\"><a class=\"anchor\" href=\"#1背景\">#</a> 1：背景</h2>\n<p>从现代计算机中所有的数据二进制的形式存储在设备中。即 0、1 两种状态，计算机对二进制数据进行的运算 (+、-、*、/) 都是叫位运算，即将符号位共同参与运算的运算。</p>\n<p>我们每一种语言最终都会通过编译器转换成机器语言来执行，所以直接使用底层的语言就不需要便编译器的转换工作从而得到更高的执行效率，当然可读性可能会降低，这也是为什么汇编在大部分情况下有更快的速度。项目中合理的运用位运算能提高我们代码的执行效率。</p>\n<p>在 iOS 系统中位运算多见于枚举中，其他地方很少见，因为位运算是底层的计算机语言，而在 iOS 开发中不管是 Objective—C 还是 Swift 都属于高级的编程语言，大量的位运算都被苹果封装了起来，我们只关心调用的接口不用关心内部的实现。</p>\n<p><figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_OPTIONS</span>(<span class=\"type\">NSUInteger</span>, <span class=\"type\">NSLayoutFormatOptions</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllLeft</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeLeft</span>),</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllRight</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeRight</span>),</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllTop</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeTop</span>),</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllBottom</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeBottom</span>),</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllLeading</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeLeading</span>),</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllTrailing</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeTrailing</span>),</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br />\n<span id=\"more\"></span></p>\n<h2 id=\"10计算机计算原理\"><a class=\"anchor\" href=\"#10计算机计算原理\">#</a> 10：计算机计算原理</h2>\n<h4 id=\"加法和乘法\"><a class=\"anchor\" href=\"#加法和乘法\">#</a> 加法和乘法</h4>\n<p>举一个简单的例子来看下 CPU 是如何进行计算的，比如这行代码</p>\n<p><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">int a</span> = 35;</span><br><span class=\"line\"><span class=\"attribute\">int b</span> = 47;</span><br><span class=\"line\"><span class=\"attribute\">int c</span> = a + b;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 计算两个数的和，因为在计算机中都是以二进制来进行运算，所以上面我们所给的 int 变量会在机器内部先转换为二进制在进行相加</p>\n<p><figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">35: <span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>0<span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>1</span><br><span class=\"line\">47: <span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>0<span class=\"number\"> 1 </span>1<span class=\"number\"> 1 </span>1</span><br><span class=\"line\">————————————————————</span><br><span class=\"line\">82: <span class=\"number\"> 0 </span>1<span class=\"number\"> 0 </span>1<span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>0</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>再来看下乘法，执行如下的代码</p>\n<p><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a = 3;</span><br><span class=\"line\">int b = 2;</span><br><span class=\"line\">int c = a <span class=\"emphasis\">* b;</span></span><br><span class=\"line\"><span class=\"emphasis\"></span></span><br><span class=\"line\"><span class=\"emphasis\">3:  0 0 0 0 0 0 1 1  *</span>  2</span><br><span class=\"line\">————————————————————</span><br><span class=\"line\">6:  0 0 0 0 0 1 1 0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"emphasis\">*</span></span><br><span class=\"line\"><span class=\"emphasis\"></span></span><br><span class=\"line\"><span class=\"emphasis\">int a = 3;</span></span><br><span class=\"line\"><span class=\"emphasis\">int b = 4;</span></span><br><span class=\"line\"><span class=\"emphasis\">int c = a *</span> b;</span><br><span class=\"line\"></span><br><span class=\"line\">3:  0 0 0 0 0 0 1 1  <span class=\"emphasis\">*  4</span></span><br><span class=\"line\"><span class=\"emphasis\">————————————————————</span></span><br><span class=\"line\"><span class=\"emphasis\">12:  0 0 0 0 1 1 0 0</span></span><br><span class=\"line\"><span class=\"emphasis\"></span></span><br><span class=\"line\"><span class=\"emphasis\"><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span>*</span></span><br><span class=\"line\"></span><br><span class=\"line\">int a = 3;</span><br><span class=\"line\">int b = 8;</span><br><span class=\"line\">int c = a <span class=\"emphasis\">* b;</span></span><br><span class=\"line\"><span class=\"emphasis\"></span></span><br><span class=\"line\"><span class=\"emphasis\">3:  0 0 0 0 0 0 1 1  *</span>  8</span><br><span class=\"line\">————————————————————</span><br><span class=\"line\">24:  0 0 0 1 1 0 0 0</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 通过以上运算可以看出当用 a 乘 b，且如果 b 满足 2^N 的时候 就相当于把 a 的二进制数据向左移动 N 位，放到代码中 我们可以这样来写 <strong>a &lt;&lt; N</strong>, 所以上面<strong> 3 * 2、3 * 4、3 * 8</strong> 其实是可以写成<strong> 3&lt;&lt;1、3&lt;&lt;2、3&lt;&lt;3</strong>，运算结果都是一样的。</p>\n<p>那假如相乘的两个数都不满足 2<sup>N 怎么办呢？其实这个时候编译器会将其中一个数拆分成多个满足 2</sup>N 的数相加的情况，打个比方</p>\n<p><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> a = <span class=\"number\">15</span>;\t\t\t\t<span class=\"built_in\">int</span> a = <span class=\"number\">15</span></span><br><span class=\"line\"><span class=\"built_in\">int</span> b = <span class=\"number\">13</span>;      =&gt;    \t<span class=\"built_in\">int</span> b = (<span class=\"number\">4</span> + <span class=\"number\">8</span> + <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"built_in\">int</span> c = a * b;\t\t\t<span class=\"built_in\">int</span> c = a * b</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 最后其实执行相乘运算就会变成这样 <strong>15 * 4 + 15 * 8 + 15 * 1</strong>，按照上文说的移位来转换为位运算就会变成<strong> 15 &lt;&lt; 2 + 15 &lt;&lt; 3 + 15 &lt;&lt; 0</strong></p>\n<h4 id=\"减法和除法\"><a class=\"anchor\" href=\"#减法和除法\">#</a> 减法和除法</h4>\n<p>减法也是与加法同理只不过计算机内减法操作就是加上一个数的负数形式，且在操作系统中都是以补码的形式进行操作 (因为正数的源码补码反码都与本身相同)。首先，因为人脑可以知道第一位是符号位，在计算的时候我们会根据符号位，选择对真值区域的加减。但是对于计算机，加减乘数已经是最基础的运算，要设计的尽量简单。计算机辨别 &quot;符号位&quot; 显然会让计算机的基础电路设计变得十分复杂！于是人们想出了将符号位也参与运算的方法。我们知道，根据运算法则减去一个正数等于加上一个负数，即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法，这样计算机运算的设计就更简单了.</p>\n<p>除法的话其实和乘法原理相同，不过乘法是左移而除法是右移，但是除法的计算量要比乘法大得多，其大部分的消耗都在拆分数值，和处理小数的步骤上，所以如果我们在进行生成变量的时候如果遇到多位的小数我们尽量把他换成 string 的形式，这也是为什么浮点运算会消耗大量的时钟周期 (操作系统中每进行一个移位或者加法运算的过程所消耗的时间就是一个时钟周期，3.0GHz 频率的 CPU 可以在一秒执行运算 3.0<em>1024</em>1024*1024 个时钟周期)</p>\n<h2 id=\"11位运算符\"><a class=\"anchor\" href=\"#11位运算符\">#</a> 11：位运算符</h2>\n<p>使用的运算符包括下面：</p>\n<table>\n<thead>\n<tr>\n<th>含义</th>\n<th>运算符</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>左移</td>\n<td>&lt;&lt;</td>\n<td>0011  =&gt;  0110</td>\n</tr>\n<tr>\n<td>右移</td>\n<td>&gt;&gt;</td>\n<td>0110  =&gt;  0011</td>\n</tr>\n<tr>\n<td>按位或</td>\n<td>︳</td>\n<td>0011 &lt;br&gt; -------  =&gt; 1011&lt;br&gt;1011</td>\n</tr>\n<tr>\n<td>按位与</td>\n<td>&amp;</td>\n<td>0011 &lt;br&gt; -------  =&gt; 1011&lt;br&gt;1011</td>\n</tr>\n<tr>\n<td>按位取反</td>\n<td>~</td>\n<td>0011  =&gt; 1100</td>\n</tr>\n<tr>\n<td>按位异或 (相同为零不同为一)</td>\n<td>^</td>\n<td>0011 &lt;br&gt; -------  =&gt; 1000&lt;br&gt;1011</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"100颜色转换\"><a class=\"anchor\" href=\"#100颜色转换\">#</a> 100：颜色转换</h2>\n<h4 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景</h4>\n<p>上面说了 iOS 中经常见到的位运算的地方是在枚举中，那么颜色转换应该是除了枚举之外第二比较常用位运算的场景。打个比方设计师再给我们出设计稿的时候通常会在设计稿上按照 16 进制的样子给我们标色值。但是 iOS 中的 UIColor 并不支持使用十六进制的数据来初始化。所以我们需要将十六进制的色值转换为 UIColor。</p>\n<h4 id=\"原理分析\"><a class=\"anchor\" href=\"#原理分析\">#</a> 原理分析</h4>\n<p>UIColor 中通常是用传入 RGB 的数值来初始化，而且每个颜色的取值范围是十进制下的 0~255，而设计同学又给的是十六进制数据，所以在操作系统中需要把这两种进制的数据统一成二进制来进行计算，这就用到了位运算。这里用一个十六进制的色值来举例子比如<strong> 0xffa131</strong> 我们要转换就要先理解其组成</p>\n<ul>\n<li>\n<p>0x 或者 0X：十六进制的标识符，表示这个后面是个十六进制的数值，对数值本身没有任何意义</p>\n</li>\n<li>\n<p>ff 颜色中的 R 值，转换为二进制为 1111 1111</p>\n</li>\n<li>\n<p>a1 颜色中的 G 值，转换为二进制为 1010 0001</p>\n</li>\n<li>\n<p>31 颜色中的 B 值，转换为二进制为 0011 0001</p>\n</li>\n<li>\n<p>上述色彩值转换为二进制后为<strong> 1111 1111 1010 0001 0011 0001 (每一位十六进制的对应 4 位二进制，如果位数不够记得高位补零)</strong></p>\n</li>\n</ul>\n<p>通常来讲十六进制的颜色是按照上面的 RGB 的顺序排列的，但是并不固定，有时候可能会在其中加 A (Alpha) 值，具体情况按照设计为准，本文以通用情况举例。</p>\n<p>综上，我们只需把对应位的值转换为 10 进制然后 / 255.0f 就可得到 RGB 色彩值，从而转换为 UIColor</p>\n<h4 id=\"转换代码\"><a class=\"anchor\" href=\"#转换代码\">#</a> 转换代码</h4>\n<p>先列出代码，后续解析</p>\n<p><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (UIColor *)colorWithHex:(<span class=\"type\">long</span>)hexColor <span class=\"built_in\">alpha</span>:(<span class=\"type\">float</span>)opacity</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//将传入的十六进制颜色0xffa131 转换为UIColor</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">float</span> <span class=\"built_in\">red</span> = ((hexColor &amp; <span class=\"number\">0xFF0000</span>) &gt;&gt; <span class=\"number\">16</span>)/<span class=\"number\">255.0</span>f;</span><br><span class=\"line\">    <span class=\"type\">float</span> <span class=\"built_in\">green</span> = ((hexColor &amp; <span class=\"number\">0xFF00</span>) &gt;&gt; <span class=\"number\">8</span>)/<span class=\"number\">255.0</span>f;</span><br><span class=\"line\">    <span class=\"type\">float</span> <span class=\"built_in\">blue</span> = (hexColor &amp; <span class=\"number\">0xFF</span>)/<span class=\"number\">255.0</span>f;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [UIColor colorWithRed:<span class=\"built_in\">red</span> <span class=\"built_in\">green</span>:<span class=\"built_in\">green</span> <span class=\"built_in\">blue</span>:<span class=\"built_in\">blue</span> <span class=\"built_in\">alpha</span>:opacity];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 大概原理可以看出将 RGB 每个值都解析出来然后变成 UIColor，先拿第一步转换红色值来说，我们按照运算顺序一步步来讲 (默认将参数代入，用 0xffa131 代替 hexColor)</p>\n<ul>\n<li>\n<p><strong>0xffa131 &amp; 0xFF0000</strong></p>\n<p>我们知道红色值是前两位也就是<strong> ff</strong>，所以这一步我们既然要取出红色值就要把其他位全部置零来排除干扰，这步操作便是如此，在计算机系统内是二进制来实现的，即：&lt;br&gt;<br />\n1111 1111 1010 0001 0011 0001&lt;br&gt;-------------------------------------------  =&gt; &amp; =&gt; 1111 1111 0000 0000 0000&lt;br&gt;<br />\n1111 1111 0000 0000 0000 0000&lt;br&gt; 这部操作做完后可以看出将除了 R 值之外的 G 值 B 值全部置零了，但是离最终结果还差点，因为 0xFF 是 1111 1111，而我们的结果后面多出了 16 个 0，所以便有了第二步操作</p>\n</li>\n<li>\n<p><strong>&gt;&gt; 16</strong></p>\n<p>将上一步得到的结果右移 16 位即得到<strong> 0000 0000 0000 0000 1111 1111</strong> 高位的零可以忽略，这也是最终的结果</p>\n</li>\n<li>\n<p><strong>/ 255.0f</strong></p>\n<p>这一步应该都知道 UIColor 中传入的数值范围在 0~1，所以我们要做下转换</p>\n</li>\n<li>\n<p>后续的 G 值和 B 值都是一样的，只是大家注意位数就可以了，<strong>值得注意的是两个二进制数进行位运算一定保证两个数的位数相同，位数不够的那个数高位要用 0 补齐</strong></p>\n</li>\n</ul>\n<h2 id=\"101枚举\"><a class=\"anchor\" href=\"#101枚举\">#</a> 101：枚举</h2>\n<p>关于枚举中使用位运算我们之前也讲过，下面我们自己来写一个枚举 (伪代码)</p>\n<p><figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_OPTIONS</span>(<span class=\"type\">NSUInteger</span>, <span class=\"type\">TestOptions</span>) &#123;</span><br><span class=\"line\">     <span class=\"type\">TestOptionOne</span>     =    1 &lt;&lt; 0, （000001)</span><br><span class=\"line\"></span><br><span class=\"line\">  \t <span class=\"type\">TestOptionTwo</span>     =    1 &lt;&lt; 1,\t(000010)</span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"type\">TestOptionThree</span>   =    1 &lt;&lt; 2,\t(000100)</span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"type\">TestOptionFour</span>    =    1 &lt;&lt; 3,\t(001000)</span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"type\">TestOptionFive</span>    =    1 &lt;&lt; 4,\t(010000)</span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"type\">TestOptionSix</span>     =    1 &lt;&lt; 5,\t(100000)</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>解析<br />\n上面的枚举我后面用括号表明了位移后对应的二进制的值。这样写枚举的好处是我可以对其中选项多选比如<strong> TestOptionOne | TestOptionTwo （000001 | 000010 =&gt; 000011）</strong> 或者有其他的自定义组合。</li>\n</ul>\n<h2 id=\"110加密\"><a class=\"anchor\" href=\"#110加密\">#</a> 110：加密</h2>\n<p>在 iOS 中我们可以利用异或来进行加解密，异或的特性如下<br />\n <figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A ^ B = <span class=\"function\"><span class=\"params\">C</span> =&gt;</span> C ^ A = <span class=\"function\"><span class=\"params\">B</span> =&gt;</span> C ^ B = A</span><br></pre></td></tr></table></figure><br />\n 上文我们可以把 A 认为是需要加密的数据，B 认为是密钥 C 是加密后的数据<br />\n比如:</p>\n<p><figure class=\"highlight prolog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   char a[]=<span class=\"string\">&quot;MyPassword&quot;</span>;        <span class=\"comment\">/*要加密的密码*/</span></span><br><span class=\"line\">   char b[]=<span class=\"string\">&quot;cryptographic&quot;</span>;     <span class=\"comment\">/*密钥*/</span></span><br><span class=\"line\">   int i;</span><br><span class=\"line\">   <span class=\"comment\">/*加密代码*/</span></span><br><span class=\"line\">   for(i=<span class=\"number\">0</span>;a[i]!=<span class=\"string\">&#x27;\\0&#x27;</span>;i++)</span><br><span class=\"line\">a[i]=a[i]^b[i];</span><br><span class=\"line\">   printf(<span class=\"string\">&quot;You Password encrypted: %s\\n&quot;</span>,a);</span><br><span class=\"line\">   <span class=\"comment\">/*解密代码*/</span></span><br><span class=\"line\">   for(i=<span class=\"number\">0</span>;a[i]!=<span class=\"string\">&#x27;\\0&#x27;</span>;i++)</span><br><span class=\"line\">a[i]=a[i]^b[i];</span><br><span class=\"line\">   printf(<span class=\"string\">&quot;You Password: %s\\n&quot;</span>,a);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"111其他应用\"><a class=\"anchor\" href=\"#111其他应用\">#</a> 111：其他应用</h2>\n<ul>\n<li>记得 iOS 总有一道面试题<strong>在不使用第三个变量的情况下交换两个变量的值</strong>，这里用到异或的上面加解密中的特性。我有 x、y 两个个变量，做如下位运算操作</li>\n</ul>\n<p><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">void</span> exchange(int x , int y)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attribute\">x</span><span class=\"regexp\"> ^=</span> y;</span><br><span class=\"line\">    <span class=\"attribute\">y</span><span class=\"regexp\"> ^=</span> x;</span><br><span class=\"line\">    <span class=\"attribute\">x</span><span class=\"regexp\"> ^=</span> y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>判断一个数的奇偶性，其实我们可以用 **%2** 来判断，代码量不高，但是之前讲过，除法运算的时钟周期非常多，所以代码虽然不多并不代表效率高，我们可以用如下运算来完成:</li>\n</ul>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x&amp;<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;奇数&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;偶数&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 原理很简单，因为二进制是满二进一，一旦超过 1 就会变 0 并进一位，这时候和 00001 做 **&amp;** 操作一定会为 0，反之不为零。这样写效率会更高。</p>\n<ul>\n<li>计算两个数的平均值，通常我们都是（x+y）/2, 先不考虑效率问题，这样还会引起一个其他的问题，那就是 x+y 的值很有可能溢出大于 INT_MAX，所以我们采用位运算的办法来解决即可：</li>\n</ul>\n<p><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">average</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (x&amp;y)+((x^y)&gt;&gt;<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"1000总结\"><a class=\"anchor\" href=\"#1000总结\">#</a> 1000：总结</h2>\n<p>其实位运算的应用远远不止这些，在算法方面适当的使用还是很有帮助的。</p>\n",
            "tags": [
                "算法",
                "C语言",
                "排序"
            ]
        }
    ]
}