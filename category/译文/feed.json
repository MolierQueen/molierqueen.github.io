{
    "version": "https://jsonfeed.org/version/1",
    "title": "Molier • All posts by \"译文\" category",
    "description": "iOS 开发 移动App 博客 杂谈 随笔 相册",
    "home_page_url": "https://oliverqueen.cn",
    "items": [
        {
            "id": "https://oliverqueen.cn/2022-08-24-WWDC22%EF%BC%9ARuntime%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%92%8CApp%E5%87%8F%E5%8C%85/",
            "url": "https://oliverqueen.cn/2022-08-24-WWDC22%EF%BC%9ARuntime%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%92%8CApp%E5%87%8F%E5%8C%85/",
            "title": "WWDC22：Runtime的性能优化和App减包",
            "date_published": "2022-08-24T07:04:39.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>本 Session 讲了为了让你的应用包体积更小，运行更快，启动速度更快，我们对 Swift 和 Objective-C 运行时做了怎样的优化。同时通过本 Session 你将发现如何通过高效的协议检查，更小的消息发送，以及优化后的 ARC 机制，来提高你的 App 性能。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202301102018054.png\" alt=\"\" /></p>\n<p><span id=\"more\"></span></p>\n<p><div class=\"media-container\"><div class=\"player\" data-type=\"audio\" data-src='[\"https://music.163.com/#/song?id=1929370102\"]'></div></div></p>\n<h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>WWDC2022 上苹果更新了 Xcode14，里面提到了一些相关的优化。其中讲了通过对 Swift 和 Objective-C 运行时做了一些优化，达到了包体积变得更小、运行速度更快，启动速度更快的目的。如果你是用 Xcode14 来构建 App，那么会有其中三点优化</p>\n<ul>\n<li>高效的协议检查（针对 Swift protocol check）</li>\n<li>更快的消息发送机制（message send）</li>\n<li>release 和 retain 调用优化（release &amp; retain）</li>\n<li>Autorelease elision 的优化（自动释放省略）</li>\n</ul>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202301102019048.png\" alt=\"\" /></p>\n<p>当你用 Swift 或 Objective-C 编写代码时，其实是会经历三个个步骤。</p>\n<ul>\n<li>编码，通过 Xcode 编写代码</li>\n<li>编译，使用了 Swift 和 Clang 编译器</li>\n<li>运行，通过 Swift 和 Objective-C 运行时中完成</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gp9rcbq1j215t0u0754.jpg\" alt=\"image-20220823144936761\" /></p>\n<p>此次的这些关键优化其实就是在第三步骤运行时来完成的，运行时嵌入在我们所有平台的操作系统中。编译器在构建时不能做的事情，运行时可以做。而此次所有的修改其实对于开发者来说是无感透明的，所以任何代码都不用改动，只要你使用 Xcode14 来进行打包编译，便会享受的这些优化点。</p>\n<h2 id=\"swift协议检查protocol-checks\"><a class=\"anchor\" href=\"#swift协议检查protocol-checks\">#</a> Swift 协议检查（Protocol checks）</h2>\n<p>先来看一个例子！</p>\n<p><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个协议</span></span><br><span class=\"line\"><span class=\"keyword\">protocol</span> <span class=\"title class_\">CustomLoggable</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 协议中定义一个属性 customString，只读属性</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> customLogString: <span class=\"type\">String</span> &#123; <span class=\"keyword\">get</span> &#125;        </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个log函数，参数为Any类型</span></span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">log</span>(<span class=\"params\">value</span>: <span class=\"keyword\">Any</span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">//如果value遵循CustomLoggable协议，就输出字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> value <span class=\"operator\">=</span> value <span class=\"keyword\">as?</span> <span class=\"type\">CustomLoggable</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">debugPrint</span>(value.customLogString)        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"operator\">...</span>        </span><br><span class=\"line\">    &#125;       </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个Event类型 遵循协议，并实现customLogString</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Event</span>: <span class=\"title class_\">CustomLoggable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> date: <span class=\"type\">String</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> customLogString: <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;<span class=\"subst\">\\(<span class=\"keyword\">self</span>.name)</span>, on <span class=\"subst\">\\(<span class=\"keyword\">self</span>.date)</span>&quot;</span>    </span><br><span class=\"line\">    &#125;        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>看上面代码，因为 log 函数的参数需要输出字符串，所以在输出前要先判断这个 value 是否遵循 CustomLoggable 协议，Swift 是静态语言，所以一般来说这样的检查都是发生在编译时期。但是编译器不一定能拿到足够的协议元数据信息来完成检查。比如这里并不知道每次传入的 Any 类型是哪个确定类型，也就无法确定是否遵循  <code>CustomLoggable</code>  协议。所以这种检查常常发生运行时，系统借助计算好的协议检查元数据 (protocol check metadata)，运行库知道这个特殊对象是否符合协议。</p>\n<p>这些元数据的构建虽然大部分在编译期间，但是还是有一部分是要在运行时完成，比如上面的例子，而且一个项目中肯定不止有一个协议，所以随着协议越多运行时的效率就越低，对于用户来说这个时间大部分是启动时间，所以用户感知为启动时间变长。而 Xcode14 新推的的 Swift Runtime 解决了这个问题，只要你是用 Xcode14 编译且运行在 iOS16 及以上版即可。</p>\n<p>按照苹果的说法，他们会把 <code>是否遵循协议</code> 的这个判断前置到 build 时期，也就是把 <code>协议元数据计算</code> 的步骤前置到 build 中，具体就是他把这些操作放在 App 可执行文件和启动时任何动态库的 dyld 闭包的一部分</p>\n<p>为什么这样做可以节省启动时间，需要先了解下 app 启动流程，需要一个知识背景 <code>从iOS11开始dyld3被加入，iOS13第三方库也开始使用dyld3加载。</code> 所以我们要看下 dyld3 的加载流程</p>\n<p><img data-src=\"https://upload-images.jianshu.io/upload_images/2438680-b5edfa4c2bcdb205.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1044/format/webp\" alt=\"img\" /></p>\n<p><em>dyld 3</em> 主要包含了两个过程 进程外（启动前）和进程内（启动后），我们来看启动前做了那些事情</p>\n<ul>\n<li>进程外 <em>Mach-O</em> 分析器和编译器 （<em>out-of-process mach-o parser</em>）<br />\n<em>dyld 3</em> 中将采用提前写入把结果数据缓存成文件的方式构成一个 <em>lauch closure</em>（可以理解为缓存文件）</li>\n<li>分析依赖库</li>\n<li>执行符号查找</li>\n<li><em>Write closure</em> 缓存服务 (<em>launch closure cache</em> )<br />\n 系统程序的 <em>closure</em> 直接内置在 <em>shared cache</em> 中，而对于第三方 APP，将在 APP 安装或更新时生成，这样就能保证 <em>closure</em> 总是在 APP 打开之前准备好。说白了就是把上面做的结果全都缓存起来</li>\n</ul>\n<p>综上看来以前需要在 in-process 中做的事情，现在在 out-of-process 就可以完成，启动时或者运行时直接读取缓存数据即可，加快了启动速度和运行时的性能。其实在笔者看来当我们下载或者更新 App 的时候 App 上的进度条其实是分两部分 <code>正在下载</code> 和 <code>正在安装</code> ，此次的优化可能略微提高安装的时长来降低启动速度，提高运行时性能。</p>\n<p><code>on apps that rely heavily in Swift, this could add up to half the launch time</code>  如果有条件的同学可以试下是否可以提高这么多的启动耗时。</p>\n<h2 id=\"消息发送优化message-send\"><a class=\"anchor\" href=\"#消息发送优化message-send\">#</a> 消息发送优化（Message send）</h2>\n<p>直接抛结果，苹果这边给到的数据是使用 Xcode14 编译打包的数据可以让 ARM64 上发送消息消耗从 12 字节降低到 8 字节，二进制大小也有 2% 的降低，也就是苹果对包大小和性能都做了优化，默认是同时开启的，由苹果来平衡两者的关系，当然也可以使用 <code>objc_stubs_small</code>  来仅仅优化包大小。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5grqpljrej215t0u0aax.jpg\" alt=\"image-20220823161510950\" /></p>\n<p>下面我们看下是怎么优化的，同样使用官方代码举例</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 声明一个日历对象</span><br><span class=\"line\">NScalendar *cal = [self makeCalendar];</span><br><span class=\"line\"></span><br><span class=\"line\">// 声明一个日期对象并赋值</span><br><span class=\"line\">NSDateComponents *dateComponents = [[NSDateComponents alloc] init];</span><br><span class=\"line\">dateComponents.year = 2022;</span><br><span class=\"line\">dateComponents.month = 2022;</span><br><span class=\"line\">dateComponents.day = 2022;</span><br><span class=\"line\">S</span><br><span class=\"line\">// 把日期转换为date</span><br><span class=\"line\">NSDate *theDate = [cal dateFromComponents: dateComponents];</span><br><span class=\"line\"></span><br><span class=\"line\">// 返回date</span><br><span class=\"line\">return theDate;</span><br></pre></td></tr></table></figure></p>\n<p>大家知道 OC 调用方法最终会走到 <code>_objc_msgSend</code> ，所以上面代码不算最终的 return，会走 7 个  <code>_objc_msgSend</code> ，其中每一个都需要一条指令来调用就是 bl 如下图</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gsa0ef9kj20n00gidgx.jpg\" alt=\"image-20220823163343886\" /></p>\n<p>该函数定义为 <code>Id objc_msgSend(id self, SEL _cmd, ...) </code> ，参数定义为 self 是函数的调用方，SEL 为具体调用哪个函数，具体的方法查找流程就不在这里赘述。</p>\n<p>我们拿其中具体的一个函数调用来分析</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSDate *theDate = [cal dateFromComponents: dateComponents]; </span><br></pre></td></tr></table></figure></p>\n<p>比如这个函数调用，转化为 mesagesend 的时候就变成这样</p>\n<p><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_msgSend(cal, @selector(dateFromComponents))</span><br></pre></td></tr></table></figure></p>\n<p>为了告诉运行时调用哪个方法，我们必须传递一个 Selector 给这些 objc_msgSend 调用，就如上图的 <code>@selector(dateFromComponents)</code></p>\n<p>我们再来看 <code>Id objc_msgSend(id self, SEL _cmd, ...)</code>  执行后他是怎么执行汇编指令的。</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用adrp找到该方法的地址   消耗4字节</span><br><span class=\"line\">adrp x1, [selector &quot;dateFromComponents&quot;]  </span><br><span class=\"line\"></span><br><span class=\"line\">// 将 地址加载到X1寄存器中  消耗4字节</span><br><span class=\"line\">ldr  x1, [x1, selector &quot;dateFromComponents&quot;] </span><br><span class=\"line\"></span><br><span class=\"line\">// 执行bl指令跳转到该方法并执行  消耗4字节</span><br><span class=\"line\">bl _objc_msgSend</span><br></pre></td></tr></table></figure></p>\n<p>从上面的代码看出每次执行方法调用都会 走以上三个步骤，每个步骤消耗 4 字节 一共消耗 12 字节，而前两步是准备 selector，任何一次方法调用都会执行他，目前的策略是每调一个方法都会生成上面三步，那么此时优化空间就来了。</p>\n<p>因为这里存在相同的代码（前两步）， <code>我们可以考虑共享它，并且只在每个 selector 中触发它一次，而不是每次发送消息时都生成这段指令代码</code> 。所以我们可以把这部分相同代码提取出来，放到一个小助手函数中 (helper function), 并调用该函数。通过使用同一 selector 进行多次调用 (通过传递参数不同，内部指令是相同的，现在封装成一个存根函数，以前是散落在各个 _objc_msgSend 调用处)，我们可以保存所有这些指令字节。所以可以理解为 <code>把前两步封装一下</code></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gvtbfnh1j20n00git9h.jpg\" alt=\"image-20220823183604633\" /></p>\n<p>所以原来的调用就变成了</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bl _objc_msgSend$dateFromComponents 4字节</span><br><span class=\"line\">bl _objc_msgSend    4字节</span><br></pre></td></tr></table></figure></p>\n<p>这也就是苹果说的从 12 字节优化到 8 字节，其中 <code>_objc_msgSend$dateFromComponents</code>  也被称为 <code>selector stub 存根函数</code></p>\n<p>同样 <code>_objc_msgSend</code>  本身也有一个存根函数写法</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gw1kpzuzj20n00giwfd.jpg\" alt=\"image-20220823184401200\" /></p>\n<p>这样一来我们现在就有两个存根函数</p>\n<ul>\n<li>_objc_msgSend$dateFromComponents:</li>\n<li>_objc_msgSend:</li>\n</ul>\n<p>这两个函数封装了一些通用的东西，共享了最多的代码，使代码尽可能的小，但是这样带来的不足是我需要连着两个 bl 跳转，这对操作系统来说开销较大。所以为了平衡包体积和性能，我们可以使用下面这种方法来提升这一点。我们可以把前面调用的两个存根函数封装成一个 (都封装成_objc_msgSend$dateFromComponents)，这样，我们可以使代码更紧凑，不需要那么多调用。如下图这样</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gwei63esj20bo07u74l.jpg\" alt=\"image-20220823185626349\" /></p>\n<p>这就回到了之前的问题，你可以通过 <code>_objc_stubs_small</code>  标记了只降低包大小，或者采用默认的方式让系统自动平衡，两者的区别在汇编层面就体现在如下图</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gwg7hnugj20n00gidhc.jpg\" alt=\"image-20220823185804687\" /></p>\n<p>综上：这就是 Meesage send 占用从 12 bytes 降低到 8 bytes 和二进制大小下降 12% 的原因</p>\n<h2 id=\"retain-and-release\"><a class=\"anchor\" href=\"#retain-and-release\">#</a> Retain and release</h2>\n<p>这个优化是苹果这边使 Retain and release 的开销更小，苹果的说法是 Retain and release 的调用开销从 8 字节降低到 4 字节，同时包体积也会有 2% 的优化</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gwkqxaenj20n00gidg9.jpg\" alt=\"image-20220823190226429\" /></p>\n<p>我们知道 ARC 相比于 MRC 是开发者不需要再写 retain、release 这些代码，其实并不是不需要，而是编译器帮我们自动在需要的位置插入了这些代码，所以换句话说他们还是存在的，只是你看不到也不用在关心他们。</p>\n<p>还是拿之前的例子来说</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Retain/release calls inserted by ARC</span><br><span class=\"line\">NScalendar *cal = [self makeCalendar]; // bl    _objc_retain</span><br><span class=\"line\"></span><br><span class=\"line\">NSDateComponents *dateComponents = [[NSDateComponents alloc] init]; // bl    _objc_retain</span><br><span class=\"line\">dateComponents.year = 2022; </span><br><span class=\"line\">dateComponents.month = 2022;</span><br><span class=\"line\">dateComponents.day = 2022;</span><br><span class=\"line\"></span><br><span class=\"line\">NSDate *theDate = [cal dateFromComponents: dateComponents]; // bl    _objc_retain</span><br><span class=\"line\">return theDate;</span><br><span class=\"line\">// bl    _objc_release </span><br><span class=\"line\">// bl    _objc_release </span><br><span class=\"line\">// bl    _objc_release </span><br></pre></td></tr></table></figure></p>\n<p>在变量创建的时候我们使用 retain 来增加的他的引用计数不被销毁，在方法结束后我们使用 release 来销毁不需要的变量，这也是 iOS 的内存管理机制。在 ARC 下这些都是编译器我们插入的代码，我们无需关心。</p>\n<p>retain 和 release 都是 C 语言的函数，他们携带一个参数就是被操作的对象，同时他遵循 C 语言的 ABI，所以当你调用这些方法的时候系统还会为你做一些额外的事情，比如下图中的 mov 操作，而这些操正是我们优化的用武之地，通过自定义调用重新约定 retain/release 接口，我们可以根据对象指针的位置，适当的使用正确的变量，这样就可以不用移动它。简单的说， <code>就是修改了底层 ABI</code> 。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gwylzjkuj20n00giab1.jpg\" alt=\"image-20220823191546398\" /></p>\n<p>我们是怎么做的优化呢？看下之前的流程，我们用下面这行代码举例</p>\n<p><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_release(dateComponents); </span><br><span class=\"line\"><span class=\"comment\">// mov  x0, x20                    消耗4 字节                                                                                                                                                           </span></span><br><span class=\"line\"><span class=\"comment\">// bl    _objc_release         消耗4字节</span></span><br></pre></td></tr></table></figure></p>\n<p>流程为</p>\n<ul>\n<li>先执行 mov 把副本地址（X20, 也就是对象的地址）存到寄存器 x0</li>\n<li>然后 bl 跳转到 <code>_objc_release</code>  函数进行释放</li>\n</ul>\n<p>根据之前讲的每个指令消耗 4 字节，所以这里消耗 8 字节</p>\n<p>我们修改 ABI 之后其省掉调用 mov 指令 然后原本跳转到_objc_release 函数 改为跳转到 <code>_objc_release_x20</code>  函数，而 mov 的指令放到 C 语言更底层的 ABI 里面去做，你可以理解为 <code>我们封装了一个新的retain、release函数，你只要传入一个寄存器地址我就去更底层的地方完成mov操作，所以效率更高了</code> 。现在因为只用执行一条指令，所以内存消耗为 4 字节。现在的流程看起来为</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gx83ebs8j20n00giab9.jpg\" alt=\"image-20220823192452605\" /></p>\n<p>这么看来我们代码里大量的 release 和 retain 都经过这样的样的优化所以整体的二进制包降低 2% 同时调用内存消耗游 8 字节变为 4 字节，同时 ABI 接口修改，去除冗余 mov 指令调用，下沉到 ABI。 <code>由于 ABI 是内嵌系统</code> ，这里新增 mov 指令占用可以忽略不计。</p>\n<p><code>Apple 果然是坚持用户体验优先，为了更好体验不惜修改 c 的 ABI</code></p>\n<h2 id=\"autorelease-elision自动释放省略优化\"><a class=\"anchor\" href=\"#autorelease-elision自动释放省略优化\">#</a> Autorelease elision（自动释放省略优化）</h2>\n<p>iOS 中除了使用 release 之外还有另一个 就是 autorelease 自动释放机制，同样在这个地方苹果也做了自动释放省略的优化让自动释放机制效率更高。我们来看下面这个例子</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Return Value Autoreleases </span><br><span class=\"line\"></span><br><span class=\"line\">theWWDCDate = [event getWWDCDate];</span><br><span class=\"line\"></span><br><span class=\"line\">-(NSDate*)getWWDCDate &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    return theDate;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>创建一个临时对象 (theDate)，并将其返回给调用方 (event)。 <code>getWWDCDate()</code>  方法中返回临时的 theDate，然后调用完成 (返回 theDate 之后，getWWDCDate 就调用完成)。这时调用方（event）将其保存到自己的变量中（theWWDCDate 中）。</p>\n<p>根据系统插入 retain 和 release 的机制来说应该是这样的，但是明显 retain 处不能进行 release，因为我需要吧 theDate 返回回去，如果这里释放了我就没办法呢返回了。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gy19928nj20n00gi3yz.jpg\" alt=\"image-20220823195254398\" /></p>\n<p>因此，为了解决上述问题，需要使用一个特殊的约定用来返回这个临时返回值。这就引入了 Autorelease，这样调用者能够 retain 它。autorelease 在这里保证在调用方可以正常返回该值，而不被提前释放，延长释放生命周期。你之前可能看到过 autorelease 和 autoreleasePools：其实这是一种将 release 操作推迟到稍后某个时间的方法。所以上面的代码改为 Autorelease</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Return Value Autoreleases </span><br><span class=\"line\"></span><br><span class=\"line\">theWWDCDate = [[event getWWDCDate] retain];</span><br><span class=\"line\"></span><br><span class=\"line\">-(NSDate*)getWWDCDate &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    return [theDate autorelease]; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>系统并不知道他在什么时候会被释放，反正只要不在 retain 的时候释放就行，所以我在 retain 的时候先打个标记，标记他之后可能会被释放。但是这样的操作目前会带来一些开销，其实就是 <code>我虽然打了release标记，但是我明明一会还要retain，没必要多此一举</code> ，所以基于此我们之前引入了 <code>Autorelease elision</code>  来减少这部分开销（ <code>如果Autorelease后紧接一个retain我就都不做了</code> ）。我们先从汇编层面看下 Autorelease elision 做了什么</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gy8n9wnzj20n00giwf7.jpg\" alt=\"image-20220823195959365\" /></p>\n<p>提炼出以下代码</p>\n<p><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// What the compiler emits</span></span><br><span class=\"line\"> bl    _getWWDCDate </span><br><span class=\"line\"> mov   x29, x29</span><br><span class=\"line\"> bl    _objc_retainAutoreleasedReturnValue</span><br><span class=\"line\"></span><br><span class=\"line\"> b    _objc_autoreleaseReturnValue   <span class=\"comment\">// autorelease -&gt; runtime -&gt; _objc_autoreleaseReturnValue</span></span><br></pre></td></tr></table></figure></p>\n<p>其实就是以下步骤</p>\n<ul>\n<li>当我们返回值调用 Autorelease 时候系统会调用 <code>_objc_autoreleaseReturnValue</code>  来返回一个 <code>autoreleased value</code></li>\n<li>执行 Autorelease 后编译器会添加个标记 <code>mov x29, x29</code>   而这句指令在实际运行中这个指令会变为二进制的形式变为 <code>0xAA1D03FD</code></li>\n<li>后续的操作就运行时会先判断是否有对应的标记 <code>0xAA1D03FD</code> ，如果有，这意味着编译器告诉 runtime, 我们将返回一个已经被标记，但是将立即被持有（retain） 的临时变量，后面就不需要再 retain 操作了</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5h056kleej20n00gigm5.jpg\" alt=\"image-20220823210550374\" /></p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static ALWAYS_INLINE bool </span><br><span class=\"line\">callerAcceptsOptimizedReturn(const void *ra)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // fd 03 1d aa    mov fp, fp</span><br><span class=\"line\">    // arm64 instructions are well-aligned</span><br><span class=\"line\">    if (*(uint32_t *)ra == 0xaa1d03fd) &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">        // 返回true 需要优化 把release、rentain删掉</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>说白了就是在返回值身上调用 <code>objc_autoreleaseReturnValue</code>  方法时，runtime 将这个返回值 object 标记（储存在 TLS 中），然后直接返回这个 object（不调用 autorelease）；同时，在外部接收这个返回值的 <code>objc_retainAutoreleasedReturnValue</code>  里，发现有之前的标记（TLS 中正好存了这个对象），那么直接返回这个 object（清楚之前的标记且不再调用 retain）。</p>\n<p>注意：TLS 相关的含义可以参考 [这里](<span class=\"exturl\" data-url=\"aHR0cDovL3NlYW5jaGVuc2UuZ2l0aHViLmlvLzIwMTgvMDkvMjAvZWFybGdyZXktc291cmNlLWNvZGUtcmVhZC0xLyNUTFM=\">EarlGrey 源码阅读（一） | SeanChense</span>)</p>\n<p>但是这里有一个问题，以二进制的形式来加载代码并不是很常见，而且我们不但要加载它还要比较他尤其在 CPU 上并不是最优策略，所以这里还是有开销的，因此我们看下如何优化。</p>\n<p>同样执行流程，当执行完 <code> _objc_autoreleaseReturnValue</code>  函数时候我们会获得一个返回地址，这个地址是一个指针，指向了被标记为 Autorelease 的对象。然后代码继续执行到 <code>_objc_retainAutoreleasedReturnValue</code>  这里要进行 reatin，而被 reatain 的变量地址我们也可以拿到，所以只要比较这两个指针即可，这样一来我们也不再需要 mov 操作</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5h0ws62g0j20n00gidg3.jpg\" alt=\"image-20220823213224122\" /></p>\n<p>优化点</p>\n<ul>\n<li>把原来的比较二进制数据改为比较指针。速度更快效率更高</li>\n<li>减少 mov 指令 减少 4 字节，二进制大小预计降低 2%</li>\n</ul>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>这就是 Xcode14+iOS16 的编译期间优化，可以看出苹果也在帮我们完成 OKR 减少包体积，提高启动速度，增加代码执行效率，同时也能看出苹果在追求极致用户体验道路上所做的事情。本文部分翻译自<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL3ZpZGVvcy9wbGF5L3d3ZGMyMDIyLzExMDM2My8=\"> Improve app size and runtime performance</span>，同时也添加了自己的思考。</p>\n",
            "tags": [
                "iOS",
                "WWDC2022"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-05-08-RX-Swift-Study-One/",
            "url": "https://oliverqueen.cn/2018-05-08-RX-Swift-Study-One/",
            "title": "关于RxSwift的一点理解",
            "date_published": "2018-05-08T02:12:00.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"hello-rxswift\"><a class=\"anchor\" href=\"#hello-rxswift\">#</a> Hello RxSwift!</h2>\n<p>这本书可以让你用 Swift 来编写响应式编程代码。但是到底什么是 RxSwift, 这里有很好的定义：</p>\n<p>&lt;font color=orange&gt;RxSwift 是由可被观察的事件的异步队列和可操作的功能性的运算符组成的库，并且他可以由调度者通过参数的方式进行调度。&lt;/font&gt; &lt;br&gt;</p>\n<p><img data-src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1525870736284&amp;di=9f373001bac8687d5fe11b3d7b40016f&amp;imgtype=0&amp;src=http%3A%2F%2Fcode4app.com%2Fdata%2Fattachment%2Fforum%2F201703%2F21%2F210007p6wy7buzq6hqhhdu.png\" alt=\"\" /></p>\n<p>听起来很复杂？其实不用担心，因为无论是你编写响应式编程，还是理解他们背后的思想和一些相关的东西，官方通常都是用一些很吓人的术语来解释。尤其是当你第一次接触，或者是之前从未有人向你介绍过这些的时候，你就会觉得很可怕。</p>\n<p><span id=\"more\"></span></p>\n<p>本书的目标就是带你逐步的去理解 RxSwift 的 API，并且去运用每一个 API，然后把它们运用到实际的 iOSApp 中。</p>\n<p>你将会从 RxSwift 中最基本的功能开始，然后循序渐进的由中级到高级。花一些时间去广泛的理解里面的概念，这样以来读完本书后你就会精通 RxSwift 额思想和使用。其实 Rx 是非常广的话题，以至于不能单单通过这一本书来讲完，因此我们通过这本书让你对 RX 有一个坚实的了解，这样你就能继续提高自己的 Rx 水平了</p>\n<p>其实我们并没有非常确信 RxSwift 的思想是什么，让我们在这个章节里面通过几个简单的例子来帮助我们理解响应式编程。</p>\n<p>&lt;font color=orange&gt;RxSwift 本质其实就是当你的数据或者对象发生变化时候他会把这个变化放在一个单独的管道 (队列) 里面，以此来达到简化异步并发的过程的目的 &lt;/font&gt;&lt;br&gt;</p>\n<p>这里打个比方一个按钮我点击了就会触发一个时间 那么我每点击一次就会生成一个 Action 我们用一个管道去装在这些 Action，每加一个 Action 就会把他放管道里面，我们可以理解为管道里面流动的 Actions，且管道与管道之间相互独立。同理我们可以吧 Button 改成一个 UITExtField，Action 就是每一次输入事件。</p>\n<p>作为一个 iOS 的开发者我相信这已经很好帮你去理解什么是 RxSwift 了吧，这应该是比你在一开始看到的那些专业术语好理解的多。</p>\n<p>如果你还是不清楚，那么你至少应该理解，RxSwift 可以很轻松的帮你编写异步操作的代码，你要知道编写异步操作的代码是比较难的，所以所任何一点点的帮助都是受大家所欢迎的。</p>\n<h3 id=\"异步编程的介绍\"><a class=\"anchor\" href=\"#异步编程的介绍\">#</a> 异步编程的介绍</h3>\n<p>如果你想用一种通俗简单的语言来描述异步编程，比如你在做一个 iSO 的 App，那么你一定想到如下几个东西：</p>\n<ul>\n<li>\n<p>接受 Button 的点击事件</p>\n</li>\n<li>\n<p>当 text field 的 Action 和键盘的弹出和收起动画之间的关系</p>\n</li>\n<li>\n<p>从网上下载大图片</p>\n</li>\n<li>\n<p>往硬盘里面存数据</p>\n</li>\n<li>\n<p>播放视频</p>\n</li>\n</ul>\n<p>以上的所有东西看似是发生在同一时刻其实真的是吗？我们思考一个问题：比如你在看视频，这时候你点击了 textfield 弹出键盘，大家都知道键盘由下往上弹出是有一个动画的，就算键盘已经出现到了屏幕上，只要动画没有做完你的视频就不会暂停，真的是这样吗，内部又是如何实现的？如下图:</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1fr41y6xhkij31kw0q0h80.jpg\" alt=\"\" /></p>\n<p>程序里面不同的部分不会阻塞彼此的执行，iOS 提供了几种 API，通过多核 CPU 来在不同的线程上进行不同的工作。</p>\n<p>其实编写真正并行的代码其实是很复杂的，打个比方假如两个线程同时访问同一个资源，就会产生资源争夺的问题，比如谁先访问，谁后访问。</p>\n<h3 id=\"uikit中的一些异步的api\"><a class=\"anchor\" href=\"#uikit中的一些异步的api\">#</a> UIKit 中的一些异步的 API</h3>\n<p>苹果在 iOS SDK 中提供了很多 api，帮助你编写异步代码。你在你的项目中使用过这些但是可能还没有考虑过它们，因为它们是编写移动应用程序的基础。毕竟苹果爸爸封装好的，我们拿来用就好了，干嘛想那么多。</p>\n<p>你一定用过以下几点</p>\n<ul>\n<li>\n<p>NotificationCenter</p>\n</li>\n<li>\n<p>delegate</p>\n</li>\n<li>\n<p>Grand Central Dispatch(GCD)</p>\n</li>\n<li>\n<p>Closures（Block）</p>\n</li>\n</ul>\n<p>由于大部分的类都是异步的，并且 UI 在内部也是异步的，所以很难去猜测整个程序的执行顺序，因此你的 APp 会因为一些外部的原因而表现不同，比如用户的输入不同、网络环境的不同、或者一些其他的东西。用户每次在打开你的 APp 其实代码的执行顺序都是不同的 (当然除了一些自动化测试的场景，那些条件都是预先设置好的。)</p>\n<p>其实写好异步代码并不是绝对不可能的，毕竟苹果给我提供了非常强大的 API，相比较于其他平台这要好很多。不过问题在于编写复杂的异步代码很难，部分原因是因为苹果给我们提供了大量的 SDK，而且他们并不统一。如果使用 delegate 我们需要遵循特制的格式，block，NotificationCenter 等等都是这样的，所以并没有一种通用的、贯穿所有异步方法的 API，这样就导致读懂并且书写这样的异步代码很难。可以看下下图:</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1fr4342v718j31kw0nlgzj.jpg\" alt=\"\" /></p>\n<p>我们来比较两个代码片段来总结下这章。一个是异步一个是同步。</p>\n<h4 id=\"同步代码\"><a class=\"anchor\" href=\"#同步代码\">#</a> 同步代码</h4>\n<p>对数组的每个元素进行操作你应该很熟悉了吧，其实就是循环遍历嘛。这是一个非常简单而又坚实的功能，因为它保证了两件事:</p>\n<ul>\n<li>\n<p>它是同步执行的。</p>\n</li>\n<li>\n<p>在循环遍历时候他是不可变的</p>\n</li>\n</ul>\n<p>花点时间想想这意味着什么。当你遍历一个数组的时候，你不需要检查所有的元素是否仍然存在，并且您不需要重新返回，以防另一个线程在集合的开始插入一个元素。您假定您总是在循环的开始时遍历整个集合。试试以下代码:</p>\n<p><figure class=\"highlight smali\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var<span class=\"built_in\"> array </span>= [1, 2, 3]</span><br><span class=\"line\">for number in<span class=\"built_in\"> array </span>&#123;</span><br><span class=\"line\">  print(number)</span><br><span class=\"line\"> <span class=\"built_in\"> array </span>= [4, 5, 6]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">print(array)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 最后的输出结果：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1fr43rz56omj304p02at8i.jpg\" alt=\"\" /></p>\n<p>数组在 for 循环中是不可变的吗？执行顺序是什么？</p>\n<h4 id=\"异步代码\"><a class=\"anchor\" href=\"#异步代码\">#</a> 异步代码</h4>\n<p>再考虑一个类似的代码，如下用户通过点击事件触发下面代码，每次点击都会输出数组下一个元素，然后用户重复点击直到把数组所有的元素输出完成：<br />\n<figure class=\"highlight smali\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var<span class=\"built_in\"> array </span>= [1, 2, 3]</span><br><span class=\"line\">var currentIndex = 0</span><br><span class=\"line\"></span><br><span class=\"line\">//this method is connected in IB to a button</span><br><span class=\"line\">@IBAction func printNext(_ sender: Any) &#123;</span><br><span class=\"line\">  print(array[currentIndex])</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"built_in\"> if </span>currentIndex != array.count-1 &#123;</span><br><span class=\"line\">    currentIndex += 1</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 试想一下如果放在我们现实的 App 中真的可以这么执行吗？这个可说不准，因为如果在用户的两次点击之间又有其他的线程对这个数组进行了操作 (增加、删除元素) 那么数据就会发生错乱。而且如果 currentIndex 被另一个线程改变了那么你也不会得到预期的结果。</p>\n<p>其实多线程最重要的就是数据争夺的问题，然而 RxSwift 很好的解决了这个问题</p>\n",
            "tags": [
                "Swift"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-24-iOS%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/",
            "url": "https://oliverqueen.cn/2018-01-24-iOS%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/",
            "title": "iOS端自动内存泄漏检测工具",
            "date_published": "2018-01-24T03:41:50.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h4 id=\"产生的背景\"><a class=\"anchor\" href=\"#产生的背景\">#</a> 产生的背景</h4>\n<p>在移动设备上内存是一块公用的区域，如果一个 App 没有做好内存管理那么一定会导致性能急剧下降甚至会崩溃。<br />\nFacebook 的 iOS 端有许多的地方都共享着一块内存，如果任何一个地方占用太多的内存的话就会影响到整个 App，比如一个地发生了内存泄漏，就会出现这种情况。我们把一组内存分配我们的一个对象，但是当我们使用完之后忘记释放他，这就通常就会引起内存泄漏，这就意味着系统永远不能回收这块内存也就导致这块内存一直不能分配给别的对象。在 Facebook 里我们有许多许多的工程师在代码的不同部分工作，内存泄漏时不可避免的，当一旦有内存泄漏发生我们就需要立即找到并且修复。虽然现在有好多检测内存泄漏的工具但是这些工具并不完善，他们仍然需要开发者去做一些工作：<br />\n<span id=\"more\"></span></p>\n<ul>\n<li>1：打开 Xcode 并且 Build</li>\n<li>2：运行 instrument</li>\n<li>3：使用 App 尽可能的去复现</li>\n<li>4：寻找内存泄漏的来源</li>\n<li>5：解决问题</li>\n</ul>\n<p>这意味着需要大量的体力活，并且都是些重复无聊的工作，这也导致了我们不能在开发周期就定位并且修复问题。</p>\n<p>将这个过程自动化可以让我们在不需要太多的开发者的情况下更快的去找到内存泄漏。为了解决这个问题我们已经建立一套工具使我们能够自动的去完成这些过程，并且这套工具已经解决了我们自己代码的一些问题，今天我们很激动的宣布我们把他们发布了出来<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL0ZCUmV0YWluQ3ljbGVEZXRlY3Rvcg==\"> FBRetainCycleDetector</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL0ZCQWxsb2NhdGlvblRyYWNrZXI=\">FBAllocationTracker</span>, and <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL0ZCTWVtb3J5UHJvZmlsZXI=\">FBMemoryProfiler</span>.</p>\n<h4 id=\"循环引用\"><a class=\"anchor\" href=\"#循环引用\">#</a> 循环引用</h4>\n<p>Objective-C 使用引用计数来管理内存的，内存中的一个对象可以引用其他的对象，只要有一个对象使用它，那么他就会一直被留在内存中。我们也可以说一个对象持有另一个对象。</p>\n<p>  一般来说这都没问题。但是有一种情会使我们陷入僵局。当两个 obj 不在相互持有，而是通过另一个 obj 来互相持有，这样就会陷入一个循环引用的状态就像下面这张图</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fnrkogrtqbj30kg0cndhd.jpg\" alt=\"循环引用\" /></p>\n<p>一个 View Controller 持有一个 Viw View 中持有 delegate delegate 中持有 ViewController。这样就形成一个环状，谁也无法释放。</p>\n<p>  循环引用会导致一些列的的问题，如果一个对象在 RAM 中无限的占用空间，充其量也只是浪费一点点内存。如果这些泄漏的对象正在做一些其他的事情那么就会导致 App 的其他的地方再也无法使用这块内存。更严重的如果循环引用过多，就会浪费掉大量的内存最终导致程序的 crash。</p>\n<p>  在我们进行人工调试的时候我们已经找出了大量的很明显的循环引用，我们能很好地定位他，但是在运行之后我们就很难发现他们，但是我们这 SDK 能很轻松的做这些事。</p>\n<h4 id=\"在runtime下的循环引用检测\"><a class=\"anchor\" href=\"#在runtime下的循环引用检测\">#</a> 在 Runtime 下的循环引用检测</h4>\n<p>  在 OC 中找循环引用其实就类似于在一个节点为对象，链接线为引用关系的有向无环图中寻找一个环。打个比方如果 A 引用 B 那么 A 到 B 就会有箭头指向可以看这个<br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kvv1735j30yg0mv0ug.jpg\" alt=\"image.png\" /> 我们发现这张图在箭头处发生循环引用</p>\n<p>  这个是一个很简单的引用关系我们必须确保我们能像左侧那样的来引用对象，其实对于每一个对象我们都获取他所有引用 (持有的) 对象，有的是强引用有的是弱引用，但是循环引用只发生在强引用上，对于每个对象我们需要搞清楚如何找到引用关系。</p>\n<p>  幸运的是 OC 给我提供了强大的 Runtime，这足够让我们去挖掘其中的关系，图中的一个点可能是 block 或者是 Object 中的其中一个，让我们来分别讨论下</p>\n<h4 id=\"objects\"><a class=\"anchor\" href=\"#objects\">#</a> Objects</h4>\n<p>  Runtime 中有很多工具去帮助我们了解其中的东西，首先我们搞懂到所有实例变量的引用关系<br />\n <figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const <span class=\"built_in\">char</span> *<span class=\"keyword\">class</span><span class=\"constructor\">_getIvarLayout(Class <span class=\"params\">cls</span>)</span>;</span><br><span class=\"line\">const <span class=\"built_in\">char</span> *<span class=\"keyword\">class</span><span class=\"constructor\">_getWeakIvarLayout(Class <span class=\"params\">cls</span>)</span>;</span><br></pre></td></tr></table></figure><br />\n 对于一个给定的对象，实例变量布局图告诉我们了他都引用了哪些对象，他会给我提供一个索引，这个索引相当于一个偏移量，该对象加上这个偏移量就是他所引用的对象的地址。运行时会给我们提供一个 “弱引用” 的布局图，也就是该对象所有弱引用的对象，强引用和弱引用之间的区别我们可以猜想为就是强引用的布局图。</p>\n<p>  对于 objective-c++ 来说我们可以用结构体来定义一个对象，这些对象不会再实例变量的布局图中被获取到，不过 Runtime 给我提供了 “类型编码” 来处理这个问题，对于每个实例变量，类型编码描述了变量是如何构造的。如果它是一个 struct，类型编码可以描述出它包含的字段和类型。我们解析类型编码以找到哪些实例变量是 objective-c 的对象。然后我们可以像在布局图中那样计算他的偏移量然后拿到他所引用的对象的地址。</p>\n<p>  还有一些我们不会深入讨论的边缘案例。这些都是不同的集合，我们必须列举它们来获取它们的保留对象，这可能会产生一些副作用。</p>\n<h4 id=\"blocks\"><a class=\"anchor\" href=\"#blocks\">#</a> Blocks</h4>\n<p>  block 和对象有一点不同。运行时不允许我们轻松地查看它们的布局，但是我们仍然可以进行猜测。在处理 block 时，我们使用了 Mike Ash 在他的项目<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL21pa2Vhc2gvQ2lyY2xl\"> Circle</span> 中提出的想法：也正是这个项目激发 FBRetainCycleDetector 的项目。</p>\n<p> $emsp; 我们可以使用<span class=\"exturl\" data-url=\"aHR0cDovL2NsYW5nLmxsdm0ub3JnL2RvY3MvQmxvY2stQUJJLUFwcGxlLmh0bWw=\"> application binary interface for blocks</span> (ABI)，他可以向我们展示一个 block 在内存中是什么样子的，如果我们知道了我们所研究的 block 的表现形式我们就可以用一个假的结构体来模仿实现 block 的功能，之后我们就能知道了哪些对象被 block 引用并且一直在那里，但是不幸的是我们并不知道这些事强引用还是弱引用。</p>\n<p>  为了做到这些我们使用黑盒的方法，首先我们创建一个假的对象来模仿我们所研究的 Block，因为是我们自己创建的假对象，所以我们可以完全的操作他，我们给这个假装的 block 上面装上释放探测器，释放探测器是监听发给他们的释放消息的一个对象，如果一个所有者想放弃对对象们所有权的时候，释放探测器会给他所有强引用的对象发出消息，当我们释放我们的假对象时，我们可以检查哪些探测器收到了这样的消息。便知道了哪些 block 是被强引用的。这样一来我们可以找到我们原始 block 所持有的真是的对象，如下图所示</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fnrkpskc4zj30kg0fd76k.jpg\" alt=\"block\" /></p>\n<h4 id=\"自动化\"><a class=\"anchor\" href=\"#自动化\">#</a> 自动化</h4>\n<p>  员工在进行持续执行时，这个工具就会非常出色。自动化在客户端上是非常容易的，我们使用定时器来建立一个循环引用检测，用来周期性的扫描一部分内存去寻找循环引用，不过还是有点问题，我们第一次运行检测器的时候我们发现他不快速的扫描完整个内存空间，所以我们需要给他提供一个候选检测对象，为了做到这一点，我们建立了 FBAllocationTracker，他可以追踪任何一个 Nsobject 对象的创建和销毁，他同样可以在任何给定的时刻以最小的性能开销来获取任何类的实例对象。</p>\n<p>  在客户端上实现了这样的自动化操作意味着我们可以更加简单的在 NSTimer 上使用 FBRetainCycleDetector 和添加用了追踪实例的 FBAllocationTracker，现在让我们来看下后端到底发生了什么，循环引用可以有多个对象来组成，如果创建了许多的引用环并且有一个泄漏了那么事情将会变得非常复杂。如下如所示 A-&gt;B 就是一个坏的引用环导致了 A-&gt;B-&gt;C-&gt;D 和 A-&gt;B-&gt;C-&gt;E</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fnrkrd6o9oj30kg0j6acn.jpg\" alt=\"引用环\" /></p>\n<p>遇到这样的问题就会给我们的 SDK 带来两个问题：</p>\n<ul>\n<li>\n<p>如果这两个环是由于一个不良引用引起我们就直接标记一处不良引用就可以了，不用标记两处，这样会给开发者一个错误信号。</p>\n</li>\n<li>\n<p>如果这两个环是虽然由一个不良引用引起但是会导致两个不同的错误，那么我们就需要将这个两个循环引用都标记出来</p>\n</li>\n</ul>\n<p>因此我们需要建立一个循环引用群，我们通过下面这些启发写了一种算法。</p>\n<ul>\n<li>1：把给定日期中所检测出的所有循环引用收集起来。</li>\n<li>2：找到每个循环引用环中 Facebook 特定的类名。</li>\n<li>3：找到每个环中最小的那个环。</li>\n<li>4：把最小周期放到一个组中。</li>\n<li>5：仅仅只像开发者报告最小的周期。</li>\n</ul>\n<p>有了这些最后一部分就是找出谁可能会意外的引入一个循环引用，我们通过 “git/hg blame” 来做到这些。猜测这可能是导致出现问题的最新修改。最后一个提交代码的人会收到一个通知。整个系统可以如下展示</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fnrkrs9hmvj30kg0660ua.jpg\" alt=\"系统图\" /></p>\n<h4 id=\"手工配置\"><a class=\"anchor\" href=\"#手工配置\">#</a> 手工配置</h4>\n<p>  尽管自动化帮助简化了寻找循环引用的过程，并减少了开发人员的工作，但是手动配置仍然很重呀。我们开发的另一款工具允许任何人查看应用程序的内存使用情况，甚至不用将手机插入电脑。FBMemoryProfiler 可以很容易地添加到任何应用中，让你手动配置你的工程，并在应用中运行循环引用检测，它可以通过使用 FBAllocationTracker 和 fbretaincycle 检测器来完成。</p>\n<p>原文链接 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlLmZhY2Vib29rLmNvbS9wb3N0cy81ODM5NDYzMTUwOTQzNDcvYXV0b21hdGljLW1lbW9yeS1sZWFrLWRldGVjdGlvbi1vbi1pb3Mv\">https://code.facebook.com/posts/583946315094347/automatic-memory-leak-detection-on-ios/</span></p>\n",
            "tags": [
                "翻译",
                "优化",
                "国外文献"
            ]
        }
    ]
}