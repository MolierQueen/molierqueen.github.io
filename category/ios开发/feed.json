{
    "version": "https://jsonfeed.org/version/1",
    "title": "Molier • All posts by \"ios开发\" category",
    "description": "iOS 开发 移动App 博客 杂谈 随笔 相册",
    "home_page_url": "https://oliverqueen.cn",
    "items": [
        {
            "id": "https://oliverqueen.cn/2021-05-03-iOS%20Crash%E9%98%B2%E6%8A%A4%E4%BD%A0%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%B0%B1%E5%A4%9F%E4%BA%86-%E4%B8%8A%E7%AF%87/",
            "url": "https://oliverqueen.cn/2021-05-03-iOS%20Crash%E9%98%B2%E6%8A%A4%E4%BD%A0%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%B0%B1%E5%A4%9F%E4%BA%86-%E4%B8%8A%E7%AF%87/",
            "title": "iOS Crash防护你看这个就够了 - 上篇",
            "date_published": "2023-12-30T14:16:08.546Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"0x1-为什么要做crash防护\"><a class=\"anchor\" href=\"#0x1-为什么要做crash防护\">#</a> 0x1 为什么要做 Crash 防护</h1>\n<p>在产品开发过程中 Crash 率是一个很重要的指标，也是一个团队中几乎所有的部门都应该关注或者去参与提升的一个指标，他不仅代表着整个产品的质量，也是一个团队整体技术能力的体现。更低的 Crash 率不但能让产品获得更好的用户口碑，在整个流程中也能让团队成员获得更多的成长，加深对 iOS 系统底层的理解，为今后的开发带了更大的帮助。</p>\n<p><img data-src=\"https://image-1256056152.cos.ap-nanjing.myqcloud.com/1111111111.jpeg\" alt=\"\" /></p>\n<p><span id=\"more\"></span></p>\n<h1 id=\"0x2-为什么要写这篇文章\"><a class=\"anchor\" href=\"#0x2-为什么要写这篇文章\">#</a> 0x2 为什么要写这篇文章</h1>\n<p>起因也是因为自己的项目踩了 FB 的 SDK 的坑：2020.7.10，FB 后台下发数据错误，导致大量使用 FB SDK 的 App 发生启动 Crash，影响用户之多，范围之大，再加上当时包括我们的大部分 App 也缺乏相关的防护或者是容错处理，Crash 率瞬间飙升，重新发版又要走发布流程，只能依赖 FB 后台的修复，当时束手无策十分被动，所以决定自己做一套较为完整的 Crash 防护体系，来避免这样的场景再次发生。第二个目的就是，发生问题后我也第一之间查阅了网上的一些资料和其他团队的做法，发现大家的方式各有千秋，方法不同，效果不同，所以我也决定把市面上能找到的好的思路和方法再结合自己的一些想法和经验记录下来。最后也是因为知识是要沉淀、积累和分享的，也算是巩固和加深自己的理解吧。</p>\n<h1 id=\"0x3-怎么做\"><a class=\"anchor\" href=\"#0x3-怎么做\">#</a> 0x3 怎么做</h1>\n<p>其实当时 Crash 的场景很简单，本来一个 Dictionary 参数 FB 后台却下发了个 String 类型的数据，这样一来解析时候必然会 Crash，解决的话其实只要做一层参数安全校验即可。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq58dki0g7j31ai0u01fd.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq58c923pfj31020t8k5g.jpg\" alt=\"\" /></p>\n<p>但是这么简单的问题，大部分 App 都没处理好，证明在流程上一定有大家注意不到的地方，暴露出来的只是冰山一角，我们机制一定存在着某种问题，或者存在可以优化的地方。</p>\n<p>要想避免这种情况，就要先梳理出处理 Crash 的流程：</p>\n<h2 id=\"icrash处理流程\"><a class=\"anchor\" href=\"#icrash处理流程\">#</a> I：Crash 处理流程</h2>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6lcsxy6jj31bw0u0n1w.jpg\" alt=\"\" /></p>\n<p>在 iOS 系统中基本可以总结出这四个步骤，</p>\n<ul>\n<li>\n<p>Crash 防护 - 通过 Hook 等手段，对一些类似容器类进行入参校验等措施，来进来避免 Crash 的发生</p>\n</li>\n<li>\n<p>Crash 拦截 - 如果第一步防护失败，那么在 Crash 走到这一步就要进行拦截，要让我们发现异常</p>\n</li>\n<li>\n<p>Crash 上报 - 对防护的、捕获的 Crash 进行防护，生成有效的日志进行上报，尽可能的还原堆栈。</p>\n</li>\n<li>\n<p>Crash 后续流程 - Crash 发生后如何做才能最大限度的保护用户体验，如何优雅的 Crash</p>\n</li>\n</ul>\n<h2 id=\"iicrash防护\"><a class=\"anchor\" href=\"#iicrash防护\">#</a> II：Crash 防护</h2>\n<p>Crash 防护方式主要分两种：针对非内存问题通常采用 AOP 方式，内存问题采用 zombie 对象的方式，</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6lrlbl0vj30qi07mdg5.jpg\" alt=\"\" /><br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6ls764zyj30qm06cjrq.jpg\" alt=\"\" /></p>\n<h3 id=\"aopbr\"><a class=\"anchor\" href=\"#aopbr\">#</a> AOP：&lt;br&gt;</h3>\n<p>iOS 中 AOP 的相关知识网上线程的代码也很多，这里就不在赘述，但是在 AOP 这种频繁调用的场景中就需要注意的地方和坑点比较多。</p>\n<ul>\n<li>\n<p>AOP 的影响范围问题：当时用了普通的方式对数组相关的方法进行了 Hook，结果上线后发现大量的类似 Crash。 <code>[UIKeyboardLayoutStar release]: message sent to deallocated instance UIKeyboardLayoutStar</code></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6m6njbm8j30o40d0q8q.jpg\" alt=\"\" /><br />\n在通过一些其他场景可以判断出是因为 HookNSMutableArr 的相关方法，导致系统类的调用受到了影响。</p>\n<p>通过 Xcode 调试发现，因为 Hook 的本质就是在原有的系统调用前插入一个用户自定义的函数进行方法交换，那么在某种极端情况下（比如多线程），传入该函数的变量被释放，这样一来再走到原本系统调用的时候正常释放时就会出现重复释放的情况。大概的流程为</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6mhmeprhj31hm0fu75v.jpg\" alt=\"\" /></p>\n<p>该场景在测试过程中很难复现，但是一旦到了线上，用户量覆盖够大后该问题就会显现出来。解决方式很简单，Hook 尽量在 MRC 下进行，使用 autorelease pool 进行包装。保证内部变量在当前的 runloop 结束时候进行释放。</p>\n</li>\n<li>\n<p>AOP 的性能问题：上面说了 AOP 的原理是会多一层方法调用，那么再结合 iOS 的方法转发流程可想而知，AOP 必定会造成性能的损耗，而且在 Crash 防护场景下频繁调用，性能问题一定不能忽略。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6mswloauj310o0u0jx8.jpg\" alt=\"\" /></p>\n<p>通过上图看出，方法调用流程最终会返回出对应的 IMP 指针供外部调用，作为动态语言，OC 无法确定开发者会再什么时候插入或者交换哪个函数，所以必须通过这一套流程进行类似校验的逻辑。</p>\n<p>使用过 AOP 的同学一定知道在 AOP 前会先做一层校验</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+(void)hookClass:(Class)classObject isClassMetohd:(BOOL)classMethod fromSelector:(SEL)fromSelector toSelector:(SEL)toSelector </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Class <span class=\"keyword\">class</span> = classObject;</span><br><span class=\"line\">    Method fromMethod = <span class=\"keyword\">class</span><span class=\"constructor\">_getInstanceMethod(<span class=\"params\">class</span>, <span class=\"params\">fromSelector</span>)</span>;</span><br><span class=\"line\">    Method toMethod = <span class=\"keyword\">class</span><span class=\"constructor\">_getInstanceMethod(<span class=\"params\">class</span>, <span class=\"params\">toSelector</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">//  添加前进行检测</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (classMethod) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">class</span> = <span class=\"keyword\">object</span><span class=\"constructor\">_getClass(<span class=\"params\">classObject</span>)</span>;</span><br><span class=\"line\">        fromMethod = <span class=\"keyword\">class</span><span class=\"constructor\">_getClassMethod(<span class=\"params\">class</span>, <span class=\"params\">fromSelector</span>)</span>;</span><br><span class=\"line\">        toMethod = <span class=\"keyword\">class</span><span class=\"constructor\">_getClassMethod(<span class=\"params\">class</span>, <span class=\"params\">toSelector</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">class</span><span class=\"constructor\">_addMethod(<span class=\"params\">class</span>, <span class=\"params\">fromSelector</span>, <span class=\"params\">method_getImplementation</span>(<span class=\"params\">toMethod</span>)</span>, <span class=\"keyword\">method</span><span class=\"constructor\">_getTypeEncoding(<span class=\"params\">toMethod</span>)</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">class</span><span class=\"constructor\">_replaceMethod(<span class=\"params\">class</span>, <span class=\"params\">toSelector</span>, <span class=\"params\">method_getImplementation</span>(<span class=\"params\">fromMethod</span>)</span>, <span class=\"keyword\">method</span><span class=\"constructor\">_getTypeEncoding(<span class=\"params\">fromMethod</span>)</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">method</span><span class=\"constructor\">_exchangeImplementations(<span class=\"params\">fromMethod</span>, <span class=\"params\">toMethod</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 所以在方法我们在上面代码中的 toSelector 中 当我们需要调用回原方法时直接调用对应的函数指针即可</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6rm11f7dj30nm05a74e.jpg\" alt=\"\" /></p>\n<p>最终我对直接调用 IMP 的方法做了测试，分别是 Demo 中和 App 中的某一个场景，测试数据如下，对比结果还是较为明显。这也就是为什么 Swift 或者一些其他静态语言比 OC 快的原因。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6rw5k68mj313c0r6n13.jpg\" alt=\"\" /></p>\n</li>\n</ul>\n<h3 id=\"zombiebr\"><a class=\"anchor\" href=\"#zombiebr\">#</a> Zombie：&lt;br&gt;</h3>\n<p>使用僵尸对象来解决内存问题一直是苹果主推的方式，Xcode 也有相关设置，在 Debug 下打开相应开关，但是一旦把该功能放到线上做防护或监控就要考虑很多的问题。</p>\n<ul>\n<li>\n<p>zombie 入口问题：换句话说就是在哪个地方生成 zombie 对象，看了一些相关的 SDK 都是采用 Dealloc 作为入口函数，不是不行，只是不是最优。原因有两点:</p>\n<ul>\n<li>\n<p>1: 苹果已经不建议在 ARC 下主动调用 dealloc，目前只能采用 performSelector 或者其他动态调用的方式。</p>\n</li>\n<li>\n<p>2: 容易漏掉  <code>Objc_destructInstance</code> ，所有的成员变量、属性都会在这个函数中释放，如果漏掉这个函数就会生成一个并不干净的僵尸对象，内存占用过高，白白浪费内存空间。</p>\n</li>\n</ul>\n<p>综上两点我最终选择在 Free 函数中生成僵尸对象</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6sr4ebj5j30vx0u0dhq.jpg\" alt=\"\" /></p>\n</li>\n<li>\n<p>zombie 内存阈值问题：僵尸对象会占用内存空间，然而在线上环境操作内存一定要小心且一定要有一套完整的逻辑，当超过某一个内存阈值后需要及时清空僵尸对象。内存阈值的确定便成了关键，这里会遇到两个问题：</p>\n<ul>\n<li>\n<p>&lt;font color='red'&gt; 1：内存问题一定会和机型强相关，如何根据不同的机型调整不同的阈值？ &lt;/font&gt;</p>\n</li>\n<li>\n<p>&lt;font color='red'&gt; 2：如何做到根据线上情况灵活动态调整？&lt;/font&gt;</p>\n</li>\n</ul>\n<p>我们的底线是在加入 zombie 后不能触发 memorywarning，所以我先对大部分机型做了 memorywarning 阈值测试：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6t2xweqcj312g0sg0xq.jpg\" alt=\"\" /></p>\n<p>从上图可以看出当 App 占用内存达到总内存的 57%~69% 时候会触发内存警告，而且由于 iphone 中有一部分内存是系统保留内存并不会给到开发者，所以我们可用的也就 50% 左右，我总结出如下公式：</p>\n<p>公式 1：不能触发内存警告  <code>Y = 0.5 * deviceMem – currentAppMem</code></p>\n<p>公式 2: 僵尸对象的内存占用再大也不会超过 App 本身的内存  <code>Y = min ( ( 0.5 * deviceMem – currentAppMem ) , currentAppMem)</code></p>\n<p>上面两个公式看似完美，但是还是有优化的地方，因为并不是 APP 中所有的变量都有可能成为僵尸对象，可能只是其中的某一部分需要被监控，所以得到最终的内存阈值计算公式：</p>\n<p>&lt;font color=red size=5 face=&quot;黑体&quot;&gt;Y = min ( ( 0.5 * deviceMem – currentAppMem ) , currentAppMem / N )&lt;/font&gt;</p>\n<p>因为 app 占用内存随时在变，所以可以加一个定时器每隔一定时间去更新该值。</p>\n<p>上面公式的 N 还有一个好处就是我们可以后台动态下发，根据线上内存引起 Crash 量，如果 Crash 量大，那可能就需要更大的内存阈值去保存僵尸对象，就可以把 N 调小，反正调大，这样就可以无视机型的差异根据 Crash 的情况进行远程配置。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6tozx4odj316l0u079c.jpg\" alt=\"\" /></p>\n<p>通过如图的线上数据可以看出 随着 N 的减小，zombie 的内存阈值在增加，但是并不会超过内存警告阈值，确保了内存健康。</p>\n<p>下图表示了不同的 N 值对应不同的捕获野指针问题的数量，各自 App 可以根据自己的业务情况进行调整。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6tse6e79j31zo0kkk0x.jpg\" alt=\"\" /></p>\n</li>\n<li>\n<p>zombie 更新策略问题：目前大家的做法都是在加入新的 zombie 对象时候检查是否超过阈值，达到阈值后删掉之前的 zombie 对象再加入新的对象，这样的清理逻辑是依赖于新 zombie 对象的加入，如果没有新对象的加入那么缓存空间也不会有变化，zombie 空间一旦生成就无法删掉，无法做到缓存的自清理，等于 App 无故增大了内存占用。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6u18gh6cj30wa0saad2.jpg\" alt=\"\" /></p>\n<p>同样借鉴 LRU 最近最久未使用的逻辑，每隔 30s 会检测下缓存情况，超过 30s 还未被使用的 zombie 对象将被删除，30s 是一个经验值，通过大量测试发现，内存问题一般会发生在对象被销毁的 30s 内，超过 30s 再出现的概率及小。这样可以做到缓存自清理的逻辑。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6u92wzy3j30n00si41c.jpg\" alt=\"\" /></p>\n<p>通过 Instrument 测试发现该 zombie 逻辑并不会对 App 本身的内存造成太大的影响。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6ucxjfn5j31c60u078q.jpg\" alt=\"\" /></p>\n</li>\n</ul>\n<p>\n\t\t\t<script>\n\t\t\t\tconsole.error(\"Error: [hexo-tag-aplayer] Specified asset file not found ( https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E5%B0%B9%E6%98%94%E7%9C%A0%20-%20%E5%A5%94%E8%B5%B4%E6%98%9F%E7%A9%BA.mp3)\");\n\t\t\t</script></p>\n",
            "tags": [
                "iOS",
                "Crash防护"
            ]
        },
        {
            "id": "https://oliverqueen.cn/How-to-create-a-Swift-Command-Line-tool/",
            "url": "https://oliverqueen.cn/How-to-create-a-Swift-Command-Line-tool/",
            "title": "How to create Swift CLI",
            "date_published": "2023-03-28T09:42:10.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"为什么要做cli\"><a class=\"anchor\" href=\"#为什么要做cli\">#</a> 为什么要做 CLI</h2>\n<p>命令行工具<strong> CLI (command-line interface)</strong> 是开发者必不可少的工具之一，编写命令行工具来处理一些工作上的事情也是开发者必备的技能。对于一些重复性的工作，使用命令行脚本可以将任务自动化，这将极大的提升我们的工作效率。同时也能避免因为人为的因素导致错误。比如批量处理一些文件、表格等，在 APP 开发中<strong>持续集成</strong>的概念也是建立在一些列的自动化命令行脚本的基础之上。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/111.png\" alt=\"\" /></p>\n<h2 id=\"为什么使用swift\"><a class=\"anchor\" href=\"#为什么使用swift\">#</a> 为什么使用 Swift</h2>\n<p>命令行的开发语言有很多，比如最基本的 <code>shell脚本</code> ，还有常见的 <code>Python</code> 、 <code>Go</code> 、 <code>Ruby</code>  等。而 iOS 开发者工作中最常用也是最熟悉的就是 Objective-c 和 Swift 语言，所以这会带来几个个问题。</p>\n<ul>\n<li>App 开发者编写脚本语言需要一定的学习成本。</li>\n<li>App 开发者编写脚本时候需要频繁的进行语言切换。</li>\n<li>Swift 作为苹果主推的语言，iOS 相关的脚本都已经使用 Swift 开发，比如一些 <code>重签</code> 、 <code>动态库注入</code> 脚本等。Swift 开发的命令行程序不但能像正常的脚本语言一样完成各种批处理任务，而且对 iOS 的项目有天然的优势。</li>\n</ul>\n<p>虽然 <code>Objective-c</code>  编写的代码也可以通过 <code>clang XXXXXX.m -framework Foundation -o XXXXX</code>  来编译成可执行文件来使用，但是毕竟 Objective-c 一开始设计的初衷并不包含命令行程序，所以一些功能上还在存在不少缺陷，比如参数的传入与处理。而 Swift 在官方一推出的时候就宣传了 Swift 可以开发 App 、脚本、后台服务、前端等，应用广泛。</p>\n<h2 id=\"swift-cli基本流程\"><a class=\"anchor\" href=\"#swift-cli基本流程\">#</a> Swift CLI 基本流程</h2>\n<h3 id=\"1工程创建\"><a class=\"anchor\" href=\"#1工程创建\">#</a> 1：工程创建</h3>\n<p>使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc3dpZnQub3JnL3BhY2thZ2UtbWFuYWdlci8=\"> Swift Package Manager（SPM）</span>来创建工程，SPM 是苹果官方提供的一个用于管理源代码分发的工具，类似于 Cocoapods 或者 Carthage，但是更轻量化，并且 Xcode 原生支持，无需配置各种环境，可以直接使用。</p>\n<p><figure class=\"highlight shell\"><figcaption><span>工程创建</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">cd</span> CLIDemo  // 进入到你的文件夹</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">swift package init --<span class=\"built_in\">type</span> executable</span></span><br></pre></td></tr></table></figure></p>\n<p>执行完命令后会生成所需要的文件</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304011746092.png\" alt=\"\" /></p>\n<p>其中</p>\n<ul>\n<li>\n<p>Package.swift ：类似 Cocoapods 中的 Podfile 文件，里面描述了一些库的引用依赖关系，和工程配置。</p>\n</li>\n<li>\n<p>Source/CLIDemo 文件夹：我们的工程目录，后续我们新加源代码或者文件都放到该目录下。</p>\n</li>\n<li>\n<p>CLIDemo.swift：命令行程序入口，不可更改文件名字，里面包含 main 函数。</p>\n<p><figure class=\"highlight swift\"><figcaption><span>入口main函数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@main</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">CLIDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">private(set)</span> <span class=\"keyword\">var</span> text <span class=\"operator\">=</span> <span class=\"string\">&quot;Hello, World!&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">func</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"type\">CLIDemo</span>().text)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>Tests 文件夹：测试工程，与正常的 Xcode 工程类似。</p>\n</li>\n</ul>\n<h3 id=\"2使用xcode开发\"><a class=\"anchor\" href=\"#2使用xcode开发\">#</a> 2：使用 Xcode 开发</h3>\n<p>工程文件结构创建好之后目前还缺少 <code>XXX.xcodeproj</code>  文件，没办法用 Xcode 直接打开，使用如下命令创建 Xcode 入口</p>\n<p><figure class=\"highlight shell\"><figcaption><span>Xcode入口创建</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">swift package generate-xcodeproj</span></span><br></pre></td></tr></table></figure></p>\n<p>然后打开生成的 <code>CLIDemo.xcodeproj</code>  文件，将运行设备选择为 Mac，然后编译运行后就可以在 Xcode 的控制台看到输出的 Hello World 文案，截止到此，我们的整个命令行开发工程就已经搭建完成。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304011801713.png\" alt=\"\" /></p>\n<p>同样除了使用 Xcode GUI 的当时编译运行之外也可以使用命令行方式进行</p>\n<p><figure class=\"highlight shell\"><figcaption><span>编译运行</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">swift run CLIDemo</span></span><br></pre></td></tr></table></figure></p>\n<p>然后得到相同的输出</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304011813359.png\" alt=\"\" /></p>\n<h3 id=\"3参数传递与处理\"><a class=\"anchor\" href=\"#3参数传递与处理\">#</a> 3：参数传递与处理</h3>\n<h4 id=\"方式1系统api解析参数\"><a class=\"anchor\" href=\"#方式1系统api解析参数\">#</a> 方式 1：系统 API 解析参数</h4>\n<p>上面讲述工程创建和命令行编写，通常我们在调用命令行的时候会带有参数</p>\n<p><figure class=\"highlight shell\"><figcaption><span>命令参数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">command</span> 参数1 参数2 参数3 ....</span></span><br></pre></td></tr></table></figure></p>\n<p>同样在代码层面也有解析参数的 API</p>\n<p><figure class=\"highlight swift\"><figcaption><span>CommandLine</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Command-line arguments for the current process.</span></span><br><span class=\"line\"><span class=\"keyword\">@frozen</span> <span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">CommandLine</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Access to the raw argc value from C.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> argc: <span class=\"type\">Int32</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Access to the raw argv value from C. Accessing the argument vector</span></span><br><span class=\"line\">    <span class=\"comment\">/// through this pointer is unsafe.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> unsafeArgv: <span class=\"type\">UnsafeMutablePointer</span>&lt;<span class=\"type\">UnsafeMutablePointer</span>&lt;<span class=\"type\">Int8</span>&gt;?&gt; &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> arguments: [<span class=\"type\">String</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用方式比较简单</p>\n<p><figure class=\"highlight swift\"><figcaption><span>解析参数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 解析外部传进来的参数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arguments <span class=\"operator\">=</span> <span class=\"type\">CommandLine</span>.arguments</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第一个参数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> firstArg <span class=\"operator\">=</span> arguments[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二个参数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> secondtArg <span class=\"operator\">=</span> arguments[<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;My args = <span class=\"subst\">\\(arguments)</span>  first = <span class=\"subst\">\\(firstArg)</span>  second = <span class=\"subst\">\\(secondtArg)</span>&quot;</span>);</span><br></pre></td></tr></table></figure></p>\n<p>需要注意这里返回的参数数组中第一个元素是可执行文件本身路径，然后用户真正的输入的第一个参数是从第二个元素开始，类似与 iOS 中 <code>objcMsgSend</code>  函数，其中第一个参数是 self。然后可以通过解析这些参数来达到不同的目的</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304031744585.png\" alt=\"\" /></p>\n<h4 id=\"方式2使用swiftargumentparser\"><a class=\"anchor\" href=\"#方式2使用swiftargumentparser\">#</a> 方式 2：使用 SwiftArgumentParser</h4>\n<p>在实际使用中，一个完善的命令行参数一定不会这么简单，而且我们在解析参数的时候也不知道使用方传入参数的顺序，一些简单的命令，或者只有一个参数的情况下可以使用 CommandLine 的 API，更复杂的情况下需要时用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zd2lmdHBhY2thZ2VpbmRleC5jb20vYXBwbGUvc3dpZnQtYXJndW1lbnQtcGFyc2VyLzEuMi4yL2RvY3VtZW50YXRpb24vYXJndW1lbnRwYXJzZXIvZ2V0dGluZ3N0YXJ0ZWQ=\"> SwiftArgumentParser</span> 来进行处理。</p>\n<p><code>SwiftArgumentParser</code>  是苹果开源的一个用 Swift 编写的参数解析器，用于解析命令行参数（command-line arguments），具有直观、易用、简洁、安全的特点。虽然是苹果自己开发的，但是毕竟还是外部库需要使用 <code>Swift package</code>  打包进来，对 <code>Package</code>  文件进行编写</p>\n<p><figure class=\"highlight swift\"><figcaption><span>Package.swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> PackageDescription</span><br><span class=\"line\"><span class=\"keyword\">let</span> package <span class=\"operator\">=</span> <span class=\"type\">Package</span>(</span><br><span class=\"line\">    name: <span class=\"string\">&quot;CLIDemo&quot;</span>,</span><br><span class=\"line\">    dependencies: [</span><br><span class=\"line\">        <span class=\"comment\">//引入swift-argument-parser解析器</span></span><br><span class=\"line\">        .package(url: <span class=\"string\">&quot;https://github.com/apple/swift-argument-parser&quot;</span>, from: <span class=\"string\">&quot;1.2.0&quot;</span>),</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    targets: [</span><br><span class=\"line\">        .executableTarget(</span><br><span class=\"line\">            name: <span class=\"string\">&quot;CLIDemo&quot;</span>,</span><br><span class=\"line\">            dependencies: [</span><br><span class=\"line\">                <span class=\"comment\">//将解析器依赖到target</span></span><br><span class=\"line\">                .product(name: <span class=\"string\">&quot;ArgumentParser&quot;</span>, package: <span class=\"string\">&quot;swift-argument-parser&quot;</span>),</span><br><span class=\"line\">            ]),</span><br><span class=\"line\">        .testTarget(</span><br><span class=\"line\">            name: <span class=\"string\">&quot;CLIDemoTests&quot;</span>,</span><br><span class=\"line\">            dependencies: [<span class=\"string\">&quot;CLIDemo&quot;</span>]),</span><br><span class=\"line\">    ]</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>同时 <code>CLIDemo.swift</code>  代码文件也要相应的进行修改</p>\n<ul>\n<li>1：引入<strong> ArgumentParser</strong></li>\n<li>2：将 struct 改为 Class（方便后续的开发），并遵循 <code>ParsableCommand</code>  协议</li>\n<li>3：修改 main 函数为 run：因为遵循协议后，原来的 main 被 <code>ParsableCommand</code>  接管入口，内部会调用函数名为 <code>run</code>  的函数作为入口。</li>\n</ul>\n<p><figure class=\"highlight swift\"><figcaption><span>CLIDemo.swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ArgumentParser</span><br><span class=\"line\"><span class=\"keyword\">@main</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CLIDemo</span>: <span class=\"title class_\">ParsableCommand</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">required</span> <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">run</span>() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 解析外部传进来的参数</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> arguments <span class=\"operator\">=</span> <span class=\"type\">CommandLine</span>.arguments</span><br><span class=\"line\">        <span class=\"comment\">// 第一个参数</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> firstArg <span class=\"operator\">=</span> arguments[<span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"comment\">// 第二个参数</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> secondtArg <span class=\"operator\">=</span> arguments[<span class=\"number\">2</span>]</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;My args = <span class=\"subst\">\\(arguments)</span>  first = <span class=\"subst\">\\(firstArg)</span>  second = <span class=\"subst\">\\(secondtArg)</span>&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>工程修改完后已经具备了 <code>ArgumentParser</code>  的开发环境，ArgumentParser 的参数分为三类</p>\n<ul>\n<li>@Argument：无标记位参数，与上面介绍的直接使用 CommandLine 的 API 解析方式相似，该类型的参数没有别名标记位，而且必须按照用户传入的顺序做解析。</li>\n<li>@Option：带有标记位参数，这个类型的参数就是通过别名或者标记为来标识的，也是我们常见的参数用法比如  <code>-n myName</code>  或者 <code>--name myName</code> 。其中 <code>-n</code>  和 <code>--name</code>  就是该参数的长别名和短别名，同样因为有了别名，所以解析时候不用关系用户输入参数的顺序。</li>\n<li>@Flag：标记位，是一个 bool 变量，比如常用  <code>--verbose</code> ， <code>-h</code>  等</li>\n</ul>\n<p><figure class=\"highlight swift\"><figcaption><span>参数解析</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">var</span> configuration <span class=\"operator\">=</span> <span class=\"type\">CommandConfiguration</span>(abstract: <span class=\"string\">&quot;这是一个测试Demo&quot;</span>)</span><br><span class=\"line\"><span class=\"meta\">@Argument</span>(help: <span class=\"string\">&quot;这是一个Argument 参数&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> argumentArg: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Argument&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Option</span>(name: [.short, .long], help: <span class=\"string\">&quot;这是一个option参数&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> optionArg: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;option&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Flag</span>(name: [.short, .long], help: <span class=\"string\">&quot;这是一个Flag参数&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> flagArg: <span class=\"type\">Bool</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure></p>\n<p>关于参数的描述系统提供以下定义，通常使用 <code>short</code>  和 <code>long</code></p>\n<p><figure class=\"highlight swift\"><figcaption><span>参数定义</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">Representation</span>: <span class=\"title class_\">Hashable</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> long <span class=\"comment\">// 参数原标记位，就是变量名</span></span><br><span class=\"line\">  <span class=\"keyword\">case</span> customLong(<span class=\"keyword\">_</span> name: <span class=\"type\">String</span>, withSingleDash: <span class=\"type\">Bool</span>)  <span class=\"comment\">// 自定义标记位</span></span><br><span class=\"line\">  <span class=\"keyword\">case</span> short <span class=\"comment\">// 参数短标记位  为-加上变量名第一个字母</span></span><br><span class=\"line\">  <span class=\"keyword\">case</span> customShort(<span class=\"keyword\">_</span> char: <span class=\"type\">Character</span>, allowingJoined: <span class=\"type\">Bool</span>) <span class=\"comment\">// 自定义短标记位</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>ArgumentParser</code>  默认集成了 <code>-h</code>  参数，完成以上参数定义后，通过 <code>-h</code>  输出我们命令行 Demo 帮助文档</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304032145234.png\" alt=\"\" /></p>\n<div class=\"note warning\">\n<p>注意：参数命名时候如果使用驼峰结构，最终的参数会被添加 <code>-</code>  比如上面的我定义的 <code>flagArg</code> ，最终命令行的 Flag 参数为 <code>--flag-arg</code> 。所以这里尽量不用驼峰结构。</p>\n</div>\n<h3 id=\"4调试运行\"><a class=\"anchor\" href=\"#4调试运行\">#</a> 4：调试运行</h3>\n<p>因为我们是在 Xcode 中编程开发，所以不用每次都跑到命令行中取执行 <code>Swift run CLIDemo XXX</code>  来编译运行我们的工具，这样不然切来切去影响工作效率，而且没法使用断点调试，正确的方式是像正常的 iOS 开发一样直接在 Xcode 中编译运行。而参数传递可以在 Xcode 上方的 <code>Edit Scheme</code>  中处理</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304032152232.png\" alt=\"\" /></p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304032153290.png\" alt=\"\" /></p>\n<p>然后编译运行即可，以上行为等价于在终端中输入 <code>swift run CLIDemo arg1 -f -o option</code></p>\n<h3 id=\"5编译成可执行文件\"><a class=\"anchor\" href=\"#5编译成可执行文件\">#</a> 5：编译成可执行文件</h3>\n<p>我们假设已经完成了命令行程序的编写，最终要达到的目是执行我们的命令行程序然后输出 Hello World!，那么首先我们需要把代码编译成可执行文件，通过如下命令</p>\n<p><figure class=\"highlight shell\"><figcaption><span>编译成可执行文件</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp; swift build -c release</span><br></pre></td></tr></table></figure></p>\n<p>编译之后我们可以在工程目录下找到我们产物</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304011810603.png\" alt=\"\" /></p>\n<p>这样一来我们就可以把该文件进行分发，让其他人或者服务器端使用我们的的命令行工具了，如果有需要可以把该文件放到 /usr/local/bin/ 目录下，这样可以在任意路径下使用</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304011817712.png\" alt=\"\" /></p>\n<h2 id=\"swift-cli实战ipa下载器\"><a class=\"anchor\" href=\"#swift-cli实战ipa下载器\">#</a> Swift CLI 实战 (iPa 下载器)</h2>\n<p>上面讲了一个 Swift CLI 工具从开发到使用的完整流程，但是一个真正的命令行工具一定不仅仅是输出一个 Hello World，需要有 <code>子命令</code> 、 <code>公共参数</code> 、 <code>二次输入</code> ， <code>敏感输入</code> ， <code>终端输出样式</code> ， <code>进度回调</code> 等功能。本节内容会通过实现一个 ipa 下载器，来介绍下 Swift CLI 的一些进阶用法，这些用法几乎能覆盖之后百分之九十的工作场景。</p>\n<p>一个 iPa 下载器可以从 Appstore 下载 App，同时集成了 Appstore 相关能力，如 <code>登录</code> ， <code>搜索</code> ， <code>下载</code> 等。我们可以将这些能力封装成不同的子命令来进行调用，像如下这样</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304062017381.png\" alt=\"\" /></p>\n<h3 id=\"1子命令\"><a class=\"anchor\" href=\"#1子命令\">#</a> 1：子命令</h3>\n<p>子命令也是 <code>ArgumentParser</code>  的能力项之一，可以在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zd2lmdHBhY2thZ2VpbmRleC5jb20vYXBwbGUvc3dpZnQtYXJndW1lbnQtcGFyc2VyLzEuMi4yL2RvY3VtZW50YXRpb24vYXJndW1lbnRwYXJzZXIvY29tbWFuZHNhbmRzdWJjb21tYW5kcw==\">这里</span>查看官方文档，具体代码</p>\n<p><figure class=\"highlight swift\"><figcaption><span>子命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">var</span> configuration <span class=\"operator\">=</span> <span class=\"type\">CommandConfiguration</span>(abstract: <span class=\"string\">&quot;一个iPa下载工具&quot;</span>, subcommands: [<span class=\"type\">Search</span>.<span class=\"keyword\">self</span>, <span class=\"type\">Login</span>.<span class=\"keyword\">self</span>, <span class=\"type\">Download</span>.<span class=\"keyword\">self</span>])</span><br></pre></td></tr></table></figure></p>\n<p>其中要创建子命令对应的 <code>.swift</code>  文件。且每个文件中都应像之前的 CLIDemo.swift 的结构一样，定义自己的类，且遵循 <code>ParsableCommand</code>  协议，以 Search 举例，其他 <code>同级</code> 子命令同理，子命令 <code>嵌套</code> 子命令，结构类似，以此类推。</p>\n<p><figure class=\"highlight swift\"><figcaption><span>子命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Search</span>: <span class=\"title class_\">ParsableCommand</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">required</span> <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> configuration <span class=\"operator\">=</span> <span class=\"type\">CommandConfiguration</span>(abstract: <span class=\"string\">&quot;搜索appstore上的App&quot;</span>)</span><br><span class=\"line\">   <span class=\"keyword\">func</span> <span class=\"title function_\">run</span>() &#123;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2公共参数\"><a class=\"anchor\" href=\"#2公共参数\">#</a> 2：公共参数</h3>\n<p>当有多个子命令的时候我们一定会有一些参数是公用的，比如上面展示的 <code>--verbose</code> ，如果每个子命令文件都写一遍显然不现实，所以 <code>ArgumentParser</code>  提供了<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zd2lmdHBhY2thZ2VpbmRleC5jb20vYXBwbGUvc3dpZnQtYXJndW1lbnQtcGFyc2VyLzEuMi4yL2RvY3VtZW50YXRpb24vYXJndW1lbnRwYXJzZXIvb3B0aW9uZ3JvdXA=\"> OptionGroup 选项组</span>的能力。</p>\n<p>我们可以在一个公共的类或结构体中定义一系列公用参数，然后在需要使用公共参数的子命令文件中定义 <code>@OptionGroup</code>  如下图。在解析的时候可以用 <code>GlobalOptions.verbose</code>  来取值</p>\n<p><figure class=\"highlight swift\"><figcaption><span>参数组</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">GlobalOptions</span>: <span class=\"title class_\">ParsableArguments</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Flag</span>(name: .shortAndLong)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> verbose: <span class=\"type\">Bool</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Argument</span> <span class=\"keyword\">var</span> values: [<span class=\"type\">Int</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Search</span>: <span class=\"title class_\">ParsableArguments</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Option</span> <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"meta\">@OptionGroup</span> <span class=\"keyword\">var</span> globals: <span class=\"type\">GlobalOptions</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3appstore登录\"><a class=\"anchor\" href=\"#3appstore登录\">#</a> 3：Appstore 登录</h3>\n<p>首先登录需要输入用户名密码，所以 Login 文件的参数一定是包含 username，password，使用上面提到的方式很容易将这两个参数传入，但是输入密码的时候如果是明文的话就太不安全了，终端输入密码的方式都是 <code>隐式输入</code> ，同样我们的工具也要具备这个能力，使用 <code>getpass</code>  函数可以达到隐式输入图的目的，这样打字就不会显示到终端中，也不用为密码单独分配一个参数。</p>\n<p><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CommonMethod().showCommonMessage(text: <span class=\"string\">&quot;请输入密码：&quot;</span>)</span><br><span class=\"line\">  guard let psd = getpass(<span class=\"string\">&quot;&quot;</span>) <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"> \t CommonMethod().showErrorMessage(text: <span class=\"string\">&quot;需要输入密码&quot;</span>)</span><br><span class=\"line\">   Login.<span class=\"keyword\">exit</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304062055076.png\" alt=\"\" /></p>\n<ul>\n<li>登录 Api  <code>&quot;https://p25-buy.itunes.apple.com/WebObjects/MZFinance.woa/wa/authenticate?guid=MAC地址&quot;</code></li>\n</ul>\n<h3 id=\"4二次输入\"><a class=\"anchor\" href=\"#4二次输入\">#</a> 4：二次输入</h3>\n<p>拿到用户名和密码可以进行 Appstore API 请求进行登录了，但是 Appstore 是有二次认证的，所以我们还需要输入一个授权码。此时我们可以通过 Appstore 服务端返回的信息来提示用户输入授权码，需要授权码的错误信息为 <code>MZFinance.BadLogin.Configurator_message</code> ，此时我们的进程还未结束，需要用户 <code>二次输入</code> ，对应的 api 为 <code>readLine</code></p>\n<p><figure class=\"highlight swift\"><figcaption><span>二次输入</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">CommonMethod</span>().showWarningMessage(text: <span class=\"string\">&quot;请输入双重认证的Code：&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> authCode <span class=\"operator\">=</span> <span class=\"built_in\">readLine</span>();</span><br><span class=\"line\"><span class=\"keyword\">self</span>.authCode <span class=\"operator\">=</span> authCode <span class=\"operator\">??</span> <span class=\"string\">&quot;&quot;</span></span><br></pre></td></tr></table></figure></p>\n<p>收到用户的授权码后，携带授权码重新请求 Appstore API 接口即可，</p>\n<h3 id=\"5本地持久化\"><a class=\"anchor\" href=\"#5本地持久化\">#</a> 5：本地持久化</h3>\n<p>登录成功后会获得 <code>DSID Token</code>  以及相关 Cookie 信息，需要把这些信息持久化到本地，避免每次使用该工具都要走登录流程，持久化的方式可以使用数据库、UserDefault、写文件等方式进行，这些对于 iOS 开发人员来说并不陌生。</p>\n<h3 id=\"6文件搜索\"><a class=\"anchor\" href=\"#6文件搜索\">#</a> 6：文件搜索</h3>\n<p>文件搜索比较简单，我们可以通过 APP 的名字进行搜索，入参为：</p>\n<ul>\n<li>appname ：APP 名称</li>\n<li>appid：APP 在 applestore 上的 ID（非必要）</li>\n<li>limit：结果条数限制（非必要）</li>\n<li>Country：APP 所在国家（非必要）</li>\n</ul>\n<p>整个搜索流程为：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304081440040.png\" alt=\"\" /></p>\n<p>App 搜索的 API 为 <code>https://itunes.apple.com/search</code></p>\n<h3 id=\"7文件下载\"><a class=\"anchor\" href=\"#7文件下载\">#</a> 7：文件下载</h3>\n<p>通过上一步拿到的 bundleid 调用 AppStore 的下载接口可以实现 ipa 包的下载，所以这里的入参为：</p>\n<ul>\n<li>bundleid：App 的 bundleid</li>\n<li>path：下载路径</li>\n</ul>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304081526063.png\" alt=\"\" /></p>\n<p>拼接好请求后很容易就进入下载流程开始下载了。在 Swift 中可以使用系统原生的 NSUrlsession 或者使用一些开源三方空类似 Alamofire、moya 等。</p>\n<h3 id=\"8命令行输出样式\"><a class=\"anchor\" href=\"#8命令行输出样式\">#</a> 8：命令行输出样式</h3>\n<p>在执行下载任务或者一些耗时任务，我们需要提供进度条来给使用者一定的提示，终端中的进度条其实也是通过各种各样的字符编码组成的图案，同时通过不同的颜色来区分不同的状态</p>\n<ul>\n<li>\n<p>下载中</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304081506567.png\" alt=\"\" /></p>\n</li>\n<li>\n<p>下载完成</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304081508595.png\" alt=\"\" /></p>\n</li>\n<li>\n<p>下载失败</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304081518284.png\" alt=\"\" /></p>\n</li>\n</ul>\n<p>进度条图案是由两部分组成</p>\n<ul>\n<li>表示完成字符：█</li>\n<li>表示剩余字符：░</li>\n</ul>\n<h4 id=\"进度\"><a class=\"anchor\" href=\"#进度\">#</a> 进度</h4>\n<p>默认生成 50 个░，然后每次下载进度回调回来我们会根据百分比把已完成的部分用█替换，这样就展示了类似一个进度条在前进的样式。如果追求精细化，可以根据命令行窗口的宽度来动态调整进度条的长度，避免窗口过小，导致进度条会折行显示。</p>\n<p>同时为了保证进度条保持在一行，所以每次展示都要把光标移到开始位置然后在该行重新展示，这里使用 \\r 打头，同时去掉 print 函数末尾自带的 \\n 操作。这里封装一个显示进度的函数</p>\n<p><figure class=\"highlight swift\"><figcaption><span>进度条</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">showProcess</span>(<span class=\"params\">process</span>:<span class=\"type\">Float</span>, <span class=\"params\">customEnd</span>:<span class=\"type\">String</span>) -&gt; <span class=\"type\">Void</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//  宽度50</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> barW <span class=\"operator\">=</span> <span class=\"number\">50</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> com <span class=\"operator\">=</span> <span class=\"type\">Int</span>(<span class=\"type\">Float</span>(barW)<span class=\"operator\">*</span><span class=\"type\">Float</span>(process))</span><br><span class=\"line\">    <span class=\"keyword\">let</span> rem <span class=\"operator\">=</span> barW <span class=\"operator\">-</span> com</span><br><span class=\"line\">\t\t<span class=\"comment\">//  自定义结尾文案和颜色</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> endStr <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> color <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> customEnd.count <span class=\"operator\">&gt;</span> <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">      endStr <span class=\"operator\">=</span> customEnd</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  \t<span class=\"comment\">//  下载完成样式</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> com <span class=\"operator\">==</span> <span class=\"number\">50</span> &#123;</span><br><span class=\"line\">      endStr <span class=\"operator\">=</span> <span class=\"string\">&quot;下载完成：【100%】&quot;</span></span><br><span class=\"line\">      color <span class=\"operator\">=</span> <span class=\"string\">&quot;<span class=\"subst\">\\u&#123;001B&#125;</span>[0;32m&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t  <span class=\"comment\">// 进度条</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> bar <span class=\"operator\">=</span> <span class=\"type\">String</span>(repeating: <span class=\"string\">&quot;█&quot;</span>, count: com) <span class=\"operator\">+</span> <span class=\"type\">String</span>(repeating: <span class=\"string\">&quot;░&quot;</span>, count: rem)</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 打印进度条</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;<span class=\"subst\">\\r</span><span class=\"subst\">\\(color)</span><span class=\"subst\">\\(bar)</span> <span class=\"subst\">\\(endStr)</span>&quot;</span>, terminator: <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">  </span><br><span class=\"line\">  \t<span class=\"comment\">// 刷新输出缓冲区</span></span><br><span class=\"line\">    fflush(stdout)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"颜色\"><a class=\"anchor\" href=\"#颜色\">#</a> 颜色</h4>\n<p>在文本前添加相应的编码可以更改文本的样式，比如</p>\n<ul>\n<li>\n<p>文字颜色  <code>\\u&#123;001b&#125;[?m</code>    其中 <code> ? ∈ [30, 37]</code> 。</p>\n<p><figure class=\"highlight shell\"><figcaption><span>颜色</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">黑（black）：\\u&#123;001b&#125;[30m</span><br><span class=\"line\">红（red）：\\u&#123;001b&#125;[31m</span><br><span class=\"line\">绿（green）：\\u&#123;001b&#125;[32m</span><br><span class=\"line\">黄（yellow）：\\u&#123;001b&#125;[33m</span><br><span class=\"line\">蓝（blue）：\\u&#123;001b&#125;[34m</span><br><span class=\"line\">品红（magenta）：\\u&#123;001b&#125;[35m</span><br><span class=\"line\">蓝绿（cyan）：\\u&#123;001b&#125;[36m</span><br><span class=\"line\">白（white）：\\u&#123;001b&#125;[37m</span><br><span class=\"line\">还原初始（reset） ：\\u&#123;001b&#125;[0m</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>文字背景颜色 <code>\\u&#123;001b&#125;[?m</code> ，其中  <code>? ∈ [40, 47]</code> 。</p>\n<p><figure class=\"highlight shell\"><figcaption><span>背景</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">黑（black）：\\u&#123;001b&#125;[40m</span><br><span class=\"line\">红（red）：\\u&#123;001b&#125;[41m</span><br><span class=\"line\">绿（green）：\\u&#123;001b&#125;[42m</span><br><span class=\"line\">黄（yellow）：\\u&#123;001b&#125;[43m</span><br><span class=\"line\">蓝（blue）：\\u&#123;001b&#125;[44m</span><br><span class=\"line\">品红（magenta）：\\u&#123;001b&#125;[45m</span><br><span class=\"line\">蓝绿（cyan）：\\u&#123;001b&#125;[46m</span><br><span class=\"line\">白（white）：\\u&#123;001b&#125;[47m</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>字体样式</p>\n<p><figure class=\"highlight shell\"><figcaption><span>字体</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">加粗加亮：\\u&#123;001b&#125;[1m</span><br><span class=\"line\">降低亮度：\\u&#123;001b&#125;[2m</span><br><span class=\"line\">斜体：\\u&#123;001b&#125;[3m</span><br><span class=\"line\">下划线：\\u&#123;001b&#125;[4m</span><br><span class=\"line\">反色：\\u&#123;001b&#125;[7m</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<p>以上命令可以单独使用，也可以组合使用，如将以下条件组合在一起</p>\n<ul>\n<li>\\u {001b}[1m ：加粗加亮</li>\n<li>\\u {001b}[4m：下划线</li>\n<li>\\u {001b}[42m：绿色背景</li>\n<li>\\u {001b}[31m：红色字体</li>\n</ul>\n<p><figure class=\"highlight swift\"><figcaption><span>示例文字</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;<span class=\"subst\">\\n</span><span class=\"subst\">\\u&#123;001b&#125;</span>[1m<span class=\"subst\">\\u&#123;001b&#125;</span>[4m<span class=\"subst\">\\u&#123;001b&#125;</span>[42m<span class=\"subst\">\\u&#123;001b&#125;</span>[31m 这是一段绿色背景红色字体加粗带有下划线的文字&quot;</span>)</span><br></pre></td></tr></table></figure></p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202304081605787.png\" alt=\"\" /></p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>做完以上操作后一个 ipa 下载器就完成了，具体的源码可以查看<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL01vbGllclF1ZWVuL015SXBhTWFuYWdlcg==\">此处</span>。使用 Swift 编写 CLI 可以极大的提高 iOS 开发者的开发效率，降低脚本语言的学习成本，同时随时 Apple 对 Swift 的不断更新迭代，未来也许能用 swift 做更多的事情。</p>\n",
            "tags": []
        },
        {
            "id": "https://oliverqueen.cn/iPa%E9%80%86%E5%90%91%E4%B9%8B%E8%B7%AF/",
            "url": "https://oliverqueen.cn/iPa%E9%80%86%E5%90%91%E4%B9%8B%E8%B7%AF/",
            "title": "iPa逆向之路",
            "date_published": "2022-11-15T11:40:49.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景</h2>\n<p>逆向工程相对于正向的开发，可能关注的没有那么高，尤其是相比于安卓或者其他平台，苹果的安全机制更严格，逆向的流程也会更繁琐，除了有 ASLR（地址空间布局随机化），还有 FairPlay DRM 的 iPA 加密方式，也就是我们俗称的壳。这个给逆向工作带来了更多的挑战。但是 <code>更好更安全的加密方式也只是增加破解的成本，并不是绝对的安全</code> ，这也是逆向的前提。</p>\n<p>最近也正在做一些调研的工作，需要从技术层面去分析其他 App 的一些底层逻辑，要用到 iOS 的逆向相关的技术，但是由于笔者做这些工作的时候正处于 MacOS、iOS、Xcode 三个系统的大版本更新期间，一些系统的运行方式和逻辑发生变化，所以导致网上能找到的资料基本都失效了，所以写文档记录下。</p>\n<h2 id=\"前置工作\"><a class=\"anchor\" href=\"#前置工作\">#</a> 前置工作</h2>\n<h3 id=\"环境\"><a class=\"anchor\" href=\"#环境\">#</a> 环境</h3>\n<ul>\n<li>Mac 架构： Intel 架构</li>\n<li>MacOS： 13.0.1 (22A400)</li>\n<li>Xcode 版本：Version 14.1 (14B47b)</li>\n<li>iOS 系统版本：iOS 16.0</li>\n</ul>\n<h3 id=\"相关工具\"><a class=\"anchor\" href=\"#相关工具\">#</a> 相关工具</h3>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zb3VyY2Vmb3JnZS5uZXQvcHJvamVjdHMvbWFjaG92aWV3Lw==\">MachOView</span>\n<ul>\n<li>用来查看 Mach-o 的文件结构，以及各个部分的信息</li>\n</ul>\n</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3N0ZXZlbnlnYXJkLmNvbS9wcm9qZWN0cy9jbGFzcy1kdW1wLw==\">class-dump</span>\n<ul>\n<li>class-dump，顾名思义，就是用来 dump 目标对象 的 class 信息的工具。它利用 Objective-C 语言的 runtime 特性，将存储在 Mach-O 文件中的头文件信息提取出 来，并生成对应的.h 文件。</li>\n</ul>\n</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0Fsb25lTW9ua2V5L01vbmtleURldg==\">MonkeyDev</span>\n<ul>\n<li>非越狱开发插件，可以进行动态库注入，hook 相关操作</li>\n</ul>\n</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaG9wcGVyYXBwLmNvbS8=\">Hopper Disassembler</span>\n<ul>\n<li>Hopper Disassembler 是 Mac 上的一款二进制反汇编器，基本上满足了工作上的反汇编的需要，包括伪代码以及控制流图 (Control Flow Graph)，支持 ARM 指令集并针对 Objective-C 的做了优化。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"ipa下载\"><a class=\"anchor\" href=\"#ipa下载\">#</a> iPa 下载</h2>\n<p>iOS App 的逆向的所有操作都是基于 iPa 的操作，所以大前提是要有目标 iPa，这里提供三种方式来进行 iPa 下载，大家可以选择适合自己的方式下载。</p>\n<h3 id=\"方式1三方应用市场\"><a class=\"anchor\" href=\"#方式1三方应用市场\">#</a> 方式 1：三方应用市场</h3>\n<p>现在这样的应用市场比较多，多是平替 iTunes 的一些软件</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaTQuY24v\">爱思助手</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaXRvb2xzLmNuLw==\">iTools</span></li>\n</ul>\n<p>使用如上的三方软件可以很快的下载对应的 ipa 包，但是由于上述市场都是镜像自 AppStore 的内容，并且自己重签名，所以更新的及时性可能没有那么快，也没有那么全，而且因为是被第三方进行了修改重签，所以内容也不一定保证和官方的一致。如果不在乎这些的话还是可以采取这类的方式下载。</p>\n<h3 id=\"方式2apple-configuration\"><a class=\"anchor\" href=\"#方式2apple-configuration\">#</a> 方式 2：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdXBwb3J0LmFwcGxlLmNvbS9hcHBsZS1jb25maWd1cmF0b3I=\">Apple Configuration</span></h3>\n<p>可以直接从 Mac 上的 Apple Store 上下载，官方出品，原本是给手机上安装 app 的。用此方式其实是利用了该 App 的 App 下载机制来进行 ipa 导出的</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84np4us32j310y0io75z.jpg\" alt=\"image-20221114144926709\" /></p>\n<p>选择添加 App，然后在弹出的弹窗中选择 App 并且下载</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84nq4zkpwj30ys0na0vm.jpg\" alt=\"image-20221114145027227\" /></p>\n<p>这个时候如果你手机上没有安装该 App，则直接会安装成功，此时我们再点击安装下载，然后就会收到 <code>设备上已经存在相同的App，是否覆盖安装的提示</code> 的弹窗，此时我们 &lt;font color='red'&gt; 不要理会 &lt;/font &gt; 这个弹窗。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84nvzsytmj30u00y6mz0.jpg\" alt=\"image-20221114145604307\" /></p>\n<p>然后到如下路径就可以取到对应的 ipa</p>\n<p><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~<span class=\"regexp\">/Library/</span>Group Containers<span class=\"regexp\">/K36BKF7T3D.group.com.apple.configurator/</span>Library<span class=\"regexp\">/Caches/</span>Assets<span class=\"regexp\">/TemporaryItems/</span>MobileApps/</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"方式3-dumpapp\"><a class=\"anchor\" href=\"#方式3-dumpapp\">#</a> 方式 3 <a href=\"%5Bhttps://dumpapp.com%5D(https://dumpapp.com/)\">DumpApp</a></h3>\n<p>是一个第三的网站，同在线砸壳 + ipa 下载的服务，因为我们最终想要的就是一个砸壳之后的 ipa，所以这个网站直接帮我们做好了，只不过是收费的，每个 app 是 9 元，但是有多个境外的 App 市场，比较全面。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84par73tqj30be07saa1.jpg\" alt=\"image-20221114154450405\" /></p>\n<h2 id=\"ipa砸壳\"><a class=\"anchor\" href=\"#ipa砸壳\">#</a> iPa 砸壳</h2>\n<p>如果 iPa 的获取方式选择方式 3，则可以略过砸壳步骤</p>\n<p>app 上传到 AppStore 后   苹果使用 fairplay DRM 来加密，就是我们所说的壳 DRM 全称 Digital Rights Management，即数字版权保护。苹果为了保护 App Store 分发的音乐 / 视频 / 书籍 / App 免于盗版，开发了 Fairplay DRM 技术。</p>\n<p>所有逆向都是建立在砸壳的前提下，砸壳的方式有两种：</p>\n<h3 id=\"静态砸壳\"><a class=\"anchor\" href=\"#静态砸壳\">#</a> 静态砸壳</h3>\n<p>就是不依赖程序运行，直接用 ipa 包就可以进行砸壳解密，比如说我已经知道了他的加密算法，或者我通过暴力破解了他的加密算法，然后对 ipa 进行解密，但是这样的方法难度较大，而且如果人家一旦换了加密方式或者有其他的改动，那解密方式就不生效了，常见的静态砸壳工具有以下</p>\n<ul>\n<li>[fouldecrypt](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL055YU1pc3R5L2ZvdWxkZWNyeXB0\">NyaMisty/fouldecrypt: A lightweight and simpling iOS binary decryptor (github.com)</span>)</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0xha3IyMzMvSXJpZGl1bQ==\">Iridium</span></li>\n</ul>\n<h3 id=\"动态砸壳\"><a class=\"anchor\" href=\"#动态砸壳\">#</a> 动态砸壳</h3>\n<p>与静态相反，动态砸壳就是依赖运行时的原理来进行解密，不过与其说是解密，倒不如说是内存提取，因为无论 ipa 包用什么加密方式，最终都是解密后运行到内存里面的，所以我们可以认为 <code>一个ipa在内存上的数据是未加密的</code> ，所以此时我们只要把内存上的数据提取出来即可，整个过程也不涉及到解密操作，及时后面 Apple 更换加密方式，也不影响动态砸壳的过程。</p>\n<p>动态砸壳的方式和工具有很多，现在基本已经流水线化了，可以使用以下方式和工具来进行处理，前提是要有一个越狱的手机。</p>\n<ul>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzODkzNDk5OTA0MDA4\">dumpdecrypted</span></p>\n</li>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzODkzNDk5OTA0MDE0\">Clutch</span></p>\n</li>\n</ul>\n<h3 id=\"成果检验\"><a class=\"anchor\" href=\"#成果检验\">#</a> 成果检验</h3>\n<p>砸壳后需要检查是否砸壳成功，找到对应砸壳后的的 ipa，点进去找到 mach-o 文件，执行如下命令，然后在输出查看 <code>cryptid</code>  字段如果为 <code>0</code>  就说明砸壳成功。XXX = mach-o 名字</p>\n<p><figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">otool -l XXXXX <span class=\"string\">|grep cry</span></span><br></pre></td></tr></table></figure></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84ripqxklj30tx02imxg.jpg\" alt=\"image-20221114170141723\" /></p>\n<h2 id=\"头文件导出\"><a class=\"anchor\" href=\"#头文件导出\">#</a> 头文件导出</h2>\n<p>砸壳后的的第一步就是将 ipa 文件的头.h 文件导出，然后根据 头文件的方法和属性进行逆向分析，在找到对应的 hook 点。通常我们使用 class-dump，可以去他的官网下载对应的文件，然后将文件拷贝到对应的目录下。</p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo cp class-dump /usr/local/bin   </span><br></pre></td></tr></table></figure></p>\n<p>这一步没什么问题，拷贝完成重启终端就可以调用 class-dump 的方法了.</p>\n<h3 id=\"导出\"><a class=\"anchor\" href=\"#导出\">#</a> 导出</h3>\n<p>执行下面的命令，导出头文件，需要注意的是：导出后会有上万个个文件，所以目标目录最好不要选 Desktop 或者其他的根目录</p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class-dump -S -s -H XXXXX -o /path/to/headers/</span><br></pre></td></tr></table></figure></p>\n<p>有的时候会收到这样的错误</p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error:Cannot find offset for address 0xd80000000101534a in stringAtAddress:</span><br></pre></td></tr></table></figure></p>\n<p>这是因为项目使用了 Oc 和 Swift 的混编，需要赋予 class-dump 文件权限即可</p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chmod 777 /usr/local/bin/class-dump</span><br></pre></td></tr></table></figure></p>\n<p>之后就可以导出成功了。</p>\n<h2 id=\"monkeydev\"><a class=\"anchor\" href=\"#monkeydev\">#</a> MonkeyDev</h2>\n<p>这是一个为越狱和非越狱开发人员准备的工具，主要包括四个模块:</p>\n<ul>\n<li>\n<p>Logos Tweak</p>\n<ul>\n<li>使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RoZW9zL3RoZW9zL3dpa2kvSW5zdGFsbGF0aW9u\"> theos</span> 提供的 <code>logify.pl</code>  工具将 <code>*.xm</code>  文件转成 <code>*.mm</code>  文件进行编译，集成了 <code>CydiaSubstrate</code> ，可以使用 <code>MSHookMessageEx</code>  和 <code>MSHookFunction</code>  来 <code>Hook</code>  OC 函数和指定地址。</li>\n</ul>\n</li>\n<li>\n<p>CaptainHook Tweak</p>\n<ul>\n<li>使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3JwZXRyaWNoL0NhcHRhaW5Ib29rLw==\"> CaptainHook</span> 提供的头文件进行 OC 函数的 Hook 以及属性的获取。</li>\n</ul>\n</li>\n<li>\n<p>Command-line Tool</p>\n<ul>\n<li>可以直接创建运行于越狱设备的命令行工具</li>\n</ul>\n</li>\n<li>\n<p>MonkeyApp</p>\n<ul>\n<li>这是自动给第三方应用集成 Reveal、Cycript 和注入 dylib 的模块，支持调试 dylib 和第三方应用，支持 Pod 给第三放应用集成 SDK，只需要准备一个砸壳后的 ipa 或者 app 文件即可。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"安装\"><a class=\"anchor\" href=\"#安装\">#</a> 安装</h3>\n<p>Monkeydev 依赖<span class=\"exturl\" data-url=\"aHR0cHM6Ly90aGVvcy5kZXYvZG9jcy9pbnN0YWxsYXRpb24=\"> Theos</span>.Theos 是一个越狱开发工具包，由 iOS 越狱界知名人士 Dustin Howett 开发并分享到 GitHub 上。Theos 与其他越狱开发工具相比，最大特点就是简单：下载安装简单、Logos 语法简单、编译发布简单，可以让使用者将精力都放在开发工作上去。</p>\n<h4 id=\"安装thoes\"><a class=\"anchor\" href=\"#安装thoes\">#</a> 安装 Thoes</h4>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo git clone --recursive https://github.com/theos/theos.git /opt/theos</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"安装monkeydev\"><a class=\"anchor\" href=\"#安装monkeydev\">#</a> 安装 Monkeydev</h4>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo /bin/sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/AloneMonkey/MonkeyDev/master/bin/md-install)&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"卸载monkeydev\"><a class=\"anchor\" href=\"#卸载monkeydev\">#</a> 卸载 Monkeydev</h4>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo /bin/sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/AloneMonkey/MonkeyDev/master/bin/md-uninstall)&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"更新monkeydev\"><a class=\"anchor\" href=\"#更新monkeydev\">#</a> 更新 Monkeydev</h4>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo /bin/sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/AloneMonkey/MonkeyDev/master/bin/md-update)&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"安装问题\"><a class=\"anchor\" href=\"#安装问题\">#</a> 安装问题</h4>\n<p>在安装过程中，修改用户  <code>profile</code>  文件时，找不到  <code>MacOSX Package Types.xcspec</code>  和  <code>MacOSX Product Types.xcspec</code>  文件</p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/Library/Xcode/Specifications/MacOSX Package Types.xcspec not found</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>这个是因为最新的 Xcode14 中 这个路径已经改变，所以原路径无法找到，不过如果大家需要逆向的事 iOS 的 App 到这一步可以不用关心，这个是 MacOS 相关的模板文件。此时打开 Xcode 如果有以下模版文件，并能成功创建工程即可。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84skm4dlej30li0fbjsb.jpg\" alt=\"image-20221114173807449\" /></p>\n<h4 id=\"编译报错\"><a class=\"anchor\" href=\"#编译报错\">#</a> 编译报错</h4>\n<p>通过上一步的模板文件创建好工程后，直接真机编译运行，这个时候会提示编译错误</p>\n<p><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iOS <span class=\"keyword\">file</span> not found: <span class=\"regexp\">/usr/</span>lib/libstdc++.dylib</span><br></pre></td></tr></table></figure></p>\n<p>这是因为 <code>Xcode 10</code>  之后删除的 <code>libstdc++</code>  库。可以参考此<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2RibXo1MDIvTW9ua2V5RGV2X1hjb2RlMTQ=\">解决方案</span>。之后就可以编译成功了，并且手机上可以跑起来。</p>\n<p>第二个错误是 Fishhook 中的错误，这个是是由于 Fishhook 用的是比较老的版本，本身存在 bug，只要去 github 官网找到 fishhook 最新代码 copy 过来即可。</p>\n<h3 id=\"文件结构\"><a class=\"anchor\" href=\"#文件结构\">#</a> 文件结构</h3>\n<p>文件结构如下如图</p>\n<p><img data-src=\"https://upload-images.jianshu.io/upload_images/1609369-0a4b973075bc5df2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/854/format/webp\" alt=\"image-20221114174320781\" /></p>\n<p>这是一个标准的 MonkeyDemo 的结构</p>\n<ul>\n<li>\n<p><code>TargetApp</code> ：放目标 <code>ipa</code>  的文件，将需要逆向的破壳 <code>ipa</code>  放在此处</p>\n</li>\n<li>\n<p><code>Logos</code> ：编写相关 <code>hook</code>  的文件，所有 <code>hook</code>  操作在此处，但是因为该文件下要用了 logos 语句，有一定的学习成本，所以后面的 hook 函数可以直接写在上面的 MonkeyDeomDyLib.m 中</p>\n</li>\n<li>\n<p><code>fishhook</code> ：用来 <code>hook</code>  系统函数的库</p>\n</li>\n</ul>\n<p>上方的 MonkeyDeomDyLib 就是我们即将注入进去的动态库。</p>\n<h3 id=\"动态库注入\"><a class=\"anchor\" href=\"#动态库注入\">#</a> 动态库注入</h3>\n<p>运行 demo 后动态库注入成功，控制台会有如下输出</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84swti61vj31le0qn43z.jpg\" alt=\"image-20221114174950556\" /></p>\n<p><figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">🎉!!！congratulations!!！🎉\\n👍----------------insert dylib success----------------👍</span><br></pre></td></tr></table></figure></p>\n<p>但是如果是和我一样的运行环境，你是大概率看不到的，因为会注入失败。这里尝试了两种方式</p>\n<ul>\n<li>insert_dylib 同样注入失败，</li>\n<li>optool 注入成功</li>\n</ul>\n<p>下面说下 optool 使用</p>\n<ul>\n<li>\n<p>下载编译 optool</p>\n<p><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https:<span class=\"regexp\">//gi</span>thub.com<span class=\"regexp\">/alexzielenski/</span>optool.git</span><br><span class=\"line\">cd optool</span><br><span class=\"line\">git submodule update --init --recursive</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>找到编译产物</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84t2mlrmaj30aa0b7wer.jpg\" alt=\"image-20221114175525945\" /></p>\n</li>\n<li>\n<p>把编译产物拷贝到 <code>/opt/MonkeyDev/bin</code>  下</p>\n</li>\n<li>\n<p>修改 <code>/opt/MonkeyDev/Tools/pack.sh</code></p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">顶部插入</span><br><span class=\"line\">OPTOOL=&quot;$&#123;MONKEYDEV_PATH&#125;/bin/optool&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">同上面一样</span><br><span class=\"line\">修改插入动态库工具代码</span><br><span class=\"line\">&quot;$OPTOOL&quot; install -c load -p &quot;@executable_path/Frameworks/lib&quot;&quot;$&#123;TARGET_NAME&#125;&quot;&quot;Dylib.dylib&quot; -t &quot;$&#123;BUILD_APP_PATH&#125;/$&#123;APP_BINARY&#125;&quot;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>然后保存重新运行即可注入成功</p>\n</li>\n</ul>\n<h3 id=\"pod使用\"><a class=\"anchor\" href=\"#pod使用\">#</a> pod 使用</h3>\n<p>在调试 App 时候我们会用到类似 lookIn 或者 FLEX 的等工具来看 App 的层级结构和 沙盒文件，同样需要 pod 来接入。</p>\n<ul>\n<li>\n<p>像平时创建 podfile 文件一样 进入到工程目录 <code>pod init</code></p>\n</li>\n<li>\n<p>在生成的 podfile 中添加 pod，但是要注意是在 &lt;font color='red'&gt; DemoLib &lt;/font &gt; 的 trarget 中添加，因为我们的 pod 是打入动态库的，然后由动态库带入 App</p>\n<p><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Uncomment the next line to define a global platform for your project</span></span><br><span class=\"line\"><span class=\"comment\"># platform :ios, &#x27;9.0&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">target <span class=\"string\">&#x27;Demo&#x27;</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">  <span class=\"comment\"># Comment the next line if you don&#x27;t want to use dynamic frameworks</span></span><br><span class=\"line\">  use_frameworks!</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">target <span class=\"string\">&#x27;DemoDylib&#x27;</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">  <span class=\"comment\"># Comment the next line if you don&#x27;t want to use dynamic frameworks</span></span><br><span class=\"line\">  use_frameworks!</span><br><span class=\"line\"></span><br><span class=\"line\">    pod <span class=\"string\">&#x27;FLEX&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    pod <span class=\"string\">&#x27;LookinServer&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>然后 <code>pod install</code>  即可看到效果</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h85lo8xilij31b90u0ada.jpg\" alt=\"image-20221115102451908\" /></p>\n</li>\n</ul>\n<h3 id=\"代码hook\"><a class=\"anchor\" href=\"#代码hook\">#</a> 代码 Hook</h3>\n<p>通过 Lookin 我们可以找到入手点和对应的类名，然后通过之前导出的头文件可以查看类名对应的函数，接下来就是要看下函数里面做了哪些事情，就要用到 Hook 手段，MonkeyDev 给我们封装好了 Hook 相关的方法，包括 OC 和 C 的 Hook 函数</p>\n<ul>\n<li>\n<p>CHDeclareClass</p>\n<p>注册类名。也就是注册要被 hook 的函数所在的类，比如</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CHDeclareClass(MYViewController)</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>CHOptimizedMethod1</p>\n<p>hook 实例方法，你会发现后面跟了数字 1~10，代表被 hook 的函数的参数的个数，比如我将要 hook 的函数只有一个参数 那么就使用 CHOptimizedMethod1 参数含义为</p>\n<ul>\n<li>\n<p>第一个参数，一般传 self</p>\n</li>\n<li>\n<p>第二个参数，传返回值类型，没有返回值就是 void</p>\n</li>\n<li>\n<p>第三个参数，函数所在的类名</p>\n</li>\n<li>\n<p>第四个参数，方法名</p>\n</li>\n<li>\n<p>第五个参数，函数参数的类型</p>\n</li>\n<li>\n<p>第六个参数，函数参数的变量</p>\n<p>其中第五第六个参数在 CHOptimizedMethod1 ~10 中会重复 1~10 次</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CHOptimizedMethod1(self, void, MYViewController, appMethod, id, para) &#123;</span><br><span class=\"line\">    NSLog(@&quot;appMethod被Hook = %@&quot;, para);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n</li>\n<li>\n<p>CHOptimizedClassMethod3</p>\n<p>hook 类方法，所有函数定义同上</p>\n</li>\n<li>\n<p>CHConstructor 结构</p>\n<p>用来注册刚才的 hook 操作</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CHConstructor&#123;</span><br><span class=\"line\">  // 注册将要hook的类</span><br><span class=\"line\">    CHLoadLateClass(MYViewController);</span><br><span class=\"line\">\t// 注册将要hook 的方法</span><br><span class=\"line\">    CHHook1(MYViewController, appMethod);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面流程执行完成后就可以看到函数被 Hook 了</p>\n</li>\n</ul>\n<h2 id=\"hopper-disassembler\"><a class=\"anchor\" href=\"#hopper-disassembler\">#</a> Hopper Disassembler</h2>\n<p>上面的步骤讲了如何通过 lookin 或者 reveal 等工具来定位类名，然后通过类名在头文件中找到函数名，然后通过 hook 手段来改变函数的一些表现，但是在如何没有拿到.m 文件的前提下看到某个函数的实现呢？比如一个函数中都做了哪些操作，调用了哪些其他函数，以及调用链是怎样的？</p>\n<p>这个时候就需要用到 <code>Hopper Disassembler</code>  或者 <code>IDA Pro</code>  这样的工具了，不过目前遇到的困难是在笔者的系统环境下，这两个软件的破解版无法安装，而且 <code>IDA Pro</code>  的官方试用版还不支持 Arm 的汇编，所以只能使用 Hopper Disassembler 来举例子。打开软件，将 <code>对应App 的Mach-o</code>  文件拖入 Hopper 中等待它分析完成</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h85mc4b62oj31ec0u075n.jpg\" alt=\"image-20221115104755241\" /></p>\n<p>处理完后的界面左边会显示方法名，支持搜索查询，中间区域显示的是汇编代码，我们搜索一个在之前 dump 出的头文件中的一个函数名试下。</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[XXXXXXXX listenerDownloadLyricWithSongId:resultBlock:]</span><br></pre></td></tr></table></figure></p>\n<p>可以看到中间的部分显示出来函数所对应的汇编代码</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h861n7q3isj317b0u0dlg.jpg\" alt=\"image-20221115193733635\" /></p>\n<p>然后按快捷键 <code>Option+enter</code>  即可转为伪 OC 代码，虽然包含一些的寄存器信息，但是也足以分析了。同时双击可以跳转到对应的函数内部。</p>\n<h2 id=\"最后\"><a class=\"anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>以上就是目前的逆向调研过程，这里先记录下，后面还会深入研究，有新的发现会同步更新此文章。</p>\n",
            "tags": [
                "iOS",
                "逆向"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2022-06-13-WWDC2022-iOS%E7%AF%87%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/",
            "url": "https://oliverqueen.cn/2022-06-13-WWDC2022-iOS%E7%AF%87%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/",
            "title": "WWDC2022-iOS篇完全解析",
            "date_published": "2022-06-13T09:05:31.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景</h1>\n<p>Apple 于北京时间 2022 年 6 月 7 日举办了 WWDC2022，作为一名 Apple 开发者，不仅仅是为了保持技术敏感度，同时也希望在第一时间将新的内容呈现在大家眼前。本文对发布会内容做了整理归纳，并着重对 iOS 的新内容进行分析。希望这篇文章对大家有所帮助的同时也给我们的产品带来更多的可能性。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h344hz8cl3j21g20pswhk.jpg\" alt=\"9690f67c1bc2cc62bd8729e5182ef19a\" /></p>\n<p><span id=\"more\"></span></p>\n<p>相对于 iOS15 来说，iOS16 的整体变化比较大，尤其是在我们看得见的地方，比如一些 UI 样式，交互行为和一些新增的功能。下面会按照 WWDC 的出厂顺序来介绍，其中包含了每个改动点的细节以及个人的理解和后面的展望。</p>\n<h1 id=\"developer\"><a class=\"anchor\" href=\"#developer\">#</a> Developer</h1>\n<h2 id=\"xcode相关\"><a class=\"anchor\" href=\"#xcode相关\">#</a> Xcode 相关</h2>\n<p>新版的 Xcode 同样也跟新了相关的内容，帮助开发者提高开发效率。</p>\n<h4 id=\"方法吸顶以及代码提示\"><a class=\"anchor\" href=\"#方法吸顶以及代码提示\">#</a> 方法吸顶以及代码提示</h4>\n<p>在之前的版本中，如果方法函数过多超了一屏展示，随着滚动函数名不可见，而新版的 Xcode 提供了类似 TableViewHeader 的效果，让方法名和实现名字固定在顶部，方便随时查看和复制。对小屏还是比较友好的。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342t0jx5qj215h0u040m.jpg\" alt=\"enter image description here\" /></p>\n<p>同样在使用初始化方法的时候如果是支持传入参数的初始化方法也会通过斜体来进行参数提示 (Swift 专属)</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342t2czj8j20u00akt9s.jpg\" alt=\"enter image description here\" /></p>\n<h4 id=\"xcode安装体积\"><a class=\"anchor\" href=\"#xcode安装体积\">#</a> Xcode 安装体积</h4>\n<p>新版的 Xcode 优化了包体积，同时在进行安装的时候可以自定义需要哪些平台，需要哪些模拟器，笔者亲测相比之前的无脑把 AppleTV、Apple Watch、ipad 等都安装下来的情况来看，整个包体积减少了十几个 G 左右。对于小存储的 MacBook 是一个福音。</p>\n<h4 id=\"xcode编译与调试\"><a class=\"anchor\" href=\"#xcode编译与调试\">#</a> Xcode 编译与调试</h4>\n<p>根据苹果的描述新版 Xcode 优化项目的编译速度， <code>得益于更强大的并行编译能力，项目构建速度提升至高可达 25%</code> 。</p>\n<ul>\n<li>改善前：先编译 framework 里的代码，然后生成 module，然后编译 app 里的代码，最终经过链接完成了构建。</li>\n<li>改善后：通过提高并发，缩短了构建的关键的路径</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tn4mxij20yl0u0415.jpg\" alt=\"enter image description here\" /></p>\n<p>同时单元测试的效率也提高了 30%</p>\n<p>Xcode14 还支持输出编译期间每个阶段的耗时和详细信息，相比之前的只能通过控制台的名字描述要直观不少。<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342x91jz4j21910u0wir.jpg\" alt=\"编译耗时\" /></p>\n<p>对于 LLDB，现在还可以看到执行的过程和信息，对于一些需要长时间跑的命令较为友好，类似于 <code>--verbose</code>  参数的含义</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tgt828j21dg0323yy.jpg\" alt=\"enter image description here\" /></p>\n<p>在新版的 Xcode 中除了 App 和系统的日志，同样支持 LLDB 的日志输出，当时在用 LLDB 调试的时候发生 Crash，便可以到相关路径中找到对应日志。<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342t3pka9j21ay02kjrp.jpg\" alt=\"enter image description here\" /></p>\n<h2 id=\"开发者模式\"><a class=\"anchor\" href=\"#开发者模式\">#</a> 开发者模式</h2>\n<p>新版的 iOS 和 Watch OS 引入了新的开发者模式，原理和安卓的开发者模式类似，用苹果的话说是为了 <code>开发者模式可防止人们无意中在其设备上安装可能有害的软件，并减少开发者专用功能所暴露的攻击媒介。</code> ，对于普通人来说确实可以提高安全性，之前只要是加入了开发者账号的手机都可以从 Xcode 编译运行第三方的 App，或者按照企业证书的签名包，而不这些手机主人都是无感的，现在需要手机主人通过多重确认来打开此功能后才可以进行安装非 <code>App Store</code>  和 <code>Testfilght</code>  渠道的包。</p>\n<p>但是这个对于开发者来说并不友好，首先是调试过程有会多增加一些步骤，而且在自动化测试方面，所有的手机都要先通过命令来打开开发者模式，并且根据苹果的说法，使用命令行进行开关要确保手机没有密码，否则会被拒绝运行。这里笔者也尝试在未打开 <code>开发者模式</code> 的情况下进行 Xcode 编译，确实会失败。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342ygml7gj208y01kdfo.jpg\" alt=\"enter image description here\" /></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3358k3glij207s087aaa.jpg\" alt=\"\" /></p>\n<p>笔者预测该功能可能是为后续的第三方 App 市场做准备，因为现在虽然苹果不支持三方市场，但是普通用户还是可以通过一些三方网站安装重签包，同时他们并不知道这些包会带来潜在的危险，再加上欧盟一些反垄断政策的施压，所以苹果决定逐步开放三方应用市场，这应该就是第一步吧，先让用户意识到这样做可能会有一些危害。</p>\n<p><code>无论是美国的《美国选择与创新法案》、还是欧盟的《数字市场法案》，都要求苹果在App Store之外为用户提供额外的应用下载渠道。现在看来，苹果方面可能已经认为改变欧盟与美国的态度已经不太可能了，那么既然支持侧载或许无法避免，那么让用户更难发现侧载功能的入口就成为了备选项。</code></p>\n<h1 id=\"lockscreen\"><a class=\"anchor\" href=\"#lockscreen\">#</a> LockScreen</h1>\n<h2 id=\"锁屏样式\"><a class=\"anchor\" href=\"#锁屏样式\">#</a> 锁屏样式</h2>\n<p>重新修改了锁屏的样式，在优化了时间显示的字体的同时也在锁屏上提供了更多能力，展示更多的信息，并加入了一些新的交互样式，通过在锁屏界面长按来进入锁屏界面的编辑状态，这个动画效果有点类似安卓的编辑桌面的效果。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3430h983bg208a0gnhe7.gif\" alt=\"image\" /></p>\n<p>iOS16 的锁屏样式可以大致分为两类</p>\n<ul>\n<li>动态锁屏<br />\n比如在 Beta1 中可以看到的天气锁屏，依赖于天气 App 的信息，在点亮屏幕的一瞬间可以在锁定屏幕上动态显示天气的效果，比如雨雪风晴等，持续几秒钟后停止。笔者预测该能力后续会和 Livephoto 关联起来，实现用户自定义动态照片，毕竟现在的 livephoto 设置锁屏之后只有在长按才会触发播放，到时候长按的手势会和设置锁屏的手势冲突，所以 livephoto 必然会变成自动播放，</li>\n</ul>\n<p>再长远预测的话也可能后续会把该能力开放给第三方 App 来定制动态锁屏的图片，类型于现在的天气 App。比如 QQ 音乐的专辑封面，歌手的演唱动图等。目前动态背景只支持锁屏界面，解锁后进入桌面便会停止，估计是处于性能考虑，动态桌面的可能性不大，应该仅限于锁屏。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tiho1zg207u0gou0z.gif\" alt=\"image\" /></p>\n<ul>\n<li>静态照片<br />\n iPhone 一直可以支持设置静态照片为锁屏壁纸，但是 iOS16 给静态照片锁屏提供了更多的玩法。</li>\n<li>照片随机切换：用户可以选定一组照片来作为锁屏壁纸，类似于幻灯片放映的样式，切换的频率可以设置为  <code>每次点亮</code>  、  <code>每次点击</code>  、  <code>每小时</code>  、  <code>每天</code>  。</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tuul3fg207z0gnqvl.gif\" alt=\"image\" /></p>\n<ul>\n<li>照片景深：这个能力算是 iOS16 更新比较大的，通过机器学习模型将照片中的主体突出，可以遮挡在时间上，这里的主体可以是图片中任何可区分的物体，不仅仅是人像模式的照片。(在实际使用中，经常会失败，beta1 还是不够稳定)</li>\n</ul>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzExYno5bmoyMGkyMTJ5YWNpLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h34311bz9nj20i212yaci.jpg</span>&quot; alt=&quot;image#268px #578px&quot; style=&quot;zoom:50%;&quot; /&gt; &lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzI0OHBnOWoyMG11MTh1ZG1oLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h343248pg9j20mu18udmh.jpg</span>&quot; alt=&quot;image#292px #574px&quot; style=&quot;zoom:43%;&quot; /&gt;</p>\n<ul>\n<li>表情壁纸：将 IPhone 输入法中自带的表情进行一定规律的排列组合形成一张壁纸，最多支持输入六个表情。</li>\n<li>颜色壁纸：可以定义一些渐变颜色</li>\n<li>官方背景图壁纸。一些官方图片，支持景深效果</li>\n</ul>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MnRxcXZldWoyMGh3MTB3cTViLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tqqveuj20hw10wq5b.jpg</span>&quot; alt=&quot;image#189px #390px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h2 id=\"锁屏组件\"><a class=\"anchor\" href=\"#锁屏组件\">#</a> 锁屏组件</h2>\n<p>iOS16 在锁屏界面可以展示更多的信息，其中就包括了锁屏小组件的加入。可以看到锁屏顶部分三个区域。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzJkMTZoc2oyMGllMTNhZGllLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3432d16hsj20ie13adie.jpg</span>&quot; alt=&quot;image#270px #577px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<ul>\n<li>顶部：顶部区域是一个小的小组件区域，同时只能容纳一种小组件放置，🇳信息量有限。</li>\n<li>中部：中部区域是固定展示时间的区域，不可放置自定义小组件。只能展示时间信息，但是用户可自定义字体（包括阿拉伯文、天成文）和颜色。</li>\n<li>底部：底部区域为第二个小组件区域，范围较大，最多可容纳 4 个正方形（1*1）的小组件。同时支持排列组合。</li>\n</ul>\n<p>目前小组件的支持非常有限，目前只能将系统级的 App 的组件放上去，并不支持第三方 App，笔者尝试写了一个小组件，在主屏幕上可以正常添加，但是在锁定屏幕无法使用，猜测两个原因，一是目前是 Beta1 版可能还没有开放三方 App 的小组件，后续会陆续优化上来；第二个原因可能是处于性能或者其他因素考虑锁频组件和主屏组件不是一套逻辑，并不互通，但是通过查看 Xcode Beta 版本的代码，没有看到相关线索，不过 WWDC 也提到了，一些功能在后续会以 API 的形式像开发者提供。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MnR5bThndGoyMGk2MTMwNzdoLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tym8gtj20i613077h.jpg</span>&quot; alt=&quot;image#266px #571px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h2 id=\"锁屏通知\"><a class=\"anchor\" href=\"#锁屏通知\">#</a> 锁屏通知</h2>\n<p>iOS16 调整了锁屏的样式，增加了锁屏界面所展示的信息和交互，所以希望锁屏界面不要被大量的通知遮挡，因此从新调整了通知推送的位置和出现动画。iOS16 之前：通知铺满锁屏，同时新的通知会插到到最上面。从上往下依次排列。iOS16 之后：锁屏区域被限定在底部一小块区域，新来的通知会插到第一层，但是默认只展示 3 个（叠放的形式），想看更多的话跟之前一样，上拉即可。任何新增的通知，包括常驻的音乐播放调都是从下往上增长，通知增长到一定高度就会开始折叠，这样的好处就是可以给锁屏留出空间，不至于被占满。</p>\n<p>这样的修改确实可以让锁屏界面看的更整洁，且能让用户看到自己喜欢的锁屏画面，但是带来一个问题是用户想要查看通知内容时候需要多做一步上拉的操作，可能会稍微影响到 Push 的效果，比如点击率之类的指标。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3432t13nsg207m0go7wr.gif\" alt=\"image\" /></p>\n<h2 id=\"live-activities\"><a class=\"anchor\" href=\"#live-activities\">#</a> Live Activities</h2>\n<p>上面说的苹果弱化了通知展示的样式，默认采用了折叠策略给锁屏留出了更大的空间，但是为了让用户实时的追踪想要的信息便推出了  <code>Live Activities</code>  。该控件可以常驻在锁屏界面，且能够实时刷更新的一个 UI 控件，</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tq7i9qj214g0mg3zz.jpg\" alt=\"image\" /></p>\n<p>WWDC 上举了一个恰当的例子，比如我在追踪一场比赛，我需要知道实时的比分信息，但是又不方便拿着手机 app 观看直播，所以支持了  <code>Live Activities</code>  能力的 App 可以再锁屏界面来实时展示比赛信息，同时不需要解锁屏幕，还有优步的信息。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzMxbGNyM2oyMHdjMG13bjFnLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h34331lcr3j20wc0mwn1g.jpg</span>&quot; alt=&quot;image#321px #227px&quot; style=&quot;zoom: 33%;&quot; /&gt;&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzM3NWh2ZWoyMHc2MG0wanZhLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h343375hvej20w60m0jva.jpg</span>&quot; alt=&quot;image#334px #228px&quot; style=&quot;zoom: 35%;&quot; /&gt;</p>\n<p>这有点类似于锁屏的音乐播放条。同时 IOS16 针对音乐播放调界面也做 UI 优化，可以通过点击来实现封面图展开，同时背景设置为封面的魔法色，实现全屏沉浸式播放。但是笔者实测时候并未在 beta 版上成功使用该功能，SDK 中也没有看到相关代码。应该是在后续的版本开放更新。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzVsb3c4Z2oyMGhrMHhlNDFqLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3435low8gj20hk0xe41j.jpg</span>&quot; alt=&quot;image#305px #580px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h2 id=\"专注模式\"><a class=\"anchor\" href=\"#专注模式\">#</a> 专注模式</h2>\n<p>苹果去年推出了  <code>专注模式</code>  ，但是专注模式的切换需要到控制中心，或者设置菜单中进行切换，隐藏较深，在这次的 iOS16 中，苹果将专注模式和锁定屏幕绑定起来，也就是实现专注模式和锁定屏幕  <code>一一对应</code>  的关系，一个锁屏对应一套锁屏组件和一个专注模式。</p>\n<p>比如我下图中两个锁定屏幕分别对应两种模式，工作模式可以设置只接受某些 App 的推送（比如企业微信。WeSing 等），忽略某些不重要的通知。右边的游戏模式可以吧比较关注的电量信息放到锁屏，同时屏蔽通知避免游戏误操作。关键是在 iOS16 上两种模式的切换只要在锁屏上长按就可以进行更改，方便很多。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzV0a3QxZWoyMGcyMHpnYWQxLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3435tkt1ej20g20zgad1.jpg</span>&quot; alt=&quot;image#337px #744px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h1 id=\"信息app\"><a class=\"anchor\" href=\"#信息app\">#</a> 信息 App</h1>\n<h2 id=\"消息编辑\"><a class=\"anchor\" href=\"#消息编辑\">#</a> 消息编辑</h2>\n<p>根据 WWDC 的描述，信息 App 带来的三个呼声最高的功能（应该是国外用户）</p>\n<ul>\n<li>动态编辑信息：对于已经发送出去的信息，如果发现错别字，可以直接在自己刚刚发送的对话气泡上进行修改，像这样，就不需要再撤回然后重新辑后发送。</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3436v6e47g20go080e86.gif\" alt=\"image\" /></p>\n<ul>\n<li>\n<p>标记未读（国内玩腻了的）</p>\n</li>\n<li>\n<p>消息撤回（国内玩腻了的）</p>\n</li>\n</ul>\n<h2 id=\"shareapi\"><a class=\"anchor\" href=\"#shareapi\">#</a> ShareApi</h2>\n<p>iOS15 中提到了  <code>SharePlay</code>  的能力，但是当时该能力必须基于 FaceTime。在 iOS16 中，该能力已经扩展的信息 App 中。笔者认为，  <code>SharePlay</code>  的能力后续会形成套单独的 SDK（类似于 AirPlay 的 SDK），供第三方 App 接入，且不依赖 Facetim 和信息等系统 App。这对于音视频的 App 是有比较大的帮助，可以一起听歌、看视频。但是对于版权的管理要更为严格。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM3cmhidXc2Y2oyMGkyMGx3YWJ3LmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h37rhbuw6cj20i20lwabw.jpg</span>&quot; alt=&quot;image#389px #472px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h1 id=\"语音输入\"><a class=\"anchor\" href=\"#语音输入\">#</a> 语音输入</h1>\n<p>苹果在很早的版本就支持语音输入，但是有一个弊端就是语音输入和键盘输入是两个独立的过程。而在 iOS16 中输入文本时，可在语音和触控这两种方式间无缝切换。无需中断听写，照样可用键盘打字、轻点文本栏、移动光标，或插入快速输入建议。<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h37rautdseg20go080e89.gif\" alt=\"image\" /></p>\n<h1 id=\"coreml\"><a class=\"anchor\" href=\"#coreml\">#</a> CoreML</h1>\n<h2 id=\"livetext\"><a class=\"anchor\" href=\"#livetext\">#</a> LiveText</h2>\n<p>CoreML 是苹果早期发布的机型学习 API，通过他可训练一些人工智能相关的东西，其中 iOS15 推出的  <code>LiveText</code>  便是其中之一，他可以让我们对图片里面的一些文字做提取操作，在 iOS16 中，apple 增强了  <code>LiveText</code>  的能力，除了静态图片，还加入了视频帧的支持。  <code>Live Text in Video</code>  , 根据 WWDC 的描述，在播放视频的时候进行暂停，便可以提取当前帧上的文字内容。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h37rfclnkvj21mp0u0dkd.jpg\" alt=\"image\" /></p>\n<p>选中后除了对文字进行复制操作外，iOS16 还提供了一些其他的快捷功能，其中包括汇率转换、翻译。更重要的是，实况文本的 API 已经开发给开发者使用，很快我们就能从 app 的照片和视频中提取相关的文字信息。</p>\n<h2 id=\"visual-look-up\"><a class=\"anchor\" href=\"#visual-look-up\">#</a> Visual Look Up</h2>\n<p>也是苹果之前基于机器学习提供的一个能力，可以检测照片中的物体，来识别是什么东西，在 iOS16 中，该能力被大幅加强，同时集成到了照片 App 中。用户可以打开一个照片，通过长按，把照片主体拖动出来到相应的 App 中。（拖出的图片为 png 图片）</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3437xq1cag207n0gnkk7.gif\" alt=\"image\" /></p>\n<p>该能力已经提供独立的 API，目前的 Apple 的  <code>可立拍</code>   App 里面将 Core ML 的能力运用到视频处理中，大家可以下载体验。</p>\n<h1 id=\"apple-pay\"><a class=\"anchor\" href=\"#apple-pay\">#</a> Apple Pay</h1>\n<h2 id=\"apple-pay-later\"><a class=\"anchor\" href=\"#apple-pay-later\">#</a> Apple pay later</h2>\n<p>类似于国内的京东白条、蚂蚁花呗，不同的是   <code>Apple pay later</code>   只提供 4 周或者 6 周的分期还款，且无息。</p>\n<h2 id=\"钥匙共享\"><a class=\"anchor\" href=\"#钥匙共享\">#</a> 钥匙共享</h2>\n<p>通过常用的通讯类 app，安全地共享钱包 app 中的钥匙（智能家居钥匙，汽车钥匙等）。你可以决定钥匙的使用地点和时间，并能随时撤销。</p>\n<h2 id=\"追踪订单\"><a class=\"anchor\" href=\"#追踪订单\">#</a> 追踪订单</h2>\n<p>可以查看票据，还能直接在钱包 app 中追踪你的 Apple Pay 订单。商户可以将订单的相续信息推送到消费者的钱包里</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzhlcnF1ZmoyMGVnMHNrZ243LmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3438erqufj20eg0skgn7.jpg</span>&quot; alt=&quot;image#304px #601px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h1 id=\"apple-map\"><a class=\"anchor\" href=\"#apple-map\">#</a> Apple Map</h1>\n<h2 id=\"增加途经点规划\"><a class=\"anchor\" href=\"#增加途经点规划\">#</a> 增加途经点规划</h2>\n<p>国内高德百度已经玩了很久的功能，在导航的时候可以在起点和终点之间增加途经点。快车顺风车经常要用的功能。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzhzZjJlZ2oyMGR5MHQwbjA4LmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3438sf2egj20dy0t0n08.jpg</span>&quot; alt=&quot;image#297px #618px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h2 id=\"实时公交信息\"><a class=\"anchor\" href=\"#实时公交信息\">#</a> 实时公交信息</h2>\n<p>可以查看公交出行的公交信息，包括公交时间，公交线路，公交价格等，同样也是国内使用了很久的能力。</p>\n<h2 id=\"共享交通工具查看\"><a class=\"anchor\" href=\"#共享交通工具查看\">#</a> 共享交通工具查看</h2>\n<p>可以在地图上看到附近的共享汽车、共享滑板车、共享单车等。同样也是国能很多共享单车厂商实现了的能力。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzliM21lb2oyMGhxMHcwNzZxLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3439b3meoj20hq0w076q.jpg</span>&quot; alt=&quot;image#307px #554px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h1 id=\"apple-tv-amp-apple-news\"><a class=\"anchor\" href=\"#apple-tv-amp-apple-news\">#</a> Apple TV &amp;amp; Apple News</h1>\n<p>Apple TV 和 Apple News 是两个不同的东西，之所以放到一起说是因为他们在 iOS16 中提供了相同的能力，都新增了体育板块，可以每周免费观看两场比赛，同时可以和 iPhone 联动，在锁屏上展示   <code>Live Activities</code></p>\n<h1 id=\"家长控制\"><a class=\"anchor\" href=\"#家长控制\">#</a> 家长控制</h1>\n<p>家长控制的粒度更细，除了是否可以启动某个 App，还可以详细控制某个 App 的权限，比如禁止某个 App 访问摄像头权限，来避免儿童色情的问题。之后的开发者可能要在权限控制这里做额外的判断。除了允许、拒绝、未决定外，新增了家长控制的枚举条件。</p>\n<h1 id=\"homekit\"><a class=\"anchor\" href=\"#homekit\">#</a> HomeKit</h1>\n<p>接入了更多智能家居品牌。同时和其他主流品牌一起在 HomeKit 的基础上创立了新的智能家居协议标准   <code>matter</code>  。可以让智能家居跨平台协同操作。目前已经有一部分厂商支持了   <code>matter</code></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3439rmf5bj21sq0sqtcw.jpg\" alt=\"image\" /></p>\n<h1 id=\"crarplay\"><a class=\"anchor\" href=\"#crarplay\">#</a> CrarPlay</h1>\n<p>苹果也看出了现在汽车发展的趋势就是大屏幕，而且一辆车往往不止一块屏幕，所以在 iOS16 上，苹果针对这个现象重新优化了 CraePlay，新的 CarPlay 不仅仅可以通过车机来控制 iPhone，还可以通过 iPhone 来设置车机的主题。 支持新 CarPlay 的车型将于 2023 年下半年生产，前期支持的车型为</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h343a6xc3bj21vm0tmtbn.jpg\" alt=\"image\" /></p>\n<p><code>新一代 CarPlay 车载将出类拔萃的 iPhone 体验带入车内。它可为车内所有的驾驶员屏幕提供内容，包括仪表盘在内，让你的爱车和 iPhone 在体验上融为一体。车载的收音机、空调等功能可直接通过 CarPlay 车载来控制。而多种个性化选项，包括小组件以及精选的仪表盘设计，更带来独特的驾驶体验。</code></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h343ak4evxj221o0t60ya.jpg\" alt=\"\" /></p>\n<h1 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h1>\n<p>以上就是 WWDC 中关于 iOS 的相关内容，笔者第一时间更新了 iOS16 的 Beta 版本，但也遇到一些问题</p>\n<ul>\n<li>iOS16 官方最低支持到 iPhone 8 系列，但是 iPhone 8 更新后，很多功能无法使用，建议使用 iPhoneXs 以及以上机型体验。</li>\n<li>WWDC 中提到的大部分功能现在都无法在 Beta1 中体验。且最新的 XcodeBeta 中也没有相关的新 Api，不过 WWDC 上也说了，iOS16 上的功能会在后续稍晚的时候以 API 的形式提供。</li>\n<li>Beta1 耗电发热非常夸张，尤其是在锁屏界面。可能还需相关优化，目前手机必须连着电源使用。</li>\n</ul>\n<p>文中提到得到一些功能更新虽然和国内开发者关系不大，但是毕竟都是业务层面的东西，底层都是通用的，毕竟技术无国界，也希望能将更新的技术用到自己的项目中，提高用户的产品体验，向用户展示出我们的专业能力和创新能力。希望这篇文章能对 iOS 开发者和产品同学在后续的技术、产品规划上有一定的帮助。</p>\n",
            "tags": [
                "iOS",
                "WWDC2022"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2022-05-26-Apple%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/",
            "url": "https://oliverqueen.cn/2022-05-26-Apple%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/",
            "title": "Apple登录流程详解",
            "date_published": "2022-05-26T02:53:20.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"1背景\"><a class=\"anchor\" href=\"#1背景\">#</a> 1：背景</h2>\n<p>2019 年苹果推出 苹果登录（Sign in with Apple）方式，要求 2020 年 4 月之后运行在 iOS13 及以上系统的 APP 如果使用第三方或社交登录服务（如 Facebook、谷歌、 Twitter、Linkedln 或亚马逊等），必须向用户提供 “以苹果账号登录” 服务的选项。其中苹果的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDJmempqd3d1YWoyMTY0MHA0NDRkLmpwZw==\">审核细则 4.8</span> 也明确的规定了这一点。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2lmep99kij21ns0rkaba.jpg\" alt=\"\" /></p>\n<p><span id=\"more\"></span></p>\n<p>&lt;font color=&quot;#dd0000&quot;&gt; 不过需要注意的一点是腾讯系列的产品如果只是使用微信、QQ 登录并不算第三方登录，所以可以添加 AppleID 登录方式。&lt;/font&gt;&lt;br /&gt;</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2fzjjwwuaj21640p444d.jpg\" alt=\"\" /></p>\n<h2 id=\"2前置配置\"><a class=\"anchor\" href=\"#2前置配置\">#</a> 2：前置配置</h2>\n<h4 id=\"21-xcode工程配置\"><a class=\"anchor\" href=\"#21-xcode工程配置\">#</a> 2.1 Xcode 工程配置</h4>\n<p>选中工程 trager，在 capabilities 中添加 AppleID 登录的能力</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g28b5w8aj21960u0769.jpg\" alt=\"\" /></p>\n<h4 id=\"22-开发者账号配置\"><a class=\"anchor\" href=\"#22-开发者账号配置\">#</a> 2.2 开发者账号配置</h4>\n<p>基于授权码的后端验证方式需要此步骤，如果使用 JWT 验证方式则不依赖此步骤，不过建议按顺序看完多做了解。</p>\n<p>该步骤的最终目的是获取用于校验客户端身份的所需内容，其中包括以下三个内容</p>\n<ul>\n<li>\n<p>生成一个用于校验客户端身份的密钥文件</p>\n</li>\n<li>\n<p>获取 KeyID</p>\n</li>\n<li>\n<p>获取 iss（TeamID）</p>\n</li>\n</ul>\n<p>&lt;font color=&quot;#dd0000&quot;&gt; 注意：该步骤需要登录 Apple 开发者账号并对其进行功能的配置、开启、以及描述文件更新等操作，可能需要证书管理团队或者有相关权限的人员来处理，并由他们将对应信息输出 &lt;/font&gt;&lt;br /&gt;</p>\n<h5 id=\"步骤一能力开启\"><a class=\"anchor\" href=\"#步骤一能力开启\">#</a> <strong>步骤一：能力开启</strong></h5>\n<p>进入开发者账号，选择需要支持 AppleID 登录能力的应用并进入打开其 AppleID 登录的功能<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g335dozbj219o0kiwg6.jpg\" alt=\"\" /><br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g36gha89j216x0u0gnx.jpg\" alt=\"\" /></p>\n<h5 id=\"步骤二更新profile\"><a class=\"anchor\" href=\"#步骤二更新profile\">#</a> <strong>步骤二：更新 profile</strong></h5>\n<p>对 app 的任何更改都会导致现有的 profile 文件失效，所以需要重新生成 profile 描述文件。<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g38wg6kij20ia08qmxk.jpg\" alt=\"\" /><br />\n按照如下路径操作，点进已经 <code>invalid</code>  的描述文件并重新生成<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g3em4u2oj21fq0lc75x.jpg\" alt=\"\" /></p>\n<h5 id=\"步骤三生成密钥文件\"><a class=\"anchor\" href=\"#步骤三生成密钥文件\">#</a> <strong>步骤三：生成密钥文件</strong></h5>\n<p>进入如下界面点击 <code>加号</code> 进行生成<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g3hh2cz2j216m0ms406.jpg\" alt=\"\" /></p>\n<p>填完并勾选 <code>Sigin with apple</code>  后点击右侧的 <code>Configure</code>  进行配置，在配置页面选择需要开启苹果登录的 app 并保存，然后回到上一页并开始注册<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g3kyolw0j21m10u043i.jpg\" alt=\"\" /><br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g3ps0bfjj21v70u0td1.jpg\" alt=\"\" /><br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g3qw6gvmj22120s0dkq.jpg\" alt=\"\" /></p>\n<p>最终注册成功后会有 KeyID、TeamID 和可供下载的密钥文件<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g3umbtqzj21wg0s4gqg.jpg\" alt=\"\" /></p>\n<p>密钥文件格式为.p8 实际是文本文件<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g3yn74llj212g0badht.jpg\" alt=\"\" /></p>\n<p>&lt;font color=&quot;#dd0000&quot;&gt; 注意：密钥文件只能被下载一次，下载后保存在安全的地方，丢了的话只能重新申请了 &lt;/font&gt;&lt;br /&gt;</p>\n<h2 id=\"3登录流程\"><a class=\"anchor\" href=\"#3登录流程\">#</a> 3：登录流程</h2>\n<p>登录流程分两大块，一个是客户端部分，一个是后端部分，其中后端部分有两种校验方式 <code>基于授权码的后端验证</code> 、 <code>基于JWT的算法验证</code> ，稍后会一一讲解。总体流程如下图：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g4un5dizj20ve0u0dip.jpg\" alt=\"\" /></p>\n<h4 id=\"31-客户端侧\"><a class=\"anchor\" href=\"#31-客户端侧\">#</a> 3.1 客户端侧</h4>\n<h5 id=\"步骤一授权\"><a class=\"anchor\" href=\"#步骤一授权\">#</a> <strong>步骤一：授权</strong></h5>\n<p>对于客户端来说 AppleID 登录与传统的三方登录流程一样，分为 <code>调用接口</code> 与 <code>回调信息获取</code> 两步，唯一不同点是苹果登录的 API 是在 iOS SDK 内部封装，只用导入对应头文件即可<br />\n <code>#import &lt;AuthenticationServices/AuthenticationServices.h&gt; </code></p>\n<p>关于登录入口，苹果对 AppleID 登录的 UI 有严格的限制，因此专门提供了提供了一套继承于 <code>UIControl</code>  等控件来供开发者使用 <code>ASAuthorizationAppleIDButton</code></p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ASAuthorizationAppleIDButton * appleIDBtn = [ASAuthorizationAppleIDButton buttonWithType:ASAuthorizationAppleIDButtonTypeDefault style:ASAuthorizationAppleIDButtonStyleWhite];</span><br><span class=\"line\">appleIDBtn.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">100</span>, <span class=\"number\">60</span>);</span><br><span class=\"line\">[appleIDBtn addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(didAppleIDBtnClicked) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:appleIDBtn];</span><br></pre></td></tr></table></figure></p>\n<p>其中按钮的 <code>文案类型</code> 和 <code>UI风格</code> 可以通过枚举进行配置<br />\n <figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//  文案类型</span><br><span class=\"line\">typedef <span class=\"type\">NS_ENUM</span>(<span class=\"type\">NSInteger</span>, <span class=\"type\">ASAuthorizationAppleIDButtonType</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationAppleIDButtonTypeSignIn</span>,</span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationAppleIDButtonTypeContinue</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationAppleIDButtonTypeSignUp</span> <span class=\"type\">API_AVAILABLE</span>(ios(13.2), macos(10.15.1), tvos(13.1)) <span class=\"type\">API_UNAVAILABLE(watchos)</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationAppleIDButtonTypeDefault</span> = <span class=\"type\">ASAuthorizationAppleIDButtonTypeSignIn</span>,</span><br><span class=\"line\">&#125; <span class=\"type\">NS_SWIFT_NAME</span>(<span class=\"type\">ASAuthorizationAppleIDButton</span>.<span class=\"type\">ButtonType</span>) <span class=\"type\">API_AVAILABLE</span>(ios(13.0), macos(10.15), tvos(13.0)) <span class=\"type\">API_UNAVAILABLE</span>(watchos);</span><br><span class=\"line\"></span><br><span class=\"line\">//  <span class=\"type\">UI</span>风格</span><br><span class=\"line\">typedef <span class=\"type\">NS_ENUM</span>(<span class=\"type\">NSInteger</span>, <span class=\"type\">ASAuthorizationAppleIDButtonStyle</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationAppleIDButtonStyleWhite</span>,</span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationAppleIDButtonStyleWhiteOutline</span>,</span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationAppleIDButtonStyleBlack</span>,</span><br><span class=\"line\">&#125; <span class=\"type\">NS_SWIFT_NAME</span>(<span class=\"type\">ASAuthorizationAppleIDButton</span>.<span class=\"type\">Style</span>) <span class=\"type\">API_AVAILABLE</span>(ios(13.0), macos(10.15), tvos(13.0)) <span class=\"type\">API_UNAVAILABLE</span>(watchos);</span><br></pre></td></tr></table></figure><br />\n 但是并不推荐这种方式使用，原因如下：</p>\n<ul>\n<li>1：固定 UI 无法满足业务的定制化需求</li>\n<li>2：文案固定，多语言配置需要在单独的地方去配置文案</li>\n</ul>\n<p>所以建议自己写 UI，直接在点击事件中调用 AppleID 的相关 API 进行授权登陆操作，具体代码为，其中 <code>ASAuthorizationAppleIDRequest</code>  为是否使用 Keychain 信息，如果如果 KeyChain 里面也有登录信息的话，可以直接使用里面保存的用户名和密码进行登录。可以根据实际业务需求来<br />\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">KINFO</span>(@<span class=\"string\">&quot;[AppleLoginWrapper]开始苹果登录鉴权&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">@available</span>(<span class=\"keyword\">iOS</span> <span class=\"number\">13.0</span>, <span class=\"operator\">*</span>)) &#123;</span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationAppleIDProvider</span> <span class=\"operator\">*</span>provider <span class=\"operator\">=</span> [<span class=\"type\">ASAuthorizationAppleIDProvider</span> new];</span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationAppleIDRequest</span> <span class=\"operator\">*</span>request <span class=\"operator\">=</span> [provider createRequest];</span><br><span class=\"line\">    request.requestedScopes <span class=\"operator\">=</span> @[ <span class=\"type\">ASAuthorizationScopeFullName</span>, <span class=\"type\">ASAuthorizationScopeEmail</span> ]; <span class=\"comment\">//请求的用户信息</span></span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationPasswordRequest</span> <span class=\"operator\">*</span> keychainRequest <span class=\"operator\">=</span> [[[<span class=\"type\">ASAuthorizationPasswordProvider</span> alloc] <span class=\"keyword\">init</span>] createRequest];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationController</span> <span class=\"operator\">*</span>vc <span class=\"operator\">=</span> [[<span class=\"type\">ASAuthorizationController</span> alloc] initWithAuthorizationRequests:@[ request ,keychainRequest]];</span><br><span class=\"line\">    vc.delegate <span class=\"operator\">=</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    vc.presentationContextProvider <span class=\"operator\">=</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    [vc performRequests];</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Fallback on earlier versions</span></span><br><span class=\"line\">    <span class=\"type\">KINFO</span>(@<span class=\"string\">&quot;[AppleLoginWrapper]iOS系统低于13&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"步骤二信息回调\"><a class=\"anchor\" href=\"#步骤二信息回调\">#</a> <strong>步骤二：信息回调</strong></h5>\n<p>依赖的两个 delegate<br />\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark- 代理 ASAuthorizationControllerDelegate</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)authorizationController:(ASAuthorizationController *)controller didCompleteWithAuthorization:(ASAuthorization *)authorization &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  成功</span></span><br><span class=\"line\">    <span class=\"comment\">//  其中`authorization.credential`包含了Token，用户ID等授权所需信息，可上报到后台</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"type\">void</span>)authorizationController:(ASAuthorizationController *)controller didCompleteWithError:(<span class=\"built_in\">NSError</span> *)error &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  失败</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark- 代理ASAuthorizationControllerPresentationContextProviding</span></span><br><span class=\"line\">- (ASPresentationAnchor)presentationAnchorForAuthorizationController:(ASAuthorizationController *)controller &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  展示在哪个Window上</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.view.window;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"步骤三用户id状态校验\"><a class=\"anchor\" href=\"#步骤三用户id状态校验\">#</a> <strong>步骤三：用户 ID 状态校验</strong></h5>\n<p>防止用户注销 AppleId 或 停止使用 Apple ID 的状态处理<br />\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">-</span> (<span class=\"type\">BOOL</span>)application:(<span class=\"type\">UIApplication</span> <span class=\"operator\">*</span>)application didFinishLaunchingWithOptions:(<span class=\"type\">NSDictionary</span> <span class=\"operator\">*</span>)launchOptions &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Override point for customization after application launch.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">@available</span>(<span class=\"keyword\">iOS</span> <span class=\"number\">13.0</span>, <span class=\"operator\">*</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 注意 存储用户标识信息需要使用钥匙串来存储 这里使用NSUserDefaults 做的简单示例</span></span><br><span class=\"line\">        <span class=\"type\">NSString</span> <span class=\"operator\">*</span> userIdentifier <span class=\"operator\">=</span> [[<span class=\"type\">NSUserDefaults</span> standardUserDefaults] valueForKey:@<span class=\"string\">&quot;appleID&quot;</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (userIdentifier) &#123;</span><br><span class=\"line\">            <span class=\"type\">ASAuthorizationAppleIDProvider</span> <span class=\"operator\">*</span> appleIDProvider <span class=\"operator\">=</span> [[<span class=\"type\">ASAuthorizationAppleIDProvider</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">            [appleIDProvider getCredentialStateForUserID:userIdentifier</span><br><span class=\"line\">                                              completion:<span class=\"operator\">^</span>(<span class=\"type\">ASAuthorizationAppleIDProviderCredentialState</span> credentialState, <span class=\"type\">NSError</span> <span class=\"operator\">*</span> _Nullable error) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">switch</span> (credentialState) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"type\">ASAuthorizationAppleIDProviderCredentialAuthorized</span>:</span><br><span class=\"line\">                        <span class=\"comment\">// 授权状态有效</span></span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"type\">ASAuthorizationAppleIDProviderCredentialRevoked</span>:</span><br><span class=\"line\">                        <span class=\"comment\">// 苹果账号登录的凭据已被移除，需解除绑定并重新引导用户使用苹果登录</span></span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"type\">ASAuthorizationAppleIDProviderCredentialNotFound</span>:</span><br><span class=\"line\">                        <span class=\"comment\">// 未登录授权，直接弹出登录页面，引导用户登录</span></span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"type\">ASAuthorizationAppleIDProviderCredentialTransferred</span>:</span><br><span class=\"line\">                        <span class=\"comment\">// 授权AppleID提供者凭据转移</span></span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">YES</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"32-sever侧\"><a class=\"anchor\" href=\"#32-sever侧\">#</a> 3.2 Sever 侧</h4>\n<p>基于上面流程图，Sever 侧校验 Token 有效性的方式有两种：</p>\n<h5 id=\"方式一基于授权码的后端验证\"><a class=\"anchor\" href=\"#方式一基于授权码的后端验证\">#</a> <strong>方式一：基于授权码的后端验证</strong></h5>\n<p>后端在收到客户端传递的包含 token 的信息后进行验证</p>\n<ul>\n<li>构建 client_secret<br />\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----BEGIN PRIVATE KEY-----</span><br><span class=\"line\">BASE64编码后的密钥 (步骤<span class=\"number\">2.2</span>中获得)</span><br><span class=\"line\">-----END PRIVATE KEY-----</span><br><span class=\"line\"> </span><br><span class=\"line\">public  byte<span class=\"literal\">[]</span> read<span class=\"constructor\">Key()</span> throws Exception &#123;</span><br><span class=\"line\">    String temp = <span class=\"string\">&quot;密钥文件中间的编码字符串&quot;</span>;</span><br><span class=\"line\">    return <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Base64</span>.</span></span>decode<span class=\"constructor\">Base64(<span class=\"params\">temp</span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">构建client_secret关键代码：</span><br><span class=\"line\"></span><br><span class=\"line\">String client_id = <span class=\"string\">&quot;...&quot;</span>; <span class=\"comment\">// 被授权的APP ID(步骤2.2中获得)</span></span><br><span class=\"line\">Map&lt;String, Object&gt; header = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;<span class=\"literal\">()</span>;</span><br><span class=\"line\">header.put(<span class=\"string\">&quot;kid&quot;</span>, <span class=\"string\">&quot;密钥id&quot;</span>); <span class=\"comment\">// 参考后台配置(步骤2.2中获得)</span></span><br><span class=\"line\">Map&lt;String, Object&gt; claims = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;<span class=\"literal\">()</span>;</span><br><span class=\"line\">claims.put(<span class=\"string\">&quot;iss&quot;</span>, <span class=\"string\">&quot;team id&quot;</span>); <span class=\"comment\">// 参考后台配置 team id(步骤2.2中获得)</span></span><br><span class=\"line\">long now = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>current<span class=\"constructor\">TimeMillis()</span><span class=\"operator\"> / </span><span class=\"number\">1000</span>;</span><br><span class=\"line\">claims.put(<span class=\"string\">&quot;iat&quot;</span>, now);</span><br><span class=\"line\">claims.put(<span class=\"string\">&quot;exp&quot;</span>, now + <span class=\"number\">86400</span><span class=\"operator\"> * </span><span class=\"number\">30</span>); <span class=\"comment\">// 最长半年，单位秒</span></span><br><span class=\"line\">claims.put(<span class=\"string\">&quot;aud&quot;</span>, <span class=\"string\">&quot;https://appleid.apple.com&quot;</span>); <span class=\"comment\">// 默认值</span></span><br><span class=\"line\">claims.put(<span class=\"string\">&quot;sub&quot;</span>, client_id);</span><br><span class=\"line\">PKCS8EncodedKeySpec pkcs8EncodedKeySpec = <span class=\"keyword\">new</span> <span class=\"constructor\">PKCS8EncodedKeySpec(<span class=\"params\">readKey</span>()</span>);</span><br><span class=\"line\">KeyFactory keyFactory = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">KeyFactory</span>.</span></span>get<span class=\"constructor\">Instance(<span class=\"string\">&quot;EC&quot;</span>)</span>;</span><br><span class=\"line\">PrivateKey privateKey = keyFactory.generate<span class=\"constructor\">Private(<span class=\"params\">pkcs8EncodedKeySpec</span>)</span>;</span><br><span class=\"line\">String client_secret = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Jwts</span>.</span></span>builder<span class=\"literal\">()</span>.set<span class=\"constructor\">Header(<span class=\"params\">header</span>)</span>.set<span class=\"constructor\">Claims(<span class=\"params\">claims</span>)</span>.sign<span class=\"constructor\">With(SignatureAlgorithm.ES256, <span class=\"params\">privateKey</span>)</span>.compact<span class=\"literal\">()</span>;       </span><br></pre></td></tr></table></figure></li>\n<li>验证客户端 Token<br />\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span> <span class=\"built_in\">url</span> = <span class=\"string\">&quot;https://appleid.apple.com/auth/token&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// POST 请求</span></span><br><span class=\"line\">HttpSynClient client = <span class=\"keyword\">new</span> HttpSynClient(<span class=\"number\">5000</span>, <span class=\"number\">5000</span>, <span class=\"number\">5000</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">String</span>&gt; form = <span class=\"keyword\">new</span> HashMap&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">String</span>&gt;();</span><br><span class=\"line\">form.put(<span class=\"string\">&quot;client_id&quot;</span>, client_id);</span><br><span class=\"line\">form.put(<span class=\"string\">&quot;client_secret&quot;</span>, client_secret);</span><br><span class=\"line\">form.put(<span class=\"string\">&quot;code&quot;</span>, code);form.put(<span class=\"string\">&quot;grant_type&quot;</span>,<span class=\"string\">&quot;authorization_code&quot;</span>);</span><br><span class=\"line\">form.put(<span class=\"string\">&quot;redirect_uri&quot;</span>, redirectUrl);</span><br><span class=\"line\">HttpResponse result = client.excutePost(<span class=\"built_in\">url</span>, form);</span><br><span class=\"line\">System.out.println(result);</span><br></pre></td></tr></table></figure></li>\n<li>上述步骤结束后即可将结果回调给客户端，进行登录或者是错误处理\n<ul>\n<li>成功示例<br />\n <figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\"><span class=\"attr\">&quot;access_token&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;a0996b16cfb674c0eb0d29194c880455b.0.nsww.5fi5MVC-i3AVNhddrNg7Qw&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;token_type&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;Bearer&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;expires_in&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">3600</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;refresh_token&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;r9ee922f1c8b048208037f78cd7dfc91a.0.nsww.KlV2TeFlTr7YDdZ0KtvEQQ&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;id_token&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;eyJraWQiOiJBSURPUEsxIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL2FwcGxlaWQuYXBwbGUuY29tIiwiYXVkIjoiY29tLnNreW1pbmcuYXBwbGVsb2dpbmRlbW8iLCJleHAiOjE1NjU2NjU1OTQsImlhdCI6MTU2NTY2NDk5NCwic3ViIjoiMDAwMjY2LmRiZTg2NWIwYWE3MjRlMWM4ODM5MDIwOWI5YzdkNjk1LjAyNTYiLCJhdF9oYXNoIjoiR0ZmODhlX1ptc0pqQ2VkZzJXem85ZyIsImF1dGhfdGltZSI6MTU2NTY2NDk2M30.J6XFWmbr0a1hkJszAKM2wevJF57yZt-MoyZNI9QF76dHfJvAmFO9_RP9-tz4pN4ua3BuSJpUbwzT2xFD_rBjsNWkU-ZhuSAONdAnCtK2Vbc2AYEH9n7lB2PnOE1mX5HwY-dI9dqS9AdU4S_CjzTGnvFqC9H5pt6LVoCF4N9dFfQnh2w7jQrjTic_JvbgJT5m7vLzRx-eRnlxQIifEsHDbudzi3yg7XC9OL9QBiTyHdCQvRdsyRLrewJT6QZmi6kEWrV9E21WPC6qJMsaIfGik44UgPOnNnjdxKPzxUAa-Lo1HAzvHcAX5i047T01ltqvHbtsJEZxAB6okmwco78JQA&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></li>\n<li>失败示例<br />\n <figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\"><span class=\"attr\">&quot;error&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;invalid_client&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"方式二基于jwt验证原理\"><a class=\"anchor\" href=\"#方式二基于jwt验证原理\">#</a> <strong>方式二：基于 JWT 验证原理</strong></h5>\n<ul>\n<li>\n<p>获取苹果公钥，并保存</p>\n<p>用到公钥接口  <code>https://appleid.apple.com/auth/keys</code> <br />\n 返回值样例<br />\n <figure class=\"highlight prolog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"string\">&quot;keys&quot;</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;kty&quot;</span>: <span class=\"string\">&quot;RSA&quot;</span>, </span><br><span class=\"line\">        <span class=\"string\">&quot;kid&quot;</span>: <span class=\"string\">&quot;AIDOPK1&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;use&quot;</span>: <span class=\"string\">&quot;sig&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;alg&quot;</span>: <span class=\"string\">&quot;RS256&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;n&quot;</span>: <span class=\"string\">&quot;lxrwmuYSAsTfn-lUu4goZSXBD9ackM9OJuwUVQHmbZo6GW4Fu_auUdN5zI7Y1dEDfgt7m7QXWbHuMD01HLnD4eRtY-RNwCWdjNfEaY_esUPY3OVMrNDI15Ns13xspWS3q-13kdGv9jHI28P87RvMpjz_JCpQ5IM44oSyRnYtVJO-320SB8E2Bw92pmrenbp67KRUzTEVfGU4-obP5RZ09OxvCr1io4KJvEOjDJuuoClF66AT72WymtoMdwzUmhINjR0XSqK6H0MdWsjw7ysyd_JhmqX5CAaT9Pgi0J8lU_pcl215oANqjy7Ob-VMhug9eGyxAWVfu_1u6QJKePlE-w&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;e&quot;</span>: <span class=\"string\">&quot;AQAB&quot;</span></span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>验证客户端的 Token 有效性</p>\n<p>客户端会传以下几个值给服务端</p>\n<ul>\n<li>\n<p>userID：授权的用户唯一标识</p>\n</li>\n<li>\n<p>email、fullName：授权的用户资料</p>\n</li>\n<li>\n<p>authorizationCode：授权 code</p>\n</li>\n<li>\n<p>identityToken：授权用户的 JWT 凭证<br />\n示例 identityToken：授权用户的 JWT 凭证<br />\n <figure class=\"highlight smali\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eyJraWQiOiJBSURPUEsxIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL2FwcGxlaWQuYXBwbGUuY29tIiwiYXVkIjoiY29tLmZ1bi5BcHBsZUxvZ2luIiwiZXhwIjoxNTY4NzIxNzY5LCJpYXQiOjE1Njg3MjExNjksInN1YiI6IjAwMDU4MC4wODdjNTU0ZGNlMzU0NjZmYTg1YzVhNWQ1OTRkNTI4YS4wODAxIiwiY19oYXNoIjoiel9KY0RscFczQjJwN3ExR0Nna1JaUSIsImF1dGhfdGltZSI6MTU2ODcyMTE2OX0.WmSa4LzOzYsdwTqAJ_8mub4Ls3eyFkxZoGLoy-U7DatsTd_JEwAs3_OtV4ucmj6ENT3153iCpYY6vBxSQromOMcXsN74IrUQew24y_zflN2g4yU8ZVvBCbTrR_6p9f2fbeWjZiyNcbPCha0dv45E3vBjyHhmffWnk3vyndBBiwwuqod4pyCZ3UECf6Vu-o7dygKFpMHPS1ma60fEswY5d-_TJAFk1HaiOfFo0XbL6kwqAGvx8HnraIxyd0n8SbBVxV_KDxf15hdotUizJDW7N2XMdOGQpNFJim9SrEeBhn9741LWqkWCgkobcvYBZsrvnUW6jZ87SLi15rvIpq8_fw</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\ntoken 被解密后分为三个部分</p>\n</li>\n<li>\n<p>header: 包括了 key id 与加密算法</p>\n</li>\n<li>\n<p>payload:</p>\n<ul>\n<li>iss: 签发机构，苹果</li>\n<li>aud: 接收者，目标 app</li>\n<li>exp：过期时间</li>\n<li>iat: 签发时间</li>\n<li>sub: 用户 id</li>\n<li>c_hash: 一个哈希数列</li>\n<li>auth_time: 签名时间</li>\n</ul>\n</li>\n<li>\n<p>signature: 用于验证 JWT 的签名</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Token 验证原理：</p>\n<p>因为 idnetityToken 使用非对称加密 RSASSA【RSA 签名算法】 和 ECDSA【椭圆曲线数据签名算法】，当验证签名的时候，利用公钥来解密 Singature，当解密内容与 base64UrlEncode (header) + “.” + base64UrlEncode (payload) 的内容完全一样的时候，表示验证通过。</p>\n</li>\n<li>\n<p>防止中间人攻击原理：</p>\n<p>该 token 是苹果利用私钥生成的一段 JWT，并给出公钥我们对 token 进行验证，由于中间人并没有苹果的私钥，所以它生成出来的 token 是没有办法利用苹果给出的公钥进行验证的，确保的 token 的安全性。</p>\n</li>\n</ul>\n<h2 id=\"4-总结\"><a class=\"anchor\" href=\"#4-总结\">#</a> 4 总结</h2>\n<p>目前使用的是基于授权码的后端验证方式，每次收到客户端登录请求后都会像苹果服务器发送 post 请求来验证，导致受网络影响较大。如果改成第一种方式后，除了获取公钥外不再依赖网络请求，可降低网络异常情况带来的损失。但是服务端要定期刷新公钥，防止公钥变化带来的验证失败</p>\n<h2 id=\"5-参考文档\"><a class=\"anchor\" href=\"#5-参考文档\">#</a> 5 参考文档</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIub2t0YS5jb20vYmxvZy8yMDE5LzA2LzA0L3doYXQtdGhlLWhlY2staXMtc2lnbi1pbi13aXRoLWFwcGxl\">https://developer.okta.com/blog/2019/06/04/what-the-heck-is-sign-in-with-apple</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2NuL3NpZ24taW4td2l0aC1hcHBsZS8=\">https://developer.apple.com/cn/sign-in-with-apple/</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2RvY3VtZW50YXRpb24vc2lnbmlud2l0aGFwcGxlcmVzdGFwaS9nZW5lcmF0ZV9hbmRfdmFsaWRhdGVfdG9rZW5z\">https://developer.apple.com/documentation/signinwithapplerestapi/generate_and_validate_tokens</span></p>\n",
            "tags": [
                "iOS",
                "Apple登录"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2021-07-27-%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E4%B8%80%E5%9C%BAPresentation/",
            "url": "https://oliverqueen.cn/2021-07-27-%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E4%B8%80%E5%9C%BAPresentation/",
            "title": "如何做好一场Presentation",
            "date_published": "2021-07-26T16:14:53.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"0x1-前言\"><a class=\"anchor\" href=\"#0x1-前言\">#</a> 0X1 前言：</h2>\n<p>其实很早就想写这篇文章了，当时晋级答辩之后本想趁热打铁，把自己的一些经历和想法分享出来和大家一起探讨，但是工作上的事情七七八八，再加上拖延症犯了，所以导致直到今天大家才能看到这篇文章。不奢求大家看过文章后晋级答辩就能一路绿灯，只是希望能在答辩季这关键时期给需要的人些许的启发或者能与大家产生一些共鸣，更主要的是希望本文能起到抛砖引玉的作用，大家都可以将自己的经历和想法分享出来。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNgy1gsvni8ogskj31ts0u00zc.jpg\" alt=\"\" /></p>\n<p><span id=\"more\"></span></p>\n<p>对于大部分开发同学来说，Presentation 一直都是短板，因为答辩不仅仅是技术能力本身的体现，还涉及到包括但不限于以下几个方面：</p>\n<ul>\n<li>\n<p>信息分类检索聚合能力。</p>\n</li>\n<li>\n<p>PPT 的书写能力。</p>\n</li>\n<li>\n<p>临场发挥、表达能力。</p>\n</li>\n</ul>\n<h2 id=\"0x2-如何选取素材\"><a class=\"anchor\" href=\"#0x2-如何选取素材\">#</a> 0x2 如何选取素材？</h2>\n<p>想要解决问题就要知道都有哪些问题，以及这些问题是怎么来的，然后再对症下药。在答辩前也跟不少同事聊过，总结了几个大家都会提到的问题，其中被提到次数最多的就是 “不知道要答什么”。每个人都会说，这半年没做过什么 &lt; font color=&quot;#dd0000&quot;&gt; 有技术含量 &lt;/font &gt; 的事情，&lt;font color=&quot;#dd0000&quot;&gt; 业务需求 &lt;/font &gt; 都忙不过来。关键字已经标红，可以看出来这两个因素是阻挠我们的真凶。</p>\n<h4 id=\"21技术含量\"><a class=\"anchor\" href=\"#21技术含量\">#</a> 2.1：技术含量？</h4>\n<p>对于一个技术答辩来说什么样的事情算是有技术含量？其实并不一定是那种前无古人后无来者的高精尖技术突破，也不是多么高深莫测的技术点。其实做移动端，或者大前端开发的人都知道，互联网在我国也有几十年的发展史，能挖的技术点早已经被挖透了，各种知识随便 google 一下就一大堆，想在这种环境下研究新技术出来实在是难于登天。所以大家有这样的疑问也是情理之中的。</p>\n<p>既然这样我们何不换一个思路去思考问题，稍稍改变一下 <code>技术含量</code> 这个词的定义。我个人的理解是 <code>在技术方面能对现有项目起到正向优化效果，或者能提高现有工作的效率的工作</code> ，凡是这样的工作，都值得被用来答辩或者作为 Presentation 的素材，这样一来，是不是感觉能答辩的东西就很多了，可选的范围变广了。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNgy1gsuruavcq7j30u00k40uw.jpg\" alt=\"\" /></p>\n<h4 id=\"22业务需求\"><a class=\"anchor\" href=\"#22业务需求\">#</a> 2.2：业务需求？</h4>\n<p>这是这里面临第二个 “难题”。的确大部分的同事的大部分时间都跟业务需求打交道，需求的点子是产品同学想的，代码也是按照需求单里面的写的，乍一看确实没什么可说的。但是大家都是在公司上班的人，业务需求肯定躲不过。其实现代技术的发展一开始都是由人类需求来驱动的。比如音视频编码技术，流媒体技术，各种加解密、排序算法等，都是先有需求再有技术产出，而针对同一个需求的不同技术方案也有 <code>优劣差异</code> ，比如 H264,H265；比如各种排序算法的复杂度等。所以我们答辩的内容最好是要从平时各种需求去挖掘，而实现需求时方案的 <code>优劣差异</code> 正是我们需要展示出的亮点。这一套做完后我们再通过业务需求本身的一些数据来佐证我们论点。</p>\n<p>这样一来形成一个完整的闭环，让 <code>业务需求</code> 从绊脚石变成促成我们一次答辩或者 Presentation 成功的一个助推剂。有业务需求作为支撑，可以使我们的内容更加有说服力，不至于让我们的 presentation 变成纸上谈兵。换句话来说，过多的业务需求未必是一件坏事，不过这就需要我们在做每个需求时都要有认真的思考，我们不仅仅是要完成需求本事，而是要考虑同样的工作如何做的更好。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNgy1gsurso7t1lj30xc0huaau.jpg\" alt=\"\" /></p>\n<p>这时候一定会有人说，技术需求大多简单没什么值得说的地方。其实对于移动端来说，目前的编程语言都已经是非常高级的语言，我们在平时的开发中几乎接触不到底层的东西，比如汇编，或者硬件之类的。安卓和苹果都通过层层封装为开发者屏蔽了底层的实现，但是我们真的明白当我调用一个高级接口的时候底层都做了哪些事情吗？打个很简单的比方：大家都知道圆角或者透明图层会导致离屏渲染，会影响性能，但是有多少人能说出为什么会离屏渲染？离屏渲染时候 CPU 在做什么、GPU 在做什么？切圆角触发了哪些 GPU 的指令？GPU 和 CPU 以及各种显示管线是如何交互的？其实我们并不是缺少素材，而是缺乏透过问题看本质的能力。对于大前端来说我们接触到的都只是冰山一角，而冰山下面的东西是值得我们去细细挖掘的。</p>\n<h4 id=\"23兜底策略\"><a class=\"anchor\" href=\"#23兜底策略\">#</a> 2.3：兜底策略！</h4>\n<p>如果看了上面两段还是不知道说什么那兜底策略就是： <code>能报就报，先报再说</code> ，人都是有惰性的，不逼自己一把永远不知道自己的潜力，而且对自己个人成长有益事情要学会争取，答辩或者 presentation 的意义不仅仅是升职加薪，其中的过程也能学到很多东西，对自己各方面能力都是很大的提高，之前基本所有参与过的同学都说过：“答辩掉层皮，但是能学到很多东西”。对于这种好事我们怎么能拒绝呢？</p>\n<h2 id=\"0x3-开始ppt之前要做什么\"><a class=\"anchor\" href=\"#0x3-开始ppt之前要做什么\">#</a> 0x3 开始 PPT 之前要做什么</h2>\n<p>PPT 是答辩中必不可少的一个部分，但是 PPT 只是一个辅助工具，他的作用是把自己的想法更加具象的表达出来。所以最重要的是我们的想法和思路，以及我们的内容，在这里笔者建议 &lt;font color=&quot;#dd0000&quot;&gt; 不要着急写 PPT！&lt;/font&gt;，因为过早的写 PPT 就避免不了后期大量的修改，很容易导致前功尽弃。而且过早的写也容易禁锢自己的思路。</p>\n<p>对于什么时候开始写，这个可能要取决于每个人内容的积累程度，当你相关的知识储备到达一定量级的时候你自然就会感觉” 下笔如有神 “，这个时候就可以开始了。这里还是建议最晚开始时间要在答辩前一个月左右。关于如何做知识积累，我这边有个方法：在平时工作时候，将答辩相关的知识点全部都记录在一个文档里，不需要记录多详细，可能是一行网址、一个截图、一个书名 + 页数，甚至是一行 API。在 PPT 开始前必须保证这个文档已经形成了一套较为完整的知识体系，这样之后才能快速高质量的完成 PPT。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNgy1gsvme0203eg30f80gonpr.gif\" alt=\"\" /></p>\n<p>这里用笔者的亲身经历举例，第一次答辩时候没有经验，很早就把重心放到了 PPT 书写上，导致在该做技术积累的时候时间都花在构思 PPT 上。最终的结果就是 PPT 改了无数版，面目全非，而且最后发现技术深度不够，信息密度不够，才开始后期恶补。第二次答辩吸取了教训，早早地就把各种相关知识点沉淀到文档中，确定了大方向和提纲。然后最后一个月左右的时间，从该文档中进行信息提取整合，写 PPT 的效率翻倍，而且自始至终基本不会有结构上太大的修改。</p>\n<h2 id=\"0x4-如何写ppt\"><a class=\"anchor\" href=\"#0x4-如何写ppt\">#</a> 0x4 如何写 PPT</h2>\n<p>知道了要讲什么东西，那这节来看看如何把一件事情清晰的描述出来。就像写代码一样，任何事情都要有条理，要有先后顺序，先讲什么后讲什么，都必须遵循一定的规律，虽说不上要引人入胜，但是至少让听众或者评委能顺着你的思路走。所以在写 PPT 或者演讲稿之前要从上帝视角来审视整个流程，整理出一个大概的提纲，之后的工作才是细化内容，挖掘深度等。根据事物发展的客观规律，并以时间线为依托，一个好的描述手法基本可以分为以下几个部分。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNgy1gsuv69e6bkg30xc0ioql2.gif\" alt=\"\" /></p>\n<h4 id=\"41背景\"><a class=\"anchor\" href=\"#41背景\">#</a> 4.1：背景</h4>\n<p>做任何事情都有原因，在开始一切之前反问一下自己 <code>我为什么要做这个事情？</code> 。但是这里的原因并不是” 因为有这个产品需求所以我做了 “，因为 presentation 的素材绝对不是需求本身，而是由需求引出的更高层次的思考，来源于需求，高于需求。因此 &lt; font color=&quot;#dd0000&quot;&gt; 背景是建立在你对现状清晰的认识的基础上，指出现阶段存在的问题，并表达出要迫切优化的诉求 &lt;/font&gt;。换句话说 <code>背景</code> 就是让听众带着问题听下去，你也可以通过不同的问题来主导听众的思考方向。</p>\n<ul>\n<li>描述方式：背景的描述方式尽量采用 &lt;font color=&quot;#dd0000&quot;&gt;1. 2. 3.  ... 点来列出来 &lt;/font&gt;，这样不仅清晰明了，而且也方便后面的针对性解答，起到点题的作用。</li>\n</ul>\n<h4 id=\"42竞品对比\"><a class=\"anchor\" href=\"#42竞品对比\">#</a> 4.2：竞品对比</h4>\n<p>之前也讲过，互联网发展这么久，任何问题都有现成的解决方案，所以你能想到的问题其他人也一定会想到，说不定别人已经有了一套成熟的体系，所以要体现自己的价值就一定要找到我们比他强的地方，或者是我们不能用他人的只能用你的原因。这点很重要，前期不做好功课，不然等评委问道了 <code>用XXX一样可以解决问题，你为什么还重复造轮子?</code>  的时候哑口无言，那就很尴尬了。</p>\n<p>竞品对比要尽量找些知名度较高的竞品，这样更有说服力，也更能衬托出你所做内容的优势。同时要思考全面，让听众能感受到你对行业的敏感性和思考问题的全面性。</p>\n<ul>\n<li>描述方式：该模块尽量采用 &lt;font color=&quot;#dd0000&quot;&gt; 表格 &lt;/font &gt; 描述，通过不同维度的对比来突出自己的优势。但是有一点要注意，不要一味的贬低竞品，可以在一些无关痛痒或者跟本次演讲内容无关的地方去肯定他人的做法，不然会让人觉得你做的东西也比较廉价。</li>\n</ul>\n<h4 id=\"43工作内容描述\"><a class=\"anchor\" href=\"#43工作内容描述\">#</a> 4.3：工作内容描述</h4>\n<p>这个环节就是真正开始描述自己所做的事情，有以下几点要注意</p>\n<ul>\n<li>\n<p>不要写流水账，要突出亮点。</p>\n</li>\n<li>\n<p>尽量不要贴代码，除非你的代码很优秀没有破绽，或者是官方 API，不然非常容易被挑战。</p>\n</li>\n<li>\n<p>文字一定要越少越好，不然很容易变成照着读 (那样评委就会自己读而不去听你讲的了)，把你想写的话尽量通过图表达出来。</p>\n</li>\n<li>\n<p>每一页的内容不要过多，一页不能出现两个主题。</p>\n</li>\n<li>\n<p>合理使用动画和转场效果，避免花里胡哨。</p>\n</li>\n<li>\n<p>描述顺序最好跟照前面背景中提到的问题顺序一致，这样可以保证和背景中的问题要一一对应起来。</p>\n</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNgy1gsvkt02wfaj30hi0b7q47.jpg\" alt=\"\" /></p>\n<h4 id=\"44数据佐证\"><a class=\"anchor\" href=\"#44数据佐证\">#</a> 4.4：数据佐证</h4>\n<p>对于任何的工作，数据是最有说服力的证明，尽量选择线上数据，进行纵向、横向对比</p>\n<ul>\n<li>\n<p>纵向对比：同一个项目中，在你所做工作介入前和介入后 对于项目某项指标的提升做对比。</p>\n</li>\n<li>\n<p>横向对比：同市面上的其他相似方案在对于项目的某项指标上的提升进行对比，类似于上文提到的竞品对比。</p>\n</li>\n<li>\n<p>描述方式：尽量采用表格，饼图、折线图等数据图表并配以少量的文字描述来进行展示。</p>\n</li>\n</ul>\n<h4 id=\"45后续优化点\"><a class=\"anchor\" href=\"#45后续优化点\">#</a> 4.5：后续优化点</h4>\n<p>对于在计划中但还没有完成或开始的工作可以写到该模块下，但是要注意的是该处不要写 <code>过于简单或者很容易实现</code> 的内容，不然很容易被挑战：” 为什么不一起做完再来讲？“。该模块还有一个重要的功能就是对上面所讲内容的一个补充，体现出自己考虑问题的广度和深度。对于该模块所涉及到的知识点可以理解的不那么细，毕竟是预研阶段，但是要让评委或者是听众知道你在有计划的执行下去，同时后续方案已经具备了一定的可行性。</p>\n<h4 id=\"46关于口水稿\"><a class=\"anchor\" href=\"#46关于口水稿\">#</a> 4.6：关于口水稿</h4>\n<p>口水稿就是把自己要说的一字不漏的直接写在 PPT 备注里面，包含一些白话和口语。可能大多数同学会认为，对于一些不善于表达的同学可以添加口水稿。但是个人觉得对于每个人来说口水稿都是必要的，不仅仅是在答辩过程中能给你相应的提示，更重要的是写口水稿的过程其实就是模拟答辩的过程，你可以梳理自己的思路，对于 PPT 查漏补缺。这一点是非常重要的。一般在最后一到两版的 PPT 开始写口水稿，笔者在这个期间也发现了很多问题，其中不乏一些逻辑错误，或者表达错误。</p>\n<h4 id=\"47其他建议\"><a class=\"anchor\" href=\"#47其他建议\">#</a> 4.7：其他建议</h4>\n<ul>\n<li>\n<p>关于主题</p>\n<p>尽量选择一个主题来表述，如果一定要选择多个项目，一定要分清主次，最好 1：9 或者 2：8 来讲，同时非主要内容要先讲，然后再开始最重要的内容。因为大部分评委或者听众会对你最后讲的内容记忆深刻，而且 Q&amp;A 环节也是在最后。</p>\n</li>\n<li>\n<p>关于篇幅</p>\n<p>答辩总时长 30 分钟，PPT 最终有效页数要控制在 35 页内，如果超了这个页数说明你的内容不够精简，要做适当的调整，&lt;font color=&quot;#dd0000&quot;&gt; 确保每一个字都不是废话，都要有自己的使命。&lt;/font&gt;</p>\n</li>\n</ul>\n<h2 id=\"0x5-答辩前如何准备\"><a class=\"anchor\" href=\"#0x5-答辩前如何准备\">#</a> 0x5 答辩前如何准备</h2>\n<p>&lt;/br&gt;</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNgy1gsvmqw7dnkj30u00w6jtv.jpg\" alt=\"\" /></p>\n<p>&lt;/br&gt;</p>\n<p>很多同学会担心紧张，个人认为其实紧张分两种，一种是正常的生理反应，这个谁都避免不了，但是这样的紧张基本不会影响到临场的发挥。另一种就是由于自己准备不充分而带来的慌张、自我怀疑、没有安全感的状态，这个就比较可怕，他会极大的影响到你的发挥表现，而且准备不充分本身就是致命的错误。</p>\n<p>其实第二种紧张的状态也比较好解决，这里提供几个方法：</p>\n<ul>\n<li>\n<p>自己在家或者会议室多进行模拟答辩 (要卡时间 30 分钟)，对自己要求高的可以进行脱稿。</p>\n</li>\n<li>\n<p>多找资深的同事或者 leader 帮你过 PTT。</p>\n</li>\n<li>\n<p>积极参加团队内的预答辩，争取一切表现自己的机会。</p>\n</li>\n<li>\n<p>尽可能的考虑周全，把评委可能挑战的点都想到，同时要有兜底策略，如果评委真的问道没有准备的或者不会的问题要怎么办 (这个可以找过来人分享他们的经验)。</p>\n</li>\n</ul>\n<p>真正的胸有成竹的时候你会有一种急于展示自我的跃跃欲试的感觉，与其说紧张倒不如说激动，当你有这种感觉的时候说明你离成功不远了。自信的人才最有可能发挥自己的全部实力。</p>\n<h2 id=\"0x6-最后\"><a class=\"anchor\" href=\"#0x6-最后\">#</a> 0x6 最后</h2>\n<p>如果你都已经按照上面做了，那么其实最后的结果已经不重要了，我相信每个公司设立答辩机制的初衷一定都是提高员工的综合能力，提高公司整体竞争力，增进员工间的良性竞争氛围，提升技术产品敏感度等。这些都与职级和薪酬无关。全力以赴准备一次答辩，你就基本已经具备了这些优秀的特质。当然从结果导向的理论来说，还是希望大家顺利通过！</p>\n",
            "tags": []
        },
        {
            "id": "https://oliverqueen.cn/2021-05-05-iOS-Crash%E9%98%B2%E6%8A%A4%E4%BD%A0%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%B0%B1%E5%A4%9F%E4%BA%86-%E4%B8%8B%E7%AF%87/",
            "url": "https://oliverqueen.cn/2021-05-05-iOS-Crash%E9%98%B2%E6%8A%A4%E4%BD%A0%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%B0%B1%E5%A4%9F%E4%BA%86-%E4%B8%8B%E7%AF%87/",
            "title": "iOS Crash防护你看这个就够了-下篇",
            "date_published": "2021-05-05T02:23:42.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"0x1-previously\"><a class=\"anchor\" href=\"#0x1-previously\">#</a> 0x1: Previously</h1>\n<p><a href=\"https://oliverqueen.cn/2021/05/03/iOS%20Crash%E9%98%B2%E6%8A%A4%E4%BD%A0%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%B0%B1%E5%A4%9F%E4%BA%86-%E4%B8%8A%E7%AF%87/\">上篇</a> 中讲到了 Crash 处理流程分为四个环节，也分析了 Crash 防护的方法，本章来讲下其余三个环节。</p>\n<h1 id=\"0x2-crash的拦截\"><a class=\"anchor\" href=\"#0x2-crash的拦截\">#</a> 0x2: Crash 的拦截</h1>\n<p>所有的未被防护住的 Crash 最终会走到这里，在这里我们必须要保证拦截的  <code>全面性</code> 、 <code>稳定性</code> 尽可能多的拦截到所有类型的异常，同时拦截逻辑本身不能产生异常。那么我们需要通过以下几个方面去考虑。</p>\n<p><img data-src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fdingyue.ws.126.net%2F2020%2F0504%2Fa0ef0444j00q9saus002gc000xc00irm.jpg&amp;refer=http%3A%2F%2Fdingyue.ws.126.net&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1622826899&amp;t=2b1dd016c1ac10c52097431b7fa9af7d\" alt=\"\" /></p>\n<p><span id=\"more\"></span></p>\n<h2 id=\"i-crash类型\"><a class=\"anchor\" href=\"#i-crash类型\">#</a> I: Crash 类型</h2>\n<p>和多数操作系统一样，iOS 的异常也基本分为  <code>用户层</code>   <code>系统底层</code>   <code>信号</code>  这三个类别，接下来我们看下每种异常都做了哪些事情</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq7dqhr2e2j31860qg79l.jpg\" alt=\"\" /></p>\n<ul>\n<li>\n<p>Mach Exception &lt;br&gt;<br />\nMach 异常，分为两种情况，第一种是本身就是硬件层面或者系统层面的异常，这个大家比较好理解，因为 mach 是微内核，所以底层的内核级别的包括硬件的异常都是 mach 异常。另一种是 iOS 系统独有的逻辑或者说是苹果独有的。就是用户层面的异常也都首先下沉到 mach 层再发出来，也等于是另一种意义上的 mach 异常。苹果官方文档上写的是为了统一机制才做了这样的处理，但是没有说具体原因。他的触发流程大概为下图</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq7yp0q2aaj30f60uqtaf.jpg\" alt=\"\" /></p>\n<p>然后我去看 Runtime 的源码进一步证明了这个说法，runloop 中大量使用这种方式监听 mach 异常消息，一旦 Crash 随时准备打破循环，因为系统也需要监听 crash，统一出口将对监听来说对系统将变得非常方便。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq7yvd5gpvj30pc02mt9o.jpg\" alt=\"\" /></p>\n<p>根据代码上下文可以判断出，苹果会监听统一的异常端口，在出现异常后进行相应的操作，也印证了我当时的推断。</p>\n</li>\n<li>\n<p>Exception &lt;br&gt;<br />\n 很常见的异常，触发流程大概为<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq7z1qkeksj30g60lkaax.jpg\" alt=\"\" /></p>\n</li>\n<li>\n<p>signal &lt;br&gt;</p>\n<p>signal 的产生流程大概分为几种情况</p>\n<ul>\n<li>\n<p>由于  <code>MachExcption</code>  转换而成的 signal</p>\n</li>\n<li>\n<p>由于 Exception 而发出的 abort 信号</p>\n</li>\n<li>\n<p>用户自定义的信号</p>\n</li>\n</ul>\n<p>但是需要注意一点：&lt;font color=red size=3 face=&quot;黑体&quot;&gt; 收到 signal 不一定会 Crash，但是 Crash 一定会有 Signal 发出 &lt;/font&gt;</p>\n</li>\n</ul>\n<h2 id=\"ii-crash传递流程\"><a class=\"anchor\" href=\"#ii-crash传递流程\">#</a> II: Crash 传递流程</h2>\n<p>上面分析了每种 Crash 的类型，那么这三种类型的 Crash 是如何在 App 生命周期中传递的呢？他们又是如何相互转化以及相互之间有什么关系呢？</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq7z8sxdxoj313o0n07hs.jpg\" alt=\"\" /></p>\n<p>帮大家提取下上图中的几个关键信息</p>\n<ul>\n<li>\n<p>1：Exception 最终会转化为 Mach Exception</p>\n</li>\n<li>\n<p>2：通过 Mach 端口拦截的较为全面</p>\n</li>\n<li>\n<p>3：如果发生了 exception 那么就不会抛出对应的 signal 只能抛出 abort ();</p>\n</li>\n<li>\n<p>4：通过捕获 signal 是无法拦截到 exception。</p>\n</li>\n</ul>\n<h2 id=\"iii-拦截的选择\"><a class=\"anchor\" href=\"#iii-拦截的选择\">#</a> III: 拦截的选择</h2>\n<p>通过上面的分析大家一定会说通过 Mach 端口的拦截更加全面，毕竟苹果自己也在用。但是在实际使用中有一个问题，mach 会拦截所有的异常以及信号量，也就是随便一个操作（比如发一个自定义 signal 等）可能都被 mach 捕获，那么如果在其捕获回调中再进行捕获就会很容易发生死锁，而且容易和系统的处理产生冲突。当时看了 PLCrash 的文档，也看到了开发者写的一句话：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq7znanxjrj315y03odjv.jpg\" alt=\"\" /></p>\n<p>这样说明了大家确实被坑过。</p>\n<p>那接下来只剩 signal 和 exception，其实细心的同学早已发现这两个的优缺点是一个互补的状态</p>\n<ul>\n<li>\n<p>singal 能捕获除 Exception 之外的所有异常。</p>\n</li>\n<li>\n<p>exception 只能获取应用层的异常而对信号量无法处理</p>\n</li>\n</ul>\n<p>那么最终的方式采用 singnal + exception 的方式进行捕获，最终的流程为：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq7zrbfy5xj30c40okdgu.jpg\" alt=\"\" /></p>\n<h2 id=\"iv-坑点\"><a class=\"anchor\" href=\"#iv-坑点\">#</a> IV: 坑点</h2>\n<p>上面的流程图可以看出在每一个 CustomHandle 之前都会有一个 PreviousHandle，其实是因为在 iOS 系统中只能存在一个 customHandel，如果你的项目中接入了或者准备接入多个 Crash 防护相关的 SDK（虽然不建议这么做），那么多个 Handle 之间一定会产生冲突，导致堆栈不明确，或者丢失。所以在注册我们的 handle 前先将之前的 handle 指针保存下来，等我们的 handle 处理完后在通过函数指针调用回去，这样就能保证每一个 handle 都能被正常调用。</p>\n<ul>\n<li>\n<p>exception：通过 <code>NSGetUncaughtExceptionHandler</code>  获得之前 handle 指针，之后再通过 <code>NSSetUncaughtExceptionHandler(oldHandler);</code>  调用回去。</p>\n</li>\n<li>\n<p>signal: 使用 <code>sigaction</code>  函数获得之前的 handle 指针。</p>\n</li>\n</ul>\n<h1 id=\"0x3-堆栈获取\"><a class=\"anchor\" href=\"#0x3-堆栈获取\">#</a> 0x3: 堆栈获取</h1>\n<p>因为苹果使用了 (Address Space Layout Randomization) 地址空间配置随机加载技术，所以线上堆栈必须要通过符号表堆栈还原进行解读，不然的话就是内存地址。所以当我们使用 NSThread 的相关函数在 Debug 下虽然能看到可读性行的堆栈，但是在线上包上并不可取，那我们要怎么获取堆栈呢？先来看下符号表的构造：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq80i60uhsj30ya0eih1g.jpg\" alt=\"\" /></p>\n<p>之前拿到这样的符号表，我们通常手动还原，找一个相同系统的真机，找到对应库的基地址按照符号表上函数的偏移量进行计算（通过 LLDB 的相关函数）</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq80lfgy0hj30q208i0te.jpg\" alt=\"\" /></p>\n<p>通过看 Mach-o 相关接口可以找到相关函数进行端内符号表还原，大致流程为：</p>\n<ul>\n<li>\n<p>获取函数地址：</p>\n<ul>\n<li>\n<p>遍历 Mach-o 中的所有 image</p>\n</li>\n<li>\n<p>获取每个 image 的基地址</p>\n</li>\n<li>\n<p>通过堆栈偏移地址获取栈帧函数地址</p>\n</li>\n</ul>\n</li>\n<li>\n<p>将函数地址翻译成函数名</p>\n<ul>\n<li>\n<p>找到对应 Image 的 symple table 段的 nlist_64 结构体</p>\n</li>\n<li>\n<p>通过 nlist_64.n_un.n_strx 获取函数对应的字符串</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>最终的效果:</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq80unfse1j31fc0cin8n.jpg\" alt=\"\" /></p>\n<h1 id=\"0x4-crash后续\"><a class=\"anchor\" href=\"#0x4-crash后续\">#</a> 0x4: Crash 后续</h1>\n<p>通常在 AppCrash 后会在 handle 中做些上报操作.</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq80xn75voj31cc04ydg7.jpg\" alt=\"\" /></p>\n<p>但是这样做有两个问题：</p>\n<ul>\n<li>\n<p>苹果不推荐在 Handle 中做太多操作，而且数据上报等网络请求属于耗时操作，有可能没有完成 App 就被杀死。</p>\n</li>\n<li>\n<p>App 直接闪退，体验不好</p>\n</li>\n</ul>\n<p>通过查看 runloop 源码可以看出，在 Crash 发生后当前 runloop 中断</p>\n<p>&lt;font color='red'&gt; 注意：runloop 本次循环还在继续，但是循环已经被打破，本次循环结束后 app 才退出 &lt;/font&gt; 既下图的 retVal 被置为 NO<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq810qv4osj317e0nawla.jpg\" alt=\"\" /></p>\n<p>iOS Crash 发生后   runloop 中的 do-while 循环的条件会被置为 NO，然后 Handler 函数走完之后当前循环后直接结束，不会在进行下一次循环了，此时我们只需要再 handler 中再重启 runloop，便可以继续执行代码，通过观察 runloop 源码可以看出 这样的操作是在之前已经中断但是还没结束的 runloop 中开启一个新的 runloop，他依然可以接受各种事件，比如交互事件等，前提是每个 model 都要开启，因为不同操作是发生在不同阶段的。  但是之前 runloop 中的内容处于不可控状态，且之前的东西被永远的留在内存中，不可恢复，所以在做完相关操作后要立即结束 App，避免其他异常情况，这种做法类似于一种安全模式，在安全模式中处理相关的东西。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq814a1gryj31f00ac3zo.jpg\" alt=\"\" /></p>\n<p>函数调用：</p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> continueAfterCrash()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopRef</span> runLoop = <span class=\"built_in\">CFRunLoopGetCurrent</span>();</span><br><span class=\"line\">    <span class=\"built_in\">CFArrayRef</span> allModes = <span class=\"built_in\">CFRunLoopCopyAllModes</span>(runLoop);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *mode <span class=\"keyword\">in</span> (__bridge <span class=\"built_in\">NSArray</span> *)allModes)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CFRunLoopRunInMode</span>((<span class=\"built_in\">CFStringRef</span>)mode, <span class=\"number\">1.0e10</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq81k7k7xcj30cq0um0wg.jpg\" alt=\"\" /></p>\n<p>在新的 runloop 中我们做一些操作后再调用 abort 退出 App，比如弹出友好提示之类的操作，告知用户 app 即将退出，但是该操作存在风险，需要注意以下情况</p>\n<ul>\n<li>\n<p>新开 runloop 后之前的 runloop 内容便会永远的留在内存中变成不可控的状态如果一旦被访问可能会有异常，所以在做完我们必要的操作后要及时结束 App。</p>\n</li>\n<li>\n<p>安全模式必须保证稳定，在新 runloop 中执行的上报、弹窗或者其他逻辑必须要使用系统原生的 API，不能依赖任何第三方。</p>\n</li>\n<li>\n<p>尽量不要做太多的操作，及时结束。</p>\n</li>\n</ul>\n<h1 id=\"0x5-参考资料\"><a class=\"anchor\" href=\"#0x5-参考资料\">#</a> 0x5: 参考资料</h1>\n<ul>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2RvY3VtZW50YXRpb24=\">Apple iOS Api</span></p>\n</li>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9vcGVuc291cmNlLmFwcGxlLmNvbS8=\">iOS Open Sourcre</span></p>\n</li>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9vcGVuc291cmNlLmFwcGxlLmNvbS9zb3VyY2UvQ0YvQ0YtMTE1MS4xNi8=\">CFRunloop</span></p>\n</li>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL29wZW5zb3VyY2UuYXBwbGUuY29tL3RhcmJhbGxzL3hudS94bnUtMzI0OC42MC4xMC50YXIuZ3o=\">XNU 3248.60.10 源码</span></p>\n</li>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2RvY3VtZW50YXRpb24veGNvZGUvZGlhZ25vc2luZ19pc3N1ZXNfdXNpbmdfY3Jhc2hfcmVwb3J0c19hbmRfZGV2aWNlX2xvZ3MvYW5hbHl6aW5nX2FfY3Jhc2hfcmVwb3J0\">Understanding Crash Reports on iPhone OS</span></p>\n</li>\n<li>\n<p>《深入解析 MAC OS X &amp; IOS 操作系统》</p>\n</li>\n</ul>\n<h1 id=\"0x6-最后\"><a class=\"anchor\" href=\"#0x6-最后\">#</a> 0x6: 最后</h1>\n<p>大概这就是所有 Crash 防护的流程，通过两篇文章讲解，希望大家对 iOS 系统的 Crash 流程能有些许的了解，并没有贴太多的源码，其实还是解耦度不够，思路有了代码就很简单了。</p>\n<p>\n        <div id=\"aplayer-yREUnHKW\" class=\"aplayer aplayer-tag-marker\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t  <script>\n\t\t\t\t  var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":0,\"mutex\":true,\"music\":[{\"title\":\"错位时空\",\"author\":\"艾辰\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E8%89%BE%E8%BE%B0%20-%20%E9%94%99%E4%BD%8D%E6%97%B6%E7%A9%BA.mp3\",\"pic\":\"https://bkimg.cdn.bcebos.com/pic/a8ec8a13632762d0f7037ac288a71ffa513d26976830?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2UxMTY=,g_7,xp_5,yp_5/format,f_auto\",\"lrc\":\"https://歌词.lrc\"}]};\n\t\t\t\t  options.element = document.getElementById(\"aplayer-yREUnHKW\");\n\t\t\t\t  var ap = new APlayer(options);\n\t\t\t    window.aplayers || (window.aplayers = []);\n\t\t\t\t  window.aplayers.push(ap);\n\t\t\t  </script></p>\n",
            "tags": [
                "iOS",
                "Crash防护"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-08-22-GitFlow/",
            "url": "https://oliverqueen.cn/2018-08-22-GitFlow/",
            "title": "GitFlow流程",
            "date_published": "2018-08-23T06:20:39.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"关于gitflow\"><a class=\"anchor\" href=\"#关于gitflow\">#</a> 关于 gitflow</h1>\n<h2 id=\"概念\"><a class=\"anchor\" href=\"#概念\">#</a> 概念：</h2>\n<p>Git Flow 是构建在 Git 之上的一个组织、管理软件开发活动的模型。Git Flow 是一套使用 Git 进行源代码管理时的一套行为规范和，通过利用 Git 创建和管理分支的能力，为每个分支设定具有特定的含义名称，并将软件生命周期中的各类活动归并到不同的分支上。实现了软件开发过程不同操作的相互隔离。这种软件开发的活动模型被称为 “Git Flow”。</p>\n<h2 id=\"原理\"><a class=\"anchor\" href=\"#原理\">#</a> 原理：</h2>\n<p>gitflow 的\b核心就 branch，通过在项目的不同阶段对 branch 的不同操作包括但不限于 create、marge、rebase、等来实现一个完整的高效率的工作流程。一般而言，软件开发模型有常见的瀑布模型、迭代开发模型、以及最近出现的敏捷开发模型等不同的模型。每种模型有各自应用场景。<strong>Git Flow 重点解决的是由于源代码在开发过程中的各种冲突导致开发活动混乱的问题。因此，Git flow 可以很好的于各种现有开发模型相结合使用，尤其是多人合作开发时提高效率</strong>。用一张图来了解 gitflow 的流程：从右向左看 从上到下看</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1ftk5pkvn7ij30vy16cwhl.jpg\" alt=\"\" /></p>\n<p><span id=\"more\"></span></p>\n<h2 id=\"branch\"><a class=\"anchor\" href=\"#branch\">#</a> Branch：</h2>\n<p>Branch 是 gitfolw 的核心。主要分为两大类 <strong>Main Branchs</strong> 和 <strong>Supporting branches</strong>, 其中 <strong>Main Branchs</strong> 中又包含了 <strong>Master</strong> 和 <strong>Develop</strong>，而 <strong>Supporting branches</strong> 中包含了 **Feature **、<strong>Release</strong>、<strong>Hotfix</strong> <strong>以及其他自定义分支</strong>，下面逐一讲解：</p>\n<h4 id=\"master\"><a class=\"anchor\" href=\"#master\">#</a> Master:</h4>\n<ul>\n<li>\n<p>描述：</p>\n<p>master 分支上存放的是最稳定的正式版的代码，并且该分支的代码应该是随时可在开发环境中使用的代码（Production Ready state）。当一个版本开发完毕后，产生了一份新的稳定的可供发布的代码时，master 分支上的代码要被更新，同时，每一次更新，都需要在 master 上打上对应的版本号 (tag)。</p>\n</li>\n<li>\n<p>生成及销毁：</p>\n<p>任何人不允许在 master 上进行代码的直接提交，只接受合入，Master 上的代码必须是要从经过多轮测试且已经发布一段时间 (根据 DAU 以及项目实际情况来定，个人建议 K 歌国际版可以定为一周) 且线上已经稳定的 <strong>release</strong> 分支合并进去，然后在 Master 上生成 tag (通常就是对应的版本号)</p>\n</li>\n<li>\n<p>命名：</p>\n<p>master</p>\n</li>\n</ul>\n<h4 id=\"develop\"><a class=\"anchor\" href=\"#develop\">#</a> Develop:</h4>\n<ul>\n<li>\n<p>描述：</p>\n<p>develop 分支是保存当前最新版本开发成果的分支。该分支上的代码允许有 BUG，但是必须保证编译通过，且该分支可以作为每天夜间测试的分支 (如果有夜间测试的话) 所以该分支也叫做 Nightly build。当 develop 分支上的代码已实现了软件需求说明书中所有的功能 (必须经过开发自测，但是不必经过 QA) 且相对稳定时候，就可以基于此分支来拉出新的 release 分支交付 QA 进行测试。</p>\n</li>\n<li>\n<p>生成及销毁：</p>\n<p>Develop 分支是由一个人 (通常是 Team Leader) 从 Master 中拉出，任何人不得在 Develop 上进行代码提交，只接受合入。Develop 上所有代码一定都是由 <strong>Supporting branches</strong> 中的 Branch 合并进来，且合入 Develop 的分支必须保证功能完整，可以独立运行，可允许包含一些 BUG (但是最好经过自测，不要有太大或者太明显的 BUG，比如一启动就 crash 之类的)。</p>\n</li>\n<li>\n<p>命名：</p>\n<p>develop</p>\n</li>\n<li>\n<p>流程：</p>\n</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1ftk7aszas4j30eu0mc74p.jpg\" alt=\"\" /></p>\n<h4 id=\"feature\"><a class=\"anchor\" href=\"#feature\">#</a> Feature:</h4>\n<ul>\n<li>\n<p>描述：</p>\n<p>Feature 分支通常叫做功能分支，也可以叫做个人分支，一般命名为 <strong>feature/XXXX</strong>, 该分支就是每一个开发人员进行开发的分支，比如做一些功能、需求之类的东西，这个分支上的代码变更最终合并回 develop 分支或者干脆被抛弃掉（例如实验性且效果不好的代码变更）。一般而言，feature 分支代码可以保存在开发者自己的代码库中而不强制提交到主代码库里。</p>\n</li>\n<li>\n<p>生成及销毁：</p>\n<p>每个开发者从通常会 Develop 分支中拉取自己的 feature，且开发者可以随意的在自己的 feature 上进行操作 包括但不限于 提交、回滚、删除。如果最终需要合并入 develop 那就要保证功能的完整性以及代码的稳定新，比如我在 feature 上做了 3 个需求但是由于时间关系我只做了两个，那也可以将 feature 合并入 develop，然后剩下的那一个需求等有时间了再去 feature 上做完之后再合入 develop。所以这里说的功能的完整性并不是值得要做完所有的功能，而是要保证你所要做的所有需求中的某一个或者某几个功能已经做完，不允许把做到一半的功合并入 develop。合并入 develop 尽量上删除远端的 feature 分支，本地的 feature 可以视情况而取舍。</p>\n</li>\n<li>\n<p>命名：</p>\n<p>feature 通常是从 develope 上拉取 所有通常用 <strong>dev_功能描述_英文名</strong> 来命名。比如 <strong>feature/dev_refresh_molierzhang</strong></p>\n</li>\n<li>\n<p>流程：</p>\n</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1ftk7br1fvqj307e0jugln.jpg\" alt=\"\" /></p>\n<h4 id=\"release\"><a class=\"anchor\" href=\"#release\">#</a> Release:</h4>\n<ul>\n<li>\n<p>描述：</p>\n<p>Release 分支通常叫做发布分支，也可以叫做测试 - 发布分支，一般命名为 <strong>Release/1.2.3</strong>（后面是版本号）, 该分支是为测试 - 发布新的产品版本而开辟的。因为包含测试流程，所以在这个分支上的代码允许做小的缺陷修正、准备发布版本所需的各项说明信息（版本号、发布时间、编译时间等等）。通过在 release 分支上进行这些工作可以让 develop 分支空闲出来以接受新的 feature 分支上的代码提交，进入新的软件开发迭代周期。<strong>注意：该分支上的代码一定是可编译可运行的，允许包含小 BUG</strong></p>\n</li>\n<li>\n<p>生成及销毁：</p>\n<p>当 develop 分支上的代码已经包含了该版本所有即将发布的功能和需求，并且已通过自测且已基本稳定，我们就可以考虑准备基于 develop 拉取 release 分支了。而所有在当前即将发布的版本之外的业务需求一定要确保不能混到 release 分支之内（避免由此引入一些不可控的系统缺陷）。成功的派生了 release 分支之后，develop 分支就可以为 “下一个版本” 服务了。所谓的 “下一个版本” 是在当前即将发布的版本之后发布的版本。开发人员可以在此分支上修改 BUG，进行提交、回滚等操作，但是与 feature 不同的是 release 分支是被多人操作的，不像 feature，所以一定要小心避免冲突。当现在 QA 测试没有问题，便从 release 上发布上线，且经过一段时间的验证没有问题后合入 master，并且删除 release 分支，其实根据 release 分支的特性我们可以使用 Git Hook 触发软件自动测试以及生产环境代码的自动更新工作。这些自动化操作将有利于减少新代码发布之后的一些事务性工作。</p>\n</li>\n<li>\n<p>命名：</p>\n<p>release/1.2.3 后面跟对应的版本号</p>\n</li>\n<li>\n<p>流程：</p>\n<p>同 feature</p>\n</li>\n</ul>\n<h4 id=\"hotfix\"><a class=\"anchor\" href=\"#hotfix\">#</a> Hotfix:</h4>\n<ul>\n<li>\n<p>描述：</p>\n<p>Hotfix 叫热修复分支，除了是计划外创建的以外，hotfix 分支与 release 分支十分相似，当已经发布的版本（Master 上代码）遇到了异常情况或者发现了严重到必须立即修复的软件缺陷的时候，就需要从 master 分支上指定的 tag 版本拉取 hotfix 分支来组织代码的紧急修复工作。这样做的显而易见的好处是不会打断正在进行的 develop 分支的开发工作，能够让团队中负责新功能开发的人与负责代码紧急修复的人并行、独立的开展工作。</p>\n</li>\n<li>\n<p>生成及销毁：</p>\n<p>由 Master 上拉取，进行修复，负责修改 BUG 的同事可以进行提交及其它操作，后续的热修复测试也在此分支上进行。通过测试验证没问题后有一个人 (通常为 teamleader)<strong> 合并入 Master 分支，且同时也要合并入 Develop 分支</strong></p>\n</li>\n<li>\n<p>命名：</p>\n<p>Hotfix/1.2.3 后面跟对应的版本号</p>\n</li>\n<li>\n<p>流程：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1ftk81yr4iej308j0bqwf3.jpg\" alt=\"\" /></p>\n</li>\n</ul>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>Git Flow 开发模型从源代码管理角度对通常意义上的软件开发活动进行了约束。应该说，为我们的软件开发提供了一个可供参考的管理模型。Git Flow 开发模型让开发代码仓库保持整洁，让小组各个成员之间的开发相互隔离，能够有效避免处于开发状态中的代码相互影响而导致的效率低下和混乱。</p>\n<p>所谓模型，在不同的开发团队，不同的文化，不同的项目背景情况下都有可能需要进行适当的裁剪或扩充。</p>\n<h2 id=\"效率工具\"><a class=\"anchor\" href=\"#效率工具\">#</a> 效率工具</h2>\n<p>推荐 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc291cmNldHJlZWFwcC5jb20v\">sourceTree</span> 和 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ2l0a3Jha2VuLmNvbS8=\">gitkarken</span> (用免费版即可，不用充钱) 前者对 gitsubmodel 的支持不太好，不过目前介于我们没有实现组件化所以暂时可以无视；后者完美支持 gitsubmodel，但是在拉取一些比较大的库的时候可能会卡死，前公司一个项目 30G+ 会有卡死情况出现，后者界面炫酷一些 iOS 的话 Xcdoe 自带 git 也可以试试。</p>\n",
            "tags": [
                "git",
                "效率工作"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-06-19-MusicAbout/",
            "url": "https://oliverqueen.cn/2018-06-19-MusicAbout/",
            "title": "关于实现唱吧清唱功能的理解",
            "date_published": "2018-06-19T06:44:56.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"简介\"><a class=\"anchor\" href=\"#简介\">#</a> 简介</h2>\n<h4 id=\"avfoundation\"><a class=\"anchor\" href=\"#avfoundation\">#</a> AVFoundation</h4>\n<p>在 iOS 上多媒体的处理主要依赖的是 AVFoundation 框架，而 AVFoundation 是基于 CoreAudio、CoreVideo、CoreMedia、CoreAnimation 之上高层框架，在 AVFoundation 框架之上苹果还提供给我们更高层一些处理媒体数据的框架。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fsgu5859czj30ol0et75h.jpg\" alt=\"\" /><br />\n<span id=\"more\"></span></p>\n<p>如 AVKit、iOS 的 UIKit、OS 的 AppKit。AVFoundation 提供了大量强大的工具集，可通过这个框架处理音视频编程，但是如同苹果中的的 Kit 一样，封装的越高级，个性化就会困难些，一些实际项目中的奇葩需求难以实现。本章所讲的内容是 AVFoundation 上层加下层的 AVAudioEngine 实现。</p>\n<h4 id=\"avaudioengine\"><a class=\"anchor\" href=\"#avaudioengine\">#</a> AVAudioEngine</h4>\n<p>AVAudioEngine 是 Objective-C 的音频 API 接口，具有低延迟 (low-latency) 和实时 (real-time) 的音频功能，并且具有如下特点：</p>\n<ul>\n<li>\n<p>读写所有 Core Audio 支持的格式音频文件</p>\n</li>\n<li>\n<p>播放和录音使用 (files) 和音频缓冲区 (buffers)</p>\n</li>\n<li>\n<p>动态配置音频处理模块 (audio processing blocks)</p>\n</li>\n<li>\n<p>可以进行音频挖掘处理 (tap processing)</p>\n</li>\n<li>\n<p>可以进行立体声音频信号混合和 3d 效果的混合</p>\n</li>\n<li>\n<p>音乐设备数字接口 MIDI 回放和控制，通过乐器的采样器</p>\n</li>\n</ul>\n<p>AVAudioEngine 的工作原理可以简单的分为三个部分:</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fsgusaq6ttj316208i41t.jpg\" alt=\"\" /></p>\n<p>从图中可以看出 AVAudioEngine 的每一步操作都是一个音频操作节点 (Node)，每个完整的操作都包含输入节点和输出节点以及经中间的若干个处理节点，包括但不限于，添加音效、混音、音频处理等。整体的流程和 GPUImage 的流程差不多，都是链式结构，通过节点来链接成一个完整的流水线，其中每个节点都有自己特有的属性，可以通过改变属性的值来改变经由该节点后的音频输出效果，用音效节点举例：一个声音流通过这个音效节点，假如这个节点可以给该段声音添加一个回响的效果，那么通过该节点特有的属性可以设置回想的间隔、干湿程度等，这样一来经过这个节点处理过的声音流就会变成我们想要的样子，然后他作为为一个输入了再次流入其他节点。上图的 Mixer 其实是包含若干个这样的音效节点</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fsgvxmt21cj310c0dpq4l.jpg\" alt=\"\" /></p>\n<h2 id=\"原理\"><a class=\"anchor\" href=\"#原理\">#</a> 原理</h2>\n<p>清唱的功能很简单，就是通过麦克风录制声音，然后添加音效或者做一些处理之后再输出，因为不要配乐，所以省略了一大部分操作 (添加配乐完整 K 歌在下期会讲到)，但是有一个问题就是耳返，也叫返送：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fsgv4t4pd6j30n602ujsg.jpg\" alt=\"\" /></p>\n<p>这个东西是必不可少的，因为有了耳返你就可以实时调整自己的声音，极大的降低了走调的风险和尴尬，一个很简单的例子，现在有不少人喜欢在水房唱歌或者是洗澡的时候唱歌，原因就是在水房或者是卫生间通常会有回音，而回音就是天然的耳返，所以在有回音的地方唱歌就会感觉自己的声音洪亮而且音准很好 (因为你可以实时的通过回音来调整自己的声调)。演唱会上唱歌的人的耳机中都是耳返。而且耳返要有一个要求就是，你所听到的你自己的声音一定要和观众或者是其他的人听到的一样，不然就不会有作用，我们平时自己说话自己能听到是因为声音通过骨传导到达我们的耳朵，而听众听到的是通过空气介质传播，所以是否有耳返直接决定了你演唱质量的好坏。</p>\n<p>使用 AVAudioEngine 来完成这个功能其实就是运用了他的实时音频的特点，他可以几乎在没有延迟的情况下同时创建音频的输入和输出，而且对这个做了高度的封装使我们能更加关心音效调整</p>\n<h2 id=\"实现\"><a class=\"anchor\" href=\"#实现\">#</a> 实现</h2>\n<h6 id=\"创建音频文件用来接收待录制的声音\"><a class=\"anchor\" href=\"#创建音频文件用来接收待录制的声音\">#</a> 创建音频文件用来接收待录制的声音：</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建音频文件。</span></span><br><span class=\"line\">   <span class=\"built_in\">NSString</span> * path = <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">   <span class=\"built_in\">NSString</span> * filePath = [path stringByAppendingPathComponent:<span class=\"string\">@&quot;123.caf&quot;</span>];</span><br><span class=\"line\">   <span class=\"built_in\">NSURL</span> * url = [<span class=\"built_in\">NSURL</span> fileURLWithPath:filePath];</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"创建avaudioengine并打通输入和输出节点\"><a class=\"anchor\" href=\"#创建avaudioengine并打通输入和输出节点\">#</a> 创建 AVAudioEngine，并打通输入和输出节点：</h6>\n<ul>\n<li>\n<p>创建 AVAudioEngine，并初始化。这里要弄成属性不然会被释放，没有效果</p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">AVAudioEngine</span> * engine;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">AVAudioMixerNode</span> * mixer;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">self.engine</span> = [[AVAudioEngine alloc] init]<span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"attr\">self.mixer</span> = [[AVAudioMixerNode alloc] init]<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>打通输入和输出节点：</p>\n<p><figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"variable\">_engine</span> connect:<span class=\"variable\">_engine</span>.inputNode <span class=\"keyword\">to</span>:<span class=\"variable\">_engine</span>.outputNode <span class=\"built_in\">format</span>:[<span class=\"variable\">_engine</span>.inputNode inputFormatForBus:AVAudioPlayerNodeBufferLoops]];</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 所使用的是如下方法。<br />\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*!\t@method connect:to:format:</span></span><br><span class=\"line\"><span class=\"comment\">\t@abstract</span></span><br><span class=\"line\"><span class=\"comment\">\t\tEstablish a connection between two nodes</span></span><br><span class=\"line\"><span class=\"comment\">\t@discussion</span></span><br><span class=\"line\"><span class=\"comment\">\t\tThis calls connect:to:fromBus:toBus:format: using bus 0 on the source node,</span></span><br><span class=\"line\"><span class=\"comment\">\t\tand bus 0 on the destination node, except in the case of a destination which is a mixer,</span></span><br><span class=\"line\"><span class=\"comment\">\t\tin which case the destination is the mixer&#x27;s nextAvailableInputBus.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)connect:(<span class=\"built_in\">AVAudioNode</span> *)node1 to:(<span class=\"built_in\">AVAudioNode</span> *)node2 format:(<span class=\"built_in\">AVAudioFormat</span> * __<span class=\"keyword\">nullable</span>)format;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>开启 AVAudioEngine:</p>\n<p>该方法可能会开启失败，需要开发者自定去处理</p>\n<p><figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[_engine startAndReturnError:nil]</span><span class=\"comment\">;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>以上步骤走完后并且开启成功你就会发现你从耳机里面可以实时的听到你的声音了。</p>\n</li>\n<li>\n<p>音效：</p>\n<p>正常来说光有耳返还不够，因为清唱虽然没有配乐伴奏，但是是支持用户调节音效的，类似于变声。这就用到 AVAudioEngine 中的 AVAudioUnitEffect 类。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fsgxpydeq8j30hw0cwq32.jpg\" alt=\"\" /></p>\n<ul>\n<li>\n<p>1.AVAudioUnitReverb: 混响，混响可以模拟咱们在一个空旷的环境，比如教堂、大房间等，这样咱们在说话的时候，就会有回音，并且声音也比较有立体感。其中该类别下面又分为<br />\n <figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_ENUM</span>(<span class=\"type\">NSInteger</span>, <span class=\"type\">AVAudioUnitReverbPreset</span>) &#123;</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetSmallRoom</span>       = 0,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetMediumRoom</span>      = 1,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetLargeRoom</span>       = 2,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetMediumHall</span>      = 3,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetLargeHall</span>       = 4,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetPlate</span>           = 5,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetMediumChamber</span>   = 6,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetLargeChamber</span>    = 7,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetCathedral</span>       = 8,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetLargeRoom2</span>      = 9,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetMediumHall2</span>     = 10,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetMediumHall3</span>     = 11,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetLargeHall2</span>      = 12</span><br><span class=\"line\">  &#125; <span class=\"type\">NS_ENUM_AVAILABLE</span>(10_10, 8_0);</span><br></pre></td></tr></table></figure><br />\n 从名字可以看出是在模拟不同环境下的音效，比如其中的大中小屋子，大厅等。</p>\n<p>该类别可以自定义的属性是 wetDryMix，就是可以让我们的声音更空灵。</p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">/*! @property wetDryMix</span></span><br><span class=\"line\"><span class=\"comment\">    @abstract</span></span><br><span class=\"line\"><span class=\"comment\">    Blend of the wet and dry signals</span></span><br><span class=\"line\"><span class=\"comment\">    Range:      0 (all dry) -&gt; 100 (all wet)</span></span><br><span class=\"line\"><span class=\"comment\">    Unit:       Percent</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"type\">float</span> wetDryMix;</span><br></pre></td></tr></table></figure></p>\n<p>可以通过如下方式创建 AVAudioUnitReverb<br />\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">AVAudioUnitReverb</span> <span class=\"operator\">*</span> reverd <span class=\"operator\">=</span> [[<span class=\"type\">AVAudioUnitReverb</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">reverd.wetDryMix <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">[reverd loadFactoryPreset:<span class=\"type\">AVAudioUnitReverbPresetLargeRoom</span>];</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>2.AVAudioUnitEQ: 均衡器，咱们可以使用均衡器来调节咱们音频的各个频段，比如，我想让我的低音更加浑厚，我就可以调节 EQ 的 20-150HZ 的频段，如果你想让你的声音更加明亮，那可以调节 500-1KHZ 的频段，这个调节涉及到一些专业方面的知识，如果只是想让用户去使用的话，可以用苹果给我们更封装好的几个效果即可，这个就类似于 photoshop 和美图秀秀的区别。</p>\n<p><figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_ENUM</span>(<span class=\"type\">NSInteger</span>, <span class=\"type\">AVAudioUnitEQFilterType</span>) &#123;</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeParametric</span>        = 0,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeLowPass</span>           = 1,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeHighPass</span>          = 2,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeResonantLowPass</span>   = 3,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeResonantHighPass</span>  = 4,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeBandPass</span>          = 5,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeBandStop</span>          = 6,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeLowShelf</span>          = 7,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeHighShelf</span>         = 8,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeResonantLowShelf</span>  = 9,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeResonantHighShelf</span> = 10,</span><br><span class=\"line\">  &#125; <span class=\"type\">NS_ENUM_AVAILABLE</span>(10_10, 8_0);</span><br></pre></td></tr></table></figure></p>\n<p>上面是一些苹果帮助我们定义好的滤波器，比如低通滤波器 衰弱高频、可以引发共鸣的 低通滤波器<br />\n不过一般在清唱的时候这个用处不大，这个效果主要用到在配合伴奏的时候，如果伴奏音调过高，可以使用该方法适当的提高人声音调或者降低伴奏的音调，</p>\n<p>可以通过如下方式使用，然后更改这个节点一些属性值。<br />\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AVAudioUnitEQ * <span class=\"keyword\">eq</span> <span class=\"operator\">=</span> [[AVAudioUnitEQ alloc] initWithNumberOfBands:<span class=\"number\">1</span>]<span class=\"comment\">;</span></span><br><span class=\"line\">AVAudioUnitEQFilterParameters * <span class=\"keyword\">filter</span> <span class=\"operator\">=</span> <span class=\"keyword\">eq</span>.bands.firstObject<span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"keyword\">filter</span>.filterType <span class=\"operator\">=</span> AVAudioUnitEQFilterTypeResonantHighShelf<span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"keyword\">filter</span>.bandwidth <span class=\"operator\">=</span> <span class=\"number\">10</span><span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"keyword\">filter</span>.gain <span class=\"operator\">=</span> <span class=\"number\">20</span><span class=\"comment\">;</span></span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>3.AVAudioUnitDistortion：失真，这个就是我们常说的电音，一般说唱或者摇滚，重金属之类的曲风会用到这个效果，同样苹果给我们提供了预设的几个效果，如果不是有专业的需求我们可以直接使用。</p>\n<p><figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  typedef <span class=\"type\">NS_ENUM</span>(<span class=\"type\">NSInteger</span>, <span class=\"type\">AVAudioUnitDistortionPreset</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetDrumsBitBrush</span>           = 0,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetDrumsBufferBeats</span>        = 1,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetDrumsLoFi</span>               = 2,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiBrokenSpeaker</span>      = 3,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiCellphoneConcert</span>   = 4,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDecimated1</span>         = 5,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDecimated2</span>         = 6,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDecimated3</span>         = 7,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDecimated4</span>         = 8,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDistortedFunk</span>      = 9,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDistortedCubed</span>     = 10,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDistortedSquared</span>   = 11,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiEcho1</span>              = 12,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiEcho2</span>              = 13,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiEchoTight1</span>         = 14,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiEchoTight2</span>         = 15,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiEverythingIsBroken</span> = 16,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetSpeechAlienChatter</span>      = 17,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetSpeechCosmicInterference</span> = 18,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetSpeechGoldenPi</span>          = 19,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetSpeechRadioTower</span>        = 20,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetSpeechWaves</span>             = 21</span><br><span class=\"line\">&#125; <span class=\"type\">NS_ENUM_AVAILABLE</span>(10_10, 8_0);</span><br></pre></td></tr></table></figure><br />\n 其实里面有些还是比较有感觉的，比如扭曲的立方体，或者外星人的喋喋不休等。有兴趣的可以说都试试</p>\n<p>使用方式同之前的效果一样</p>\n<p><figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AVAudioUnitDistortion * <span class=\"keyword\">dist </span>= [[AVAudioUnitDistortion alloc] init];</span><br><span class=\"line\">[<span class=\"keyword\">dist </span>loadFactoryPreset:AVAudioUnitDistortionPresetDrumsBitBrush];</span><br><span class=\"line\"><span class=\"keyword\">dist.preGain </span>= <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"keyword\">dist.wetDryMix </span>= <span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>4.AVAudioUnitDelay: 延迟，延迟就是 发出一个声音之后，过段时间再次发出，一直衰减到听不见。类似咱们的回声。可以通过里面的属性去细微的调节延迟的时间、速度等。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>添加音效：<br />\n主要流程就是链式关系</p>\n<p><strong>input (Mic 或者音频文件) -&gt; 效果器 -&gt;output</strong></p>\n<p>如果是多个音效</p>\n<p><strong>input (Mic 或者音频文件) -&gt; 效果器 1-&gt; 效果器 2-&gt;output</strong></p>\n<p>我们以 AVAudioUnitReverb 效果为例</p>\n<p><figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AVAudioUnitReverb * reverb = [[AVAudioUnitReverb alloc] init];</span><br><span class=\"line\">[reverb loadFactoryPreset:AVAudioUnitReverbPresetLargeRoom];</span><br><span class=\"line\">reverb.wetDryMix = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"comment\">//把混响附着到音频引擎</span></span><br><span class=\"line\">[<span class=\"variable\">_engine</span> attachNode:reverb];</span><br><span class=\"line\"><span class=\"comment\">//依次链接输入-&gt; 混响 -&gt; 输出</span></span><br><span class=\"line\">[<span class=\"variable\">_engine</span> connect:<span class=\"variable\">_engine</span>.inputNode <span class=\"keyword\">to</span>:reverb <span class=\"built_in\">format</span>:[<span class=\"variable\">_engine</span>.inputNode inputFormatForBus:AVAudioPlayerNodeBufferLoops]];</span><br><span class=\"line\">[<span class=\"variable\">_engine</span> connect:reverb <span class=\"keyword\">to</span>:<span class=\"variable\">_engine</span>.outputNode <span class=\"built_in\">format</span>:[<span class=\"variable\">_engine</span>.inputNode inputFormatForBus:AVAudioPlayerNodeBufferLoops]];</span><br><span class=\"line\"><span class=\"comment\">//启动引擎</span></span><br><span class=\"line\">[<span class=\"variable\">_engine</span> startAndReturnError:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 同理添加多个音效则需要严格按照 <strong>input (Mic 或者音频文件) -&gt; 效果器 1-&gt; 效果器 2-&gt;output</strong> 顺序来添加</p>\n<p>综上：完成了以上所有操作后你就可以实时在耳机中听到自己经过音效处理过的声音了，而且这样带着耳机唱歌效果会非常好，声音洪亮不易跑调。还可以针对不同的曲风调整自己的音效。</p>\n</li>\n</ul>\n<h6 id=\"声音混合-写入本地\"><a class=\"anchor\" href=\"#声音混合-写入本地\">#</a> 声音混合、写入本地：</h6>\n<p>我们需要把我们清唱的歌曲录制到本地，正常的录制时使用 AVAudioRecorder 来进行录制的，像这样</p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">AVAudioSession</span> * session = [<span class=\"built_in\">AVAudioSession</span> sharedInstance];</span><br><span class=\"line\">    [session setCategory:<span class=\"built_in\">AVAudioSessionCategoryPlayAndRecord</span> error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    [session setActive:<span class=\"literal\">YES</span> error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> * path = <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.filePath = [path stringByAppendingPathComponent:<span class=\"string\">@&quot;SoWeak&quot;</span>];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.recordFileUrl = [<span class=\"built_in\">NSURL</span> fileURLWithPath:<span class=\"keyword\">self</span>.filePath];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//设置参数</span></span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> *recordSetting = [[<span class=\"built_in\">NSDictionary</span> alloc] initWithObjectsAndKeys:</span><br><span class=\"line\">                                   <span class=\"comment\">//采样率  8000/11025/22050/44100/96000（影响音频的质量）</span></span><br><span class=\"line\">                                   [<span class=\"built_in\">NSNumber</span> numberWithFloat: <span class=\"number\">8000.0</span>],<span class=\"built_in\">AVSampleRateKey</span>,</span><br><span class=\"line\">                                   <span class=\"comment\">// 音频格式</span></span><br><span class=\"line\">                                   [<span class=\"built_in\">NSNumber</span> numberWithInt: kAudioFormatLinearPCM],<span class=\"built_in\">AVFormatIDKey</span>,</span><br><span class=\"line\">                                   <span class=\"comment\">//采样位数  8、16、24、32 默认为16</span></span><br><span class=\"line\">                                   [<span class=\"built_in\">NSNumber</span> numberWithInt:<span class=\"number\">16</span>],<span class=\"built_in\">AVLinearPCMBitDepthKey</span>,</span><br><span class=\"line\">                                   <span class=\"comment\">// 音频通道数 1 或 2</span></span><br><span class=\"line\">                                   [<span class=\"built_in\">NSNumber</span> numberWithInt: <span class=\"number\">2</span>], <span class=\"built_in\">AVNumberOfChannelsKey</span>,</span><br><span class=\"line\">                                   <span class=\"comment\">//录音质量</span></span><br><span class=\"line\">                                   [<span class=\"built_in\">NSNumber</span> numberWithInt:<span class=\"built_in\">AVAudioQualityHigh</span>],<span class=\"built_in\">AVEncoderAudioQualityKey</span>,</span><br><span class=\"line\">                                   <span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.recorder = [[<span class=\"built_in\">AVAudioRecorder</span> alloc] initWithURL:<span class=\"keyword\">self</span>.recordFileUrl settings:recordSetting error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.recorder) &#123;</span><br><span class=\"line\">        _recorder.meteringEnabled = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">        [_recorder prepareToRecord];</span><br><span class=\"line\">        [_recorder record];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>但是很明显这样录制声音需要开启 session 而声音的 session 是一个单利，如果这样开启了那么我们后面就不能用 AVAudioEngine 来进行音频采集了，也就没有之前的效果。所有根据以往的经验，AVAudioEngine 在开启引擎之后一定会有一个 delegate 或者是 block 回调出采集到的数据的。于是我们找到了 AudioNode 中的这个方法：<br />\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)installTapOnBus:(<span class=\"built_in\">AVAudioNodeBus</span>)bus bufferSize:(<span class=\"built_in\">AVAudioFrameCount</span>)bufferSize format:(<span class=\"built_in\">AVAudioFormat</span> * __<span class=\"keyword\">nullable</span>)format block:(<span class=\"built_in\">AVAudioNodeTapBlock</span>)tapBlock;</span><br></pre></td></tr></table></figure><br />\n 其中的 block 的 buffer 便是我们采集到的数据。</p>\n<p><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*!\t<span class=\"doctag\">@typedef</span> AVAudioNodeTapBlock</span></span><br><span class=\"line\"><span class=\"comment\">\t<span class=\"doctag\">@abstract</span> A block that receives copies of the output of an AVAudioNode.</span></span><br><span class=\"line\"><span class=\"comment\">\t<span class=\"doctag\">@param</span> buffer</span></span><br><span class=\"line\"><span class=\"comment\">\t\ta buffer of audio captured from the output of an AVAudioNode</span></span><br><span class=\"line\"><span class=\"comment\">\t<span class=\"doctag\">@param</span> when</span></span><br><span class=\"line\"><span class=\"comment\">\t\tthe time at which the buffer was captured</span></span><br><span class=\"line\"><span class=\"comment\">\t<span class=\"doctag\">@discussion</span></span></span><br><span class=\"line\"><span class=\"comment\">\t\tCAUTION: This callback may be invoked on a thread other than the main thread.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">typedef <span class=\"keyword\">void</span> (^AVAudioNodeTapBlock)(AVAudioPCMBuffer *buffer, AVAudioTime *when);</span><br></pre></td></tr></table></figure></p>\n<p>我们需要把 buffer 转成 AVAudioFile 然后通过 AVAudioFile 的 write 方法写入<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">初始化<span class=\"built_in\">AVAudioFile</span></span><br><span class=\"line\"><span class=\"built_in\">AVAudioFile</span> * audioFile = [[<span class=\"built_in\">AVAudioFile</span> alloc] initForWriting:url settings:@&#123;&#125; error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">然后在block中实现</span><br><span class=\"line\">[audioFile writeFromBuffer:buffer error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 这个时候写入成功然后播放本地录音文件发现只有自己的原生，并没有后面添加的音效，回音等效果。</p>\n<p>其实是因为我们虽然添加了音效但是我们没有把音效和原生混合在一起，即使我们实时听到的是没有问题的，但是当保存到本地之后如果没有做混合，系统会默认将最原始的声音写入本地，这里我们需要用到</p>\n<p><strong>AVAudioMixerNode</strong></p>\n<p>他是继承与 AVAudioNode 也属于一个特殊音频处理节点，使用方式和之前的音效节点一样，添加在所有的处理之后、输出之前即可，像这样</p>\n<p><strong>input (Mic 或者音频文件) -&gt; 效果器 1-&gt; 效果器 2-&gt;Mixer-&gt;output</strong></p>\n<p>不过唯一需要注意的是这个 mixer 最好也写成属性、不然会出问题。</p>\n<p>所以一个完整的带音效的清唱录制为：<br />\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建音频文件。</span></span><br><span class=\"line\">    <span class=\"type\">NSString</span> <span class=\"operator\">*</span> path <span class=\"operator\">=</span> <span class=\"type\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"type\">NSDocumentDirectory</span>, <span class=\"type\">NSUserDomainMask</span>, <span class=\"type\">YES</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"type\">NSString</span> <span class=\"operator\">*</span> filePath <span class=\"operator\">=</span> [path stringByAppendingPathComponent:@<span class=\"string\">&quot;123.caf&quot;</span>];</span><br><span class=\"line\">    <span class=\"type\">NSURL</span> <span class=\"operator\">*</span> url <span class=\"operator\">=</span> [<span class=\"type\">NSURL</span> fileURLWithPath:filePath];</span><br><span class=\"line\">    <span class=\"type\">AVAudioFile</span> <span class=\"operator\">*</span> audioFile <span class=\"operator\">=</span> [[<span class=\"type\">AVAudioFile</span> alloc] initForWriting:url settings:@&#123;&#125; error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.recordFileUrl <span class=\"operator\">=</span> url;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitReverb</span> <span class=\"operator\">*</span> reverd <span class=\"operator\">=</span> [[<span class=\"type\">AVAudioUnitReverb</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    reverd.wetDryMix <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">    [reverd loadFactoryPreset:<span class=\"type\">AVAudioUnitReverbPresetLargeRoom</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.engine attachNode:reverd];</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.engine attachNode:_mixer];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.engine connect:<span class=\"keyword\">self</span>.engine.inputNode to:reverd format:audioFile.processingFormat];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.engine connect:reverd to:_mixer format:audioFile.processingFormat];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.engine connect:_mixer to:<span class=\"keyword\">self</span>.engine.outputNode format:audioFile.processingFormat];</span><br><span class=\"line\"></span><br><span class=\"line\">    [_mixer installTapOnBus:<span class=\"number\">0</span> bufferSize:<span class=\"number\">4096</span> format:[_engine.inputNode inputFormatForBus:<span class=\"type\">AVAudioPlayerNodeBufferLoops</span>] block:<span class=\"operator\">^</span>(<span class=\"type\">AVAudioPCMBuffer</span> <span class=\"operator\">*</span> _Nonnull buffer, <span class=\"type\">AVAudioTime</span> <span class=\"operator\">*</span> _Nonnull when) &#123;</span><br><span class=\"line\">        [audioFile writeFromBuffer:buffer error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">        <span class=\"type\">NSLog</span>(@<span class=\"string\">&quot;我录制到的数据是 === %@&quot;</span>, buffer);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.engine startAndReturnError:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>通过如上方法可以完整的实现清唱功能，但是唱吧清唱使用的是 AudioUnit，AudioUnit 是 iOS 中音频的非常底层的实现，由 C 语言实现，因为唱吧中除了清唱之外还有很多非常复杂的音频处理功能，所以只有 AudioUnit 可以满足，但是对于清唱这个功能来说，两种实现方式达到了同样的效果，本文介绍的更加轻量级，不过关于 AudioUnit 也正在学习过程，后续会输出相应的文章。</p>\n",
            "tags": [
                "音频",
                "唱吧",
                "K歌",
                "AVFoundation"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-03-30-AlamoFire/",
            "url": "https://oliverqueen.cn/2018-03-30-AlamoFire/",
            "title": "AlamoFire的使用(下载队列，断点续传)",
            "date_published": "2018-03-30T09:54:38.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>最近开始做了一个新项目，几乎没有时间来写自己的博客，大部分都在写 feature（BUG），自己研究的东西很少，本来之前说好每个月要写两篇文章也没能坚持下来，最近在项目中遇到了一些问题，就在这里总结下吧。一些小的技巧而已，大神可以忽略了。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Alamofire/Alamofire/master/alamofire.png\" alt=\"\" /><br />\n<span id=\"more\"></span></p>\n<h2 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景</h2>\n<p>新项目包含了上传下载网络请求相关功能，由于是 swift 编写所以自然而然选择了 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FsYW1vZmlyZS9BbGFtb2ZpcmU=\">AlamoFire</span> (好像也没得选) 来做底层，正常的网络请求 post、get 等都是直接傻瓜式调用 AlamoFire 的接口，本文主要将一些细节问题</p>\n<h2 id=\"设置通用超时时间\"><a class=\"anchor\" href=\"#设置通用超时时间\">#</a> 设置通用超时时间</h2>\n<p>使用 Alamofire 发起请求时候有这两个接口</p>\n<p><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Creates a `DataRequest` using the default `SessionManager` to retrieve the contents of the specified `url`,</span></span><br><span class=\"line\"><span class=\"comment\">/// `method`, `parameters`, `encoding` and `headers`.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - parameter url:        The URL.</span></span><br><span class=\"line\"><span class=\"comment\">/// - parameter method:     The HTTP method. `.get` by default.</span></span><br><span class=\"line\"><span class=\"comment\">/// - parameter parameters: The parameters. `nil` by default.</span></span><br><span class=\"line\"><span class=\"comment\">/// - parameter encoding:   The parameter encoding. `URLEncoding.default` by default.</span></span><br><span class=\"line\"><span class=\"comment\">/// - parameter headers:    The HTTP headers. `nil` by default.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - returns: The created `DataRequest`.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">request</span>(<span class=\"keyword\">_</span> <span class=\"params\">url</span>: <span class=\"type\">URLConvertible</span>, <span class=\"params\">method</span>: <span class=\"type\">Alamofire</span>.<span class=\"type\">HTTPMethod</span> <span class=\"operator\">=</span> <span class=\"keyword\">default</span>, <span class=\"params\">parameters</span>: <span class=\"type\">Parameters</span>? <span class=\"operator\">=</span> <span class=\"keyword\">default</span>, <span class=\"params\">encoding</span>: <span class=\"type\">ParameterEncoding</span> <span class=\"operator\">=</span> <span class=\"keyword\">default</span>, <span class=\"params\">headers</span>: <span class=\"type\">HTTPHeaders</span>? <span class=\"operator\">=</span> <span class=\"keyword\">default</span>) -&gt; <span class=\"type\">Alamofire</span>.<span class=\"type\">DataRequest</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Creates a `DataRequest` using the default `SessionManager` to retrieve the contents of a URL based on the</span></span><br><span class=\"line\"><span class=\"comment\">/// specified `urlRequest`.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - parameter urlRequest: The URL request</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - returns: The created `DataRequest`.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">request</span>(<span class=\"keyword\">_</span> <span class=\"params\">urlRequest</span>: <span class=\"type\">URLRequestConvertible</span>) -&gt; <span class=\"type\">Alamofire</span>.<span class=\"type\">DataRequest</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 而我们在调用的时候通常会直接这么用</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> req : URLRequest = <span class=\"constructor\">URLRequest(<span class=\"params\">url</span>: URL(<span class=\"params\">fileURLWithPath</span>: <span class=\"string\">&quot;32&quot;</span>)</span>, cachePolicy: .useProtocolCachePolicy, timeoutInterval: <span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第一种方法调用，后面参数直接用default</span></span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Alamofire</span>.</span></span>request(<span class=\"constructor\">URL(<span class=\"params\">fileURLWithPath</span>: <span class=\"string\">&quot;32&quot;</span>)</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第二中调用，使传入request</span></span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Alamofire</span>.</span></span>request(req)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> semaphore = <span class=\"constructor\">DispatchSemaphore(<span class=\"params\">value</span>: 0)</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>其中第一种方法我们不能传入超时时间，第二中方法我们可以通过传入的 URLRequest 来设置超时时间，但是我们通常一个项目中大部分的请求，可能除了某些特殊的下载请求之外所有的超时时间都是一样的，这样的话我们需要同样的代码写好多遍，这个时候有两个办法</p>\n<ul>\n<li>\n<p>对生成 Request 的方法做一个封装，通用的参数如超时时间、header、请求方式 写死在方法里面，对于会变动的参数如 URL 和可以通过参数传入.</p>\n</li>\n<li>\n<p>创建  <code>Alamofire.SessionManager</code>  通过 sessionManager 来设置超时时间等一些通用的东西</p>\n</li>\n</ul>\n<p><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> networkManager : SessionManager = &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">config</span> : URLSessionConfiguration = URLSessionConfiguration<span class=\"variable\">.default</span></span><br><span class=\"line\">        <span class=\"keyword\">config</span><span class=\"variable\">.timeoutIntervalForRequest</span> = <span class=\"number\">10</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> manager = Alamofire<span class=\"variable\">.SessionManager</span><span class=\"variable\">.init</span>(configuration: <span class=\"keyword\">config</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> manager</span><br><span class=\"line\">    &#125;()</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"断点续传\"><a class=\"anchor\" href=\"#断点续传\">#</a> 断点续传</h2>\n<p>Alamofire 支持断点续传下载，原理就是将下载一半的数据保存到本地，然后下次再启动时候通过 data 的拼接来进行继续下载。用法也很简单，只是调用接口而已，关键是看开发者如何自己去维护这个已下载的数据，比如是存内存还是存硬盘，要存多久，淘汰策略是什么之类的。其实就是两个步骤， 断点和续传</p>\n<h4 id=\"第一步-断点\"><a class=\"anchor\" href=\"#第一步-断点\">#</a> 第一步 断点</h4>\n<p>监听下载中断，中断后将已经下载的数据进行保留，我这边用一个属性来存，具体到项目实现大家可以采用自己存储方式，存到硬盘或者数据库之类的</p>\n<p><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Alamofire<span class=\"selector-class\">.download</span>(<span class=\"string\">&quot;http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4&quot;</span>, method: <span class=\"selector-class\">.get</span>, parameters: nil, encoding: URLEncoding<span class=\"selector-class\">.default</span>, headers: nil) &#123; (url, response) -&gt; (destinationURL: URL, options: DownloadRequest.DownloadOptions) <span class=\"keyword\">in</span></span><br><span class=\"line\">            return (<span class=\"built_in\">URL</span>(fileURLWithPath: <span class=\"built_in\">String</span>(describing : <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"selector-class\">.documentDirectory</span>, <span class=\"selector-class\">.userDomainMask</span>, false)<span class=\"selector-attr\">[0]</span>+<span class=\"string\">&quot;123.mp4&quot;</span>)), <span class=\"selector-attr\">[.createIntermediateDirectories, .removePreviousFile]</span>)</span><br><span class=\"line\">            &#125;<span class=\"selector-class\">.responseJSON</span> &#123; (response) <span class=\"keyword\">in</span></span><br><span class=\"line\"></span><br><span class=\"line\">                switch response<span class=\"selector-class\">.result</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                case <span class=\"selector-class\">.success</span>:</span><br><span class=\"line\">                    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;success&quot;</span>)</span><br><span class=\"line\">                case <span class=\"selector-class\">.failure</span>:</span><br><span class=\"line\">                    <span class=\"comment\">//意外中断后在此处处理下载完成的部分</span></span><br><span class=\"line\">                    self<span class=\"selector-class\">.tmpData</span> = response<span class=\"selector-class\">.resumeData</span></span><br><span class=\"line\"></span><br><span class=\"line\">                default:</span><br><span class=\"line\">                    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;failed&quot;</span>)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"第二步-续传\"><a class=\"anchor\" href=\"#第二步-续传\">#</a> 第二步 续传</h4>\n<p>当下载再次启动时候，需要在上一步数据的基础上继续下载，我们调用 Alamofire 这个方法<br />\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Creates a `DownloadRequest` using the default `SessionManager` from the `resumeData` produced from a</span></span><br><span class=\"line\"><span class=\"comment\">/// previous request cancellation to retrieve the contents of the original request and save them to the `destination`.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// If `destination` is not specified, the contents will remain in the temporary location determined by the</span></span><br><span class=\"line\"><span class=\"comment\">/// underlying URL session.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// On the latest release of all the Apple platforms (iOS 10, macOS 10.12, tvOS 10, watchOS 3), `resumeData` is broken</span></span><br><span class=\"line\"><span class=\"comment\">/// on background URL session configurations. There&#x27;s an underlying bug in the `resumeData` generation logic where the</span></span><br><span class=\"line\"><span class=\"comment\">/// data is written incorrectly and will always fail to resume the download. For more information about the bug and</span></span><br><span class=\"line\"><span class=\"comment\">/// possible workarounds, please refer to the following Stack Overflow post:</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">///    - http://stackoverflow.com/a/39347461/1342462</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - parameter resumeData:  The resume data. This is an opaque data blob produced by `URLSessionDownloadTask`</span></span><br><span class=\"line\"><span class=\"comment\">///                          when a task is cancelled. See `URLSession -downloadTask(withResumeData:)` for additional</span></span><br><span class=\"line\"><span class=\"comment\">///                          information.</span></span><br><span class=\"line\"><span class=\"comment\">/// - parameter destination: The closure used to determine the destination of the downloaded file. `nil` by default.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - returns: The created `DownloadRequest`.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">download</span>(<span class=\"params\">resumingWith</span> <span class=\"params\">resumeData</span>: <span class=\"type\">Data</span>, <span class=\"params\">to</span> <span class=\"params\">destination</span>: <span class=\"type\">Alamofire</span>.<span class=\"type\">DownloadRequest</span>.<span class=\"type\">DownloadFileDestination</span>? <span class=\"operator\">=</span> <span class=\"keyword\">default</span>) -&gt; <span class=\"type\">Alamofire</span>.<span class=\"type\">DownloadRequest</span></span><br></pre></td></tr></table></figure><br />\n 这个接口需要我们传入已存在的数据，然后基于我们传入的数据进行下载，它支持从新指定目的地路径，如果你有需要可以重新指定<br />\n <figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Alamofire.download(resumingWith: tmpData!)</span><br></pre></td></tr></table></figure><br />\n 同样他返回一个 request 的对象，我们可以通过点语法来拿到进度、response 等信息</p>\n<h2 id=\"批量下载\"><a class=\"anchor\" href=\"#批量下载\">#</a> 批量下载</h2>\n<p>当我们需要同时下载很多东西的时候，往往需要我们自己维护一个下载队列，比如下一个载素材列表之类的。Alamo 给我们提供了下载的接口，但是下载的线程队列需要我们自己去维护，其实就是一个多线程并发队列。</p>\n<h4 id=\"gcd\"><a class=\"anchor\" href=\"#gcd\">#</a> GCD</h4>\n<p>我们很自然而然的想到 GCD，但是 GCD 有一个问题无法控制最大并发数，而且对队列的管理也并不完善，比如我们要下载 100 个文件，如果同时下载的话开辟 100 个线程，那肯定是不行的，先不说移动设备是否支持 (最多 70 个左右)，即使支持了那这个开销太大。虽说 GCD 的话可以使用信号量进行线程控制，但是每个线程的暂停启动之类的又是问题，而且毕竟是曲线救国的方法。</p>\n<h4 id=\"operationqueue\"><a class=\"anchor\" href=\"#operationqueue\">#</a> OperationQueue</h4>\n<p>Operation 及 OperationQueue 是基于 GCD 封装的对象，作为对象可以提供更多操作选择，可以用方法或 block 实现多线程任务，同时也可以利用继承、类别等进行一些其他操作；但同时实现代码相对复杂一些。但是他毕竟不像 GCD 那样使用 C 语言实现，所以效率会相比 GCD 低一些。但是对线程的控制的灵活性要远高于 GCD，对于下载线程来说可以优先选择这个。</p>\n<h4 id=\"实现\"><a class=\"anchor\" href=\"#实现\">#</a> 实现</h4>\n<p>我们把每一个下载任务封装成一个 operation。注意 Operation 不能直接使用，我们需要使用他的子类，这里我选择使用  <code>BlockOperation</code>  他的闭包则是需要执行的下载任务，然后我们把他添加进 queue 中便开始执行了任务</p>\n<p><figure class=\"highlight roboconf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let op : BlockOperation = BlockOperation &#123; [<span class=\"attribute\">weak self] in</span></span><br><span class=\"line\"><span class=\"attribute\">            Alamofire.download(&quot;http</span>://clips<span class=\"variable\">.vorwaerts-gmbh</span><span class=\"variable\">.de</span>/big_buck_bunny<span class=\"variable\">.mp</span>4&quot;, method: <span class=\"variable\">.get</span>, parameters: nil, encoding: URLEncoding<span class=\"variable\">.default</span>, headers: nil) &#123; (url, response) -&gt; (destinationURL: URL, options: DownloadRequest<span class=\"variable\">.DownloadOptions</span>) in</span><br><span class=\"line\">                return (URL(fileURLWithPath: String(describing : NSSearchPathForDirectoriesInDomains(<span class=\"variable\">.documentDirectory</span>, <span class=\"variable\">.userDomainMask</span>, false)[0]+&quot;123<span class=\"variable\">.mp</span>4&quot;)), [<span class=\"variable\">.createIntermediateDirectories</span>, <span class=\"variable\">.removePreviousFile</span>])</span><br><span class=\"line\">                &#125;<span class=\"variable\">.downloadProgress</span> &#123; [weak self] (pro) in</span><br><span class=\"line\">                    let percent = Float(pro<span class=\"variable\">.completedUnitCount</span>) / Float(pro<span class=\"variable\">.totalUnitCount</span>)</span><br><span class=\"line\">                    if count == 0 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                        self?<span class=\"variable\">.downLoadLabel</span><span class=\"variable\">.snp</span><span class=\"variable\">.remakeConstraints</span> &#123; (make) in</span><br><span class=\"line\">                            make<span class=\"variable\">.width</span><span class=\"variable\">.equalTo</span>(300 * percent)</span><br><span class=\"line\">                            make<span class=\"variable\">.height</span><span class=\"variable\">.equalTo</span>(30)</span><br><span class=\"line\">                            make<span class=\"variable\">.top</span><span class=\"variable\">.equalTo</span>((self?<span class=\"variable\">.stopButton</span><span class=\"variable\">.snp</span><span class=\"variable\">.bottom</span>)!)<span class=\"variable\">.offset</span>(30)</span><br><span class=\"line\">                            make<span class=\"variable\">.left</span><span class=\"variable\">.equalToSuperview</span>()<span class=\"variable\">.offset</span>(30)</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; else &#123;</span><br><span class=\"line\">                        self?<span class=\"variable\">.downLoadLabel</span>2<span class=\"variable\">.snp</span><span class=\"variable\">.remakeConstraints</span> &#123; (make) in</span><br><span class=\"line\">                            make<span class=\"variable\">.width</span><span class=\"variable\">.equalTo</span>(300 * percent)</span><br><span class=\"line\">                            make<span class=\"variable\">.height</span><span class=\"variable\">.equalTo</span>(30)</span><br><span class=\"line\">                            make<span class=\"variable\">.top</span><span class=\"variable\">.equalTo</span>((self?<span class=\"variable\">.downLoadLabel</span><span class=\"variable\">.snp</span><span class=\"variable\">.bottom</span>)!)<span class=\"variable\">.offset</span>(30)</span><br><span class=\"line\">                            make<span class=\"variable\">.left</span><span class=\"variable\">.equalToSuperview</span>()<span class=\"variable\">.offset</span>(30)</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;<span class=\"variable\">.responseJSON</span> &#123; (response) in</span><br><span class=\"line\"></span><br><span class=\"line\">                    switch response<span class=\"variable\">.result</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    case <span class=\"variable\">.success</span>:</span><br><span class=\"line\">                        print(&quot;success&quot;)</span><br><span class=\"line\">                    case <span class=\"variable\">.failure</span>:</span><br><span class=\"line\">                        self?<span class=\"variable\">.tmpData</span> = response<span class=\"variable\">.resumeData</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    default:</span><br><span class=\"line\">                        print(&quot;failed&quot;)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        queue<span class=\"variable\">.addOperation</span>(op)</span><br></pre></td></tr></table></figure><br />\n 每一个 opeeation 对象我们都可以设置他的优先级、启动、暂停、等属性，简单的调用接口就可以，在此就不一一作解释了。然后我们需要对我们的 queue 进行设置，我们设置最大并发数，大家可以根据实际情况来设置，demo 中我只有两个下载任务，所以我就设置最大并发数为 1 这样就是一个一个下载。<br />\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"built_in\">queue</span> : OperationQueue = &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> que : OperationQueue = OperationQueue()</span><br><span class=\"line\">        que.maxConcurrentOperationCount = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> que</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 我们运行然后点击开始下载</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fpw0vlzbp6g308h0gnkjm.gif\" alt=\"\" /></p>\n<p>很奇怪我们发现他还是同时下载，我们又试了其他的个数，无论多少都是同时下载，最大线程数量完全不起作用，再反过来看下上面加入 queue 的任务。正常来说每一个 operation 都要等上一个 operation 完成后才会执行，而系统判断完成的标准就是上一个 operation 的闭包走完，我们闭包中放入的是一个下载任务，而 Alamofire 的下载都是异步执行，所以导致 operation 的闭包走完了，但是其实下载是异步在另一个线程执行的，实际上下载没有完成，知道原因我们对症下药，只需要保证 operation 闭包中的代码是同步执行的就 OK 了。而 Alamofire 是基于 URLSession 来实现的，并没有像 connection 那样提供同步的方法，所以我们使用信号量卡一下，像这样</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fpw1444jp0j31610qbgrr.jpg\" alt=\"\" /></p>\n<p>这样之后就会按照我们设置好的队列进行了</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fpw15riwhjg308h0gnb2i.gif\" alt=\"\" /></p>\n<p>有人会说下载同步进行会不会有影响，其实不会的首先我们实现同步的方式是信号量，本质上还是异步的只是我们阻塞的当前的下载线程，这个被阻塞线程一定不是主线程 (除非 Alamofire 的开发者把他回调到主线程下载，这个基本不可能)，而且当我们把这个下载任务加到一个 operation 中之后，就注定不会在主线程中了，没一个 operation 都会被系统分配到一个非主线程的地方去做，所以这样不会性能有任何影响。</p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>因为时间紧迫，暂时做了这么多，也遇到了这些问题，所以写出了总结下，本文还会继续更新，会慢慢的整个网络层分享出来。就是可能更新会慢，毕竟工作量有点饱和。多谢关注</p>\n<p>\n        <div id=\"aplayer-bwMrXBRX\" class=\"aplayer aplayer-tag-marker\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t  <script>\n\t\t\t\t  var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":0,\"mutex\":true,\"music\":[{\"title\":\"Thank You Very Much\",\"author\":\"Margaret\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/Thankyou.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M000000VbGX83hRicw.jpg?max_age=2592000\",\"lrc\":\"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=001Ii3g54dIYpO\"}]};\n\t\t\t\t  options.element = document.getElementById(\"aplayer-bwMrXBRX\");\n\t\t\t\t  var ap = new APlayer(options);\n\t\t\t    window.aplayers || (window.aplayers = []);\n\t\t\t\t  window.aplayers.push(ap);\n\t\t\t  </script></p>\n",
            "tags": [
                "swift",
                "网络请求"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-03-14-Simple-HotFix-Mtehod/",
            "url": "https://oliverqueen.cn/2018-03-14-Simple-HotFix-Mtehod/",
            "title": "简单的iOS线上热修复方案",
            "date_published": "2018-03-14T06:04:46.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"向大佬致敬\"><a class=\"anchor\" href=\"#向大佬致敬\">#</a> 向大佬致敬</h2>\n<p>总是喜欢把参考资料、致谢等写在文章最前面，毕竟是站在人家的肩膀上，向大佬致敬，写这篇文章的也是参考他的 然后加上一些自己的思考，主要目的还是自己再写一遍 Demo 和文档，以便加深记忆，也帮助自己更好的理解，有句话说：看懂的东西不一定就是学会了，自己能在不看资料的前提下写出来才算是略知一二。<br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fpcbkfx1z9j319e0kkdmp.jpg\" alt=\"\" /></p>\n<p>以下是 ** <span class=\"exturl\" data-url=\"aHR0cDovL2xpbWJveS5tZS90ZWNoLzIwMTgvMDMvMDQvaW9zLWxpZ2h0d2VpZ2h0LWhvdGZpeC5odG1s\">原文链接</span><strong>有兴趣的还可以看下</strong><span class=\"exturl\" data-url=\"aHR0cDovL2xpbWJveS5tZS8=\">大佬博客</span> **<br />\n<span id=\"more\"></span></p>\n<h2 id=\"工作原理分析\"><a class=\"anchor\" href=\"#工作原理分析\">#</a> 工作原理分析</h2>\n<p>要实现热修复其实原理就是我们可以动态的修改代码，在方法前、中、后插入自己想要的东西或者代码。其实这个需求并不难，iOS 的运行时机制可以满足我们的这个要求，但是如果是已经上架了的 APP, 已经打成了 Ipa 包我们该如何修改呢？这里就需要服务端去控制，通过下发不同的内容来达到我们想要的目的，但是这里有一个要求，服务端所下发的内容并不能是任意的，而是要通过下发的内容调起我们 App 内的 RunTime 机制然后进行偷梁换柱。满足这个要求的数据格式只有字符串化的 JS 代码，因为我们知道在 iOS 中 JS 代码是可以调用 OC 的代码。综上所述打到热修复整套流程所需的技术如下：</p>\n<ul>\n<li>\n<p>Runtime：</p>\n<p>可以在本站搜索 Runtime 关键字找到 Runtime 相关资料</p>\n</li>\n<li>\n<p>与服务器交互：</p>\n<p>现在大部分 APP 都具有于服务端交互的能力，就是我们常说的网络请求 AFNetWorking 等</p>\n</li>\n<li>\n<p>JS 与 OC 交互：</p>\n<p>大家可以参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9kMTk2ODllMGVkODM=\">这篇文章</span>，主要参考方式二，使用 JavaScriptCore 进行交互</p>\n</li>\n</ul>\n<p>进行了上述操作后每次用户启动，App 都会进行如下操作</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fpcce8vzimj30vg0t0wva.jpg\" alt=\"\" /></p>\n<p>这样一来如果开发在项目发布出去后发现有 Crash 那么可以立即通过服务器下发 JS 代码来制定 APp 每次执行新方法 (新方法的定义也是在下发的 JS 代码中)，可以避免一些问题。</p>\n<h2 id=\"实际使用\"><a class=\"anchor\" href=\"#实际使用\">#</a> 实际使用</h2>\n<h4 id=\"第三方\"><a class=\"anchor\" href=\"#第三方\">#</a> 第三方</h4>\n<p>这里用到一个第三方库<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3N0ZWlwZXRlL0FzcGVjdHM=\"> Aspects</span> 这个库可以理解为一个 iOS 中的 Runtime 库，我们不用写繁琐的代码，直接调用他的接口即可，</p>\n<p><figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class=\"line\">                           withOptions:(AspectOptions)options</span><br><span class=\"line\">                            usingBlock:(<span class=\"built_in\">id</span>)block</span><br><span class=\"line\">                                 <span class=\"keyword\">error</span>:(NSError **)<span class=\"keyword\">error</span>;</span><br></pre></td></tr></table></figure></p>\n<p>其中的枚举就是选择我们要插入方法的位置，其中包含</p>\n<p><figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_OPTIONS</span>(<span class=\"type\">NSUInteger</span>, <span class=\"type\">AspectOptions</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">AspectPositionAfter</span>   = 0,            /// <span class=\"type\">Called</span> after the original implementation (default)</span><br><span class=\"line\">    <span class=\"type\">AspectPositionInstead</span> = 1,            /// <span class=\"type\">Will</span> replace the original implementation.</span><br><span class=\"line\">    <span class=\"type\">AspectPositionBefore</span>  = 2,            /// <span class=\"type\">Called</span> before the original implementation.</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">AspectOptionAutomaticRemoval</span> = 1 &lt;&lt; 3 /// <span class=\"type\">Will</span> remove the hook after the first execution.</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 这个库据说是对上线没有影响。</p>\n<h4 id=\"配置工程\"><a class=\"anchor\" href=\"#配置工程\">#</a> 配置工程</h4>\n<p>用实际代码来证明下，这是我 Controller 中的一个代码，很明显会产生数组越界的 Crash，假如我们在上线后才发现了这个问题，这时候需要修复</p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;ViewController.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> crashMethod:<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)crashMethod:(<span class=\"built_in\">NSInteger</span>)argument</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argument == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSArray</span> * arr = @[<span class=\"string\">@&quot;1&quot;</span>];</span><br><span class=\"line\">        [arr objectAtIndex:<span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)didReceiveMemoryWarning &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> didReceiveMemoryWarning];</span><br><span class=\"line\">    <span class=\"comment\">// Dispose of any resources that can be recreated.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 导入上面说的那个第三方.h 和.m 然后自己建立一个桥接类，用来处理 JS 和 O 的交互，大概的结构就是这样</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fpcdbh9ahbj307k0duwfd.jpg\" alt=\"\" /></p>\n<p>其中交互类中暴露出如下接口</p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;Aspects.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;JavaScriptCore/JavaScriptCore.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Felix</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 初始化</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)fixIt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 开始执行JS代码</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param javascriptString 需要执行的JS</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)evalString:(<span class=\"built_in\">NSString</span> *)javascriptString;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>.m 文件的内容可以到大佬博客中参考这里不放出，不然篇幅太长。</p>\n<h4 id=\"开始使用\"><a class=\"anchor\" href=\"#开始使用\">#</a> 开始使用</h4>\n<p>因为我们最好用能控制代码里面的所有方法，所以我们要尽早的注册交互类，在 APpdelegate 中如下注册</p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Override point for customization after application launch.</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    [Felix fixIt];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *fixScriptString = <span class=\"string\">@&quot; \\</span></span><br><span class=\"line\"><span class=\"string\">    fixInstanceMethodReplace(&#x27;ViewController&#x27;, &#x27;crashMethod:&#x27;, function(instance, originInvocation, originArguments)&#123; \\</span></span><br><span class=\"line\"><span class=\"string\">    if (originArguments[0] == 0) &#123; \\</span></span><br><span class=\"line\"><span class=\"string\">    console.log(&#x27;crash！！！！！&#x27;); \\</span></span><br><span class=\"line\"><span class=\"string\">    &#125; else &#123; \\</span></span><br><span class=\"line\"><span class=\"string\">    runInvocation(originInvocation); \\</span></span><br><span class=\"line\"><span class=\"string\">    &#125; \\</span></span><br><span class=\"line\"><span class=\"string\">    &#125;); \\</span></span><br><span class=\"line\"><span class=\"string\">    \\</span></span><br><span class=\"line\"><span class=\"string\">    &quot;</span>;</span><br><span class=\"line\">    [Felix evalString:fixScriptString];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    如果是多个方法建议用循环执行</span></span><br><span class=\"line\"><span class=\"comment\">//    NSArray * hotFixStr = @[fixScriptString];</span></span><br><span class=\"line\"><span class=\"comment\">//    for (int i = 0; i &lt; hotFixStr.count; i ++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        [Felix evalString:hotFixStr[i]];</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 其中 JS 的代码就是我们所要修改的内容，可以看到当参数为 0 的时候输出 crash！！！然后不再继续执行了。实际项目中这段代码是由服务器动态返回的，如果我们要修改多个方法，就需要服务器返回 JS 字符串数组我们这边来进行循环处理即可。这时候在运行下代码不会崩溃，下面会输出一个 crash！！！！</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fpcdjfkqkmj30i4034t8s.jpg\" alt=\"\" /></p>\n<h2 id=\"思考\"><a class=\"anchor\" href=\"#思考\">#</a> 思考</h2>\n<p>这个方法相比较之前的 JSpatch 是非常轻量级的，而且也只是实现了简单的容错功能，并不能做一些复杂的操作，比如生成一个对象之类的，不过对于一般的控制已经可以满足了，毕竟在苹果爸爸这么严厉的管制下能有这样的方法也还不错啊。</p>\n<p>\n        <div id=\"aplayer-AtmiJQux\" class=\"aplayer aplayer-tag-marker\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t  <script>\n\t\t\t\t  var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":0,\"mutex\":true,\"music\":[{\"title\":\"不知归期的故人\",\"author\":\"房东的猫\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E4%B8%8D%E7%9F%A5%E5%BD%92%E6%9C%9F%E7%9A%84%E6%95%85%E4%BA%BA.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M000004NFJ230yX0Nz.jpg?max_age=2592000\",\"lrc\":\"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=000zreoj2VtcID\"}]};\n\t\t\t\t  options.element = document.getElementById(\"aplayer-AtmiJQux\");\n\t\t\t\t  var ap = new APlayer(options);\n\t\t\t    window.aplayers || (window.aplayers = []);\n\t\t\t\t  window.aplayers.push(ap);\n\t\t\t  </script></p>\n",
            "tags": [
                "热修复",
                "JSPath"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-02-08-%E5%85%B3%E4%BA%8EiPhone-X%E4%B8%8BHome%E9%94%AE%E7%9A%84%E9%9A%90%E8%97%8F%E5%92%8C%E5%BB%B6%E8%BF%9F%E5%93%8D%E5%BA%94/",
            "url": "https://oliverqueen.cn/2018-02-08-%E5%85%B3%E4%BA%8EiPhone-X%E4%B8%8BHome%E9%94%AE%E7%9A%84%E9%9A%90%E8%97%8F%E5%92%8C%E5%BB%B6%E8%BF%9F%E5%93%8D%E5%BA%94/",
            "title": "关于iPhone X下Home键的隐藏和延迟响应",
            "date_published": "2018-02-08T02:15:57.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"ios-11通用相关\"><a class=\"anchor\" href=\"#ios-11通用相关\">#</a> iOS 11 通用相关</h1>\n<h2 id=\"edge-protect\"><a class=\"anchor\" href=\"#edge-protect\">#</a> Edge Protect</h2>\n<p>iPhone X 刚出来的时候苹果第一时间更新了新设备的交互文档，其中针对了大家最关心的 “系统手势和 App 自带手势冲突” 的问题也给出了相应的解决办法:</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo8u9uqjehj31kw0t7h2q.jpg\" alt=\"\" /></p>\n<p>虽然苹果用黑体字写着强烈不建议开发者干涉系统的手势，但是为了增强用户体验还是开出了接口，苹果管这个叫做 &quot;edge protect&quot; 因为进入 App 后系统手势都是从边缘触发，引起冲突的地方也会是在边缘中。</p>\n<p><span id=\"more\"></span></p>\n<p>根据官方文档描述，在冲突区域第一次执行手势的时候会优先触发 App 的内部手势，当短时间内再次进行同样的操作则会触发系统手势。也就是将系统手势延迟到下一次执行。</p>\n<h2 id=\"api-discussion\"><a class=\"anchor\" href=\"#api-discussion\">#</a> API Discussion</h2>\n<p>根据官方文档找到对应的 API</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Override to return a child view controller or nil. If non-nil, that view controller&#x27;s screen edges deferring system gestures will be used. If nil, self is used. Whenever the return value changes, -setNeedsScreenEdgesDeferringSystemGesturesUpdate should be called.</span></span><br><span class=\"line\">- (nullable UIViewController *)childViewControllerForScreenEdgesDeferringSystemGestures <span class=\"constructor\">API_AVAILABLE(<span class=\"params\">ios</span>(11.0)</span>) <span class=\"constructor\">API_UNAVAILABLE(<span class=\"params\">watchos</span>, <span class=\"params\">tvos</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Controls the application&#x27;s preferred screen edges deferring system gestures when this view controller is shown. Default is UIRectEdgeNone.</span></span><br><span class=\"line\">- (UIRectEdge)preferredScreenEdgesDeferringSystemGestures <span class=\"constructor\">API_AVAILABLE(<span class=\"params\">ios</span>(11.0)</span>) <span class=\"constructor\">API_UNAVAILABLE(<span class=\"params\">watchos</span>, <span class=\"params\">tvos</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This should be called whenever the return values for the view controller&#x27;s screen edges deferring system gestures have changed.</span></span><br><span class=\"line\">- (void)setNeedsUpdateOfScreenEdgesDeferringSystemGestures <span class=\"constructor\">API_AVAILABLE(<span class=\"params\">ios</span>(11.0)</span>) <span class=\"constructor\">API_UNAVAILABLE(<span class=\"params\">watchos</span>, <span class=\"params\">tvos</span>)</span>;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"childviewcontrollerforscreenedgesdeferringsystemgestures\"><a class=\"anchor\" href=\"#childviewcontrollerforscreenedgesdeferringsystemgestures\">#</a> childViewControllerForScreenEdgesDeferringSystemGestures</h4>\n<p>该方法是用来控制子试图控制器是否允许开发者控制 edge protect 的开启或是关闭。如果实现了这个方法并且返回值不为空那么子 VC 的 edge protect 设置就会遵循父 VC 的设置，跟随父 VC 是否延迟执行系统手势。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo917ycqy6j319i0bqjtr.jpg\" alt=\"\" /></p>\n<h4 id=\"preferredscreenedgesdeferringsystemgestures\"><a class=\"anchor\" href=\"#preferredscreenedgesdeferringsystemgestures\">#</a> preferredScreenEdgesDeferringSystemGestures</h4>\n<p>该方法是设置 edge protect 的方法，返回值是一个边界的枚举</p>\n<p><figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_OPTIONS</span>(<span class=\"type\">NSUInteger</span>, <span class=\"type\">UIRectEdge</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeNone</span>   = 0,</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeTop</span>    = 1 &lt;&lt; 0,</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeLeft</span>   = 1 &lt;&lt; 1,</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeBottom</span> = 1 &lt;&lt; 2,</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeRight</span>  = 1 &lt;&lt; 3,</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeAll</span>    = <span class=\"type\">UIRectEdgeTop</span> | <span class=\"type\">UIRectEdgeLeft</span> | <span class=\"type\">UIRectEdgeBottom</span> | <span class=\"type\">UIRectEdgeRight</span></span><br><span class=\"line\">&#125; <span class=\"type\">NS_ENUM_AVAILABLE_IOS</span>(7_0);</span><br></pre></td></tr></table></figure></p>\n<p>因为不论我们从 shang、左、下、右边都可触发系统手势，所以方法保护了四个边框，将边界触发的手势延迟执行，这个方法从 iOS11 开始使用，不过枚举中虽然有左右的边界保护，但是系统手势中还不清楚左右滑动会触发什么效果，实验发现对于 VC 的左边界右滑动 pop 手势是无效的，也就是说这个 pop 手势一直有着最高的优先级。不过上下就很好理解，底部上拉出控制中心，顶部下拉是通知中心。</p>\n<ul>\n<li>\n<p>无限制</p>\n<p>当不做任何限制时候在顶部和底部很容易触发到系统的手势，他们会优先于 Tab.eView 的 scroll 手势执行，虽说屏幕大部分的界面还是执行 TableView 手势的，但是当用户误触到边界的时候还是会稍稍影响体验，尤其是在全屏模式下、相机、视频、游戏等</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo909u85fpg308k0goe8d.gif\" alt=\"\" /></p>\n</li>\n<li>\n<p>Edge Protent</p>\n<p>在对应的 ViewControll 中添加如下代码，我们这边开启的是所有边界限制其中包括了上、下边界。在下拉或者上拉的话会先触发 App 内部手势，同时出现一个小箭头然后在箭头消失之前再次滑动就会触发系统手势。<br />\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"built_in\">UIRectEdge</span>)preferredScreenEdgesDeferringSystemGestures</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">UIRectEdgeAll</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo90rfo0dig308k0go7wu.gif\" alt=\"\" /></p>\n</li>\n</ul>\n<h4 id=\"setneedsupdateofscreenedgesdeferringsystemgestures\"><a class=\"anchor\" href=\"#setneedsupdateofscreenedgesdeferringsystemgestures\">#</a> setNeedsUpdateOfScreenEdgesDeferringSystemGestures</h4>\n<p>这个方法是在应用内部动态控制 edge protect，我们可以在上个方法中返回一个 BOOL 变量，然后根据需要改变该变量的值，然后调用该方法进行刷新。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo912yvhsag308k0goe8h.gif\" alt=\"\" /></p>\n<h1 id=\"iphone-x使用相关\"><a class=\"anchor\" href=\"#iphone-x使用相关\">#</a> iPhone X 使用相关</h1>\n<p>iPhone X 在系统手势上面交互和其他设备还是有一定区别的，因为加入了 Home Indicator 的原因，引入了新的手势，同时对以往的手势也做了相应的调整。</p>\n<h2 id=\"iphone-x-edge-protect\"><a class=\"anchor\" href=\"#iphone-x-edge-protect\">#</a> iPhone X Edge Protect</h2>\n<p>在 iPhone X 中通知中心和控制中心全部都移动到了由顶部刘海处下拉和右上角下拉来触发。原本底部的所有手势都被 Home Indicator 占用。其实 Edge Protect 在这里依然适用，只是对于 Home Indicator 的手势有一个小插曲。正常来说他在底部，就应该受到 UIRectEdgeBottom 或者是 UIRectEdgeAll 控制，但是一开始苹果并没有这么做，不论怎么写代码，他都有着最高的优先级，在 iPhone X 刚发布我就试图去处理交互问题，因为海报工厂并没有传统的 UITabBarController，且里面所有的 tableView 都是直通到底，但是始终都无法延迟执行与 Home Indicator 相关的任何手势。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo920zedwnj308w0j9gxa.jpg\" alt=\"\" /></p>\n<p>后来看了其他游戏，视频类 App 在 iPhone X 上的表现也都是如此。腾讯的王者荣耀，网易的吃鸡都是一样。腾讯官方给出的解释是暂时开起引导式访问，也仍然不方便。后来在今年 1 月 25 日苹果推送了 iOS 11.2.5 的版本更新，然后王者荣耀也跟着进行了一波更新，在进入游戏时候就会发现，底部的 Home Indicator 当你一段时间不去触碰它的时候由黑色或者白色 (根据当前的屏幕显示的内容来决定) 变成非常透明的灰色，当你第一次进行操作会默认执行 App 内手势，同时激活 Home Indicator，短时间内进行第二次操作就可以返回桌面</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo935pn8dsg30go07s1l2.gif\" alt=\"\" /></p>\n<p>一开以为是有新的 API 出现，不过看了交互文档并没有新的东西，而且小版本的系统更新应该也不会出现新的东西。所以找到了之前的 edge protect 代码运行后确实可以达到效果。对于视频，游戏等 App，确实可以起到很好的防误触的效果。遗憾的是并没有太多的人使用这个功能。目前主流的大型游戏，包括 Gameloft 出品的游戏都没做相应的处理。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo943bx7sog308h0gox6z.gif\" alt=\"\" /></p>\n<h2 id=\"iphone-x-home-indicator-hidden\"><a class=\"anchor\" href=\"#iphone-x-home-indicator-hidden\">#</a> iPhone X Home Indicator Hidden</h2>\n<p>如果说上面的 Edge Protect 适合在游戏中使用，那么 Home Indicator Hidden 则更适合在非游戏环境下增强 App 的沉浸感，尤其是全屏视屏播放、录制的时候。同样三个 API，和 Edge protect 的用法完全一样。</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Override to return a child view controller or nil. If non-nil, that view controller&#x27;s home indicator auto-hiding will be used. If nil, self is used. Whenever the return value changes, -setNeedsHomeIndicatorAutoHiddenUpdate should be called.</span></span><br><span class=\"line\">- (nullable UIViewController *)childViewControllerForHomeIndicatorAutoHidden <span class=\"constructor\">API_AVAILABLE(<span class=\"params\">ios</span>(11.0)</span>) <span class=\"constructor\">API_UNAVAILABLE(<span class=\"params\">watchos</span>, <span class=\"params\">tvos</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Controls the application&#x27;s preferred home indicator auto-hiding when this view controller is shown.</span></span><br><span class=\"line\">- (BOOL)prefersHomeIndicatorAutoHidden <span class=\"constructor\">API_AVAILABLE(<span class=\"params\">ios</span>(11.0)</span>) <span class=\"constructor\">API_UNAVAILABLE(<span class=\"params\">watchos</span>, <span class=\"params\">tvos</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This should be called whenever the return values for the view controller&#x27;s home indicator auto-hiding have changed.</span></span><br><span class=\"line\">- (void)setNeedsUpdateOfHomeIndicatorAutoHidden <span class=\"constructor\">API_AVAILABLE(<span class=\"params\">ios</span>(11.0)</span>) <span class=\"constructor\">API_UNAVAILABLE(<span class=\"params\">watchos</span>, <span class=\"params\">tvos</span>)</span>;</span><br></pre></td></tr></table></figure><br />\n 上面写的是自动隐藏，也就是说系统会根据当时的使用情况来进行显示或者隐藏，而不是永久的隐藏掉，实际测试发当界面两秒内没有进行任何交互操作的时候 Home Indicator 会逐渐隐去，直达屏幕上出现了点击的操作，注意是点击，TableView 的滑动并不能触发显示，不过只是是隐藏，但是手势依然可以使用。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo94hujx35g308h0go4qy.gif\" alt=\"\" /></p>\n<p>如果是 feed 流界面搭配酷一点的 UI 就会提高沉浸感，比如这样：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo94p0bmoqg308h0gox6t.gif\" alt=\"\" /></p>\n<p>有的人可能会问如果说点击的手势会触发它再次显示那我获取 window 上的交互每次在它即将显示的时候通过<strong> setNeedsUpdateOfHomeIndicatorAutoHidden</strong> 在让他隐藏不就好了吗？这样一来既不影响系统手势也不会让它在显示出来，其实我自己试过不行的，毕竟苹果不会让你这样改。</p>\n<h2 id=\"坑点\"><a class=\"anchor\" href=\"#坑点\">#</a> 坑点</h2>\n<p>需要注意的是：prefersHomeIndicatorAutoHidden 和 preferredScreenEdgesDeferringSystemGestures 不可一起使用，如果一起使用的话后者是不生效的。</p>\n",
            "tags": [
                "UI",
                "屏幕适配",
                "iOS 11"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-24-%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%85%A8%E7%9A%84iOS%E7%AB%AFHttpDns%E9%9B%86%E6%88%90%E6%96%B9%E6%A1%88/",
            "url": "https://oliverqueen.cn/2018-01-24-%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%85%A8%E7%9A%84iOS%E7%AB%AFHttpDns%E9%9B%86%E6%88%90%E6%96%B9%E6%A1%88/",
            "title": "可能是最全的iOS端HttpDns集成方案",
            "date_published": "2018-01-24T05:54:36.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"科普片\"><a class=\"anchor\" href=\"#科普片\">#</a> 科普片</h1>\n<h5 id=\"1-dns劫持的危害\"><a class=\"anchor\" href=\"#1-dns劫持的危害\">#</a> 1、DNS 劫持的危害</h5>\n<p>不知道大家有没有发现这样一个现象，在打开一些网页的时候会弹出一些与所浏览网页不相关的内容比如这样奇 (se) 怪 (qing) 的东西</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6jm5b190j30h60ugqkg.jpg\" alt=\"图一\" /></p>\n<p>或者这样<br />\n<span id=\"more\"></span></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6jmr1afuj30ww0ue4qp.jpg\" alt=\"图二\" />，</p>\n<p>其实造成这样的原因就是 DNS 劫持，在我们正常浏览的网页链接里面被恶意插入一些奇怪的东西。不止是这些，DNS 劫持还会对我们的个人信息安全造成很大的伤害，钓鱼网站之类的，也许我们所访问的网站根本不是我们需要的网站，或者根本打不开网页，有时还会消耗我们过多的流量。</p>\n<h5 id=\"2-什么是dns解析\"><a class=\"anchor\" href=\"#2-什么是dns解析\">#</a> 2、什么是 DNS 解析</h5>\n<p>现在假如我们访问一个网站 www.baidu.com 从按下回车到百度页面显示到我们的电脑上会经历如下几个步骤</p>\n<ul>\n<li>1：计算机会向我们的运营商 (移动、电信、联通等) 发出打开 www.baidu.com 的请求。</li>\n<li>2：运营商收到请求后会到自己的 DNS 服务器中找 www.baidu.com 这个域名所对应的服务器的 IP 地址 (也就是百度的服务器的 IP 地址)，这里比如是 180.149.132.47。</li>\n<li>3：运营商用第二步得到的 IP 地址去找到百度的服务器请求得到数据后返回给我们。</li>\n</ul>\n<p>其中第二步就是我们所说的 DNS 解析过程，域名和 IP 地址的关系其实就是我们的身份证号和姓名的关系，都是来标记一个人或者是一个网站的，只是 IP 地址 \\ 身份证号只是一串没有意义的数字，辨识度低，又不好记，所以就会在 IP 上加上一个域名以便区分，或是做的更加个性化，但是如果真的要来准确的区分还是要靠身份证号码或者是 IP 的，所以 DNS 解析就应运而生了。</p>\n<h5 id=\"3什么是dns劫持\"><a class=\"anchor\" href=\"#3什么是dns劫持\">#</a> 3：什么是 DNS 劫持</h5>\n<p>DNS 劫持，是指在 DNS 解析过程中拦截域名解析的请求，然后做一些自己的处理，比如返回假的 IP 地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能反应或访问的是假网址。根本原因就是以下两点：</p>\n<ul>\n<li>1：恶意攻击，拦截运营商的解析过程，把自己的非法东西嵌入其中。</li>\n<li>2：运营商为了利益或者一些其他的因素，允许一些第三方在自己的链接里打打广告之类的。</li>\n</ul>\n<h5 id=\"4防止dns劫持\"><a class=\"anchor\" href=\"#4防止dns劫持\">#</a> 4：防止 DNS 劫持</h5>\n<p>了解了 DNS 劫持的相关资料后我们就知道了，防止 NDS 劫持就要从第二步入手，因为 DNS 解析过程是运营商来操作的，我们不能去干涉他们，不然我们也就成了劫持者了，所以我们要做的就是在我们请求之前对我们的请求链接做一些修改，<span class=\"exturl\" data-url=\"aHR0cDovL3huLS13d3ctb3Q5ZHg4c3k0bm9qa284Y2c2azl1bmtwMWF3ODBkb3N5YS5iYWlkdS5jb20=\">将我们原本的请求链接 www.baidu.com</span> 修改为 180.149.132.47，然后请求出去，这样的话就运营商在拿到我们的请求后发现我们直接用的就是 IP 地址就会直接给我们放行，而不会去走他自己 DNS 解析了，也就是说我们把运营商要做的事情自己先做好了。不走他的 DNS 解析也就不会存在 DNS 被劫持的问题，从根本是解决了。</p>\n<h1 id=\"技术篇\"><a class=\"anchor\" href=\"#技术篇\">#</a> 技术篇</h1>\n<h5 id=\"5项目中的实际操作\"><a class=\"anchor\" href=\"#5项目中的实际操作\">#</a> 5：项目中的实际操作</h5>\n<h6 id=\"51dnspod相关\"><a class=\"anchor\" href=\"#51dnspod相关\">#</a> 5.1：DNSPOD 相关</h6>\n<p>我们知道要要把项目中请求的接口替换成成 IP 其实很简单，URL 是字符串，域名替换 IP，无非就是一个字符串替换而已，的确这块其实没有什么技术含量，而且现在像阿里云 (没开源)，七牛云 (开源)，等一些比较大的平台在这方面也都有了比较成熟的解决方案，一个 SDK，传个普通的 URL 进去就会返回一个域名被替换成 IP 的 URL 出来，也比较好用，这里要说一下 IP 地址的来源，如何拿到一个域名所对应的 IP 呢？这里就是需要用到另一个服务 ——HTTPDNS，国内比较有名的就是 DNSPOD，包括阿里，七牛等也是使用他们的 DNS 服务来解析，就是这个</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6jnbe2zhj30sa0i8dwv.jpg\" alt=\"DNSPOD logo\" /></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6jnt2uw9j31kw0icava.jpg\" alt=\"简介\" /></p>\n<p>他会给我们提供一个接口，我们使用 HTTP 请求的方式去请求这个接口，参数带上我们的域名，他们就会把域名对应的 IP 列表返回回来。类似这样：<br />\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///这个请求URL的结构是固定的119.29.29.29是DNSPOD固定的服务器地址，ttl参数的意思是返回结果是否带ttl是个BOOL，dn就是我们需要解析的域名，id就是我们在dnspod上注册时候他给我们的一个KEY</span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *url = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@&quot;http://119.29.29.29/d?ttl=1&amp;dn=www.baidu.com&amp;id=KEY&quot;</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSMutableURLRequest</span> * request = [<span class=\"built_in\">NSMutableURLRequest</span> requestWithURL:[<span class=\"built_in\">NSURL</span> URLWithString:url] cachePolicy:<span class=\"built_in\">NSURLRequestUseProtocolCachePolicy</span> timeoutInterval:<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSData</span> * data = [<span class=\"built_in\">NSURLConnection</span> sendSynchronousRequest:request returningResponse:<span class=\"literal\">nil</span> error:&amp;networkError];</span><br></pre></td></tr></table></figure></p>\n<p>这里使用同步还是异步都是可以的，具体根据你们业务需求。</p>\n<h6 id=\"52项目中的使用\"><a class=\"anchor\" href=\"#52项目中的使用\">#</a> 5.2：项目中的使用</h6>\n<p>其实 dnspod 最难的部分是接入的部分，因为不同的 APP 不同的网络环境会导致各种各样的问题，如果你是一个新的项目那么接入难度会大大降低，因为你完全可以自己封装一套网络请求，把 DNS 解析相关的逻辑都封装到自己的网络请求中，这样你就可以得到 APP 所有的网络层的控制权，想干什么就干什么，但是如果是在一个已经比较完善的 APP 中加入 DNS 防劫持的话那就是比较困难，因为你不能拿到所有网络请求的控制权这篇文章中我主要使用是 NSURLProtocol + Runtime hook 方式来处理这些东西的，NSURLProtocol 属于 iOS 黑魔法的一种可以拦截任何从 APP 的 URL Loading System 系统中发出的请求，其中包括如下</p>\n<ul>\n<li>File Transfer Protocol (ftp://)</li>\n<li>Hypertext Transfer Protocol (http://)</li>\n<li>Hypertext Transfer Protocol with encryption (https://)</li>\n<li>Local file URLs (file:///)</li>\n<li>Data URLs (data://)</li>\n</ul>\n<p>如果你的请求不在以上列表中就不能进行拦截了，比如 WKWebview，AVPlayer (比较特殊，虽然请求也是 http/https 但是就是不走这套系统，苹果爸爸就是这样～) 等，其实对于正常来说光用已经 NSURLProtocol 足够了。<br />\n  NSURLProtocol 这个类我们不能直接使用，我们需要自己创建一个他的子类然后在我们的子类中操作他们像这样<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 注册自定义protocol</span></span><br><span class=\"line\">[<span class=\"built_in\">NSURLProtocol</span> registerClass:[CustomURLProtocol <span class=\"keyword\">class</span>]];</span><br><span class=\"line\"> <span class=\"built_in\">NSURLSessionConfiguration</span> *configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">configuration.protocolClasses = @[[CustomURLProtocol <span class=\"keyword\">class</span>]];</span><br></pre></td></tr></table></figure><br />\n 在这个类中我们可以拦截到请求，然后进行处理。这个类中有四个非常重要的方法<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"type\">BOOL</span>)canInitWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLRequest</span> *)canonicalRequestForRequest:(<span class=\"built_in\">NSURLRequest</span> *)request;</span><br><span class=\"line\">- (<span class=\"type\">void</span>)startLoading;</span><br><span class=\"line\"><span class=\"comment\">//对于拦截的请求，NSURLProtocol对象在停止加载时调用该方法</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)stopLoading;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"boolcaninitwithrequestnsurlrequest-request\"><a class=\"anchor\" href=\"#boolcaninitwithrequestnsurlrequest-request\">#</a> + (BOOL)canInitWithRequest:(NSURLRequest *)request;</h6>\n<p>通过返回值来告诉 NSUrlProtocol 对进来的请求是否拦截，比如我只拦截 HTTP 的，或者是某个域名的请求之类</p>\n<h6 id=\"nsurlrequest-canonicalrequestforrequestnsurlrequest-request\"><a class=\"anchor\" href=\"#nsurlrequest-canonicalrequestforrequestnsurlrequest-request\">#</a> + (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request;</h6>\n<p>如果上面的方法返回 YES 那么 request 会传到这里，这个地方通常不做处理 直接返回 request</p>\n<h6 id=\"-voidstartloading\"><a class=\"anchor\" href=\"#-voidstartloading\">#</a> - (void)startLoading;</h6>\n<p>这个地方就是对我们拦截的请求做一些处理，我们文中所做的 IP 对域名的替换就在这里进行，处理完之后将请求转发出去，比如这样<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)startLoading &#123;</span><br><span class=\"line\"><span class=\"comment\">///其中customRequest是处理过的请求(域名替换后的)</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLSession</span> *session = [<span class=\"built_in\">NSURLSession</span> sessionWithConfiguration:[[<span class=\"built_in\">NSURLSessionConfiguration</span> alloc] init] delegate:<span class=\"keyword\">self</span> delegateQueue:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:customRequest];</span><br><span class=\"line\">    [task resume];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 你可以在 - startLoading 中使用任何方法来对协议对象持有的 request 进行转发，包括 NSURLSession、 NSURLConnection 甚至使用 AFNetworking 等网络库，只要你能在回调方法中把数据传回 client，帮助其正确渲染就可以，比如这样：<br />\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session dataTask:(<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTask didReceiveResponse:(<span class=\"built_in\">NSURLResponse</span> *)response completionHandler:(<span class=\"type\">void</span> (^)(<span class=\"built_in\">NSURLSessionResponseDisposition</span>))completionHandler &#123;</span><br><span class=\"line\">    [[<span class=\"keyword\">self</span> client] URLProtocol:<span class=\"keyword\">self</span> didReceiveResponse:response cacheStoragePolicy:<span class=\"built_in\">NSURLCacheStorageAllowed</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    completionHandler(<span class=\"built_in\">NSURLSessionResponseAllow</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session dataTask:(<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class=\"built_in\">NSData</span> *)data &#123;</span><br><span class=\"line\">    [[<span class=\"keyword\">self</span> client] URLProtocol:<span class=\"keyword\">self</span> didLoadData:data];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\nclient 在后面会有讲解。</p>\n<h6 id=\"-voidstoploading\"><a class=\"anchor\" href=\"#-voidstoploading\">#</a> - (void)stopLoading;</h6>\n<p>请求完毕后调用<br />\n大概的执行流程是这样</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6jtpp3z0j30ze1by122.jpg\" alt=\"流程\" /></p>\n<p>在 NSURLProtocol 中有一个贯穿始终的变量<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*!</span></span><br><span class=\"line\"><span class=\"comment\">    @method client</span></span><br><span class=\"line\"><span class=\"comment\">    @abstract Returns the NSURLProtocolClient of the receiver.</span></span><br><span class=\"line\"><span class=\"comment\">    @result The NSURLProtocolClient of the receiver.  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">readonly</span>, <span class=\"keyword\">retain</span>) <span class=\"type\">id</span> &lt;<span class=\"built_in\">NSURLProtocolClient</span>&gt; client;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 你可以认为是这个是请求的发送者，打个比方，A 想给 B 发送一个消息，由于距离遥远于是 A 去了邮局，A 把消息内容告诉了邮局，并且 A 在邮局登记了自己名字方便 B 有反馈的时候邮局来通知 A 查收。这个例子中邮局就是 NSURLProtocol，A 在邮局登记的名字就是 client。所有的 client 都实现了 NSURLProtocolClient 协议，协议的作用就是在 HTTP 请求发出以及接受响应时向其它对象传输数据：<br />\n<figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@protocol NSURLProtocolClient &lt;NSObject&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">- <span class=\"params\">(void)</span>URLProtocol:<span class=\"params\">(NSURLProtocol *)</span>protocol didReceiveResponse:<span class=\"params\">(NSURLResponse *)</span>response cacheStoragePolicy:<span class=\"params\">(NSURLCacheStoragePolicy)</span>policy;</span><br><span class=\"line\"></span><br><span class=\"line\">- <span class=\"params\">(void)</span>URLProtocol:<span class=\"params\">(NSURLProtocol *)</span>protocol didLoadData:<span class=\"params\">(NSData *)</span>data;</span><br><span class=\"line\"></span><br><span class=\"line\">- <span class=\"params\">(void)</span>URLProtocolDidFinishLoading:<span class=\"params\">(NSURLProtocol *)</span>protocol;</span><br><span class=\"line\">...</span><br><span class=\"line\">@<span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure><br />\n 当然这个协议中还有很多其他的方法，比如 HTTPS 验证、重定向以及响应缓存相关的方法，你需要在合适的时候调用这些代理方法，对信息进行传递。<br />\n到此正常情况下的 DNS 的解析过程已经结束，如果你发现按照如上操作之后并没有达到预期效果那么请往下看，(通常情况下完成以上操作 原有的 URL 的就会变成 http://123.456.789.123/XXX/XXX/XXX 的格式。如果发现请求不成功就往下看吧)</p>\n<h5 id=\"6遇到的坑点\"><a class=\"anchor\" href=\"#6遇到的坑点\">#</a> 6：遇到的坑点</h5>\n<h6 id=\"61我们知道运营商本来是根据域名来确定一个url的我们将域名改为ip之后虽然不用运营商帮我们解析了但是运营商在收到一串数字的时候也是懵逼状态我们还是需要将域名传给他们但是不能用正常的方式传我们需要把原来的域名加到http请求的header中的host字段下根据http协议的规定如果在url中无法找到域名的话就会去header中找这样一来我们既把域名告诉了运营商同时也直接制定了ip地址这个是必须配置的不然的话是请求不成功的\"><a class=\"anchor\" href=\"#61我们知道运营商本来是根据域名来确定一个url的我们将域名改为ip之后虽然不用运营商帮我们解析了但是运营商在收到一串数字的时候也是懵逼状态我们还是需要将域名传给他们但是不能用正常的方式传我们需要把原来的域名加到http请求的header中的host字段下根据http协议的规定如果在url中无法找到域名的话就会去header中找这样一来我们既把域名告诉了运营商同时也直接制定了ip地址这个是必须配置的不然的话是请求不成功的\">#</a> 6.1：我们知道运营商本来是根据域名来确定一个 URL 的，我们将域名改为 IP 之后虽然不用运营商帮我们解析了，但是运营商在收到一串数字的时候也是懵逼状态，我们还是需要将域名传给他们，但是不能用正常的方式传，我们需要把原来的域名加到 http 请求的 Header 中的 host 字段下，根据 Http 协议的规定，如果在 URL 中无法找到域名的话就会去 Header 中找，这样一来我们既把域名告诉了运营商同时也直接制定了 IP 地址，这个是必须配置的，不然的话是请求不成功的。</h6>\n<p><figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mutableRequest <span class=\"built_in\">set</span>Value:<span class=\"literal\">self</span>.request.URL.host <span class=\"keyword\">for</span>HTTPHeaderField:@<span class=\"string\">&quot;HOST&quot;</span>];</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"加上header再去请求就没问题了不过有些特殊的情况下会需要带上cookie同样也是加到header中\"><a class=\"anchor\" href=\"#加上header再去请求就没问题了不过有些特殊的情况下会需要带上cookie同样也是加到header中\">#</a> 加上 Header 再去请求就没问题了，不过有些特殊的情况下会需要带上 cookie，同样也是加到 Header 中</h6>\n<p><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">mutableRequest setValue:YOUR Cookie forHTTPHeaderField:@<span class=\"string\">&quot;Cookie&quot;</span></span>];</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"62关于afnetworking的问题现在大部分网络请求是基于afnetworking的这里有一个坑我们知道我们注册customprotocol的时候是这样\"><a class=\"anchor\" href=\"#62关于afnetworking的问题现在大部分网络请求是基于afnetworking的这里有一个坑我们知道我们注册customprotocol的时候是这样\">#</a> 6.2：关于 AfNetworking 的问题，现在大部分网络请求是基于 Afnetworking 的，这里有一个坑，我们知道我们注册 CustomProtocol 的时候是这样</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 注册自定义protocol</span></span><br><span class=\"line\">[<span class=\"built_in\">NSURLProtocol</span> registerClass:[CustomURLProtocol <span class=\"keyword\">class</span>]];</span><br><span class=\"line\"> <span class=\"built_in\">NSURLSessionConfiguration</span> *configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">configuration.protocolClasses = @[[CustomURLProtocol <span class=\"keyword\">class</span>]];</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"在系统的configuration加入我们的customprotocolprotocolclasses是一个数组里面可以放很多各种不同的customprotocol我们看一下afnetworking的初始化方法\"><a class=\"anchor\" href=\"#在系统的configuration加入我们的customprotocolprotocolclasses是一个数组里面可以放很多各种不同的customprotocol我们看一下afnetworking的初始化方法\">#</a> 在系统的 configuration 加入我们的 CustomProtocol，protocolClasses 是一个数组里面可以放很多各种不同的 CustomProtocol，我们看一下 afnetworking 的初始化方法。</h6>\n<p><figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AFHTTPSessionManager * sessionManager <span class=\"operator\">=</span> [AFHTTPSessionManager manager]<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure></p>\n<h6 id=\"我相信大家通常都会这么来创建但是这里我要说下manager并不是一个单利最后都会调到一个方法\"><a class=\"anchor\" href=\"#我相信大家通常都会这么来创建但是这里我要说下manager并不是一个单利最后都会调到一个方法\">#</a> 我相信大家通常都会这么来创建，但是这里我要说下 manager 并不是一个单利，最后都会调到一个方法</h6>\n<p><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">-</span> (instancetype)initWithSessionConfiguration:(<span class=\"type\">NSURLSessionConfiguration</span> <span class=\"operator\">*</span>)configuration &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> <span class=\"operator\">=</span> [<span class=\"keyword\">super</span> <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"operator\">!</span><span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"operator\">!</span>configuration) &#123;</span><br><span class=\"line\">        configuration <span class=\"operator\">=</span> [<span class=\"type\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.sessionConfiguration <span class=\"operator\">=</span> configuration;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.operationQueue <span class=\"operator\">=</span> [[<span class=\"type\">NSOperationQueue</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.operationQueue.maxConcurrentOperationCount <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.session <span class=\"operator\">=</span> [<span class=\"type\">NSURLSession</span> sessionWithConfiguration:<span class=\"keyword\">self</span>.sessionConfiguration delegate:<span class=\"keyword\">self</span> delegateQueue:<span class=\"keyword\">self</span>.operationQueue];</span><br><span class=\"line\">    .</span><br><span class=\"line\">    .</span><br><span class=\"line\">    .</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h6 id=\"大家注意第二个判断如果没有传入configuration的话他会创建一个默认的这样以至于我们之前在configuration的protocolclasses中注册类全部被这个新的configuration替换掉了所以无法解析-这里我采取的办法就是runtime-hook因为hook第三方的代码并不是一个很好的办法所以我直接hook-nsurlsession的sessionwithconfiguration方法因为通过观察afnetworking的源码最终都是走到这里的-hook之后把自己的configuration换进去像这样\"><a class=\"anchor\" href=\"#大家注意第二个判断如果没有传入configuration的话他会创建一个默认的这样以至于我们之前在configuration的protocolclasses中注册类全部被这个新的configuration替换掉了所以无法解析-这里我采取的办法就是runtime-hook因为hook第三方的代码并不是一个很好的办法所以我直接hook-nsurlsession的sessionwithconfiguration方法因为通过观察afnetworking的源码最终都是走到这里的-hook之后把自己的configuration换进去像这样\">#</a> 大家注意第二个判断，如果没有传入 configuration 的话他会创建一个默认的，这样以至于我们之前在 configuration 的 protocolClasses 中注册类全部被这个新的 configuration 替换掉了，所以无法解析。这里我采取的办法就是 runtime hook，因为 hook 第三方的代码并不是一个很好的办法，所以我直接 hook NSURLSession 的 sessionWithConfiguration 方法，因为通过观察 Afnetworking 的源码最终都是走到这里的。Hook 之后把自己的 configuration 换进去，像这样</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">NSURLSession</span> *)swizzle_sessionWithConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionConfiguration</span> *newConfiguration = configuration;</span><br><span class=\"line\">    <span class=\"comment\">// 在现有的Configuration中插入我们自定义的protocol</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (configuration) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSMutableArray</span> *protocolArray = [<span class=\"built_in\">NSMutableArray</span> arrayWithArray:configuration.protocolClasses];</span><br><span class=\"line\">        [protocolArray insertObject:[CustomProtocol <span class=\"keyword\">class</span>] atIndex:<span class=\"number\">0</span>];</span><br><span class=\"line\">        newConfiguration.protocolClasses = protocolArray;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newConfiguration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">        <span class=\"built_in\">NSMutableArray</span> *protocolArray = [<span class=\"built_in\">NSMutableArray</span> arrayWithArray:configuration.protocolClasses];</span><br><span class=\"line\">        [protocolArray insertObject:[CustomProtocol <span class=\"keyword\">class</span>] atIndex:<span class=\"number\">0</span>];</span><br><span class=\"line\">        newConfiguration.protocolClasses = protocolArray;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> swizzle_sessionWithConfiguration:newConfiguration];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"然后就完美解决了-不过要注意下系统的是有两个方法的\"><a class=\"anchor\" href=\"#然后就完美解决了-不过要注意下系统的是有两个方法的\">#</a> 然后就完美解决了。不过要注意下系统的是有两个方法的</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Customization of NSURLSession occurs during creation of a new session.</span></span><br><span class=\"line\"><span class=\"comment\"> * If you only need to use the convenience routines with custom</span></span><br><span class=\"line\"><span class=\"comment\"> * configuration options it is not necessary to specify a delegate.</span></span><br><span class=\"line\"><span class=\"comment\"> * If you do specify a delegate, the delegate will be retained until after</span></span><br><span class=\"line\"><span class=\"comment\"> * the delegate has been sent the URLSession:didBecomeInvalidWithError: message.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLSession</span> *)sessionWithConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLSession</span> *)sessionWithConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration delegate:(<span class=\"keyword\">nullable</span> <span class=\"type\">id</span> &lt;<span class=\"built_in\">NSURLSessionDelegate</span>&gt;)delegate delegateQueue:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSOperationQueue</span> *)queue;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"这两个方法不能确定最终会走那个所以为了保险起见都hook下hook的方式是一样的\"><a class=\"anchor\" href=\"#这两个方法不能确定最终会走那个所以为了保险起见都hook下hook的方式是一样的\">#</a> 这两个方法不能确定最终会走那个，所以为了保险起见都 hook 下，hook 的方式是一样的</h6>\n<h6 id=\"63avplayer请求avplayer是我们ios系统中系统自带的播放视频的框架用到地方也很多但是这个是比较坑的因为avplayer虽然也有httphttpsfile请求这个概念但是avplayer所有的请求都不会走url-loading-system也就是说所有由avplayer发出的请求都不能被我们的customprotocol拦截这时候大家也许会问不对呀我们正常调试的时候可以被拦截到的啊-其实苹果官方上是说avplayer在真机调试和模拟器调试时候走的完全不是一套策略也就是说在模拟器运行时候是完全正常的可以被拦截到也可以被解析但是在真机上面就恰恰相反了因为我们最后还是以真机为准所以我们采取的办法还是hook因为我们需要在媒体url传给avplayer前就要将相关东西配置好域名替换啊加host啊之类的所以我们要找avplayer的入口先看初始化方法我发现项目中使用一个avurlasset来初始化avplayer那么avurlasset又是什么呢继续查到avurlasset的初始化方法可以发现这个方法\"><a class=\"anchor\" href=\"#63avplayer请求avplayer是我们ios系统中系统自带的播放视频的框架用到地方也很多但是这个是比较坑的因为avplayer虽然也有httphttpsfile请求这个概念但是avplayer所有的请求都不会走url-loading-system也就是说所有由avplayer发出的请求都不能被我们的customprotocol拦截这时候大家也许会问不对呀我们正常调试的时候可以被拦截到的啊-其实苹果官方上是说avplayer在真机调试和模拟器调试时候走的完全不是一套策略也就是说在模拟器运行时候是完全正常的可以被拦截到也可以被解析但是在真机上面就恰恰相反了因为我们最后还是以真机为准所以我们采取的办法还是hook因为我们需要在媒体url传给avplayer前就要将相关东西配置好域名替换啊加host啊之类的所以我们要找avplayer的入口先看初始化方法我发现项目中使用一个avurlasset来初始化avplayer那么avurlasset又是什么呢继续查到avurlasset的初始化方法可以发现这个方法\">#</a> 6.3：AVPlayer 请求，AVPlayer 是我们 iOS 系统中系统自带的播放视频的框架，用到地方也很多，但是这个是比较坑的，因为 AVPlayer 虽然也有 http/https/file…… 请求这个概念，但是 AVPlayer 所有的请求都不会走 URL Loading System，也就是说所有由 AVPlayer 发出的请求都不能被我们的 CustomProtocol 拦截，这时候大家也许会问，不对呀，我们正常调试的时候可以被拦截到的啊。其实苹果官方上是说 AVPlayer 在真机调试和模拟器调试时候走的完全不是一套策略，也就是说在模拟器运行时候是完全正常的，可以被拦截到也可以被解析，但是在真机上面就恰恰相反了，因为我们最后还是以真机为准，所以我们采取的办法还是 hook，因为我们需要在媒体 URL 传给 AVPlayer 前就要将相关东西配置好，域名替换啊，加 host 啊之类的，所以我们要找 AVPlayer 的入口，先看初始化方法，我发现项目中使用一个 AVURLAsset 来初始化 AVPlayer，那么 AVURLAsset 又是什么呢？继续查到 AVURLAsset 的初始化方法，可以发现这个方法：</h6>\n<p><figure class=\"highlight smali\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*!</span><br><span class=\"line\">  @method\t\tinitWithURL:options:</span><br><span class=\"line\">  @abstract\t\tInitializes an<span class=\"built_in\"> instance </span>of AVURLAsset for inspection of a media resource.</span><br><span class=\"line\">  @param\t\tURL</span><br><span class=\"line\">\t\t\t\tAn<span class=\"built_in\"> instance </span>of NSURL that references a media resource.</span><br><span class=\"line\">  @param\t\toptions</span><br><span class=\"line\">\t\t\t\tAn<span class=\"built_in\"> instance </span>of NSDictionary that contains keys for specifying options for the initialization of the AVURLAsset. See AVURLAssetPreferPreciseDurationAndTimingKey<span class=\"built_in\"> and </span>AVURLAssetReferenceRestrictionsKey above.</span><br><span class=\"line\">  @result\t\tAn<span class=\"built_in\"> instance </span>of AVURLAsset.</span><br><span class=\"line\">*/</span><br><span class=\"line\">- (instancetype)initWithURL:(NSURL *)URL options:(nullable NSDictionary&lt;NSString *, id&gt; *)options NS_DESIGNATED_INITIA<span class=\"class\">LIZER;</span></span><br></pre></td></tr></table></figure></p>\n<h6 id=\"其中url就是我们传给avplayer播放的url找到目标就hook下就可以了具体过程就不多说了还是字符串替换但是有一点需要注意的是我之前上文说过做完ip对域名的替换之后还需要设置下request的host但是这个地方只有一个url并没有request该如何处理呢其实这个方法里面的opinion参数就是处理这个的可以添加cookie之类的类似与httpheader的东西可以添加这几个key\"><a class=\"anchor\" href=\"#其中url就是我们传给avplayer播放的url找到目标就hook下就可以了具体过程就不多说了还是字符串替换但是有一点需要注意的是我之前上文说过做完ip对域名的替换之后还需要设置下request的host但是这个地方只有一个url并没有request该如何处理呢其实这个方法里面的opinion参数就是处理这个的可以添加cookie之类的类似与httpheader的东西可以添加这几个key\">#</a> 其中 URL 就是我们传给 AVPlayer 播放的 URL，找到目标就 Hook 下就可以了，具体过程就不多说了还是字符串替换，但是有一点需要注意的是，我之前上文说过做完 IP 对域名的替换之后还需要设置下 request 的 Host，但是这个地方只有一个 URL 并没有 Request 该如何处理呢？其实这个方法里面的 opinion 参数就是处理这个的，可以添加 cookie 之类的类似与 httpheader 的东西，可以添加这几个 Key</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">AVF_EXPORT</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">AVURLAssetPreferPreciseDurationAndTimingKey</span> <span class=\"built_in\">NS_AVAILABLE</span>(<span class=\"number\">10</span>_7, <span class=\"number\">4</span>_0);</span><br><span class=\"line\"><span class=\"built_in\">AVF_EXPORT</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">AVURLAssetReferenceRestrictionsKey</span> <span class=\"built_in\">NS_AVAILABLE</span>(<span class=\"number\">10</span>_7, <span class=\"number\">5</span>_0);</span><br><span class=\"line\"><span class=\"built_in\">AVF_EXPORT</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">AVURLAssetHTTPCookiesKey</span> <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0);</span><br><span class=\"line\"><span class=\"built_in\">AVF_EXPORT</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">AVURLAssetAllowsCellularAccessKey</span> <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">10</span>_0);</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"但是并没有发现和host相关的key其实这个key是有的就是avurlassethttpheaderfieldskey只是因为这个key没暴露出来-这个地方不太确定是不是苹果的私有api网上查了大量的资料也没有个说法甚至我亲自去苹果开发者去问苹果也没有给任何答复各种说法都有具体使用的话就是\"><a class=\"anchor\" href=\"#但是并没有发现和host相关的key其实这个key是有的就是avurlassethttpheaderfieldskey只是因为这个key没暴露出来-这个地方不太确定是不是苹果的私有api网上查了大量的资料也没有个说法甚至我亲自去苹果开发者去问苹果也没有给任何答复各种说法都有具体使用的话就是\">#</a> 但是并没有发现和 Host 相关的 Key，其实这个 key 是有的就是 AVURLAssetHTTPHeaderFieldsKey 只是因为这个 Key 没暴露出来。这个地方不太确定是不是苹果的私有 API，网上查了大量的资料也没有个说法，甚至我亲自去苹果开发者去问，苹果也没有给任何答复，各种说法都有，具体使用的话就是</h6>\n<p><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"variable language_\">self</span> <span class=\"symbol\">swizzle_initWithURL:</span>videoURL <span class=\"symbol\">options:</span>@&#123;AVURLAssetHTTPHeaderFieldsKey : @&#123;@<span class=\"string\">&quot;Host&quot;</span><span class=\"symbol\">:host</span>&#125;&#125;]</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"这样使用是没有任何问题的但是毕竟是没有暴露出来的方法我们不能这样明目张胆的使用其实对于字符串来说还是比较好规避的只要不要明文出现这个key就可以我在这里使用了一个加密吧key变成密文然后这个地方通过解密获取就像这样\"><a class=\"anchor\" href=\"#这样使用是没有任何问题的但是毕竟是没有暴露出来的方法我们不能这样明目张胆的使用其实对于字符串来说还是比较好规避的只要不要明文出现这个key就可以我在这里使用了一个加密吧key变成密文然后这个地方通过解密获取就像这样\">#</a> 这样使用是没有任何问题的，但是毕竟是没有暴露出来的方法，我们不能这样明目张胆的使用，其实对于字符串来说还是比较好规避的，只要不要明文出现这个 KEY 就可以，我在这里使用了一个加密，吧 key 变成密文然后这个地方通过解密获取，就像这样：</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//加密后的KEY</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">NSString</span> * headerKey = <span class=\"string\">@&quot;35905FF45AFA4C579B7DE2403C7CA0CCB59AA83D660E60C9D444AFE13323618F&quot;</span>;</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\"><span class=\"comment\">//getRequestHeaderKey方法为解密方法</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> swizzle_initWithURL:videoURL options:@&#123;[<span class=\"keyword\">self</span> getRequestHeaderKey] : @&#123;<span class=\"string\">@&quot;Host&quot;</span>:host&#125;&#125;];</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"这样之后就大功告成了avplayer可以在dns被劫持的情况下播放了\"><a class=\"anchor\" href=\"#这样之后就大功告成了avplayer可以在dns被劫持的情况下播放了\">#</a> 这样之后就大功告成了，AVPlayer 可以在 DNS 被劫持的情况下播放了，</h6>\n<h6 id=\"64post请求这块也算是一个大坑我们知道http的post请求会包含一个body体里面包含我们需要上传的参数等一些资料对于post请求我们的nsurlprotocol是可以正常拦截的但是我们拦截之后发现无论怎么样我们获得的body体都为nil后来查了一些资料发下又是苹果爸爸在做手脚-nsurlprotocol在拦截nsurlsession的post请求时不能获取到request中的httpbody这个貌似早就国外的论坛上传开了但国内好像还鲜有人知据苹果官方的解释是body是nsdata类型即可能为二进制内容而且还没有大小限制所以可能会很大为了性能考虑索性就拦截时就不拷贝了内流满面脸-为了解决这个问题我们可以通过把body数据放到header中不过header的大小好像是有限制的我试过2m是没有问题不过超过10m就直接request-timeout了-而且当body数据为二进制数据时这招也没辙了因为header里都是文本数据另一种方案就是用一个nsdictionary或nscache保存没有请求的body数据用url为key最后方法就是别用nsurlsession老老实实用古老的nsurlconnection算了-你以为这么就结束了吗并没有后来查了大量的资料发现既然post请求的httpbody没有苹果复制下来那我们就不用httpbody我们再往底层去看就会发现httpbodystream这个东西我们可以通过他来获取请求的body体具体代吗如下\"><a class=\"anchor\" href=\"#64post请求这块也算是一个大坑我们知道http的post请求会包含一个body体里面包含我们需要上传的参数等一些资料对于post请求我们的nsurlprotocol是可以正常拦截的但是我们拦截之后发现无论怎么样我们获得的body体都为nil后来查了一些资料发下又是苹果爸爸在做手脚-nsurlprotocol在拦截nsurlsession的post请求时不能获取到request中的httpbody这个貌似早就国外的论坛上传开了但国内好像还鲜有人知据苹果官方的解释是body是nsdata类型即可能为二进制内容而且还没有大小限制所以可能会很大为了性能考虑索性就拦截时就不拷贝了内流满面脸-为了解决这个问题我们可以通过把body数据放到header中不过header的大小好像是有限制的我试过2m是没有问题不过超过10m就直接request-timeout了-而且当body数据为二进制数据时这招也没辙了因为header里都是文本数据另一种方案就是用一个nsdictionary或nscache保存没有请求的body数据用url为key最后方法就是别用nsurlsession老老实实用古老的nsurlconnection算了-你以为这么就结束了吗并没有后来查了大量的资料发现既然post请求的httpbody没有苹果复制下来那我们就不用httpbody我们再往底层去看就会发现httpbodystream这个东西我们可以通过他来获取请求的body体具体代吗如下\">#</a> 6.4：POST 请求这块也算是一个大坑，我们知道 http 的 post 请求会包含一个 body 体，里面包含我们需要上传的参数等一些资料，对于 POST 请求我们的 NSURLProtocol 是可以正常拦截的，但是我们拦截之后发现无论怎么样我们获得的 body 体都为 nil！后来查了一些资料发下又是苹果爸爸在做手脚。NSURLProtocol 在拦截 NSURLSession 的 POST 请求时不能获取到 Request 中的 HTTPBody，这个貌似早就国外的论坛上传开了，但国内好像还鲜有人知，据苹果官方的解释是 Body 是 NSData 类型，即可能为二进制内容，而且还没有大小限制，所以可能会很大，为了性能考虑，索性就拦截时就不拷贝了（内流满面脸）。为了解决这个问题，我们可以通过把 Body 数据放到 Header 中，不过 Header 的大小好像是有限制的，我试过 2M 是没有问题，不过超过 10M 就直接 Request timeout 了。。。而且当 Body 数据为二进制数据时这招也没辙了，因为 Header 里都是文本数据，另一种方案就是用一个 NSDictionary 或 NSCache 保存没有请求的 Body 数据，用 URL 为 key，最后方法就是别用 NSURLSession，老老实实用古老的 NSURLConnection 算了。。。你以为这么就结束了吗？并没有，后来查了大量的资料发现，既然 post 请求的 httpbody 没有苹果复制下来，那我们就不用 httpbody，我们再往底层去看就会发现 HTTPBodyStream 这个东西我们可以通过他来获取请求的 body 体具体代吗如下</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark -</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark 处理POST请求相关POST  用HTTPBodyStream来处理BODY体</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSMutableURLRequest</span> *)handlePostRequestBodyWithRequest:(<span class=\"built_in\">NSMutableURLRequest</span> *)request &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableURLRequest</span> * req = [request mutableCopy];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([request.HTTPMethod isEqualToString:<span class=\"string\">@&quot;POST&quot;</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!request.HTTPBody) &#123;</span><br><span class=\"line\">            uint8_t d[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">            <span class=\"built_in\">NSInputStream</span> *stream = request.HTTPBodyStream;</span><br><span class=\"line\">            <span class=\"built_in\">NSMutableData</span> *data = [[<span class=\"built_in\">NSMutableData</span> alloc] init];</span><br><span class=\"line\">            [stream open];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ([stream hasBytesAvailable]) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">NSInteger</span> len = [stream read:d maxLength:<span class=\"number\">1024</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (len &gt; <span class=\"number\">0</span> &amp;&amp; stream.streamError == <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">                    [data appendBytes:(<span class=\"type\">void</span> *)d length:len];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            req.HTTPBody = [data <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">            [stream close];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> req;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h6 id=\"这样之后的req就是携带了body体的request啦可以愉快地做post请求啦\"><a class=\"anchor\" href=\"#这样之后的req就是携带了body体的request啦可以愉快地做post请求啦\">#</a> 这样之后的 req 就是携带了 body 体的 request 啦，可以愉快地做 post 请求啦。</h6>\n<h6 id=\"65wkwebview是新出的浏览器控件这里就不多说了wkwebview不走url-loading-system所以也不会被拦截不过也是有办法的但是因为这次项目中没有用到所以没有过多的去研究后续我会写一篇关于这个博客不是很难依旧是runtime大法\"><a class=\"anchor\" href=\"#65wkwebview是新出的浏览器控件这里就不多说了wkwebview不走url-loading-system所以也不会被拦截不过也是有办法的但是因为这次项目中没有用到所以没有过多的去研究后续我会写一篇关于这个博客不是很难依旧是runtime大法\">#</a> 6.5：WKWebview 是新出的浏览器控件，这里就不多说了，WKWebview 不走 URL Loading System，所以也不会被拦截，不过也是有办法的，但是因为这次项目中没有用到，所以没有过多的去研究，后续我会写一篇关于这个博客，不是很难，依旧是 runtime 大法。</h6>\n<h6 id=\"66sni环境这个可是坑了我好久好久的东西所以我会放在最后去说sni环境因为涉及到证书验证所以是在https的基础上来说的sniserver-name-indication是为了解决一个服务器使用多个域名和证书的扩展-一句话简述它的工作原理就是在连接到服务器建立ssl链接之前先发送要访问站点的域名hostname这样服务器根据这个域名返回一个合适的证书-其实关于sni环境在这里就不过多解释阿里云文档有很明白的解释同时他也有安卓和ios在sni环境下的处理文档我们发现安卓部分写的很详细可是已到了ios这边就这样了\"><a class=\"anchor\" href=\"#66sni环境这个可是坑了我好久好久的东西所以我会放在最后去说sni环境因为涉及到证书验证所以是在https的基础上来说的sniserver-name-indication是为了解决一个服务器使用多个域名和证书的扩展-一句话简述它的工作原理就是在连接到服务器建立ssl链接之前先发送要访问站点的域名hostname这样服务器根据这个域名返回一个合适的证书-其实关于sni环境在这里就不过多解释阿里云文档有很明白的解释同时他也有安卓和ios在sni环境下的处理文档我们发现安卓部分写的很详细可是已到了ios这边就这样了\">#</a> 6.6：SNI 环境，这个可是坑了我好久好久的东西，所以我会放在最后去说，SNI 环境因为涉及到证书验证所以是在 https 的基础上来说的，SNI（Server Name Indication）是为了解决一个服务器使用多个域名和证书的扩展。一句话简述它的工作原理就是，在连接到服务器建立 SSL 链接之前先发送要访问站点的域名（Hostname），这样服务器根据这个域名返回一个合适的证书。其实关于 SNI 环境在这里就不过多解释，**<span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vZG9jdW1lbnRfZGV0YWlsLzMwMTQzLmh0bWw=\"> 阿里云文档</span> ** 有很明白的解释，同时他也有安卓和 iOS 在 SNI 环境下的处理文档，我们发现安卓部分写的很详细，可是已到了 iOS 这边就这样了：</h6>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6juzsqdqj31kw0bbn5v.jpg\" alt=\"阿里云文档截图\" /></p>\n<h6 id=\"三行文字加三个链接就完事了-其实在遇到这个坑的时候我也查过很多相关资料无非就是这三行话加这三个链接复制来复制去没有实质性的进展大部分公司或者是项目没有这么重的httpdns需求所以也就不会有这个环境即使遇到了也就直接关闭httpdns了后来只能自己去用cfnetwork一点点实现-具体代码就不跟大家粘贴了因为涉及到一些公司内部的代码不过我会把我主要的参考资料发给大家-这里有个小技巧因为都在说cfnetwork是比较底层的网络实现好多东西需要开发者自行处理比如一些变量的释放之类的所以我们能少用尽量少用因为cfnetwork是为snihttps环境服务所以我们在拦截判断的时候可以区分是用上层的网络请求转发还是用底层的cfnetwork来转发\"><a class=\"anchor\" href=\"#三行文字加三个链接就完事了-其实在遇到这个坑的时候我也查过很多相关资料无非就是这三行话加这三个链接复制来复制去没有实质性的进展大部分公司或者是项目没有这么重的httpdns需求所以也就不会有这个环境即使遇到了也就直接关闭httpdns了后来只能自己去用cfnetwork一点点实现-具体代码就不跟大家粘贴了因为涉及到一些公司内部的代码不过我会把我主要的参考资料发给大家-这里有个小技巧因为都在说cfnetwork是比较底层的网络实现好多东西需要开发者自行处理比如一些变量的释放之类的所以我们能少用尽量少用因为cfnetwork是为snihttps环境服务所以我们在拦截判断的时候可以区分是用上层的网络请求转发还是用底层的cfnetwork来转发\">#</a> 三行文字加三个链接就完事了。其实在遇到这个坑的时候我也查过很多相关资料，无非就是这三行话加这三个链接复制来复制去，没有实质性的进展，大部分公司或者是项目没有这么重的 Httpdns 需求，所以也就不会有这个环境，即使遇到了也就直接关闭 httpdns 了，后来只能自己去用 CFNetwork 一点点实现。具体代码就不跟大家粘贴了因为涉及到一些公司内部的代码，不过我会把我 **<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0RhdmUxOTkxL2FsaWNsb3VkLWlvcy1kZW1vL2Jsb2IvbWFzdGVyL2h0dHBkbnNfaW9zX2RlbW8vaHR0cGRuc19pb3NfZGVtby9DRkh0dHBNZXNzYWdlVVJMUHJvdG9jb2wubQ==\"> 主要的参考资料</span> ** 发给大家。这里有个小技巧，因为都在说 CFNetwork 是比较底层的网络实现，好多东西需要开发者自行处理比如一些变量的释放之类的，所以我们能少用尽量少用，因为 Cfnetwork 是为 SNI (https) 环境服务，所以我们在拦截判断的时候可以区分是用上层的网络请求转发还是用底层的 cfnetwork 来转发，</h6>\n<p><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span>.request.<span class=\"type\">URL</span>.scheme isEqualToString:@<span class=\"string\">&quot;https&quot;</span>] ) &#123;</span><br><span class=\"line\"><span class=\"comment\">//使用CFnetwork</span></span><br><span class=\"line\">        curRequest <span class=\"operator\">=</span> req;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.task <span class=\"operator\">=</span> [[<span class=\"type\">CustomCFNetworkRequestTask</span> alloc] initWithURLRequest:originalRequest swizzleRequest:curRequest delegate:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.task) &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span>.task startLoading];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//使用普通网络请求</span></span><br><span class=\"line\">        <span class=\"type\">NSURLSessionConfiguration</span> <span class=\"operator\">*</span>configuration <span class=\"operator\">=</span> [<span class=\"type\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.session <span class=\"operator\">=</span> [<span class=\"type\">NSURLSession</span> sessionWithConfiguration:configuration delegate:<span class=\"keyword\">self</span> delegateQueue:[<span class=\"type\">NSOperationQueue</span> mainQueue]];</span><br><span class=\"line\">        <span class=\"type\">NSURLSessionTask</span> <span class=\"operator\">*</span>task <span class=\"operator\">=</span> [<span class=\"keyword\">self</span>.session dataTaskWithRequest:req];</span><br><span class=\"line\">        [task resume];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"我是这么做的\"><a class=\"anchor\" href=\"#我是这么做的\">#</a> 我是这么做的。</h6>\n<h6 id=\"67在nsurlprotocol中的那几个类方法中是可以发送同步请求的但是在实例方法发送同步请求就会卡死所以实例方法中不能有任何的阻塞进行同步操作-不然就卡死\"><a class=\"anchor\" href=\"#67在nsurlprotocol中的那几个类方法中是可以发送同步请求的但是在实例方法发送同步请求就会卡死所以实例方法中不能有任何的阻塞进行同步操作-不然就卡死\">#</a> 6.7：在 NSURLProtocol 中的那几个类方法中是可以发送同步请求的，但是在实例方法发送同步请求就会卡死，所以实例方法中不能有任何的阻塞，进行同步操作。不然就卡死。</h6>\n<h5 id=\"7总结\"><a class=\"anchor\" href=\"#7总结\">#</a> 7：总结</h5>\n<p>完成了以上的步骤之后你回发现在 DNS 坏掉的情况下手机里面除了微信 QQ (他们也做了 DNS 解析) 之外其他应用都不能上网了但是你的 App 依然可以正常浏览网络数据。这就是我最近在做的时候遇到的一些问题，有什么问题及时与我交流吧</p>\n",
            "tags": [
                "网络",
                "底层",
                "httpdns"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-24-%E5%9C%A8iOS%E5%B7%A5%E7%A8%8B%E4%B8%ADCocoapods%E7%9A%84%E4%BD%BF%E7%94%A8/",
            "url": "https://oliverqueen.cn/2018-01-24-%E5%9C%A8iOS%E5%B7%A5%E7%A8%8B%E4%B8%ADCocoapods%E7%9A%84%E4%BD%BF%E7%94%A8/",
            "title": "在iOS工程中Cocoapods的使用",
            "date_published": "2018-01-24T04:42:28.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>我们在开发 iOS 程序的时候，往往都会根据需要导入很多的第三方框架，但是不同的框架完成的功能不同，所以导入的方式也不同，并不是把它直接拖进工程中就完事了，我们需要配置各种环境，链接各种库文件等等。有的时候我们并不能一个不漏的完成导入，而一旦出了问题，尤其是那些需要框架比较多的工程 (比如早期的百度地图框架)，将很难解决，而且，如果遇到了第三方库升级，更新了方法那么我们还需要把之前的旧版本删掉，再重复一下前面的工作，这将是非常的繁琐，极大地影响了开发的效率。这个时候我们就需要用到 cocoapods 来管理我们的第三方了，在我们有了 CocoaPods 这个工具之后，只需要将用到的第三方开源库放到一个名为 Podfile 的文件中，<br />\n<span id=\"more\"></span><br />\n 然后在命令行执行 $ pod install 命令。CocoaPods 就会自动将这些第三方开源库的源码下载下来，并且为我的工程设置好相应的系统依赖和编译参数，不管是导入还是更新或者移除，都是一句命令就搞定的。网上也有类似的教程，但是有些很旧，有些写的不详细，导致新手在使用的时候整的一头雾水，我就来说下。<br />\n### 第一步 ：<br />\n首先安装 cocoapods 要在 ruby 环境下进行，虽然我们的 mac 系统都是自带了 ruby，但是为了保险起见我们还是要先更新一下 ruby 环境：在这里我们直接使用   sudo gem update --system   命令来更新，网上有的说使用 gem update --system 前面少了 sudo，其实加 sudo 的目的就是用管理员的权限去执行这句更新命令，不加的话容易出现这个错误</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6jyxwn6cj30ta06kn1a.jpg\" alt=\"\" /></p>\n<p>意思是你没有权限去执行这个命令，等出现了 RubyGems system software updated 这句话的时候就证明升级成功了。</p>\n<p>### 第二步：<br />\n安装 cocoapods 时候我们要访问 cocoapods.org 这个网站，不用想这个网站已经被墙了，所以我们可以用淘宝的 ruby 的镜像来访问该网站。首先我们输入 gem sources -l 来看一下我们现在有什么，我目前里面只有一个</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6jzdqmrlj30ma03ydjy.jpg\" alt=\"\" /></p>\n<p>也就是我们需要的，不过可能有些人的里面不止一个，会有其他的东西，这时候我们先用 gem sources --remove XXXXXXXXXXXXXXX 来把其他的 source 删除掉，只保留这一个，如果没有的话就手动添加用这个命令 gem sources -a <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ydWJ5LnRhb2Jhby5vcmcv\">https://ruby.taobao.org/</span> 来将我们需要的源添加进去，最后再用那个查看命令 最后只有确保像我里面一样只有那一个就好，要注意的是 https  网上好多教程写的是 http，那个已经作废了</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6jzxkmf5j31kw0ask74.jpg\" alt=\"\" /></p>\n<h3 id=\"第三步\"><a class=\"anchor\" href=\"#第三步\">#</a> 第三步：</h3>\n<p>安装是 cocoapods 使用 sudo gem install cocoapods 命令来安装 cocoapods，你输入完这个命令回车后会提示你输入密码，这时候是没有光标提示的，也不会移动，凭感觉输入对之后就回车吧，然后就是等，时间长短是根据你的网速来的。安装完成后终端就进入待命阶段了。<br />\n### 第四步：<br />\n使用 search 命令来搜索类库，这个是支持模糊搜索的，记不清全名，打一部分名也行，不过那样的就要从搜出来的东西里找你想要的类库了。比如我想找 afnetworking 我就输入 pod search afn 回车后就会输出所有以 afn 开头的类库名字，像这样</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k0kkcjjj311u0wq4qp.jpg\" alt=\"\" /></p>\n<p>搜出很多，其中第三就是我们想要的，afnetworking，用红圈圈起来是一会编辑 podfile 时候需要用的，可以先把他复制下来省的手打，后面的小数代表的是类库的版本，一般是最新的显示在这里，下面的 version 是历史版本，如果有需要可以直接导入它的历史版本，就是把后面的版本号替换下就好。</p>\n<h6 id=\"值得注意的是如果你不是第一次安装cocoapods-那么之前的缓存会对你有影响search先清理下缓存-使用这个命之后就可以了-rm-~librarycachescocoapodssearch_indexjson\"><a class=\"anchor\" href=\"#值得注意的是如果你不是第一次安装cocoapods-那么之前的缓存会对你有影响search先清理下缓存-使用这个命之后就可以了-rm-~librarycachescocoapodssearch_indexjson\">#</a> 值得注意的是如果你不是第一次安装 cocoapods， 那么之前的缓存会对你有影响 search 先清理下缓存 使用这个命之后就可以了 rm ~/Library/Caches/CocoaPods/search_index.json</h6>\n<p>### 第五步：<br />\n进入你的工程目录，这里建议直接右键你工程中.xcodeproj 文件选择在终端中打开，然后 在终端中输入命令 cd ..  就会跳到.xcodeproj 所在的目录，也就是我们需要的目录，很多新手在这个地方容易出错。然后输入命令 vim Podfile 熟悉 Linux 的用户都知道这是创建一个 Podfile 文件并打开编辑，按 “i” 进入编辑模式，将第五部粘贴的东西拷贝进来，然后依次操作 esc 键  -&gt;  &quot;:&quot;  -&gt;  输入 wq</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k16wn0yj311s0wqth2.jpg\" alt=\"\" /></p>\n<p>然后输入命令来安装 pod update --verbose --no-repo-update 等待过后就安装完成啦，其实使用 pod install 也可以，只是后者需要更新一个仓库，这是相当耗时的，我们可以使用前者来避免更新仓库就好，很快就结束了。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k1nkijrj311u0wq1g6.jpg\" alt=\"\" /></p>\n<p>安装成功！以后打卡工程就直接打开这个文件就好啦</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k1y1x80j306q0cb0sy.jpg\" alt=\"\" /></p>\n<p>其中 podfile 文件中显示了我们这个工程中所以集成的第三方，</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k27zcbxj30ln0bfmxn.jpg\" alt=\"\" /></p>\n<p>想修改版本的话就把后面的版本号改成你所需要的版本号就好，想删除的话就把这行删掉，想添加的话就用第五部的搜索命令去搜索然后同样把搜索结果中以 pod 开头的那句话复制进来就好。注意以上所有的增删改操作完成之后需要在去终端中相应的目录下使用 pod install --verbose --no-repo-update 命令来更新，这样才会真正的生效。</p>\n<h3 id=\"第六步\"><a class=\"anchor\" href=\"#第六步\">#</a> 第六步：</h3>\n<p>关于 cocoapods 的更新。有的时候在 pod install 的时候会出现 [!] The 'master' repo requires CocoaPods 0.32.1 - 这样的错误，是由于你 cocoapods 版本过低的原因，这时候需要进行更新，跟新的过程其实就是把以上所有的从新走一遍就相当于安装遍就好了。</p>\n<h5 id=\"值得注意1\"><a class=\"anchor\" href=\"#值得注意1\">#</a> 值得注意 1</h5>\n<p>经常遇到的错误比如下面这个</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k2hpy06j30ej01gt8q.jpg\" alt=\"\" /></p>\n<p>通常出现在 OS X 10.11 系统上 这是由于从这个系统开始苹果开始使用无根安装，这时你再用这个方法就会报这个错，这时只需</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k2pt7n9j30hy02zwev.jpg\" alt=\"\" /></p>\n<p>这个命令就可以成功升级啦</p>\n<h5 id=\"值得注意2\"><a class=\"anchor\" href=\"#值得注意2\">#</a> 值得注意 2</h5>\n<p>有的时候大家在 pod search 的时候搜不到，但是明明有这个类库别人都可以都到课时就是自己搜不到，其实原因是这样的：pod search 只会搜索你本地缓存的框架，如果你想搜索到最新的第三方框架或者某个框架的最新版本，必须先使用 pod repo update（推荐）或者 pod setup 将远程仓库的框架信息更新到本地。其实，从 pod search 的响应速度飞快，也可以猜出它并没有连接服务器，仅仅是搜索了本地的框架信息 [呵呵]<br />\n    此外，如果你的框架更新比较慢，可以尝试执行下面 2 条指令更换镜像服务器<br />\n 1：pod repo remove master<br />\n2：pod repo add master <span class=\"exturl\" data-url=\"aHR0cDovL2dpdC5vc2NoaW5hLm5ldC9ha3VhbmRldi9TcGVjcy5naXQ=\">http://git.oschina.net/akuandev/Specs.git</span><br />\n    更换镜像完毕后，以后执行 pod repo update 的速度就会快很多。在说明一点上面两条指令如果第二条无法执行提示 403 错误像这样</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k2xgrwuj30i101h3yg.jpg\" alt=\"\" /></p>\n<p>那么在执行完第一条之后直接 pod search 命令就好 这样他会自动找合适的配置了，因为第二条那个网址可能会变。</p>\n<h3 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结：</h3>\n<p>关于使用 cocoapods 在自己的项目中集成第三方就这些内容。有什么不懂的欢迎来找我交流，本人才疏学浅，如果那里写的不对请及时批评指正，免得误导新人。 新浪微博小耗子上桌子也是我，大家也可以去看下微博多多关注 谢谢！</p>\n",
            "tags": [
                "Cocoapods",
                "架构"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-24-%E8%87%AA%E5%AE%9A%E4%B9%89AlertView/",
            "url": "https://oliverqueen.cn/2018-01-24-%E8%87%AA%E5%AE%9A%E4%B9%89AlertView/",
            "title": "自定义AlertView",
            "date_published": "2018-01-24T04:37:20.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"customalertview\"><a class=\"anchor\" href=\"#customalertview\">#</a> CustomAlertView</h1>\n<p>一个自定义的 AlertView，用户可以根据自己的需求来设置。</p>\n<h2 id=\"使用方法\"><a class=\"anchor\" href=\"#使用方法\">#</a> 使用方法</h2>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k50sh34j30hy084abf.jpg\" alt=\"初始化方法\" /></p>\n<p>类似于系统的初始化方法，如果没有值的话就传 nil 就好，不要传空字符串。最后一个参数传 title 数组就好了。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k5axspej30r702rmy0.jpg\" alt=\"使用\" /></p>\n<p>然后调用 showInViewWithAction 方法显示出来<br />\n<span id=\"more\"></span></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k5idk8ij30mp041aai.jpg\" alt=\"显示\" /></p>\n<p>最后一个参数是 button 的点击事件，根据 tag 值来区分不同的 button 点击，只有取消 button 的 tag 是 0，其他的是 1.2.3... 依次往下排列就好</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k5q4o6nj30kr0ox78u.jpg\" alt=\"可自定义的一些属性\" /></p>\n<p>这些属性可以自定义，这里就不细说了，大家可以使试试。</p>\n<h2 id=\"样式截图\"><a class=\"anchor\" href=\"#样式截图\">#</a> 样式截图</h2>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k5zfyi2j30dc0notac.jpg\" alt=\"样式截图\" /></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k66fmogg308o0figvd.gif\" alt=\"使用截图\" /></p>\n<p>大概就这么多，很简单的有问题随时联系我吧。</p>\n",
            "tags": [
                "UI",
                "AlertView"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-24-NSURLProtocol%E5%AF%B9WKWebView%E7%9A%84%E5%A4%84%E7%90%86/",
            "url": "https://oliverqueen.cn/2018-01-24-NSURLProtocol%E5%AF%B9WKWebView%E7%9A%84%E5%A4%84%E7%90%86/",
            "title": "NSURLProtocol对WKWebView的处理",
            "date_published": "2018-01-24T04:24:06.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>之前写过一篇<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5qaWFuc2h1LmNvbS9wL2NkNGMxYmYxZmQ1Zg==\">文章</span>是关于基于 NSURLProtocol 做的 DNS 解析，其中对 NSURLProtocol 也有了简单的介绍，我们都知道他可以拦截所有基于 URL Loading System 中的请求，但是对于 WKWebview 里面所发出的请求即使他是 http/https 也无能为力，先来简单的了解下 WKWebView.<br />\n<span id=\"more\"></span></p>\n<h5 id=\"wkwebview\"><a class=\"anchor\" href=\"#wkwebview\">#</a> WKWebview</h5>\n<p>iOS8 以后，苹果推出了新框架 Webkit，提供了替换 UIWebView 的组件 WKWebView。各种 UIWebView 的问题没有了，速度更快了，占用内存少了，一句话，WKWebView 是 App 内部加载网页的最佳选择！我们做开发最关系的是内存问题，基本上网上所有的资料都在说 WKWebview 的内存占用会更少，但是到底少了多少我这边做了下测试，同样是加载 163 的首页</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k80vn82j3087036wem.jpg\" alt=\"使用UIWebView的内存\" /><br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k8agxuoj308002smx3.jpg\" alt=\"使用WKWebview的内存\" /></p>\n<p>从上图看出内存大概能优化百分之八十左右，而且从网页的滑动上也确实有所改善。这么明显的性能提升但是苹果并没有完全放弃 UIWebView 也一定有他的道理，就拿本文要讲的 NSURLProtocol 拦截请求来说，WKWebview 的兼容并不 UIWebView 好，还需要开发者做一些操作。</p>\n<h5 id=\"webkit源码分析\"><a class=\"anchor\" href=\"#webkit源码分析\">#</a> WebKit 源码分析</h5>\n<p>由于 WKWebview 是基于 webkit 内核来做的，所以我们在使用的时候需要导入一个这样的东西。<br />\n#import &lt;WebKit/WebKit.h&gt;<br />\n 通过这个我们可以猜到 WKWebview 中所有的请求以及一些逻辑肯定走的都是 webkit 里面的东西，所以他对于网页的加载之之类的操作也不会走系统本省的 URL Loading System，这么说来他的请求不能被 NSURLProtocol 拦截也是理所当然的了。不过 WKWebview 是否真的和 NSURLProtocol 一点关系都没有还需要去研究，幸好 webkit 是开源的，github 上很容易找到<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL1dlYktpdC93ZWJraXQ=\">源码</span>（大小大概是 1G 多点的 zip，花了我将近一天时间来看）。拉下代码直接搜索 NSURLProtocol，看看有没有有关的信息<br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k8kigkxj30i80t0tg8.jpg\" alt=\"搜索结果\" /></p>\n<p>看来的确是有和 NSURLProtocol 有关系，后面通过断点的调用栈中也找到了<br />\n + [NSURLProtocol canInitWithRequest:]<br />\n 这样的字样，再通过网上查一些资料也证实了我的猜想，其实 WKWebview 在一开始时候是会调用到 NSURLProtocol 中的入口方法 canInitWithRequest 的，但是就没有然后了，也就是说 WKWebview 是和 NSURLProtocol 有一定关联，只是在 NSURLProtocol 的入口处返回 NO 所以导致 NSURLProtocol 不接管 WKWebview 的请求。我们点进 webkit 源码中的 CustomProtocol 可以看到，整体的结构我们都差不多，但是我注意到每个 CustomProtocol 的入口函数都有这样一个判断：<br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k8wgu6tj30yg04x40p.jpg\" alt=\"入口函数1\" /></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k93edfij30rw05ijsb.jpg\" alt=\"入口函数2\" /><br />\n (粉色的可以暂时认定为是它内部的一个 custom 字符串) 通过这个可以猜想，WKWebview 并不是不走 NSURLProtocol，而是需要满足他的一个规则，他才会在入口函数这里返回 YES 来给你放行，这个规则便是你所请求的 URL 的 Scheme 要和它内部配置的 CustomScheme 相同。不过这里有一个疑问，苹果在使用 webkit 时候为什么会把 http/https 这样大众化的 scheme 过滤掉，看来他是不建议开发者来使用 NSURLProtocol。接下来我们来看这个 CustomScheme，既然苹果内部规定好的那么一定能通过某种方式来注册一个自己的 scheme，实在不行就 hook 嘛。通过翻他的源码发现最终都指向一句代码</p>\n<pre><code>[WKBrowsingContextController registerSchemeForCustomProtocol:testScheme];\n</code></pre>\n<p>方法实现为<br />\n + (void) registerSchemeForCustomProtocol:(NSString *) scheme<br />\n{<br />\nWebProcessPool::registerGlobalURLSchemeAsHavingCustomProtocolHandlers(scheme);<br />\n}<br />\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void WebProcessPool::<span class=\"built_in\">registerGlobalURLSchemeAsHavingCustomProtocolHandlers</span>(const String&amp; urlScheme)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!urlScheme)</span><br><span class=\"line\">        return;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">globalURLSchemesWithCustomProtocolHandlers</span>()<span class=\"selector-class\">.add</span>(urlScheme);</span><br><span class=\"line\">    for (auto* processPool : allProcessPools())</span><br><span class=\"line\">        processPool-&gt;<span class=\"built_in\">registerSchemeForCustomProtocol</span>(urlScheme);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 通过方法名字可以看出这个就是那个向 webkit 注册 CustomScheme 的方法，只要我们在注册完我们自己的 CustomProtocol 之后在调用该方法应该就可以了。通过他的源码也进一步印证了我的猜想 (他也是这么写的)<br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k9nobq7j30yg04tmzt.jpg\" alt=\"webkit源码\" /></p>\n<h5 id=\"具体实施\"><a class=\"anchor\" href=\"#具体实施\">#</a> 具体实施</h5>\n<p>找到了方法就要去实施，不过因为 registerSchemeForCustomProtocol 是 WKBrowsingContextController 的类方法，所以只能用 WKBrowsingContextController 去调用，但是在 webkit 的头文件发现 WKBrowsingContextController 并没有开放出来，所以我们采用 NSClassFromString 和 NSSelectorFromString 方法来拿到类和对应的方法，整体代码如下<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注册自己的protocol</span></span><br><span class=\"line\">[<span class=\"built_in\">NSURLProtocol</span> registerClass:[CustomProtocol <span class=\"keyword\">class</span>]];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建WKWebview</span></span><br><span class=\"line\"><span class=\"built_in\">WKWebViewConfiguration</span> * config = [[<span class=\"built_in\">WKWebViewConfiguration</span> alloc] init];</span><br><span class=\"line\"><span class=\"built_in\">WKWebView</span> * wkWebView = [[<span class=\"built_in\">WKWebView</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, [<span class=\"built_in\">UIScreen</span> mainScreen].bounds.size.width, [<span class=\"built_in\">UIScreen</span> mainScreen].bounds.size.height) configuration:config];</span><br><span class=\"line\">[wkWebView loadRequest:webViewReq];</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:wkWebView];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注册scheme</span></span><br><span class=\"line\">Class cls = <span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@&quot;WKBrowsingContextController&quot;</span>);</span><br><span class=\"line\">SEL sel = <span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@&quot;registerSchemeForCustomProtocol:&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> ([cls respondsToSelector:sel]) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过http和https的请求，同理可通过其他的Scheme 但是要满足ULR Loading System</span></span><br><span class=\"line\">    [cls performSelector:sel withObject:<span class=\"string\">@&quot;http&quot;</span>];</span><br><span class=\"line\">    [cls performSelector:sel withObject:<span class=\"string\">@&quot;https&quot;</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n  实现效果。我将网页中所有的图片替换成了柴犬图片</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6ka7rv18g307o0ds7wl.gif\" alt=\"效果\" /></p>\n<h5 id=\"值得注意\"><a class=\"anchor\" href=\"#值得注意\">#</a> 值得注意</h5>\n<ul>\n<li>关于私有 API</li>\n</ul>\n<p>因为 WKBrowsingContextController 和 registerSchemeForCustomProtocol 应该是私有的所以使用时候需要对字符串做下处理，用加密的方式或者其他就可以了，实测可以过审核的。</p>\n<ul>\n<li>关于 post 请求<br />\n大家会发现拦截不了 post 请求 (拦截到的 post 请求 body 体为空)，这个其实和 WKWebview 没有关系，这个是苹果为了提高效率加快流畅度所以在 NSURLProtocol 拦截之后索性就不复制 body 体内的东西，因为 body 的大小没有限制，开发者可能会把很大的数据放进去那就不好办了。我们可以采取 httpbodystream 的方式拿到 body，这个在之前的<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5qaWFuc2h1LmNvbS9wL2NkNGMxYmYxZmQ1Zg==\">文章</span>也有提过</li>\n</ul>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark -</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark 处理POST请求相关POST  用HTTPBodyStream来处理BODY体</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSMutableURLRequest</span> *)handlePostRequestBodyWithRequest:(<span class=\"built_in\">NSMutableURLRequest</span> *)request &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableURLRequest</span> * req = [request mutableCopy];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([request.HTTPMethod isEqualToString:<span class=\"string\">@&quot;POST&quot;</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!request.HTTPBody) &#123;</span><br><span class=\"line\">            uint8_t d[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">            <span class=\"built_in\">NSInputStream</span> *stream = request.HTTPBodyStream;</span><br><span class=\"line\">            <span class=\"built_in\">NSMutableData</span> *data = [[<span class=\"built_in\">NSMutableData</span> alloc] init];</span><br><span class=\"line\">            [stream open];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ([stream hasBytesAvailable]) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">NSInteger</span> len = [stream read:d maxLength:<span class=\"number\">1024</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (len &gt; <span class=\"number\">0</span> &amp;&amp; stream.streamError == <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">                    [data appendBytes:(<span class=\"type\">void</span> *)d length:len];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            req.HTTPBody = [data <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">            [stream close];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> req;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n",
            "tags": [
                "webview",
                "hook"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-24-iOS-Runtime%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%90%8C%E7%B1%BB%E7%9A%84Method-Swizzling/",
            "url": "https://oliverqueen.cn/2018-01-24-iOS-Runtime%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%90%8C%E7%B1%BB%E7%9A%84Method-Swizzling/",
            "title": "iOS Runtime简单介绍，以及不同类的Method Swizzling",
            "date_published": "2018-01-24T04:18:50.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h5 id=\"runtime介绍\"><a class=\"anchor\" href=\"#runtime介绍\">#</a> Runtime 介绍：</h5>\n<p>runtime 顾名思义就是运行时，其实我们的 App 从你按下 command+R 开始一直到 App 运行起来经历了大致两个阶段，1：编译时，2：运行时。还记得一道很经典的面试题<br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kbsn9yxj30kk03et8z.jpg\" alt=\"\" /></p>\n<p>这里给大家解释下：首先， * testObject 是告诉编译器，testObject 是一个指向某个 Objective-C 对象的指针。因为不管指向的是什么类型的对象，<br />\n<span id=\"more\"></span><br />\n 一个指针所占的内存空间都是固定的，所以这里声明成任何类型的对象，最终生成的可执行代码都是没有区别的。这里限定了 NSString 只不过是告诉编译器，请把 testObject 当做一个 NSString 来检查，如果后面调用了非 NSString 的方法，会产生警告。接着，你创建了一个 NSData 对象，然后把这个对象所在的内存地址保存在 testObject 里。那么运行时 (从这段代码执行开始，到程序结束)，testObject 指向的内存空间就是一个 NSData 对象。你可以把 testObject 当做一个 NSData 对象来用。 所以编译时是 NSString，运行时是 NSData。<br />\nruntime 是什么：<br />\n在 runtime 中，所有的类在 OC 中都会被定义成一个结构体，像这样<br />\n类在 runtime 中的表示<br />\n struct objc_class {<br />\n    Class isa;// 指针，顾名思义，表示是一个什么，  // 实例的 isa 指向类对象，类对象的 isa 指向元类<br />\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> !__OBJC2__</span></span><br><span class=\"line\">        Class super_class;  <span class=\"comment\">//指向父类</span></span><br><span class=\"line\">        <span class=\"type\">const</span> <span class=\"type\">char</span> *name;  <span class=\"comment\">//类名</span></span><br><span class=\"line\">        <span class=\"type\">long</span> version;     <span class=\"comment\">//类的版本信息，默认初始化为 0。我们可以在运行期对其进行修改（class_setVersion）或获取（class_getVersion）。</span></span><br><span class=\"line\">        <span class=\"type\">long</span> info;   <span class=\"comment\">/*供运行期使用的一些位标识。有如下一些位掩码：</span></span><br><span class=\"line\"><span class=\"comment\">                        CLS_CLASS (0x1L) 表示该类为普通 class ，其中包含实例方法和变量；</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法；</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_INITIALIZED (0x4L) 表示该类已经被运行期初始化了，这个标识位只被 objc_addClass 所设置；</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_POSING (0x8L) 表示该类被 pose 成其他的类；（poseclass 在ObjC 2.0中被废弃了）；</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_MAPPED (0x10L) 为ObjC运行期所使用</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_FLUSH_CACHE (0x20L) 为ObjC运行期所使用</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_GROW_CACHE (0x40L) 为ObjC运行期所使用</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_NEED_BIND (0x80L) 为ObjC运行期所使用</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_METHOD_ARRAY (0x100L) 该标志位指示 methodlists 是指向一个 objc_method_list 还是一个包含 objc_method_list 指针的数组；*/</span></span><br><span class=\"line\">        <span class=\"type\">long</span> instance_size  <span class=\"comment\">//该类的实例变量大小（包括从父类继承下来的实例变量）；</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">objc_ivar_list</span> *ivars <span class=\"comment\">//成员变量列表</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">objc_method_list</span> **methodLists; <span class=\"comment\">//方法列表</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">objc_cache</span> *cache;<span class=\"comment\">//缓存   一种优化，调用过的方法存入缓存列表，下次调用先找缓存</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">objc_protocol_list</span> *protocols <span class=\"comment\">//协议列表</span></span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><br />\n 相关的定义<br />\n /// 描述类中的一个方法<br />\n typedef struct objc_method *Method;</p>\n<p>/// 实例变量<br />\n typedef struct objc_ivar *Ivar;</p>\n<p>/// 类别 Category<br />\ntypedef struct objc_category *Category;</p>\n<p>/// 类中声明的属性<br />\n typedef struct objc_property *objc_property_t;</p>\n<p>ObjC 为每个类的定义生成两个 objc_class ，一个即普通的 class，另一个即 metaclass。我们可以在运行期创建这两个 objc_class 数据结构，然后使用 objc_addClass 动态地创建新的类定义。</p>\n<h5 id=\"runtime能干什么\"><a class=\"anchor\" href=\"#runtime能干什么\">#</a> runtime 能干什么：</h5>\n<ul>\n<li>：1：获取一个类中的列表比如方法列表、属性列表、协议列表、成员变量列表像如下这样 其中获取到的属性、方法都是可以获取 public 和 private 的。</li>\n</ul>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unsigned <span class=\"built_in\">int</span> count;</span><br><span class=\"line\">    Class clas = <span class=\"literal\">[WKW<span class=\"identifier\">ebViewController</span> <span class=\"identifier\">class</span>]</span>; <span class=\"comment\">//是我自己的类，之所以不用系统的类是因为系统的类方法属性太多了</span></span><br><span class=\"line\"></span><br><span class=\"line\">    objc_property_t<span class=\"operator\"> * </span>propertyList = <span class=\"keyword\">class</span><span class=\"constructor\">_copyPropertyList(<span class=\"params\">clas</span>, &amp;<span class=\"params\">count</span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">        const <span class=\"built_in\">char</span> *propertyName = property<span class=\"constructor\">_getName(<span class=\"params\">propertyList</span>[<span class=\"params\">i</span>])</span>;</span><br><span class=\"line\">        <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;  %@  属性(包括私有) --------&gt;&gt;&gt;&gt;&gt;    %@&quot;</span>,<span class=\"params\">clas</span>,[NSString <span class=\"params\">stringWithUTF8String</span>:<span class=\"params\">propertyName</span>])</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;-------------------------------------------------------------------------------------------------------------- &quot;</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Method<span class=\"operator\"> * </span>methodList = <span class=\"keyword\">class</span><span class=\"constructor\">_copyMethodList(<span class=\"params\">clas</span>, &amp;<span class=\"params\">count</span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">        Method methodName = methodList<span class=\"literal\">[<span class=\"identifier\">i</span>]</span>;</span><br><span class=\"line\">        <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;  %@ 方法(包括私有)  --------&gt;&gt;&gt;&gt;&gt;    %@&quot;</span>,<span class=\"params\">clas</span>,NSStringFromSelector(<span class=\"params\">method_getName</span>(<span class=\"params\">methodName</span>)</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;-------------------------------------------------------------------------------------------------------------- &quot;</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    Ivar *ivarList = <span class=\"keyword\">class</span><span class=\"constructor\">_copyIvarList(<span class=\"params\">clas</span>, &amp;<span class=\"params\">count</span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i&lt;count; i++) &#123;</span><br><span class=\"line\">        Ivar myIvar = ivarList<span class=\"literal\">[<span class=\"identifier\">i</span>]</span>;</span><br><span class=\"line\">        const <span class=\"built_in\">char</span> *ivarName = ivar<span class=\"constructor\">_getName(<span class=\"params\">myIvar</span>)</span>;</span><br><span class=\"line\">        <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;%@ 成员变量(包括私有) --------&gt;&gt;&gt;&gt;&gt; %@&quot;</span>,<span class=\"params\">clas</span>, [NSString <span class=\"params\">stringWithUTF8String</span>:<span class=\"params\">ivarName</span>])</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;-------------------------------------------------------------------------------------------------------------- &quot;</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//获取协议列表</span></span><br><span class=\"line\">    __unsafe_unretained Protocol **protocolList = <span class=\"keyword\">class</span><span class=\"constructor\">_copyProtocolList([<span class=\"params\">self</span> <span class=\"params\">class</span>], &amp;<span class=\"params\">count</span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i&lt;count; i++) &#123;</span><br><span class=\"line\">        Protocol *myProtocal = protocolList<span class=\"literal\">[<span class=\"identifier\">i</span>]</span>;</span><br><span class=\"line\">        const <span class=\"built_in\">char</span> *protocolName = protocol<span class=\"constructor\">_getName(<span class=\"params\">myProtocal</span>)</span>;</span><br><span class=\"line\">        <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;%@ 协议 --------&gt;&gt;&gt;&gt;&gt; %@&quot;</span>,<span class=\"params\">clas</span>, [NSString <span class=\"params\">stringWithUTF8String</span>:<span class=\"params\">protocolName</span>])</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br />\n 输出后的结果是<br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kc7w3zcj30pk0ajdks.jpg\" alt=\"image.png\" /><br />\n 其中也包括了私有方法。</p>\n<ul>\n<li>2：拦截方法调用<br />\n有的时候我们用一个类或者一个实例变量去调用一个方法，由于操作失误或者是其他原因，导致这个所被调用的方法并不存在，报出这样的错误，然后闪退！<br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kcfrky6j30tr0120sy.jpg\" alt=\"image.png\" /></li>\n</ul>\n<p>这个时候如果我们想避免这些崩溃，我们就需要在运行时对其做一些手脚。iOS 中方法调用的流程：其实调用方法就是发送消息，所有调用方法的代码例如   [obj aaa]  在运行时 runtime 会将这段代码转换为 objc_msgSend (obj, [@selector]);（本质就是发送消息）然后 obj 会通过其中 isa 指针去该类的缓存中 (cache) 查找对应函数的 Method, 如果没有找到，再去该类的方法列表（methodList）中查找，如果没有找到再去该类的父类找，如果找到了，就先将方法添加到缓存中，以便下次查找，然后通过 method 中的指针定位到指定方法执行。如果一直没有找到，便会走完如下四个方法之后崩溃。</p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    如果调用的是不存在的实例方法则会在奔溃前进入该方法，防止崩溃可以在此处做处理</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+(<span class=\"type\">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 如果调用的是不存在的类方法则会在奔溃前进入该方法，防止崩溃可以在此处做处理</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+(<span class=\"type\">BOOL</span>)resolveClassMethod:(SEL)sel &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 这个方法会把你所调用的不存在的方法重定向到一个声明了该方法的类中，只需要你返回一个有该方法的</span></span><br><span class=\"line\"><span class=\"comment\"> 类就可以，如果你重定向的这个类仍然不具有该方法那么会继续崩溃</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">-(<span class=\"type\">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 将你不存在的方法打包成NSInvocation对象，做完你自己的处理之后</span></span><br><span class=\"line\"><span class=\"comment\"> 调用invokeWithTarget让某个target来处理该方法</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">-(<span class=\"type\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)anInvocation &#123;</span><br><span class=\"line\">    [anInvocation invokeWithTarget:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>3：动态添加方法<br />\n因为我们调用了一个不存在的方法导致崩溃，那么我们在判断出不存在后就动态添加上一个方法吧 这样不就不会蹦了吗？我们先写一个方法用来给我们做出提示</li>\n</ul>\n<p><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- <span class=\"params\">(void)</span> errorMethod &#123;</span><br><span class=\"line\">    NSLog<span class=\"params\">(@<span class=\"string\">&quot;no method!!!!!!!&quot;</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 如果调用了没有的方法，那么就把这个方法添加进去，然后把被调用的方法的指针指向这个 error1：，那么一旦调用了没有的方法就会走这个。我们来看代码</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+(BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class=\"line\">    Method errorMethod =  <span class=\"keyword\">class</span><span class=\"constructor\">_getInstanceMethod([<span class=\"params\">self</span> <span class=\"params\">class</span>], @<span class=\"params\">selector</span>(<span class=\"params\">errorMethod</span>)</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">[NSS<span class=\"identifier\">tringFromSelector</span>(<span class=\"identifier\">sel</span>) <span class=\"identifier\">isEqualToString</span>:@&quot;<span class=\"identifier\">testMethod</span>&quot;]</span>) &#123;</span><br><span class=\"line\">        BOOL isAdd =  <span class=\"keyword\">class</span><span class=\"constructor\">_addMethod([<span class=\"params\">self</span> <span class=\"params\">class</span>], <span class=\"params\">sel</span>, <span class=\"params\">method_getImplementation</span>(<span class=\"params\">errorMethod</span>)</span>, <span class=\"keyword\">method</span><span class=\"constructor\">_getTypeEncoding(<span class=\"params\">errorMethod</span>)</span>);</span><br><span class=\"line\">        <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;tinajia  = %d&quot;</span>,<span class=\"params\">isAdd</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//Do something</span></span><br><span class=\"line\">    return YES;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>主要用到</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    添加方法</span></span><br><span class=\"line\"><span class=\"comment\">     @param class] 在哪个类里添加</span></span><br><span class=\"line\"><span class=\"comment\">     @param sel 添加的方法的名字</span></span><br><span class=\"line\"><span class=\"comment\">     @param errorMethod 添加的方法的实现IMP指</span></span><br><span class=\"line\"><span class=\"comment\">     @param types 方法的标示符</span></span><br><span class=\"line\"><span class=\"comment\">     @return 是否添加成功</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">BOOL isAdd =  <span class=\"keyword\">class</span><span class=\"constructor\">_addMethod([<span class=\"params\">self</span> <span class=\"params\">class</span>], <span class=\"params\">sel</span>, <span class=\"params\">method_getImplementation</span>(<span class=\"params\">errorMethod</span>)</span>, <span class=\"keyword\">method</span><span class=\"constructor\">_getTypeEncoding(<span class=\"params\">errorMethod</span>)</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>然后运行下：</p>\n<p><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">WKWebViewController</span> <span class=\"operator\">*</span> vc<span class=\"operator\">=</span> [[<span class=\"type\">WKWebViewController</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">[vc performSelector:<span class=\"meta\">@selector</span>(testMethod)];</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>我调用了并不存在的 testMethod 方法并没有崩溃并且方法已经成功添加了</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kexyuzgj30f801mwel.jpg\" alt=\"image.png\" /></p>\n<ul>\n<li>\n<p>4：动态交换方法（也叫 iOS 黑魔法，慎用）<br />\n没什么好例子，用一个网上说的例子 (引用别人的东西，懒得复制了，就截了图)</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kg3i5z6j30hv0fj0z9.jpg\" alt=\"\" /></p>\n<p>其实本质即使 SEL 和 IMP 的交换，原理是这样的：在 iOS 中每一个类中都有一个叫 dispatch table 的东西，里面存放在 SEL 和他所对应的 IMP 指针，之前也说过方法调用就是通过 sel 找 IMP 指针然后指针定位调用方法。方法交换就是对这个 dispatch table 进行操作。让 A 的 SEL 去对应 B 的 IMP，B 的 SEL 对应 A 的 IMP，如图</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kgrq52oj30f80betcz.jpg\" alt=\"\" /></p>\n<p>这样就达到方法交换的目的，下面看代码：</p>\n</li>\n</ul>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)changeMethod &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  如果是类方法 要使用 !</span></span><br><span class=\"line\">    <span class=\"comment\">//  如果是系统的集合类的属性要用元类 比如 __NSSetM = NSMutableSet</span></span><br><span class=\"line\">    <span class=\"comment\">//  Class  class = NSClassFromString(@&quot;__NSSetM&quot;);</span></span><br><span class=\"line\">    <span class=\"comment\">//  Class metaClass = objc_getMetaClass([NSStringFromClass(class) UTF8String]);</span></span><br><span class=\"line\">    Class systemClass = <span class=\"constructor\">NSClassFromString(<span class=\"params\">__NSSetM</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    SEL sel_System = <span class=\"constructor\">NSSelectorFromString(<span class=\"params\">addObject</span>:)</span>;</span><br><span class=\"line\">    SEL sel_Custom = @selector(swizzle_addObject:);</span><br><span class=\"line\"></span><br><span class=\"line\">    Method method_System = <span class=\"keyword\">class</span><span class=\"constructor\">_getInstanceMethod(<span class=\"params\">systemClass</span>, <span class=\"params\">sel_System</span>)</span>;</span><br><span class=\"line\">    Method method_Custom = <span class=\"keyword\">class</span><span class=\"constructor\">_getInstanceMethod([<span class=\"params\">self</span> <span class=\"params\">class</span>], <span class=\"params\">sel_Custom</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    IMP imp_System = <span class=\"keyword\">method</span><span class=\"constructor\">_getImplementation(<span class=\"params\">method_System</span>)</span>;</span><br><span class=\"line\">    IMP imp_Custom = <span class=\"keyword\">method</span><span class=\"constructor\">_getImplementation(<span class=\"params\">method_Custom</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">method</span><span class=\"constructor\">_exchangeImplementations(<span class=\"params\">method_System</span>, <span class=\"params\">method_Custom</span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)swizzle_addObject:(id) obj &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj) &#123;</span><br><span class=\"line\">        <span class=\"literal\">[<span class=\"identifier\">self</span> <span class=\"identifier\">swizzle_addObject</span>:<span class=\"identifier\">obj</span>]</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>主要代码  method_exchangeImplementations (method1, method2); 这两个参数很简单，就是两个需要交换的方法。<br />\n最后我调用了 m1 但是实际上走了 m2。</p>\n<h5 id=\"动态交换方法的原理以及交换过程中指针的变化\"><a class=\"anchor\" href=\"#动态交换方法的原理以及交换过程中指针的变化\">#</a> 动态交换方法的原理以及交换过程中指针的变化</h5>\n<p>在通常的方法交换中我们通常有两种情景，一种是我会针对被交换的类建一个 category，然后 hook 的方法会写在 category 中。另一种是自己创建一个 Tool 类里面放些常用的工具方法其中包含了方法交换。可能大家普遍选择第一种方法，但是如果你需要 hook 的类非常多的 (我实际项目中就遇到这样的问题) 那你就需要针对不同的类创建 category，就会导致文件过多，且每一个文件中只有一个 hook 方法，这样一来左侧一堆文件，所以我用了第二种方法，但是在使用过程中出现一个问题，先看下我的代码结构</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6khw8c97j30740ag74v.jpg\" alt=\"image.png\" /></p>\n<p>我要 hook 的是 ViewController 中的 viewDidLoad 方法，我建立了两个类一个是 ViewController 的 category，另一个是 Tool 类，为了一会区别演示不同类 hook 的不同 (两个类中 hook 的代码完全一样)</p>\n<ul>\n<li>ViewController 中将要被替换的系统方法</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kir8y63j309a02rglq.jpg\" alt=\"被替换的方法(系统方法)\" /></p>\n<ul>\n<li>Category 中将要用来替换的自定义方法</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kj5dcykj308z02lwep.jpg\" alt=\"用来替换的方法(自定义方法)\" /></p>\n<ul>\n<li>然后在 ViewController 中的 load 中做方法替换</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kjlzvdqj30f90b43zw.jpg\" alt=\"进行方法替换\" /></p>\n<p>运行一下的输出结果想必大家已经猜到了先执行 custom 再执行 system，这是通常情况下大家的做法。<br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kjxsheej30d701h3yl.jpg\" alt=\"结果\" /></p>\n<p>下面再来看下如果我将替换方法写在不同类中会怎样，调用 Tool 中的交换方法</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kka2s8uj30dx0anwfp.jpg\" alt=\"执行Tool中的交换方法\" /></p>\n<p>然后直接看结果了，因为代码都是一模一样的我直接复制过去的</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kliitupj30yd08w422.jpg\" alt=\"结果\" /></p>\n<p>发生了 crash，原因是 ViewController 中没有 swizzel_viewDidLoad_custom 这个方法，为什么不同类的交换会出现这种问题，我们用个图来说明下</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6km0wogkj30yg0pz43q.jpg\" alt=\"image.png\" /></p>\n<p>解决的办法是我们在交换方法之前要先像其中添加方法，也就是说把 customMethod 添加到 SystemClass 中，但是注意要把 customMethod 的实现指向 syetemMethod 的实现。这样一来就可以达到 SystemClass 调用 customMethod 却执行 systemMethod 的代码的效果，实现以上要求我们需要在交换之前执行这个方法。</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span><span class=\"constructor\">_addMethod(<span class=\"params\">systemClass</span>, <span class=\"params\">sel_Custom</span>, <span class=\"params\">imp_System</span>, <span class=\"params\">method_getTypeEncoding</span>(<span class=\"params\">method_System</span>)</span>)</span><br></pre></td></tr></table></figure></p>\n<p>其中第一个参数是需要往哪个类添加；第二个参数是要添加的方法的方法名；第三个参数是所添加的方法的方法实现，第四个是方法的标识符。经过就该之后我们的代码是这样</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">之前的都一样就省略</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">class</span><span class=\"constructor\">_addMethod(<span class=\"params\">systemClass</span>, <span class=\"params\">sel_Custom</span>, <span class=\"params\">imp_System</span>, <span class=\"params\">method_getTypeEncoding</span>(<span class=\"params\">method_System</span>)</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">class</span><span class=\"constructor\">_replaceMethod(<span class=\"params\">systemClass</span>, <span class=\"params\">sel_System</span>, <span class=\"params\">imp_Custom</span>, <span class=\"params\">method_getTypeEncoding</span>(<span class=\"params\">method_System</span>)</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">method</span><span class=\"constructor\">_exchangeImplementations(<span class=\"params\">method_System</span>, <span class=\"params\">method_Custom</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>我们来看下执行完 add 操作之后此时的方法和类的对应关系 (红色的为 add 的修改)</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kmhkzidj30yg0g378f.jpg\" alt=\"关系\" /></p>\n<p>因为 SystemClass 中本身不包含 customMethod 所以 add 一定是成功的，也就是说会进入判断执行 replace 方法。</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span><span class=\"constructor\">_replaceMethod(<span class=\"params\">systemClass</span>, <span class=\"params\">sel_System</span>, <span class=\"params\">imp_Custom</span>, <span class=\"params\">method_getTypeEncoding</span>(<span class=\"params\">method_System</span>)</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>第一个参数：需要修改的方法的所在的类；第二个参数：需要替换其实现的方法名；第三个参数：需要把哪个实现替换给他；第四个参数：方法标识符。此时看下我们做完 replace 之后的类与方法名以及他们实现的关系 (红色的为 replace 的修改)。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kn9m5btj30yg0ifgqa.jpg\" alt=\"关系\" /></p>\n<p>此时大家已经看出来了，虽然没有执行 exchange 方法，但是我已经达到了方法交换的目的。系统执行 systemMethod 时候会走 customMethod 的实现但是因为在 customMethod 方法中我会递归执行 [self customMethod]，所以又会走到 systemMethod 的实现，因为之前进行了方法添加，所以此时 A 类中有了 customMethod 方法，不会再发生之前的 crash。达到一个不同类进行 Method Swizzling 的目的。</p>\n<h5 id=\"综上来看一个完整严谨的methodswizzling应该在交换前先add并且add方法的参数不能错\"><a class=\"anchor\" href=\"#综上来看一个完整严谨的methodswizzling应该在交换前先add并且add方法的参数不能错\">#</a> 综上来看一个完整严谨的 MethodSwizzling 应该在交换前先 add，并且 add 方法的参数不能错</h5>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)changeMethod &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Class systemClass = <span class=\"constructor\">NSClassFromString(@<span class=\"string\">&quot;你的类&quot;</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    SEL sel_System = @selector(系统方法);</span><br><span class=\"line\">    SEL sel_Custom = @selector(你自己的方法);</span><br><span class=\"line\"></span><br><span class=\"line\">    Method method_System = <span class=\"keyword\">class</span><span class=\"constructor\">_getInstanceMethod(<span class=\"params\">systemClass</span>, <span class=\"params\">sel_System</span>)</span>;</span><br><span class=\"line\">    Method method_Custom = <span class=\"keyword\">class</span><span class=\"constructor\">_getInstanceMethod([<span class=\"params\">self</span> <span class=\"params\">class</span>], <span class=\"params\">sel_Custom</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    IMP imp_System = <span class=\"keyword\">method</span><span class=\"constructor\">_getImplementation(<span class=\"params\">method_System</span>)</span>;</span><br><span class=\"line\">    IMP imp_Custom = <span class=\"keyword\">method</span><span class=\"constructor\">_getImplementation(<span class=\"params\">method_Custom</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">class</span><span class=\"constructor\">_addMethod(<span class=\"params\">systemClass</span>, <span class=\"params\">sel_Custom</span>, <span class=\"params\">imp_System</span>, <span class=\"params\">method_getTypeEncoding</span>(<span class=\"params\">method_System</span>)</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">class</span><span class=\"constructor\">_replaceMethod(<span class=\"params\">systemClass</span>, <span class=\"params\">sel_System</span>, <span class=\"params\">imp_Custom</span>, <span class=\"params\">method_getTypeEncoding</span>(<span class=\"params\">method_System</span>)</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">method</span><span class=\"constructor\">_exchangeImplementations(<span class=\"params\">method_System</span>, <span class=\"params\">method_Custom</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h5 id=\"以上代码无论是写在工具类中还是category中都是没有问题的\"><a class=\"anchor\" href=\"#以上代码无论是写在工具类中还是category中都是没有问题的\">#</a> 以上代码无论是写在工具类中还是 category 中都是没有问题的。</h5>\n",
            "tags": [
                "底层",
                "runtime"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-24-%E8%AE%B0%E4%B8%80%E6%AC%A1Runtime-Hook%E7%9A%84%E9%97%AE%E9%A2%98/",
            "url": "https://oliverqueen.cn/2018-01-24-%E8%AE%B0%E4%B8%80%E6%AC%A1Runtime-Hook%E7%9A%84%E9%97%AE%E9%A2%98/",
            "title": "记一次Runtime Hook的问题",
            "date_published": "2018-01-24T03:35:57.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h4 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景</h4>\n<p>项目中遇到一个问题，需要引入两个 SDK，我们暂且命名为 A 和 B，由于业务需要这两个 SDK 都需要对一个系统函数 C 进行 hook, 但是有一个前提，由于 B 所做的是一个统计相关的 SDK，所以 B 要监控 App 内的所有代码这其中也包括了 SDK A 所做的一些操作，所以我们必须确保 B 在 hook C 函数时候  A 已经对 C 函数 hook 完毕，其实这就涉及到 hook 顺序的问题。<br />\n<span id=\"more\"></span></p>\n<h4 id=\"研究\"><a class=\"anchor\" href=\"#研究\">#</a> 研究</h4>\n<p>先看下代码，我用 hookMethod 来模仿系统方法。<br />\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>) TEST_HOOK_TWICE &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> changeOrginalSelectorName:<span class=\"string\">@&quot;hookedMethod&quot;</span> inClass:<span class=\"string\">@&quot;RootViewController&quot;</span> withCustomSelectorName:<span class=\"string\">@&quot;swizzle_hookedMethod1&quot;</span> isClassMethod:<span class=\"literal\">NO</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> changeOrginalSelectorName:<span class=\"string\">@&quot;hookedMethod&quot;</span> inClass:<span class=\"string\">@&quot;RootViewController&quot;</span> withCustomSelectorName:<span class=\"string\">@&quot;swizzle_hookedMethod2&quot;</span> isClassMethod:<span class=\"literal\">NO</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> hookedMethod];</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)hookedMethod &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;原始方法&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)swizzle_hookedMethod1 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;1&quot;</span>);</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> swizzle_hookedMethod1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)swizzle_hookedMethod2 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;2&quot;</span>);</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> swizzle_hookedMethod2];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 然后看下没有 hook 之前的样子</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6ll1zt21j30j80jk3zc.jpg\" alt=\"原本的样子\" /></p>\n<p>然后我们执行代码<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一步：交换A中的方法和系统方法</span></span><br><span class=\"line\"> [<span class=\"keyword\">self</span> changeOrginalSelectorName:<span class=\"string\">@&quot;hookedMethod&quot;</span> inClass:<span class=\"string\">@&quot;RootViewController&quot;</span> withCustomSelectorName:<span class=\"string\">@&quot;swizzle_hookedMethod1&quot;</span> isClassMethod:<span class=\"literal\">NO</span>];</span><br><span class=\"line\"><span class=\"comment\">//第二步：交换B中的方法和系统方法</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> changeOrginalSelectorName:<span class=\"string\">@&quot;hookedMethod&quot;</span> inClass:<span class=\"string\">@&quot;RootViewController&quot;</span> withCustomSelectorName:<span class=\"string\">@&quot;swizzle_hookedMethod2&quot;</span> isClassMethod:<span class=\"literal\">NO</span>];</span><br><span class=\"line\"><span class=\"comment\">//第三步：调用系统方法</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> hookedMethod];</span><br></pre></td></tr></table></figure><br />\n 然后我们一步一步来看，先看调用第一步之后是什么样子的 (红色箭头为第一步之后的样子)</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6llhzf0uj30ki0k2q3z.jpg\" alt=\"第一步之后\" /></p>\n<p>然后看第二步调用完之后的样子 (绿色是第二步调用)</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6lm7mfshj30jo0iu75m.jpg\" alt=\"第二部之后的样子\" /></p>\n<p>接下来我们调用系统方法也就是第三步，然后我们看下流程是怎样的 (每个方法实现里面都会递归调用下自身，为了是 hook 时候不改变原有逻辑)</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6lmi43vmj30yg03v756.jpg\" alt=\"调用顺序\" /></p>\n<p>这样一来就很明显 如果想想监控住所有的代码那就需要在 A IMP 这步，因为之前的 Hook 顺序是先 A -&gt; B -&gt; System 这样一来只要我们改一下顺序改为 B -&gt; A -&gt; System 就可以让 B SDK 监控到所有的代码。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6ln0wmlyj30yg07ign0.jpg\" alt=\"调用顺序\" /></p>\n",
            "tags": [
                "底层",
                "runtime",
                "Hook"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-23-iOS%E4%B8%AD%E4%BD%BF%E7%94%A8OpenGL%E5%AE%9E%E7%8E%B0%E5%A2%9E%E9%AB%98%E5%8A%9F%E8%83%BD/",
            "url": "https://oliverqueen.cn/2018-01-23-iOS%E4%B8%AD%E4%BD%BF%E7%94%A8OpenGL%E5%AE%9E%E7%8E%B0%E5%A2%9E%E9%AB%98%E5%8A%9F%E8%83%BD/",
            "title": "iOS中使用OpenGL实现增高功能",
            "date_published": "2018-01-23T13:23:49.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"功能效果\"><a class=\"anchor\" href=\"#功能效果\">#</a> 功能效果</h3>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6lpd4q64g308u0fqnpe.gif\" alt=\"demo示例\" /><br />\n<span id=\"more\"></span></p>\n<h3 id=\"功能分析\"><a class=\"anchor\" href=\"#功能分析\">#</a> 功能分析</h3>\n<ul>\n<li>\n<p>功能：渲染一张传入的图片 -&gt; 手动选择编辑区域 -&gt; 通过滑块来编辑区域的增高或者缩短</p>\n</li>\n<li>\n<p>OpenGL 原理：</p>\n<ul>\n<li>\n<p>因为 OpenGL 只能绘制三角形，所以在处理图像或者图形的时候我们需要将被处理的对象用三角行来分割转换为三角形和顶点的组成的对象。</p>\n</li>\n<li>\n<p>OpenGL 里面坐标是以左下角为原点 X 轴向上为正，Y 轴向右为正</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"功能实现\"><a class=\"anchor\" href=\"#功能实现\">#</a> 功能实现</h3>\n<ul>\n<li>渲染图片拆分图片：\n<ul>\n<li>拆分方法 1：通过图形看出是一个矩形，而矩形是可以分成两个三角形和四个顶点，通过此可以用 GL 渲染出图片。</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6lpjw6g3j30dw0ee7ft.jpg\" alt=\"拆分三角形\" /></p>\n<p>这样拆分之后虽然可以正常渲染，但是带来的问题是我的四个顶点都是死的，也就是四个顶点必须是画布的四个顶点，改变顶点的坐标后只能导致整张画布的变动，而不是某一个区域的变动，拉伸的话也是整张图片的拉伸，所以想要实现局部处理的话这种分割方式不可行。</p>\n<ul>\n<li>拆分方法 2：将整张图片先拆分为三个矩形，然后再把每个矩形拆分成两个三角形，得到 6 个三角形，8 个顶点，如下图：</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6lprpvrrj30dw0eddrh.jpg\" alt=\"拆分2\" /></p>\n<p>这样一来就可以保证中间的矩形的高度可以任意变化而上下两部分的高度不变只改变位置，也就是说我们这个 DEMO 中所做的任何拉伸操作都是对中间矩形的操作，换而言之就是改变最上面的矩形和最下面的矩形之间的距离来达到对中间区域的拉伸和压缩的目的。根据拆分的方式我们用顶点的坐标创建一个数组<br />\n <figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">//</span>顶点数组</span><br><span class=\"line\">GLfloat vertices[] = &#123;   </span><br><span class=\"line\">    -1.2, -1.2,     <span class=\"string\">//</span>左下</span><br><span class=\"line\">    1.2, -1.2,      <span class=\"string\">//</span>右下</span><br><span class=\"line\">    -1.2, -0.4,     <span class=\"string\">//</span>小矩形左下</span><br><span class=\"line\">    1.2, -0.4,      <span class=\"string\">//</span>小矩形右下</span><br><span class=\"line\">    -1.2,  0.4,     <span class=\"string\">//</span>小矩形左上</span><br><span class=\"line\">    1.2,  0.4,      <span class=\"string\">//</span>小矩形右上</span><br><span class=\"line\">    -1.2,  1.2,     <span class=\"string\">//</span>左上</span><br><span class=\"line\">    1.2,  1.2,      <span class=\"string\">//</span>右上</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"string\">//</span>填充纹理的数组</span><br><span class=\"line\">GLfloat texCoords[] = &#123;     </span><br><span class=\"line\">    0, 0,        <span class=\"string\">//</span>左下                  <span class=\"string\">//</span>下标为 0 1</span><br><span class=\"line\">    1, 0,        <span class=\"string\">//</span>右下                  <span class=\"string\">//</span>下标为2 3</span><br><span class=\"line\">    0, 1.0/3.0,  <span class=\"string\">//</span>小矩形左下             <span class=\"string\">//</span>下标为4 5</span><br><span class=\"line\">    1, 1.0/3.0,  <span class=\"string\">//</span>小矩形右下             <span class=\"string\">//</span>下标为6 7</span><br><span class=\"line\">    0, 2.0/3.0,  <span class=\"string\">//</span>小矩形左上角           <span class=\"string\">//</span>下标为8 9</span><br><span class=\"line\">    1, 2.0/3.0,  <span class=\"string\">//</span>小矩形右上角           <span class=\"string\">//</span>下标为10 11</span><br><span class=\"line\">    0, 1,        <span class=\"string\">//</span>左上                  <span class=\"string\">//</span>下标为12 13</span><br><span class=\"line\">    1, 1,        <span class=\"string\">//</span>右上                  <span class=\"string\">//</span>下标为14 15</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>手动选择区域：通过添加带有自定义手势的 UIView 来实现拖动修改选择区域。</li>\n</ul>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*****************CustomPanView代码******************</span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">CustomPanViewDelegate</span> &lt;<span class=\"title\">NSObject</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  开始拖拽</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param customPanView 自身</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param centerY       自身所在的y坐标</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)beginDragWithCoustomPanView:(<span class=\"built_in\">UIView</span> *)customPanView centerY:(<span class=\"built_in\">CGFloat</span>)centerY;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CustomPanView</span> : <span class=\"title\">UIView</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"type\">id</span>&lt;CustomPanViewDelegate&gt; delegate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*****************CustomPanViewDelegate代码******************</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark -</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark 拖拽View的代理方法</span></span><br><span class=\"line\">-(<span class=\"type\">void</span>)beginDragWithCoustomPanView:(<span class=\"built_in\">UIView</span> *)customPanView centerY:(<span class=\"built_in\">CGFloat</span>)centerY &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 限制范围：裁剪区不能大于图片区域</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (customPanView.center.y &gt;= imageBottom) &#123;</span><br><span class=\"line\">        customPanView.center = <span class=\"built_in\">CGPointMake</span>(customPanView.center.x, imageBottom);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (customPanView.center.y &lt;= imageTop) &#123;</span><br><span class=\"line\">        customPanView.center = <span class=\"built_in\">CGPointMake</span>(customPanView.center.x, imageTop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    获取两条线的坐标</span></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> topY = _topView.center.y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> bottomY = _bottomView.center.y;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    根据两条线的坐标刷新裁剪区域UI</span></span><br><span class=\"line\">    [_cutLabel setFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, topY &lt; bottomY ? topY : bottomY, SCREEN_WIDTH, fabs(bottomY - topY))];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    算出裁剪起始坐标和结束坐标</span></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> fromPoint = topY &lt; bottomY ? (imageBottom - bottomY) / imageHeight : (imageBottom - topY) / imageHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> toPoint = topY &lt; bottomY ? (imageBottom - topY) / imageHeight : (imageBottom - bottomY) / imageHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//将中间的矩形的顶点坐标和坐标联系裁剪区域联系起来。</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> sendFromePoint:fromPoint endPoint:toPoint];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_cutLabel.frame.size.height &lt; <span class=\"number\">30</span>) &#123;  <span class=\"comment\">//隐藏文字</span></span><br><span class=\"line\">        _cutLabel.text = <span class=\"string\">@&quot;&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        _cutLabel.text = <span class=\"string\">@&quot;编辑区域&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.slider setValue:<span class=\"number\">0.0</span> animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    tmpHeight = <span class=\"number\">0.0</span>f;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 使用一个 Delegate 将拖移后的 Y 坐标返回，因为是竖直运动的所以我们只关心 Y 轴坐标。</p>\n<ul>\n<li>改变大小：通过将 UISliderBar 的 ValueChange 和顶点坐标关联来实现改变顶点坐标，之后调用 GLKView 的 display 的方法来刷新 UI，将变化的过程展现出来。</li>\n</ul>\n<p><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)action:(UISlider *)sender &#123;</span><br><span class=\"line\">    <span class=\"regexp\">//</span>判断是否是向右滑动</span><br><span class=\"line\">    isRightDirection = sender.value &gt;= judgeDirection ? YES : NO;</span><br><span class=\"line\">    <span class=\"regexp\">//</span>所改变的高度</span><br><span class=\"line\">    changeHeight = sender.value - tmpHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"regexp\">//</span>遍历数组</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (int i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">16</span>; i ++) &#123;</span><br><span class=\"line\">        <span class=\"regexp\">//</span>将Y坐标筛选出来</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i % <span class=\"number\">2</span> != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"regexp\">//</span>下半部分矩形</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt;= <span class=\"number\">7</span>) &#123;</span><br><span class=\"line\">                <span class=\"regexp\">//</span>下半部分矩形Y轴做减法减去变化的高度</span><br><span class=\"line\">                vertices[i] = verticesCopy[i] - changeHeight;</span><br><span class=\"line\">                <span class=\"regexp\">//</span>上半部分矩形</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">9</span>) &#123;</span><br><span class=\"line\">                <span class=\"regexp\">//</span>上半部分矩形Y轴做加法加上变化的高度</span><br><span class=\"line\">                vertices[i] = verticesCopy[i] + changeHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"regexp\">//</span>缩小时候如果编辑区域已经成为一条线了就不能在缩小了</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vertices[<span class=\"number\">11</span>] &gt; vertices[<span class=\"number\">7</span>]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        [self.glView display];</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>通过 glReadPixels 来从内存中读取像素数据，GLubyte -&gt; CGImageRef -&gt; UIimage 然后最相关的保存或者其他操作。</li>\n</ul>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#pragma mark -</span><br><span class=\"line\">#pragma mark 获取处理后的图片</span><br><span class=\"line\">- (UIImage *) createImage &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> imageY = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> imgHeight = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isRightDirection) &#123; <span class=\"comment\">// 判断slider滑动方向</span></span><br><span class=\"line\"></span><br><span class=\"line\">        imageY = fabs(imageTop - fabs(changeHeight<span class=\"operator\"> * </span>perOpengleseCoordinate))<span class=\"operator\"> * </span>screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">        imgHeight = fabs(imageHeight + <span class=\"number\">2</span><span class=\"operator\"> * </span>fabs(changeHeight<span class=\"operator\"> * </span>perOpengleseCoordinate))<span class=\"operator\"> * </span>screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        imageY = fabs(imageTop + fabs(changeHeight<span class=\"operator\"> * </span>perOpengleseCoordinate))<span class=\"operator\"> * </span>screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">        imgHeight = fabs(imageHeight - <span class=\"number\">2</span><span class=\"operator\"> * </span>fabs(changeHeight<span class=\"operator\"> * </span>perOpengleseCoordinate))<span class=\"operator\"> * </span>screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> imageWidth = SCREEN_WIDTH<span class=\"operator\"> * </span>screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> dataLength = imageWidth<span class=\"operator\"> * </span>imgHeight<span class=\"operator\"> * </span><span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    GLubyte *data = (GLubyte*)malloc(dataLength<span class=\"operator\"> * </span>sizeof(GLubyte));</span><br><span class=\"line\"></span><br><span class=\"line\">    gl<span class=\"constructor\">PixelStorei(GL_PACK_ALIGNMENT, 4)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    gl<span class=\"constructor\">ReadPixels(0, <span class=\"params\">imageY</span>, <span class=\"params\">imageWidth</span>, <span class=\"params\">imgHeight</span>, GL_RGBA, GL_UNSIGNED_BYTE, <span class=\"params\">data</span>)</span>;  <span class=\"comment\">//从内存中读取像素</span></span><br><span class=\"line\">    CGDataProviderRef <span class=\"built_in\">ref</span> = <span class=\"constructor\">CGDataProviderCreateWithData(NULL, <span class=\"params\">data</span>, <span class=\"params\">dataLength</span>, NULL)</span>;</span><br><span class=\"line\">    CGColorSpaceRef colorspace = <span class=\"constructor\">CGColorSpaceCreateDeviceRGB()</span>;</span><br><span class=\"line\">    CGImageRef iref = <span class=\"constructor\">CGImageCreate(<span class=\"params\">imageWidth</span>, <span class=\"params\">imgHeight</span>, 8, 32, <span class=\"params\">imageWidth</span> <span class=\"operator\">*</span> 4, <span class=\"params\">colorspace</span>, <span class=\"params\">kCGBitmapByteOrder32Big</span> | <span class=\"params\">kCGImageAlphaPremultipliedLast</span>,<span class=\"params\">ref</span>, NULL, <span class=\"params\">true</span>, <span class=\"params\">kCGRenderingIntentDefault</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"constructor\">UIGraphicsBeginImageContext(CGSizeMake(<span class=\"params\">imageWidth</span>, <span class=\"params\">imgHeight</span>)</span>);</span><br><span class=\"line\">    CGContextRef cgcontext = <span class=\"constructor\">UIGraphicsGetCurrentContext()</span>;</span><br><span class=\"line\">    <span class=\"constructor\">CGContextSetBlendMode(<span class=\"params\">cgcontext</span>, <span class=\"params\">kCGBlendModeCopy</span>)</span>;</span><br><span class=\"line\">    <span class=\"constructor\">CGContextDrawImage(<span class=\"params\">cgcontext</span>, CGRectMake(0, 0, <span class=\"params\">imageWidth</span>, <span class=\"params\">imgHeight</span>)</span>, iref);</span><br><span class=\"line\"></span><br><span class=\"line\">    CGImageRef imageMasked = <span class=\"constructor\">CGBitmapContextCreateImage(<span class=\"params\">cgcontext</span>)</span>;</span><br><span class=\"line\">    UIImage<span class=\"operator\"> * </span>image = <span class=\"literal\">[UII<span class=\"identifier\">mage</span> <span class=\"identifier\">imageWithCGImage</span>:<span class=\"identifier\">imageMasked</span> <span class=\"identifier\">scale</span>:<span class=\"identifier\">screenScale</span> <span class=\"identifier\">orientation</span>:UII<span class=\"identifier\">mageOrientationUp</span>]</span>;</span><br><span class=\"line\">    <span class=\"constructor\">UIGraphicsEndImageContext()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    free(data);</span><br><span class=\"line\">    <span class=\"constructor\">CFRelease(<span class=\"params\">ref</span>)</span>;</span><br><span class=\"line\">    <span class=\"constructor\">CFRelease(<span class=\"params\">colorspace</span>)</span>;</span><br><span class=\"line\">    <span class=\"constructor\">CGImageRelease(<span class=\"params\">iref</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    return image;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n",
            "tags": [
                "底层",
                "OpenGL",
                "UI"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-23-%E5%85%B3%E4%BA%8E%E7%89%A9%E7%90%86%E6%95%88%E6%9E%9C%E7%9A%84%E5%8A%A8%E7%94%BB%E5%BC%95%E6%93%8EUIDynamic%E4%BB%8B%E7%BB%8D/",
            "url": "https://oliverqueen.cn/2018-01-23-%E5%85%B3%E4%BA%8E%E7%89%A9%E7%90%86%E6%95%88%E6%9E%9C%E7%9A%84%E5%8A%A8%E7%94%BB%E5%BC%95%E6%93%8EUIDynamic%E4%BB%8B%E7%BB%8D/",
            "title": "关于物理效果的动画引擎UIDynamic介绍",
            "date_published": "2018-01-23T13:18:42.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>这几天事情超多，实在很难静下心来研究一个东西，但是这个类我也是关注好久了，早就想总结下写出来， 可能这篇文章并不会像之前额那样那么详细，按理说写动画相关的东西应该是配 gif 的，但是真的是没有心思再去搞那些东西，代码并不难，大家可以照着代码写一下看下效果。<br />\n        为了实现动力 UI，需要注册一套 UI 行为的体系，之后 UI 便会按照预先的设定进行运动了。我们应该了解的新的基本概念有如下四个：<br />\nUIDynamicItem：用来描述一个力学物体的状态，其实就是实现了 UIDynamicItem 委托的对象，或者抽象为有面积有旋转的质点； 简单的说就是一个控件，就是你想往谁上面加动画，这个就是谁。<br />\nUIDynamicBehavior：动力行为的描述，用来指定 UIDynamicItem 应该如何运动，即定义适用的物理规则。一般我们使用这个类的子类对象来对一组 UIDynamicItem 应该遵守的行为规则进行描述；简单的说就是动画效果，这个类是动画效果的一个父类，它的子类大家可以用运行时的方法输出一下看一下，或者一会看我介绍，一个子类是一个效果，各种效果比如重力啊碰撞啊，链接啊之类的。<br />\nUIDynamicAnimator；动画的播放者，动力行为（UIDynamicBehavior）的容器，添加到容器内的行为将发挥作用；<br />\nReferenceView：等同于力学参考系，如果你的初中物理不是语文老师教的话，我想你知道这是啥.. 只有当想要添加力学的 UIView 是 ReferenceView 的子 view 时，动力 UI 才发生作用。下面看下我们给一个 button 加一个重力下坠的动画 使用 self.View 做参考系来建立动画<br />\n<span id=\"more\"></span><br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6m073lu9j30ft02n74g.jpg\" alt=\"\" /></p>\n<p>然后</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6m0h0bvej307900s0si.jpg\" alt=\"\" /></p>\n<p>你可以吧这里航代码写到 button 的点击事件中，这样你一点就会下坠。很简单吧。<br />\n        再看下一个碰撞</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6m1auc65j30mx02ht92.jpg\" alt=\"\" /></p>\n<p>我这里写碰撞动画的时候用了两个 button，其实大家可以猜到我是让两个 button 来碰撞的，碰撞的过程中也是会走代理方法的，开始碰撞啊，碰撞结束啊之类的。最后那句话的意思是吧他的参考系 (这里是的 self.view) 的边界作为碰撞边界，就是说这段代码运行后这两个 这两控件撞到屏幕 self.view 的边框会发生物理的碰撞反弹效果。想这样 (点我开始那个按钮)</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6m1l2ecwg308r0fl75h.gif\" alt=\"\" /></p>\n<p>除了重力和碰撞，iOS SDK 还预先帮我们实现了一些其他的有用的物理行为，它们包括<br />\n UIAttachmentBehavior 描述一个 view 和一个锚相连接的情况，也可以描述 view 和 view 之间的连接。attachment 描述的是两个点之间的连接情况，可以通过设置来模拟无形变或者弹性形变的情况（再次希望你还记得这些概念，简单说就是木棒连接和弹簧连接两个物体）。当然，在多个物体间设定多个；UIAttachmentBehavior，就可以模拟多物体连接了.. 有了这些，似乎可以做个老鹰捉小鸡的游戏了 - -…<br />\nUISnapBehavior 将 UIView 通过动画吸附到某个点上。初始化的时候设定一下 UISnapBehavior 的 initWithItem:snapToPoint: 就行，因为 API 非常简单，视觉效果也很棒，估计它是今后非游戏 app 里会被最常用的效果之一了；<br />\nUIPushBehavior 可以为一个 UIView 施加一个力的作用，这个力可以是持续的，也可以只是一个冲量。当然我们可以指定力的大小，方向和作用点等等信息。<br />\nUIDynamicItemBehavior 其实是一个辅助的行为，用来在 item 层级设定一些参数，比如 item 的摩擦，阻力，角阻力，弹性密度和可允许的旋转等等</p>\n<p>其实流程很简单创建 animator  然后创建 behivator   设置 behivator 属性 然后 animator addBehivator 。就是这个么流程。写代码要学会举一反三触类旁通。    这篇博客写的比较急，但是总体上来说功能没问题，细节上有什么问题，大家找我一起交流</p>\n",
            "tags": [
                "UI",
                "动画"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-23-%E5%85%B3%E4%BA%8E%E8%A7%86%E5%9B%BE%E5%9C%A8%E5%88%87%E5%9C%86%E8%A7%92%E6%97%B6%E5%80%99%E7%9A%84%E5%AF%BC%E8%87%B4%E7%9A%84%E6%80%A7%E8%83%BD%E4%B8%8B%E9%99%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A2%E8%AE%A8/",
            "url": "https://oliverqueen.cn/2018-01-23-%E5%85%B3%E4%BA%8E%E8%A7%86%E5%9B%BE%E5%9C%A8%E5%88%87%E5%9C%86%E8%A7%92%E6%97%B6%E5%80%99%E7%9A%84%E5%AF%BC%E8%87%B4%E7%9A%84%E6%80%A7%E8%83%BD%E4%B8%8B%E9%99%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A2%E8%AE%A8/",
            "title": "关于视图在切圆角时候的导致的性能下降的一些探讨",
            "date_published": "2018-01-23T13:08:48.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>iOS 中有的时候我们控件要做成圆形 或者是切成圆角，这个时候我们一般都会使用.layer.cornerRadius  -&gt;  clipsToBounds = YES 的属性来切，这样完全能达到我们的效果，但是如果一个界面上需要切圆角的控件很多，并且列表很长的时候，尤其是像 tableView 那样如果每一个 cell 上都有大量的控件需要切，那么就会非常卡顿，帧数严重下降 。其实原因就是这样设置会触发离屏渲染，比较消耗性能。注意：png 图片 UIImageView 处理圆角是不会产生离屏渲染的。（ios9.0 之后不会离屏渲染，ios9.0 之前还是会离屏渲染）。这里先说下离屏渲染：<br />\n ###### iOS 的渲染机制：<br />\n   CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。GPU 屏幕渲染有以下两种方式：<br />\nOn-Screen Rendering<br />\n 意为当前屏幕渲染，指的是 GPU 的渲染操作是在当前用于显示的屏幕缓冲区中进行。<br />\nOff-Screen Rendering<br />\n 意为离屏渲染，指的是 GPU 在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。<br />\n<span id=\"more\"></span><br />\n 由以上可以看出离屏渲染需要重新开辟新的缓存空间，必定要更加消耗资源。<br />\n通过查资料目前知道了设置了以下属性时，都会触发离屏绘制：<br />\nshouldRasterize（光栅化）<br />\nmasks（遮罩）<br />\nshadows（阴影）<br />\nedge antialiasing（抗锯齿）<br />\ngroup opacity（不透明）<br />\n复杂形状设置圆角等<br />\n渐变<br />\n我用一个现有的小 DEMO 来测试下，因为这个 demo 中没有切圆角，但是有阴影，一样可以出发离屏渲染，所以效果是一样的，在 tableView 中的自定义 cell 类中我设置了阴影如图：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6makjj7sj30f2025aac.jpg\" alt=\"\" /></p>\n<p>使用 Instruments 测试得到当前帧数在二三十左右</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6maqxgt6j30uf03874d.jpg\" alt=\"\" /></p>\n<p>同时屏幕是也出现了黄色图层</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mb1epsnj30dx0ou40r.jpg\" alt=\"\" /></p>\n<p>所有黄色的高亮的图层都进行了离屏渲染，也表示这些图层存在着问题，影响性能。而且帧数过低也会直接影响我们对 APP 的体验。</p>\n<h6 id=\"如何避免离屏渲染\"><a class=\"anchor\" href=\"#如何避免离屏渲染\">#</a> 如何避免离屏渲染：</h6>\n<ul>\n<li>\n<p>方法一：使用光栅化，.layer.shouldRasterize = YES;   -&gt;  .layer.rasterizationScale=[UIScreen mainScreen].scale; 设置光栅化，可以使离屏渲染的结果缓存到内存中存为位图，使用的时候直接使用缓存，节省了一直离屏渲染损耗的性能。但是如果 layer 及 sublayers 常常改变的话，它就会一直不停的渲染及删除缓存重新创建缓存，所以这种情况下建议不要使用光栅化，这样也是比较损耗性能的。</p>\n</li>\n<li>\n<p>方法二：最简单的方法，就是图片不作处理，直接覆盖一张中间为圆形透明的图片（推荐使用）这种方法 GPU 计算多层的混合渲染 blending 也是会消耗一点性能的，但比第一种方法还是好上很多的</p>\n</li>\n<li>\n<p>方法三：Core Graphics 绘制圆角。这种方式 GPU 损耗最低，可以用 UIimageView 添加个点击手势当做 UIButton 使用。<br />\nUIGraphicsBeginImageContextWithOptions(avatarImageView.bounds.size, NO, [UIScreen mainScreen].scale);<br />\n[[UIBezierPath bezierPathWithRoundedRect:avatarImageView.bounds cornerRadius:50] addClip];[image drawInRect:avatarImageView.bounds];<br />\navatarImageView.image = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();<br />\n 这段方法可以写在 SDWebImage 的 completed 回调里，在主线程异步绘制。也可以封装到 UIImageView 里，写了个 DSRoundImageView。后台线程异步绘制，不会阻塞主线程。目前这种方法只用在 imageView 上，其他地方呢不知道怎么用，不过这种方法会耗费大量的 CPU 资源和占用内存，本人不太建议使用。</p>\n</li>\n</ul>\n<p>最后给大家测试下，因为我之前的 demo 没有切圆角，而是使用的阴影，所以我就用第一种方法给大家测一下。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mbdmx1bj30lu04ywfj.jpg\" alt=\"\" /></p>\n<p>然后运行，打开 Instruments，然后看屏幕</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mbm7cn6j30e40ox76i.jpg\" alt=\"\" /></p>\n<p>图层都是绿色没问题，我们再来看帧数，几乎到 60 ，效果很明显。<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mbsz37rj30j602k747.jpg\" alt=\"\" /></p>\n<p>由此可见以后大家再切圆角的时候多注意下，刚才就研究了这么多，有什么问题及时与我交流吧。。。</p>\n",
            "tags": [
                "UI",
                "性能优化"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-23-CFNetwork%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/",
            "url": "https://oliverqueen.cn/2018-01-23-CFNetwork%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/",
            "title": "CFNetwork的介绍和使用",
            "date_published": "2018-01-23T13:04:15.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"cfnetwork背景简介\"><a class=\"anchor\" href=\"#cfnetwork背景简介\">#</a> CFNetwork 背景简介</h3>\n<p>CFNetwork 是 ISO 中一个比较底层的网络框架，C 语言编写，可以控制一些更底层的东西，如各种常用网络协议、socket 通讯等，我们通常使用的 NSURL 则更倾向于 API 数据请求等，虽然框架也提供了一些操作，但是远不如 CFNetwork 丰富。CFNetwork 已经接近于 UNIX 系统的 socket 通信了，使用 CFHttpMessageRef 进行 HTTP 连接的好处就是控制的粒度更细了，例如你可以设置 SSL 连接的 PeerName，证书验证的方式，还可以控制每个响应包的接收。不过 CFNetwork 本质上还是应用层上的封装的通用 API。使用者可以不用关心底层协议的实际细节。下图是 CFNetwork 在 iOS 系统中的位置 (图片来源于官方文档)。</p>\n<p><span id=\"more\"></span><br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mit8tsij30bn06lwen.jpg\" alt=\"image.png\" /></p>\n<p>由上图可以看出目前 iOS 的网络编程分四层：</p>\n<ul>\n<li>\n<p>WebKit：属于 Cocoa 层，苹果很多地方用到的页面渲染引擎 WKWebview；</p>\n</li>\n<li>\n<p>NSURL：也属于 Cocoa 层，对各类 URL 请求的封装 (NSURLRequest)；</p>\n</li>\n<li>\n<p>CFNetwork：属于 Core Foundation 层，基于 C 的封装，同样的还有 CFNetServices (write/readstream)；</p>\n</li>\n<li>\n<p>BSD sockets：属于 OS 层，也是基于 C 的封装；</p>\n</li>\n</ul>\n<h3 id=\"cfnetwork结构\"><a class=\"anchor\" href=\"#cfnetwork结构\">#</a> CFNetwork 结构</h3>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mlt3gwcj30od0a474w.jpg\" alt=\"image.png\" /><br />\n 上图也是官方文档的图片，描述了 CFNetwork 的结构，下面逐一讲解。</p>\n<h5 id=\"cfsocket-api\"><a class=\"anchor\" href=\"#cfsocket-api\">#</a> CFSocket API</h5>\n<p>Socket 是网络通讯的底层基础，两个 socket 端口可以互发数据。我们通常使用的是 BSD socket，CFSocket 则是 BSD socket 的抽象，基本上实现了几乎所有 BSD socket 的功能，并且还融入了 run loop。</p>\n<h5 id=\"cfstream-api\"><a class=\"anchor\" href=\"#cfstream-api\">#</a> CFStream API</h5>\n<p>CFStream API 提供了数据读写的方法，即读写流，使用它可以为内存、文件、网络（使用 socket）的数据建立 stream，我们进行网络请求就是对数据的读写，CFStream 提供 API 对两种 CFType 对象提供抽象：CFReadStream and CFWriteStream。它同时也是 CFHTTP 和 CFFTP 的基础。stream 有一个很重要的特性就是一旦数据流被提供或者被消耗，就不能从流中重新取出。比如这样</p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint8_t d[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">//循环条件：流中是否有可用数据(被读过的数据不可用了)</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> ([<span class=\"keyword\">self</span>.inputStream hasBytesAvailable]) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//读取相应长度的数据数据</span></span><br><span class=\"line\">    <span class=\"built_in\">NSInteger</span> len = [<span class=\"keyword\">self</span>.inputStream read:d maxLength:<span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"comment\">//如果读取到数据，便将数据快拼接</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &gt; <span class=\"number\">0</span> &amp;&amp; !<span class=\"keyword\">self</span>.inputStream.streamError) &#123;</span><br><span class=\"line\">        [data appendBytes:(<span class=\"type\">void</span> *)d length:len];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"cfftp-api\"><a class=\"anchor\" href=\"#cfftp-api\">#</a> CFFTP API</h5>\n<p>对用 FTP 协议通信的封装，能下载、上传文件和目录到 FTP 服务器。CFFTP 建立的连接可以是同步或者异步，此次不做详解。</p>\n<h5 id=\"cfhttp-api\"><a class=\"anchor\" href=\"#cfhttp-api\">#</a> CFHTTP API</h5>\n<p>是 HTTP 协议的抽象，主要对象是 CFHTTPMessageRef (类似于我们通常的 NSURLRequest) 我们需要像构建 NSURLRequest 那样来构建 CFHTTPMessageRef，同样包含一下几个元素</p>\n<ul>\n<li>\n<p>必须元素</p>\n<ul>\n<li>\n<p>请求方法 (类型为 CFStringRef)：POST、GET、DELETE 等..</p>\n</li>\n<li>\n<p>请求的 URL 地址 (类型为 CFURLRef)：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmFpZHUuY29t\">https://www.baidu.com</span></p>\n</li>\n<li>\n<p>请求的 HTTP 版本 (类型为 CFStringRef)：通常使用 kCFHTTPVersion1_1</p>\n</li>\n<li>\n<p>kCFAllocatorDefault：用于创建消息引用的指定默认的系统内存分配器。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>可选参数</p>\n<ul>\n<li>body 体 (类型为 CFDataRef)</li>\n</ul>\n</li>\n</ul>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">CFHTTPMessageSetBody</span>(<span class=\"built_in\">CFHTTPMessageRef</span> message, <span class=\"built_in\">CFDataRef</span> bodyData) <span class=\"built_in\">CF_AVAILABLE</span>(<span class=\"number\">10</span>_1, <span class=\"number\">2</span>_0);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>消息头部，如 User-Agent 等；</li>\n</ul>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CFHTTPMessageSetHeaderFieldValue</span>(<span class=\"built_in\">CFHTTPMessageRef</span> message, <span class=\"built_in\">CFStringRef</span> headerField, <span class=\"built_in\">CFStringRef</span> __<span class=\"keyword\">nullable</span> value) <span class=\"built_in\">CF_AVAILABLE</span>(<span class=\"number\">10</span>_1, <span class=\"number\">2</span>_0);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"cfnetwork请求过程\"><a class=\"anchor\" href=\"#cfnetwork请求过程\">#</a> CFNetwork 请求过程</h3>\n<h5 id=\"1构造并创建cfhttpmessageref对象\"><a class=\"anchor\" href=\"#1构造并创建cfhttpmessageref对象\">#</a> 1：构造并创建 CFHTTPMessageRef 对象</h5>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//构造的方式上一步已讲</span></span><br><span class=\"line\"><span class=\"built_in\">CFHTTPMessageCreateRequest</span>(<span class=\"built_in\">CFAllocatorRef</span> __<span class=\"keyword\">nullable</span> alloc, <span class=\"built_in\">CFStringRef</span> requestMethod, <span class=\"built_in\">CFURLRef</span> url, <span class=\"built_in\">CFStringRef</span> httpVersion) <span class=\"built_in\">CF_AVAILABLE</span>(<span class=\"number\">10</span>_1, <span class=\"number\">2</span>_0);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"2使用cfhttpmessageref对象创建输入流\"><a class=\"anchor\" href=\"#2使用cfhttpmessageref对象创建输入流\">#</a> 2：使用 CFHTTPMessageRef 对象创建输入流</h5>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一个参数传默认</span></span><br><span class=\"line\"><span class=\"built_in\">CFReadStreamCreateForHTTPRequest</span>(<span class=\"built_in\">CFAllocatorRef</span> __<span class=\"keyword\">nullable</span> alloc, <span class=\"built_in\">CFHTTPMessageRef</span> request) <span class=\"built_in\">CF_DEPRECATED</span>(<span class=\"number\">10</span>_2, <span class=\"number\">10</span>_11, <span class=\"number\">2</span>_0, <span class=\"number\">9</span>_0, <span class=\"string\">&quot;Use NSURLSession API for http requests&quot;</span>);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"3适配sni环境一个-ip-地址上可以为不同域名分配使用不同的-ssl-证书这同时意味着共享-ip-的虚拟主机也可实现-ssltls-连接\"><a class=\"anchor\" href=\"#3适配sni环境一个-ip-地址上可以为不同域名分配使用不同的-ssl-证书这同时意味着共享-ip-的虚拟主机也可实现-ssltls-连接\">#</a> 3：适配 SNI 环境（一个 IP 地址上可以为不同域名分配使用不同的 SSL 证书；这同时意味着，共享 IP 的虚拟主机也可实现 SSL/TLS 连接。）</h5>\n<p>因为配置 sni 环境的所有配置都是基于输入流来操作，所以我们构建完成输入流之后来处理 sni，像这样<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span>.inputStream setProperty:<span class=\"built_in\">NSStreamSocketSecurityLevelNegotiatedSSL</span> forKey:<span class=\"built_in\">NSStreamSocketSecurityLevelKey</span>];</span><br><span class=\"line\"><span class=\"comment\">//请求的URL的Host</span></span><br><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *sslProperties = @&#123; (__bridge <span class=\"type\">id</span>) kCFStreamSSLPeerName : host &#125;;</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.inputStream setProperty:sslProperties forKey:(__bridge_transfer <span class=\"built_in\">NSString</span> *) kCFStreamPropertySSLSettings];</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"4打开输入流\"><a class=\"anchor\" href=\"#4打开输入流\">#</a> 4：打开输入流</h5>\n<p>打开输入流分为两步</p>\n<ul>\n<li>设置代理：[self.inputStream setDelegate:weakSelf]</li>\n<li>加入当前的 runloop：<br />\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[_inputStream <span class=\"symbol\">removeFromRunLoop:</span><span class=\"keyword\">self</span>.runloop <span class=\"symbol\">forMode:</span>[<span class=\"keyword\">self</span> runloopMode]];</span><br></pre></td></tr></table></figure></li>\n<li>调用 Open 方法</li>\n</ul>\n<h5 id=\"5收到代理数据回调\"><a class=\"anchor\" href=\"#5收到代理数据回调\">#</a> 5：收到代理数据回调</h5>\n<p><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- <span class=\"params\">(void)</span>stream:<span class=\"params\">(NSStream *)</span>aStream handleEvent:<span class=\"params\">(NSStreamEvent)</span>eventCode;</span><br></pre></td></tr></table></figure><br />\n 其中分为几个状态<br />\n <figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_OPTIONS</span>(<span class=\"type\">NSUInteger</span>, <span class=\"type\">NSStreamEvent</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventNone</span> = 0,</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventOpenCompleted</span> = 1UL &lt;&lt; 0,</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventHasBytesAvailable</span> = 1UL &lt;&lt; 1,</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventHasSpaceAvailable</span> = 1UL &lt;&lt; 2,</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventErrorOccurred</span> = 1UL &lt;&lt; 3,</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventEndEncountered</span> = 1UL &lt;&lt; 4</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br />\n 通常我们会关心 NSStreamEventOpenCompleted、NSStreamEventHasBytesAvailable、NSStreamEventErrorOccurred、<br />\n由于数据是以流的形式回来，我们需要在在 NSStreamEventHasBytesAvailable 下取出数据然后做数据拼接，拼接好完整的数据才可使用，像这样<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"built_in\">NSStreamEventHasBytesAvailable</span>:</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">UInt8</span> buffer[BUFFER_SIZE]; <span class=\"comment\">//设置缓存区</span></span><br><span class=\"line\">    <span class=\"built_in\">NSInteger</span> numBytesRead = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSInputStream</span> *inputstream = (<span class=\"built_in\">NSInputStream</span> *) aStream;</span><br><span class=\"line\">    <span class=\"comment\">// Read data</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        numBytesRead = [inputstream read:buffer maxLength:<span class=\"keyword\">sizeof</span>(buffer)];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numBytesRead &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span>.resultData appendBytes:buffer length:numBytesRead];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (numBytesRead &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">break</span>;</span><br></pre></td></tr></table></figure><br />\n 循环结束后我们的 resultData 就是完整的返回数据了。</p>\n",
            "tags": [
                "网络",
                "底层"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-23-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Http%E8%AF%B7%E6%B1%82%E3%80%81DNS%E5%8A%AB%E6%8C%81%E4%B8%8E%E8%A7%A3%E6%9E%90/",
            "url": "https://oliverqueen.cn/2018-01-23-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Http%E8%AF%B7%E6%B1%82%E3%80%81DNS%E5%8A%AB%E6%8C%81%E4%B8%8E%E8%A7%A3%E6%9E%90/",
            "title": "深入理解Http请求、DNS劫持与解析",
            "date_published": "2018-01-23T10:12:18.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景</h3>\n<p>前段时间在处理 iOS 端的 HTTPDNS 相关 SDK，在接入和测试环节发现大家对 HTTP 的整体请求流程包括 HTTP 劫持原理以及 HTTPDNS 的工作原理并不是太清楚，所以写下这边文章帮助大家深入 web 请求过程：如何发起请求，HTTP 协议解析，DNS 域名解析。</p>\n<h3 id=\"http发起一个请求过程\"><a class=\"anchor\" href=\"#http发起一个请求过程\">#</a> HTTP 发起一个请求过程</h3>\n<p>当我们在手机端请求一个 @&quot;<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5iYWlkdS5jb20=\">www.baidu.com</span>&quot; 的域名的时候</p>\n<ul>\n<li>\n<p>1. 请求到达运营商的 DNS 服务器并由其把这个域名解析成对应的 IP 地址。</p>\n</li>\n<li>\n<p>2. 根据 IP 地址在互联网上找到对应的服务器，向这个服务器发起一个 get\\post 请求。</p>\n</li>\n<li>\n<p>3. 由这个服务器找到对应的资源原路返回给访问的用户。<br />\n<span id=\"more\"></span></p>\n</li>\n</ul>\n<p>这里只是一个大概的流程实际每一步都有复杂的结构和逻辑例如：服务器可能有很多台，到底指定哪台服务器来处理请求，需要一个负载均衡设备来平均分配所有用户的请求。请求的数据是存储在分布式缓存中还是一个静态文件中，或是在数据库里。当数据返回浏览器时，浏览器解析数据发现还有一些静态资源（如 CSS、JS 或者图片）时又会发起另外的 HTTP 请求，而这些请求很可能会在 CDN 上，那么 CDN 服务器上又会处理这个用户的请求。</p>\n<h3 id=\"http劫持\"><a class=\"anchor\" href=\"#http劫持\">#</a> HTTP 劫持</h3>\n<p>我们使用 HTTPDNS 的主要目的就是解决 HTTP 劫持问题。HTTP 的劫持分两种第一种是 DNS 劫持，第二种是内容劫持，后者是基于前者的基础上发展出来，是比较高级的劫持手段，目前无解，下面来分开讲解：</p>\n<h6 id=\"1dns劫持\"><a class=\"anchor\" href=\"#1dns劫持\">#</a> 1：DNS 劫持</h6>\n<ul>\n<li>\n<p>劫持流程<br />\n DNS 劫持又称<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOUYlOUYlRTUlOTAlOEQlRTUlOEElQUIlRTYlOEMlODE=\">域名劫持</span>，是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的 IP 地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能访问或访问的是假网址。其实本质就是对 DNS 解析服务器做手脚，或者是使用伪造的 DNS 解析服务器可以通过下图来展示</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mqqoqxrj30yg0gt7oj.jpg\" alt=\"DNS劫持原理\" /></p>\n<p>从图中可以看出红色的是劫持的流程，劫持后将你的请求转发到一个虚假的服务器。</p>\n</li>\n<li>\n<p>解决办法</p>\n<ul>\n<li>\n<p>DNS 的劫持过程是通过攻击运营商的解析服务器来达到目的。我们可以不用运营商的 DNS 解析而使用自己的解析服务器或者是提前在自己的 App 中将解析好的域名以 IP 的形式发出去就可以绕过运营商 DNS 解析，这样一来也避免了 DNS 劫持的问题。</p>\n</li>\n<li>\n<p>HttpDNS 是使用 HTTP 协议向 DNS 服务器的 80 端口进行请求，代替传统的 DNS 协议向 DNS 服务器的 53 端口进行请求，绕开了运营商的 Local DNS，从而避免了使用运营商 Local DNS 造成的劫持和跨网问题</p>\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"2内容劫持\"><a class=\"anchor\" href=\"#2内容劫持\">#</a> 2：内容劫持</h6>\n<ul>\n<li>\n<p>劫持流程<br />\n内容劫持网上很少有提到，这也是在做 httpDNS SDK 所遇到的一个问题，其实内容劫持一开始的出发点是好的，是运营商为了加快用户的访问速度同时减少自己的流量损耗而做的一个缓存机制，用户在像服务器请求数据的时候运营商会把用户的请求转移到这个缓存池中，如果缓存中有就直接返回，没有的话再去像服务器请求然后拦截并缓存服务端给用户的回调数据，这样一来可以极大的降低运营商像服务器请求的次数，也能加快用户的访问，所以出发点是好，但是一些非法的商家对缓存池内部做一些处理就是直接对返回的内容进行修改，这样一来我们就会接受到错误的数据</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mtjymehj30yg0h3tob.jpg\" alt=\"内容劫持\" /></p>\n<p>黄色线条就是比价危险的了，因为回调的数据很可能已经被篡改过。</p>\n</li>\n<li>\n<p>解决办法：<br />\n现在暂时无法通过 HTTPdns 和其他手段解决，不过这样的劫持不是很多。</p>\n</li>\n</ul>\n<h3 id=\"dns解析过程\"><a class=\"anchor\" href=\"#dns解析过程\">#</a> DNS 解析过程</h3>\n<p>如果是 iOS 设备请直接跳到第三步骤</p>\n<ul>\n<li>\n<p>1. 系统会检查浏览器缓存中有没有这个域名对应的解析过的 IP 地址，如果缓存中有，这个解析过程就将结束。浏览器缓存是受这个域名的失效时间和缓存的空间大小控制的。</p>\n</li>\n<li>\n<p>2. 如果用户的浏览器缓存中没有，浏览器会查找操作系统缓存中即为本地的 Host 文件。</p>\n</li>\n<li>\n<p>3. 如果本地 Host 文件中没有那么操作系统会把这个域名发送给这里设置的 LocalDNS，也就是本地区的域名服务器。这个 DNS 通常都提供给你本地互联网接入的一个 DNS 解析服务。这个专门的域名解析服务器性能都会很好，它们一般都会缓存域名解析结果，当然缓存时间是受域名的失效时间控制的，一般缓存空间不是影响域名失效的主要因素。大约 90% 的域名解析都到这里就已经完成了，所以 LDNS 主要承担了域名的解析工作。</p>\n</li>\n<li>\n<p>4. 如果 LDNS 仍然没有命中，就直接到 Root Server 域名服务器请求解析</p>\n</li>\n<li>\n<p>5. 根域名服务器返回给本地域名服务器一个所查询的域的主域名服务器（gTLD Server）地址。gTLD 是国际顶级域名服务器，<span class=\"exturl\" data-url=\"aHR0cDovL3huLS1idnMuY29t\">如.com</span>，.cn、.org 等。全球只有 13 台左右。</p>\n</li>\n<li>\n<p>6. 本地域名服务器（Local DNS Server）再向上一步返回的 gTLD 服务器发送请求。</p>\n</li>\n<li>\n<p>7. 接受请求的 gTLD 服务器查找并返回此域名对应的 Name Server 域名服务器的地址，这个 Name Server 通常就是你注册的域名服务器，例如你在某个域名服务提供商申请的域名，那么这个域名解析任务就由这个域名提供商的服务器来完成</p>\n</li>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cDovLzguTmFtZQ==\">8.Name</span> Server 域名服务器会查询存储的域名和 IP 的映射关系表，正常情况下都根据域名得到目标 IP 记录，连同一个 TTL 值返回给 DNS Server 域名服务器。</p>\n</li>\n<li>\n<p>9. 返回该域名对应的 IP 和 TTL 值，Local DNS Server 会缓存这个域名和 IP 的对应关系，缓存的时间由 TTL 值控制。</p>\n</li>\n<li>\n<p>10. 把解析的结果返回给用户，用户根据 TTL 值缓存在本地系统缓存中，域名解析过程结束。<br />\n以上的流程可以简化为下图</p>\n</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mu9fg86j30yg0k41hd.jpg\" alt=\"DNS解析\" /></p>\n<p>绿色的为非 iOS 设备的操作流程</p>\n<h3 id=\"cdn工作机制\"><a class=\"anchor\" href=\"#cdn工作机制\">#</a> CDN 工作机制</h3>\n<h6 id=\"cdn简介\"><a class=\"anchor\" href=\"#cdn简介\">#</a> CDN 简介</h6>\n<p>CDN，全称 Content Delivery Network，根本的作用是将网站的内容发布到最接近用户的网络 “边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。他 - 有别于镜像，它比镜像更智能，可以这样做一个比喻：CDN = 镜像（Mirror） + 缓存（cache） + 整体负载均衡（GSLB），因而，CDN 可以明显提高 Internet 中信息流动的效率。目前 CDN 都以缓存网站中的静态数据为主，如 CSS、JS、图片和静态网页等数据。用户在从主站服务器请求到动态内容后再从 CDN 上下载这些静态数据，从而加速网页数据内容的下载速度，如淘宝有 90% 以上的数据都是由 CDN 来提供的。这里引用一个网上比较形象的例子：<strong>A 家的网速 100M 的，但他只用了 10M 的速度，B 家的网速是 10M 的，但是他需要 15M 的速度才行。怎么办呢。 C 是一家 CDN 服务商，在 A 家有个节点（就像 A 是一个赞助商一样）B 在 C 家买了 CDN 加速服务。当 B 的速度不够的时候，CDN 加速就会选择有节余的节点来帮 B，提高 B 的速度。这样 B 的速度就能达到或超过 15M ，A 没浪费，B 速度有了，C 赚了钱，皆大欢喜。 当 C 的节点在全国都有，非常多的时候。那么你用 C 家的 CDN 加速服务，你就会健步如飞了</strong>。</p>\n<h6 id=\"cdn工作流程\"><a class=\"anchor\" href=\"#cdn工作流程\">#</a> CDN 工作流程</h6>\n<p>一个用户访问某个静态文件（如 CSS），<span class=\"exturl\" data-url=\"aHR0cDovL3huLS13d3ctaTY4ZG0wYjE5Y2c3a3NwaTIwZDk3dm9rbzAwYjI2OWc0ZDlkNXJ4YS5iYWlkdS5jb20=\">这个静态文件的域名假如是 www.baidu.com</span>，而这个域名最终会被指向 CDN 全局中 CDN 负载均衡服务器，再由这个负载均衡服务器来最终分配是哪个地方的访问用户，返回给离这个访问用户最近的 CDN 节点。之后用户就直接去这个 CDN 节点访问这个静态文件了，如果这个节点中请求的文件不存在，就会再回到源站去获取这个文件，然后再返回给用户。</p>\n<h6 id=\"负载均衡\"><a class=\"anchor\" href=\"#负载均衡\">#</a> 负载均衡</h6>\n<p>负载均衡就是对工作任务进行平衡、分摊到多个操作单元上执行，如图片服务器、应用服务器等，共同完成工作任务。它可以提高服务器响应速度及利用效率，避免软件或者硬件模块出现单点失效，解决网络拥塞问题，实现地理位置无关性，为用户提供较一致的访问质量。<br />\nCDN 整体的工作流程可以大概归为下图：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mup956fj30yg0f5wx0.jpg\" alt=\"image.png\" /></p>\n<h3 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h3>\n<p>以上就是 Http 请求的一些理解，如果有不对的地方及时与我来沟通。</p>\n",
            "tags": []
        },
        {
            "id": "https://oliverqueen.cn/2018-01-23-%E5%9C%A8iOS11%E4%B8%8Bapp%E5%9B%BE%E6%A0%87%E5%8F%98%E7%A9%BA%E7%99%BD%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/",
            "url": "https://oliverqueen.cn/2018-01-23-%E5%9C%A8iOS11%E4%B8%8Bapp%E5%9B%BE%E6%A0%87%E5%8F%98%E7%A9%BA%E7%99%BD%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/",
            "title": "在iOS11下app图标变空白的问题解决",
            "date_published": "2018-01-23T10:07:50.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景：</h2>\n<p>最近在做项目的时候发现运行在模拟器上图标丢失，变成了苹果默认的白板图标。因为一开始只在模拟器上出现，而且也确认没有人动过图标文件，所以没有在意，后来慢慢的该问题出现在真机上，一开始是只有 iPhone X，然后就是 iPhone 8，慢慢的变成不管是模拟器还是真机，所有 iOS11 系统的图标都没有了。接下来影响到的机型和系统越来越多。<br />\n<span id=\"more\"></span></p>\n<h2 id=\"尝试\"><a class=\"anchor\" href=\"#尝试\">#</a> 尝试：</h2>\n<p>1：一开始想到的是可能有人误改了图标文件，于是删除了 images.xcassest 中的 AppIcon 文件，从新生成→添加图标，但是依然未解决。（✘）</p>\n<p>2：想到是图片格式 / 尺寸的问题，于是所有图片按照规定重新生成，但是仍然无济于事。（✘）</p>\n<p>3：因为设置图标的方法除了在 images.xcassest 中的 AppIcon 文件中设置还可以在 info.plist 设置、或者直接在工程里面放一个 icon.png 的图片来设</p>\n<p>置，所以都检查了一便发现也不是这个原因（✘）</p>\n<p>3：重置手机。(✘)</p>\n<h2 id=\"解决\"><a class=\"anchor\" href=\"#解决\">#</a> 解决：</h2>\n<p>google 了下发现好多国外的开发遇到这个问题，并且都是使用 xcode9.X.X 版本，所以怀疑是苹果的 BUG</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mw7fbitj30yg0b0dip.jpg\" alt=\"image.png\" /></p>\n<p>不过这个问题并不是谁都会出现也不是所有使用 xcode9 + iOS11 的设备都会出现</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mwjg45nj30yg09kq41.jpg\" alt=\"image.png\" /></p>\n<p>后来经过大家的讨论终于有人说这个其实是 cocoapods 的 BUG，暂时并不能通过更新 cocoapods 更新来解决，因为最新版的 cocoapods</p>\n<p>也存在这个问题，解决方法如下：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mwrgqg2j30yg0bqdl4.jpg\" alt=\"image.png\" /></p>\n<p>在你的 podfile 中加入以下代码就可以了</p>\n<p><figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">post_install <span class=\"keyword\">do</span> |installer|</span><br><span class=\"line\">    copy_pods_resources_path = <span class=\"string\">&quot;Pods/Target Support Files/Pods-工程名/Pods-工程名-resources.sh&quot;</span></span><br><span class=\"line\">    string_to_replace = <span class=\"string\">&#x27;--compile &quot;<span class=\"subst\">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class=\"subst\">$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;</span>&quot;&#x27;</span></span><br><span class=\"line\">    assets_compile_with_app_icon_arguments = <span class=\"string\">&#x27;--compile &quot;<span class=\"subst\">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class=\"subst\">$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;</span>&quot; --app-icon &quot;<span class=\"subst\">$&#123;ASSETCATALOG_COMPILER_APPICON_NAME&#125;</span>&quot; --output-partial-info-plist &quot;<span class=\"subst\">$&#123;BUILD_DIR&#125;</span>/assetcatalog_generated_info.plist&quot;&#x27;</span></span><br><span class=\"line\">    text = File.read(copy_pods_resources_path)</span><br><span class=\"line\">    <span class=\"keyword\">new</span><span class=\"type\">_contents</span> = text.gsub(string_to_replace, assets_compile_with_app_icon_arguments)</span><br><span class=\"line\">    File.open(copy_pods_resources_path, <span class=\"string\">&quot;w&quot;</span>) &#123;|file| file.puts <span class=\"keyword\">new</span><span class=\"type\">_contents</span> &#125;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure></p>\n<p>像这样：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mx84vaxj30yg07f42t.jpg\" alt=\"image.png\" /></p>\n",
            "tags": [
                "xcode",
                "cocoapods",
                "podfile"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-23-IOS%E4%B8%8B%E4%B8%89%E7%A7%8DDNS%E8%A7%A3%E6%9E%90%E6%96%B9%E5%BC%8F%E5%88%86%E6%9E%90%EF%BC%88LocalDns%EF%BC%89/",
            "url": "https://oliverqueen.cn/2018-01-23-IOS%E4%B8%8B%E4%B8%89%E7%A7%8DDNS%E8%A7%A3%E6%9E%90%E6%96%B9%E5%BC%8F%E5%88%86%E6%9E%90%EF%BC%88LocalDns%EF%BC%89/",
            "title": "IOS下三种DNS解析方式分析（LocalDns）",
            "date_published": "2018-01-23T10:02:29.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景</h3>\n<p>最近在做 iOS 的 DNS 解析，顺便研究了下 iOS 端本地的 DNS 解析方式（localDNS）, 也就是不依赖 Http 请求，而是用原始的 API 进行解析，虽然有 HttpDNS 但是考虑到成本、第三方服务稳定性的问题，LocalDNS 仍然是一个很重要的部分，在 iOS 系统下，localDNS 的解析方式有三种，下面主要对三种方式进行下利弊分析及简单的原理介绍。</p>\n<h3 id=\"方式一\"><a class=\"anchor\" href=\"#方式一\">#</a> 方式一</h3>\n<p>这个也是我一开始在项目中使用的方式。<br />\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>：<span class=\"keyword\">struct</span> <span class=\"title class_\">hostent</span>\t*<span class=\"built_in\">gethostbyname</span>(<span class=\"type\">const</span> <span class=\"type\">char</span> *);</span><br><span class=\"line\"><span class=\"number\">2</span>：<span class=\"keyword\">struct</span> <span class=\"title class_\">hostent</span>\t*<span class=\"built_in\">gethostbyname2</span>(<span class=\"type\">const</span> <span class=\"type\">char</span> *, <span class=\"type\">int</span>);</span><br></pre></td></tr></table></figure><br />\n 两个函数作用完全一样，返回值一样，但是第一个只能用于 IPV4 的网络环境，而第二个则 IPV4 和 IPV6 都可使用，可以通过第二个参数传入当前的网络环境。<br />\n<!---more---></p>\n<h6 id=\"使用方式\"><a class=\"anchor\" href=\"#使用方式\">#</a> 使用方式：</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CFAbsoluteTime</span> start = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"type\">char</span>   *ptr, **pptr;</span><br><span class=\"line\">   <span class=\"keyword\">struct</span> hostent *hptr;</span><br><span class=\"line\">   <span class=\"type\">char</span>   str[<span class=\"number\">32</span>];</span><br><span class=\"line\">   ptr = <span class=\"string\">&quot;www.meitu.com&quot;</span>;</span><br><span class=\"line\">   <span class=\"built_in\">NSMutableArray</span> * ips = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>((hptr = gethostbyname(ptr)) == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span>(pptr=hptr-&gt;h_addr_list; *pptr!=<span class=\"literal\">NULL</span>; pptr++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> * ipStr = [<span class=\"built_in\">NSString</span> stringWithCString:inet_ntop(hptr-&gt;h_addrtype, *pptr, str, <span class=\"keyword\">sizeof</span>(str)) encoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\">        [ips addObject:ipStr?:<span class=\"string\">@&quot;&quot;</span>];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">CFAbsoluteTime</span> end = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;22222 === ip === %@ === time cost: %0.3fs&quot;</span>, ips,end - start);</span><br></pre></td></tr></table></figure></p>\n<p>使用 gethostbyname 方法后会得到一个 struct, 也就是上文的 struct hostent *hptr：<br />\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hostent</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span>\t*h_name;\t<span class=\"comment\">/* official name of host */</span></span><br><span class=\"line\">\t<span class=\"type\">char</span>\t**h_aliases;\t<span class=\"comment\">/* alias list */</span></span><br><span class=\"line\">\t<span class=\"type\">int</span>\th_addrtype;\t<span class=\"comment\">/* host address type */</span></span><br><span class=\"line\">\t<span class=\"type\">int</span>\th_length;\t<span class=\"comment\">/* length of address */</span></span><br><span class=\"line\">\t<span class=\"type\">char</span>\t**h_addr_list;\t<span class=\"comment\">/* list of addresses from name server */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\th_addr\th_addr_list[0]\t<span class=\"comment\">/* address, for backward compatibility */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">/* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */</span></span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"参数解析\"><a class=\"anchor\" href=\"#参数解析\">#</a> 参数解析：</h6>\n<ul>\n<li>\n<p>hostent-&gt;h_name<br />\n 表示的是主机的规范名。<span class=\"exturl\" data-url=\"aHR0cDovL3huLS13d3ctdWMwZXA5NmIuYmFpZHUueG4tLWNvbXd3dy1rcDJqNzRvZXN1NDJ5NjAzYjJsNWFnbXMuYS5zaGlmZW4uY29t\">例如 www.baidu.com 的规范名其实是 www.a.shifen.com</span>。</p>\n</li>\n<li>\n<p>hostent-&gt;h_aliases<br />\n 表示的是主机的别名 www.baidu.com 的别名就是他自己。有的时候，有的主机可能有好几个别名，这些，其实都是为了易于用户记忆而为自己的网站多取的名字。</p>\n</li>\n<li>\n<p>hostent-&gt;h_addrtype<br />\n 表示的是主机 ip 地址的类型，到底是 ipv4 (AF_INET)，还是 pv6 (AF_INET6)</p>\n</li>\n<li>\n<p>hostent-&gt;h_length<br />\n 表示的是主机 ip 地址的长度</p>\n</li>\n<li>\n<p>hostent-&gt;h_addr_lisst<br />\n 表示的是主机的 ip 地址，注意，这个是以网络字节序存储的。不要直接用 printf 带 % s 参数来打这个东西，会有问题的哇。所以到真正需要打印出这个 IP 的话，需要调用 <code>const char *inet_ntop(int af, const void *src, char *dst, socklen_t cnt) </code> ，来把它转成 char。详细使用见上文</p>\n</li>\n</ul>\n<h6 id=\"缺点\"><a class=\"anchor\" href=\"#缺点\">#</a> 缺点：</h6>\n<ul>\n<li>\n<p>在进行网络切换的时候小概率卡死，自测十次有一两次左右。</p>\n</li>\n<li>\n<p>在本地的 LocalDns 被破坏的时候会必卡死 30 秒，然后返回 nil 。</p>\n</li>\n<li>\n<p>缓存是个玄学东西，他会对自己解析出来的 IP 进行缓存（可能是运营商缓存）缓存时间不确定，有可能我即使切换了无数个网络，但是从早到晚同一个域名总是解析出同样的 IP，</p>\n</li>\n<li>\n<p>网上说的比较多的问题</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6myoq10ej30po01w0tb.jpg\" alt=\"image.png\" /></p>\n</li>\n</ul>\n<h3 id=\"方式二\"><a class=\"anchor\" href=\"#方式二\">#</a> 方式二</h3>\n<p>除了经常用到的 gethostbyname (3) 和 gethostbyaddr (3) 函数以外，Linux (以及其它 UNIX/UNIX-like 系统) 还提供了一套用于在底层处理 DNS 相关问题的函数 (这里所说的底层仅是相对 gethostbyname 和 gethostbyaddr 两个函数而言). 这套函数被称为地址解析函数 (resolver functions)。曾经尝试过这个方式...<br />\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span>\t\tres_query <span class=\"constructor\">__P((<span class=\"params\">const</span> <span class=\"params\">char</span> <span class=\"operator\">*</span>, <span class=\"params\">int</span>, <span class=\"params\">int</span>, <span class=\"params\">u_char</span> <span class=\"operator\">*</span>, <span class=\"params\">int</span>)</span>);</span><br><span class=\"line\">函数原型为：</span><br><span class=\"line\"><span class=\"built_in\">int</span> res<span class=\"constructor\">_query(<span class=\"params\">const</span> <span class=\"params\">char</span> <span class=\"operator\">*</span><span class=\"params\">dname</span>, <span class=\"params\">int</span> <span class=\"params\">class</span>, <span class=\"params\">int</span> <span class=\"params\">type</span>, <span class=\"params\">unsigned</span> <span class=\"params\">char</span> <span class=\"operator\">*</span><span class=\"params\">answer</span>, <span class=\"params\">int</span> <span class=\"params\">anslen</span>)</span></span><br></pre></td></tr></table></figure><br />\n 这个方式需要在项目中添加 <code>libresolv.tbd</code>  库，因为要依赖于库中的函数去解析。 <code>res_query</code>  用来发出一个指定类 (由参数 class 指定) 和类型 (由参数 type 指定) 的 DNS 询问. dname 是要查询的主机名。返回信息被存储在 answser 指向的内存区域中。信息的长度不能大于 anslen 个字节。这个函数会创建一个 DNS 查询报文并把它发送到指定的 DNS 服务器。</p>\n<h6 id=\"使用方式-2\"><a class=\"anchor\" href=\"#使用方式-2\">#</a> 使用方式</h6>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CFAbsoluteTime start = <span class=\"constructor\">CFAbsoluteTimeGetCurrent()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    unsigned <span class=\"built_in\">char</span> auResult<span class=\"literal\">[<span class=\"number\">512</span>]</span>;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> nBytesRead = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    nBytesRead = res<span class=\"constructor\">_query(<span class=\"string\">&quot;www.meitu.com&quot;</span>, <span class=\"params\">ns_c_in</span>, <span class=\"params\">ns_t_a</span>, <span class=\"params\">auResult</span>, <span class=\"params\">sizeof</span>(<span class=\"params\">auResult</span>)</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ns_msg handle;</span><br><span class=\"line\">    ns<span class=\"constructor\">_initparse(<span class=\"params\">auResult</span>, <span class=\"params\">nBytesRead</span>, &amp;<span class=\"params\">handle</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSMutableArray *ipList = nil;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> msg_count = ns<span class=\"constructor\">_msg_count(<span class=\"params\">handle</span>, <span class=\"params\">ns_s_an</span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg_count &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ipList = <span class=\"literal\">[[NSM<span class=\"identifier\">utableArray</span> <span class=\"identifier\">alloc</span>]</span> initWithCapacity:msg_count];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> rrnum = <span class=\"number\">0</span>; rrnum &lt; msg_count; rrnum++) &#123;</span><br><span class=\"line\">            ns_rr rr;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ns<span class=\"constructor\">_parserr(&amp;<span class=\"params\">handle</span>, <span class=\"params\">ns_s_an</span>, <span class=\"params\">rrnum</span>, &amp;<span class=\"params\">rr</span>)</span><span class=\"operator\"> == </span><span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">char</span> ip1<span class=\"literal\">[<span class=\"number\">16</span>]</span>;</span><br><span class=\"line\">                strcpy(ip1, inet<span class=\"constructor\">_ntoa(<span class=\"operator\">*</span>(<span class=\"params\">struct</span> <span class=\"params\">in_addr</span> <span class=\"operator\">*</span>)</span>ns<span class=\"constructor\">_rr_rdata(<span class=\"params\">rr</span>)</span>));</span><br><span class=\"line\">                NSString *ipString = <span class=\"literal\">[[NSS<span class=\"identifier\">tring</span> <span class=\"identifier\">alloc</span>]</span> initWithCString:ip1 encoding:NSASCIIStringEncoding];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!<span class=\"literal\">[<span class=\"identifier\">ipString</span> <span class=\"identifier\">isEqualToString</span>:@&quot;&quot;]</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">//将提取到的IP地址放到数组中</span></span><br><span class=\"line\">                    <span class=\"literal\">[<span class=\"identifier\">ipList</span> <span class=\"identifier\">addObject</span>:<span class=\"identifier\">ipString</span>]</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        CFAbsoluteTime <span class=\"keyword\">end</span> = <span class=\"constructor\">CFAbsoluteTimeGetCurrent()</span>;</span><br><span class=\"line\">        <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;11111 === ip === %@ === time cost: %0.3fs&quot;</span>, <span class=\"params\">ipList</span>,<span class=\"params\">end</span> - <span class=\"params\">start</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"参数解析-2\"><a class=\"anchor\" href=\"#参数解析-2\">#</a> 参数解析</h6>\n<p>由于该逻辑是 Linux 底层提供的代码，苹果用宏做了一次封装，具体的函数含义还需要对 Linux 内核的理解，这里放一篇<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcmVuaGFvL2FyY2hpdmUvMjAxMS8xMS8xNC8yMjQ4NTI4Lmh0bWw=\">参考资料</span></p>\n<h6 id=\"优点\"><a class=\"anchor\" href=\"#优点\">#</a> 优点：</h6>\n<ul>\n<li>在 LocalDns 被破坏掉的情况下能及时响应不会延迟。</li>\n<li>没有缓存，缓存由开发者控制</li>\n</ul>\n<h6 id=\"缺点-2\"><a class=\"anchor\" href=\"#缺点-2\">#</a> 缺点</h6>\n<ul>\n<li>在进行网络切换时候 3G/4G 切 wify 高概率出现卡死<br />\n这一个缺点是比较致命的，所以没有再继续使用。</li>\n</ul>\n<h3 id=\"方式三\"><a class=\"anchor\" href=\"#方式三\">#</a> 方式三</h3>\n<p>苹果原生的 DNS 解析</p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Boolean <span class=\"built_in\">CFHostStartInfoResolution</span> (<span class=\"built_in\">CFHostRef</span> theHost, <span class=\"built_in\">CFHostInfoType</span> info, <span class=\"built_in\">CFStreamError</span> *error);</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"使用方法\"><a class=\"anchor\" href=\"#使用方法\">#</a> 使用方法：</h6>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Boolean result,bResolved;</span><br><span class=\"line\">CFHostRef hostRef;</span><br><span class=\"line\">CFArrayRef addresses = NULL;</span><br><span class=\"line\">NSMutableArray<span class=\"operator\"> * </span>ipsArr = <span class=\"literal\">[[NSM<span class=\"identifier\">utableArray</span> <span class=\"identifier\">alloc</span>]</span> init];</span><br><span class=\"line\"></span><br><span class=\"line\">CFStringRef hostNameRef = <span class=\"constructor\">CFStringCreateWithCString(<span class=\"params\">kCFAllocatorDefault</span>, <span class=\"string\">&quot;www.meitu.com&quot;</span>, <span class=\"params\">kCFStringEncodingASCII</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">hostRef = <span class=\"constructor\">CFHostCreateWithName(<span class=\"params\">kCFAllocatorDefault</span>, <span class=\"params\">hostNameRef</span>)</span>;</span><br><span class=\"line\">CFAbsoluteTime start = <span class=\"constructor\">CFAbsoluteTimeGetCurrent()</span>;</span><br><span class=\"line\">result = <span class=\"constructor\">CFHostStartInfoResolution(<span class=\"params\">hostRef</span>, <span class=\"params\">kCFHostAddresses</span>, NULL)</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (result<span class=\"operator\"> == </span>TRUE) &#123;</span><br><span class=\"line\">    addresses = <span class=\"constructor\">CFHostGetAddressing(<span class=\"params\">hostRef</span>, &amp;<span class=\"params\">result</span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bResolved = result<span class=\"operator\"> == </span>TRUE ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(bResolved)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> sockaddr_in* remoteAddr;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"constructor\">CFArrayGetCount(<span class=\"params\">addresses</span>)</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        CFDataRef saData = (CFDataRef)<span class=\"constructor\">CFArrayGetValueAtIndex(<span class=\"params\">addresses</span>, <span class=\"params\">i</span>)</span>;</span><br><span class=\"line\">        remoteAddr = (<span class=\"keyword\">struct</span> sockaddr_in*)<span class=\"constructor\">CFDataGetBytePtr(<span class=\"params\">saData</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(remoteAddr != NULL)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取IP地址</span></span><br><span class=\"line\">            <span class=\"built_in\">char</span> ip<span class=\"literal\">[<span class=\"number\">16</span>]</span>;</span><br><span class=\"line\">            strcpy(ip, inet<span class=\"constructor\">_ntoa(<span class=\"params\">remoteAddr</span>-&gt;<span class=\"params\">sin_addr</span>)</span>);</span><br><span class=\"line\">            NSString<span class=\"operator\"> * </span>ipStr = <span class=\"literal\">[NSS<span class=\"identifier\">tring</span> <span class=\"identifier\">stringWithCString</span>:<span class=\"identifier\">ip</span> <span class=\"identifier\">encoding</span>:NSUTF8S<span class=\"identifier\">tringEncoding</span>]</span>;</span><br><span class=\"line\">            <span class=\"literal\">[<span class=\"identifier\">ipsArr</span> <span class=\"identifier\">addObject</span>:<span class=\"identifier\">ipStr</span>]</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">CFAbsoluteTime <span class=\"keyword\">end</span> = <span class=\"constructor\">CFAbsoluteTimeGetCurrent()</span>;</span><br><span class=\"line\"><span class=\"constructor\">NSLog(@<span class=\"string\">&quot;33333 === ip === %@ === time cost: %0.3fs&quot;</span>, <span class=\"params\">ipsArr</span>,<span class=\"params\">end</span> - <span class=\"params\">start</span>)</span>;</span><br><span class=\"line\"><span class=\"constructor\">CFRelease(<span class=\"params\">hostNameRef</span>)</span>;</span><br><span class=\"line\"><span class=\"constructor\">CFRelease(<span class=\"params\">hostRef</span>)</span>;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"参数解析-3\"><a class=\"anchor\" href=\"#参数解析-3\">#</a> 参数解析：</h6>\n<p><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/<span class=\"emphasis\">*</span></span><br><span class=\"line\"><span class=\"emphasis\"> *</span>  CFHostStartInfoResolution()</span><br><span class=\"line\"><span class=\"bullet\"> *</span>  </span><br><span class=\"line\"> <span class=\"emphasis\">*  Discussion:</span></span><br><span class=\"line\"><span class=\"emphasis\"> *</span>\tPerforms a lookup for the given host.  It will search for the</span><br><span class=\"line\"><span class=\"bullet\"> *</span>\trequested information if there is no other active request.</span><br><span class=\"line\"><span class=\"bullet\"> *</span>\tPreviously cached information of the given type will be released.</span><br><span class=\"line\"><span class=\"bullet\"> *</span>  </span><br><span class=\"line\"> <span class=\"emphasis\">*  Mac OS X threading:</span></span><br><span class=\"line\"><span class=\"emphasis\"> *</span>\tThread safe</span><br><span class=\"line\"><span class=\"bullet\"> *</span>  </span><br><span class=\"line\"> <span class=\"emphasis\">*  Parameters:</span></span><br><span class=\"line\"><span class=\"emphasis\"> *</span></span><br><span class=\"line\"><span class=\"bullet\"> *</span>\ttheHost:  //需要被解决的CFHostRef的对象</span><br><span class=\"line\"><span class=\"bullet\"> *</span>\t  The CFHostRef which should be resolved. Must be non-NULL. If</span><br><span class=\"line\"><span class=\"bullet\"> *</span>\t  this reference is not a valid CFHostRef, the behavior is</span><br><span class=\"line\"><span class=\"bullet\"> *</span>\t  undefined.</span><br><span class=\"line\"><span class=\"bullet\"> *</span></span><br><span class=\"line\"> <span class=\"emphasis\">*\tinfo: 返回值的类型 数组/Data/string..</span></span><br><span class=\"line\"><span class=\"emphasis\"> *</span>\t  The enum representing the type of information to be retrieved.</span><br><span class=\"line\"><span class=\"bullet\"> *</span>\t  If the value is not a valid type, the behavior is undefined.</span><br><span class=\"line\"><span class=\"bullet\"> *</span></span><br><span class=\"line\"> <span class=\"emphasis\">*\terror: 错误</span></span><br><span class=\"line\"><span class=\"emphasis\"> *</span>\t  A reference to a CFStreamError structure which will be filled</span><br><span class=\"line\"><span class=\"bullet\"> *</span>\t  with any error information should an error occur.  May be set</span><br><span class=\"line\"><span class=\"bullet\"> *</span>\t  to NULL if error information is not wanted.</span><br><span class=\"line\"><span class=\"bullet\"> *</span>  </span><br><span class=\"line\"> <span class=\"emphasis\">*  Result: 解析结果成功还是失败</span></span><br><span class=\"line\"><span class=\"emphasis\"> *</span>\tReturns TRUE on success and FALSE on failure.  In asynchronous</span><br><span class=\"line\"><span class=\"bullet\"> *</span>\tmode, this function will return immediately.  In synchronous</span><br><span class=\"line\"><span class=\"bullet\"> *</span>\tmode, it will block until the resolve has completed or until the</span><br><span class=\"line\"><span class=\"bullet\"> *</span>\tresolve is cancelled.</span><br><span class=\"line\"><span class=\"bullet\"> *</span>  </span><br><span class=\"line\"> <span class=\"emphasis\">*/</span></span><br><span class=\"line\"><span class=\"emphasis\">CFN_EXPORT <span class=\"strong\">__nullable CFArrayRef</span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">CFHostGetAddressing(CFHostRef theHost, Boolean * __</span>nullable hasBeenResolved) CF_AVAILABLE(10_3, 2_0);</span></span><br></pre></td></tr></table></figure></p>\n<h6 id=\"优点-2\"><a class=\"anchor\" href=\"#优点-2\">#</a> 优点：</h6>\n<ul>\n<li>在网络切换时候不会卡顿。</li>\n</ul>\n<h6 id=\"缺点-3\"><a class=\"anchor\" href=\"#缺点-3\">#</a> 缺点：</h6>\n<ul>\n<li>在本地 DNS 被破坏的情况下会出现卡死的现象 (卡 30s)</li>\n</ul>\n<h3 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结：</h3>\n<p>以上三个方法除了第二个方法会在网络切换时候卡死不可用之外，其他两个方法都是可选择的，关于那个本地 LocalDns 破坏会卡死的问题看来是无法避免，不过开发者可以自行通过 ping 等方式来判断 LocalDns 的正确性，在被破坏的情况下使用 httpDns 来进行解析即可。具体的 demo 可以到<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3poYW5nbmluZ2hhby9Mb2NhbERucw==\">这里</span>查看</p>\n",
            "tags": [
                "DNS解析",
                "LocalDNS"
            ]
        },
        {
            "id": "https://oliverqueen.cn/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%F0%9F%98%8A/",
            "url": "https://oliverqueen.cn/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%F0%9F%98%8A/",
            "title": "位运算的简单理解😊",
            "date_published": "2018-01-19T06:20:39.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"1背景\"><a class=\"anchor\" href=\"#1背景\">#</a> 1：背景</h2>\n<p>从现代计算机中所有的数据二进制的形式存储在设备中。即 0、1 两种状态，计算机对二进制数据进行的运算 (+、-、*、/) 都是叫位运算，即将符号位共同参与运算的运算。</p>\n<p>我们每一种语言最终都会通过编译器转换成机器语言来执行，所以直接使用底层的语言就不需要便编译器的转换工作从而得到更高的执行效率，当然可读性可能会降低，这也是为什么汇编在大部分情况下有更快的速度。项目中合理的运用位运算能提高我们代码的执行效率。</p>\n<p>在 iOS 系统中位运算多见于枚举中，其他地方很少见，因为位运算是底层的计算机语言，而在 iOS 开发中不管是 Objective—C 还是 Swift 都属于高级的编程语言，大量的位运算都被苹果封装了起来，我们只关心调用的接口不用关心内部的实现。</p>\n<p><figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_OPTIONS</span>(<span class=\"type\">NSUInteger</span>, <span class=\"type\">NSLayoutFormatOptions</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllLeft</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeLeft</span>),</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllRight</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeRight</span>),</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllTop</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeTop</span>),</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllBottom</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeBottom</span>),</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllLeading</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeLeading</span>),</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllTrailing</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeTrailing</span>),</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br />\n<span id=\"more\"></span></p>\n<h2 id=\"10计算机计算原理\"><a class=\"anchor\" href=\"#10计算机计算原理\">#</a> 10：计算机计算原理</h2>\n<h4 id=\"加法和乘法\"><a class=\"anchor\" href=\"#加法和乘法\">#</a> 加法和乘法</h4>\n<p>举一个简单的例子来看下 CPU 是如何进行计算的，比如这行代码</p>\n<p><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">int a</span> = 35;</span><br><span class=\"line\"><span class=\"attribute\">int b</span> = 47;</span><br><span class=\"line\"><span class=\"attribute\">int c</span> = a + b;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 计算两个数的和，因为在计算机中都是以二进制来进行运算，所以上面我们所给的 int 变量会在机器内部先转换为二进制在进行相加</p>\n<p><figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">35: <span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>0<span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>1</span><br><span class=\"line\">47: <span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>0<span class=\"number\"> 1 </span>1<span class=\"number\"> 1 </span>1</span><br><span class=\"line\">————————————————————</span><br><span class=\"line\">82: <span class=\"number\"> 0 </span>1<span class=\"number\"> 0 </span>1<span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>0</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>再来看下乘法，执行如下的代码</p>\n<p><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a = 3;</span><br><span class=\"line\">int b = 2;</span><br><span class=\"line\">int c = a <span class=\"emphasis\">* b;</span></span><br><span class=\"line\"><span class=\"emphasis\"></span></span><br><span class=\"line\"><span class=\"emphasis\">3:  0 0 0 0 0 0 1 1  *</span>  2</span><br><span class=\"line\">————————————————————</span><br><span class=\"line\">6:  0 0 0 0 0 1 1 0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"emphasis\">*</span></span><br><span class=\"line\"><span class=\"emphasis\"></span></span><br><span class=\"line\"><span class=\"emphasis\">int a = 3;</span></span><br><span class=\"line\"><span class=\"emphasis\">int b = 4;</span></span><br><span class=\"line\"><span class=\"emphasis\">int c = a *</span> b;</span><br><span class=\"line\"></span><br><span class=\"line\">3:  0 0 0 0 0 0 1 1  <span class=\"emphasis\">*  4</span></span><br><span class=\"line\"><span class=\"emphasis\">————————————————————</span></span><br><span class=\"line\"><span class=\"emphasis\">12:  0 0 0 0 1 1 0 0</span></span><br><span class=\"line\"><span class=\"emphasis\"></span></span><br><span class=\"line\"><span class=\"emphasis\"><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span>*</span></span><br><span class=\"line\"></span><br><span class=\"line\">int a = 3;</span><br><span class=\"line\">int b = 8;</span><br><span class=\"line\">int c = a <span class=\"emphasis\">* b;</span></span><br><span class=\"line\"><span class=\"emphasis\"></span></span><br><span class=\"line\"><span class=\"emphasis\">3:  0 0 0 0 0 0 1 1  *</span>  8</span><br><span class=\"line\">————————————————————</span><br><span class=\"line\">24:  0 0 0 1 1 0 0 0</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 通过以上运算可以看出当用 a 乘 b，且如果 b 满足 2^N 的时候 就相当于把 a 的二进制数据向左移动 N 位，放到代码中 我们可以这样来写 <strong>a &lt;&lt; N</strong>, 所以上面<strong> 3 * 2、3 * 4、3 * 8</strong> 其实是可以写成<strong> 3&lt;&lt;1、3&lt;&lt;2、3&lt;&lt;3</strong>，运算结果都是一样的。</p>\n<p>那假如相乘的两个数都不满足 2<sup>N 怎么办呢？其实这个时候编译器会将其中一个数拆分成多个满足 2</sup>N 的数相加的情况，打个比方</p>\n<p><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> a = <span class=\"number\">15</span>;\t\t\t\t<span class=\"built_in\">int</span> a = <span class=\"number\">15</span></span><br><span class=\"line\"><span class=\"built_in\">int</span> b = <span class=\"number\">13</span>;      =&gt;    \t<span class=\"built_in\">int</span> b = (<span class=\"number\">4</span> + <span class=\"number\">8</span> + <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"built_in\">int</span> c = a * b;\t\t\t<span class=\"built_in\">int</span> c = a * b</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 最后其实执行相乘运算就会变成这样 <strong>15 * 4 + 15 * 8 + 15 * 1</strong>，按照上文说的移位来转换为位运算就会变成<strong> 15 &lt;&lt; 2 + 15 &lt;&lt; 3 + 15 &lt;&lt; 0</strong></p>\n<h4 id=\"减法和除法\"><a class=\"anchor\" href=\"#减法和除法\">#</a> 减法和除法</h4>\n<p>减法也是与加法同理只不过计算机内减法操作就是加上一个数的负数形式，且在操作系统中都是以补码的形式进行操作 (因为正数的源码补码反码都与本身相同)。首先，因为人脑可以知道第一位是符号位，在计算的时候我们会根据符号位，选择对真值区域的加减。但是对于计算机，加减乘数已经是最基础的运算，要设计的尽量简单。计算机辨别 &quot;符号位&quot; 显然会让计算机的基础电路设计变得十分复杂！于是人们想出了将符号位也参与运算的方法。我们知道，根据运算法则减去一个正数等于加上一个负数，即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法，这样计算机运算的设计就更简单了.</p>\n<p>除法的话其实和乘法原理相同，不过乘法是左移而除法是右移，但是除法的计算量要比乘法大得多，其大部分的消耗都在拆分数值，和处理小数的步骤上，所以如果我们在进行生成变量的时候如果遇到多位的小数我们尽量把他换成 string 的形式，这也是为什么浮点运算会消耗大量的时钟周期 (操作系统中每进行一个移位或者加法运算的过程所消耗的时间就是一个时钟周期，3.0GHz 频率的 CPU 可以在一秒执行运算 3.0<em>1024</em>1024*1024 个时钟周期)</p>\n<h2 id=\"11位运算符\"><a class=\"anchor\" href=\"#11位运算符\">#</a> 11：位运算符</h2>\n<p>使用的运算符包括下面：</p>\n<table>\n<thead>\n<tr>\n<th>含义</th>\n<th>运算符</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>左移</td>\n<td>&lt;&lt;</td>\n<td>0011  =&gt;  0110</td>\n</tr>\n<tr>\n<td>右移</td>\n<td>&gt;&gt;</td>\n<td>0110  =&gt;  0011</td>\n</tr>\n<tr>\n<td>按位或</td>\n<td>︳</td>\n<td>0011 &lt;br&gt; -------  =&gt; 1011&lt;br&gt;1011</td>\n</tr>\n<tr>\n<td>按位与</td>\n<td>&amp;</td>\n<td>0011 &lt;br&gt; -------  =&gt; 1011&lt;br&gt;1011</td>\n</tr>\n<tr>\n<td>按位取反</td>\n<td>~</td>\n<td>0011  =&gt; 1100</td>\n</tr>\n<tr>\n<td>按位异或 (相同为零不同为一)</td>\n<td>^</td>\n<td>0011 &lt;br&gt; -------  =&gt; 1000&lt;br&gt;1011</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"100颜色转换\"><a class=\"anchor\" href=\"#100颜色转换\">#</a> 100：颜色转换</h2>\n<h4 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景</h4>\n<p>上面说了 iOS 中经常见到的位运算的地方是在枚举中，那么颜色转换应该是除了枚举之外第二比较常用位运算的场景。打个比方设计师再给我们出设计稿的时候通常会在设计稿上按照 16 进制的样子给我们标色值。但是 iOS 中的 UIColor 并不支持使用十六进制的数据来初始化。所以我们需要将十六进制的色值转换为 UIColor。</p>\n<h4 id=\"原理分析\"><a class=\"anchor\" href=\"#原理分析\">#</a> 原理分析</h4>\n<p>UIColor 中通常是用传入 RGB 的数值来初始化，而且每个颜色的取值范围是十进制下的 0~255，而设计同学又给的是十六进制数据，所以在操作系统中需要把这两种进制的数据统一成二进制来进行计算，这就用到了位运算。这里用一个十六进制的色值来举例子比如<strong> 0xffa131</strong> 我们要转换就要先理解其组成</p>\n<ul>\n<li>\n<p>0x 或者 0X：十六进制的标识符，表示这个后面是个十六进制的数值，对数值本身没有任何意义</p>\n</li>\n<li>\n<p>ff 颜色中的 R 值，转换为二进制为 1111 1111</p>\n</li>\n<li>\n<p>a1 颜色中的 G 值，转换为二进制为 1010 0001</p>\n</li>\n<li>\n<p>31 颜色中的 B 值，转换为二进制为 0011 0001</p>\n</li>\n<li>\n<p>上述色彩值转换为二进制后为<strong> 1111 1111 1010 0001 0011 0001 (每一位十六进制的对应 4 位二进制，如果位数不够记得高位补零)</strong></p>\n</li>\n</ul>\n<p>通常来讲十六进制的颜色是按照上面的 RGB 的顺序排列的，但是并不固定，有时候可能会在其中加 A (Alpha) 值，具体情况按照设计为准，本文以通用情况举例。</p>\n<p>综上，我们只需把对应位的值转换为 10 进制然后 / 255.0f 就可得到 RGB 色彩值，从而转换为 UIColor</p>\n<h4 id=\"转换代码\"><a class=\"anchor\" href=\"#转换代码\">#</a> 转换代码</h4>\n<p>先列出代码，后续解析</p>\n<p><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (UIColor *)colorWithHex:(<span class=\"type\">long</span>)hexColor <span class=\"built_in\">alpha</span>:(<span class=\"type\">float</span>)opacity</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//将传入的十六进制颜色0xffa131 转换为UIColor</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">float</span> <span class=\"built_in\">red</span> = ((hexColor &amp; <span class=\"number\">0xFF0000</span>) &gt;&gt; <span class=\"number\">16</span>)/<span class=\"number\">255.0</span>f;</span><br><span class=\"line\">    <span class=\"type\">float</span> <span class=\"built_in\">green</span> = ((hexColor &amp; <span class=\"number\">0xFF00</span>) &gt;&gt; <span class=\"number\">8</span>)/<span class=\"number\">255.0</span>f;</span><br><span class=\"line\">    <span class=\"type\">float</span> <span class=\"built_in\">blue</span> = (hexColor &amp; <span class=\"number\">0xFF</span>)/<span class=\"number\">255.0</span>f;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [UIColor colorWithRed:<span class=\"built_in\">red</span> <span class=\"built_in\">green</span>:<span class=\"built_in\">green</span> <span class=\"built_in\">blue</span>:<span class=\"built_in\">blue</span> <span class=\"built_in\">alpha</span>:opacity];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 大概原理可以看出将 RGB 每个值都解析出来然后变成 UIColor，先拿第一步转换红色值来说，我们按照运算顺序一步步来讲 (默认将参数代入，用 0xffa131 代替 hexColor)</p>\n<ul>\n<li>\n<p><strong>0xffa131 &amp; 0xFF0000</strong></p>\n<p>我们知道红色值是前两位也就是<strong> ff</strong>，所以这一步我们既然要取出红色值就要把其他位全部置零来排除干扰，这步操作便是如此，在计算机系统内是二进制来实现的，即：&lt;br&gt;<br />\n1111 1111 1010 0001 0011 0001&lt;br&gt;-------------------------------------------  =&gt; &amp; =&gt; 1111 1111 0000 0000 0000&lt;br&gt;<br />\n1111 1111 0000 0000 0000 0000&lt;br&gt; 这部操作做完后可以看出将除了 R 值之外的 G 值 B 值全部置零了，但是离最终结果还差点，因为 0xFF 是 1111 1111，而我们的结果后面多出了 16 个 0，所以便有了第二步操作</p>\n</li>\n<li>\n<p><strong>&gt;&gt; 16</strong></p>\n<p>将上一步得到的结果右移 16 位即得到<strong> 0000 0000 0000 0000 1111 1111</strong> 高位的零可以忽略，这也是最终的结果</p>\n</li>\n<li>\n<p><strong>/ 255.0f</strong></p>\n<p>这一步应该都知道 UIColor 中传入的数值范围在 0~1，所以我们要做下转换</p>\n</li>\n<li>\n<p>后续的 G 值和 B 值都是一样的，只是大家注意位数就可以了，<strong>值得注意的是两个二进制数进行位运算一定保证两个数的位数相同，位数不够的那个数高位要用 0 补齐</strong></p>\n</li>\n</ul>\n<h2 id=\"101枚举\"><a class=\"anchor\" href=\"#101枚举\">#</a> 101：枚举</h2>\n<p>关于枚举中使用位运算我们之前也讲过，下面我们自己来写一个枚举 (伪代码)</p>\n<p><figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_OPTIONS</span>(<span class=\"type\">NSUInteger</span>, <span class=\"type\">TestOptions</span>) &#123;</span><br><span class=\"line\">     <span class=\"type\">TestOptionOne</span>     =    1 &lt;&lt; 0, （000001)</span><br><span class=\"line\"></span><br><span class=\"line\">  \t <span class=\"type\">TestOptionTwo</span>     =    1 &lt;&lt; 1,\t(000010)</span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"type\">TestOptionThree</span>   =    1 &lt;&lt; 2,\t(000100)</span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"type\">TestOptionFour</span>    =    1 &lt;&lt; 3,\t(001000)</span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"type\">TestOptionFive</span>    =    1 &lt;&lt; 4,\t(010000)</span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"type\">TestOptionSix</span>     =    1 &lt;&lt; 5,\t(100000)</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>解析<br />\n上面的枚举我后面用括号表明了位移后对应的二进制的值。这样写枚举的好处是我可以对其中选项多选比如<strong> TestOptionOne | TestOptionTwo （000001 | 000010 =&gt; 000011）</strong> 或者有其他的自定义组合。</li>\n</ul>\n<h2 id=\"110加密\"><a class=\"anchor\" href=\"#110加密\">#</a> 110：加密</h2>\n<p>在 iOS 中我们可以利用异或来进行加解密，异或的特性如下<br />\n <figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A ^ B = <span class=\"function\"><span class=\"params\">C</span> =&gt;</span> C ^ A = <span class=\"function\"><span class=\"params\">B</span> =&gt;</span> C ^ B = A</span><br></pre></td></tr></table></figure><br />\n 上文我们可以把 A 认为是需要加密的数据，B 认为是密钥 C 是加密后的数据<br />\n比如:</p>\n<p><figure class=\"highlight prolog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   char a[]=<span class=\"string\">&quot;MyPassword&quot;</span>;        <span class=\"comment\">/*要加密的密码*/</span></span><br><span class=\"line\">   char b[]=<span class=\"string\">&quot;cryptographic&quot;</span>;     <span class=\"comment\">/*密钥*/</span></span><br><span class=\"line\">   int i;</span><br><span class=\"line\">   <span class=\"comment\">/*加密代码*/</span></span><br><span class=\"line\">   for(i=<span class=\"number\">0</span>;a[i]!=<span class=\"string\">&#x27;\\0&#x27;</span>;i++)</span><br><span class=\"line\">a[i]=a[i]^b[i];</span><br><span class=\"line\">   printf(<span class=\"string\">&quot;You Password encrypted: %s\\n&quot;</span>,a);</span><br><span class=\"line\">   <span class=\"comment\">/*解密代码*/</span></span><br><span class=\"line\">   for(i=<span class=\"number\">0</span>;a[i]!=<span class=\"string\">&#x27;\\0&#x27;</span>;i++)</span><br><span class=\"line\">a[i]=a[i]^b[i];</span><br><span class=\"line\">   printf(<span class=\"string\">&quot;You Password: %s\\n&quot;</span>,a);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"111其他应用\"><a class=\"anchor\" href=\"#111其他应用\">#</a> 111：其他应用</h2>\n<ul>\n<li>记得 iOS 总有一道面试题<strong>在不使用第三个变量的情况下交换两个变量的值</strong>，这里用到异或的上面加解密中的特性。我有 x、y 两个个变量，做如下位运算操作</li>\n</ul>\n<p><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">void</span> exchange(int x , int y)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attribute\">x</span><span class=\"regexp\"> ^=</span> y;</span><br><span class=\"line\">    <span class=\"attribute\">y</span><span class=\"regexp\"> ^=</span> x;</span><br><span class=\"line\">    <span class=\"attribute\">x</span><span class=\"regexp\"> ^=</span> y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>判断一个数的奇偶性，其实我们可以用 **%2** 来判断，代码量不高，但是之前讲过，除法运算的时钟周期非常多，所以代码虽然不多并不代表效率高，我们可以用如下运算来完成:</li>\n</ul>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x&amp;<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;奇数&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;偶数&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 原理很简单，因为二进制是满二进一，一旦超过 1 就会变 0 并进一位，这时候和 00001 做 **&amp;** 操作一定会为 0，反之不为零。这样写效率会更高。</p>\n<ul>\n<li>计算两个数的平均值，通常我们都是（x+y）/2, 先不考虑效率问题，这样还会引起一个其他的问题，那就是 x+y 的值很有可能溢出大于 INT_MAX，所以我们采用位运算的办法来解决即可：</li>\n</ul>\n<p><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">average</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (x&amp;y)+((x^y)&gt;&gt;<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"1000总结\"><a class=\"anchor\" href=\"#1000总结\">#</a> 1000：总结</h2>\n<p>其实位运算的应用远远不止这些，在算法方面适当的使用还是很有帮助的。</p>\n",
            "tags": [
                "算法",
                "C语言",
                "排序"
            ]
        }
    ]
}