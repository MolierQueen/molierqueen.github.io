{
    "version": "https://jsonfeed.org/version/1",
    "title": "Molier • All posts by \"计算机基础\" category",
    "description": "iOS 开发 移动App 博客 杂谈 随笔 相册",
    "home_page_url": "https://oliverqueen.cn",
    "items": [
        {
            "id": "https://oliverqueen.cn/2020-11-28-%E6%B1%87%E7%BC%96%E5%92%8C%E6%A0%88/",
            "url": "https://oliverqueen.cn/2020-11-28-%E6%B1%87%E7%BC%96%E5%92%8C%E6%A0%88/",
            "title": "汇编和栈",
            "date_published": "2020-11-28T08:44:42.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"汇编和栈\"><a class=\"anchor\" href=\"#汇编和栈\">#</a> 汇编和栈</h1>\n<p>当一个函数传递了六个以上的参数时，多余的参数将通过堆栈传递。但是在堆栈上传递到底是什么意思呢？现在该通过深入研究一些 “与堆栈相关的” 寄存器以及堆栈中的内容，来深入探讨从程序集角度调用函数时的情况。当您进行逆向工程程序时，了解堆栈的工作方式非常有用，因为当没有可用的调试符号时，您可以帮助推断出在某个函数中正在操纵哪些参数。在下一单元中，您将使用本章中的知识在 LLDB 中构建命令，该命令将通过在内存中抓取函数来发现一些有趣的事情。让我们开始吧</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkww85fg8yj30u012ob29.jpg\" alt=\"\" /><br />\n<span id=\"more\"></span></p>\n<h2 id=\"让我们重游堆栈\"><a class=\"anchor\" href=\"#让我们重游堆栈\">#</a> 让我们重游堆栈</h2>\n<p>正如先前在第 6 章 “线程，框架和遍历” 中所讨论的，当程序执行时，内存会被布局，因此栈从 “高地址” 开始并向下增长，向着低地址增长；也就是说，朝向堆。</p>\n<blockquote>\n<p>之前说过：栈是从  <code>高地址 -&gt; 低地址</code> ，堆是从  <code>低地址 -&gt; 高地址</code> ，而 Windows 中栈是在堆的下方，所以 Windows 中内存是从  <code>中间向两边分布</code>  。 而 Linux 中 栈是在堆的上面，所以 Linux 中的内存是  <code>从两边向中间分布</code>  。</p>\n</blockquote>\n<p>很迷惑吗？通过下面这个图片你可以看出栈的移动方式。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4nnjpqxej30u00u1n29.jpg\" alt=\"\" /></p>\n<p>栈从高位地址开始。确切地说，它的高度取决于操作系统的内核。内核为每个正在运行的程序（每个线程）提供栈空间。</p>\n<p>栈的大小是有限的，并且随着内存地址空间的向下增长而增加。当栈上的空间用完时，指向栈  <code>“顶部”</code>  的指针从最高地址向下移动到最低地址。</p>\n<p>一旦栈达到内核给定的有限大小，或者如果栈越过了堆的边界，则称栈溢出。这是一个致命错误，通常称为栈溢出。</p>\n<h2 id=\"栈指针和基本指针寄存器\"><a class=\"anchor\" href=\"#栈指针和基本指针寄存器\">#</a> 栈指针和基本指针寄存器</h2>\n<p>您尚未了解的两个非常重要的寄存器是 RSP 和 RBP。栈指针寄存器 RSP 指向特定线程的栈头。栈的顶部将向下生长，因此将项目添加到栈时，RSP 将减少。 RSP 将始终指向栈的头部。下图展示了栈调用时栈指针变化的视觉效果。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4nukmaa7j31u80pidk4.jpg\" alt=\"\" /></p>\n<p>在上图中，堆栈指针的顺序如下：</p>\n<ul>\n<li>\n<p>栈指针当前指向第 3 帧。</p>\n</li>\n<li>\n<p>指令指针寄存器指向的代码调用一个新函数。堆栈指针将更新为指向 Frame 4，该 feame 可能负责指令指针中此新调用函数中的暂存空间和数据。</p>\n</li>\n<li>\n<p>函数的具体执行在第 4 帧中完成，执行完之后指针从第四帧弹出，并继续指向第三帧.</p>\n</li>\n</ul>\n<p>还有一个重要的寄存器是基址指针寄存器（RBP），在执行在方法 / 函数内部时有多种用途，程序使用 RBP 的偏移量来访问局部变量或函数参数。之所以能这样是因为 RBP 在函数序言中的函数开始处被设置为 RSP 寄存器的值。</p>\n<p>有趣的是，基本指针的之前内容在被设置为 RSP 寄存器的值之前就已存储在栈中。这是函数序言中发生的第一件事。由于基本指针已保存到堆栈中并设置为当前堆栈指针，因此只需知道基本指针寄存器中的值即可遍历堆栈。调试器在向您显示堆栈跟踪时会执行此操作。</p>\n<blockquote>\n<p>请注意：某些系统不使用基本指针，而且他们在编译你的程序的时候也不会出现基础指针。 其实他们的逻辑可能是使用了其他的寄存器来当做指针寄存器。 但这意味着调试变得更加困难。</p>\n</blockquote>\n<p>下面这个图片可以帮助解释。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4pfvxkx2j30u00vw12l.jpg\" alt=\"\" /></p>\n<p>当一个函数序言完成设置时，RBP 的内容将指向堆栈帧下面的前一个 RBP</p>\n<blockquote>\n<p>注意：当您通过单击 Xcode 中的帧或使用 LLDB 跳到另一个堆栈帧时，RBP 和 RSP 寄存器都将更改值以对应于新的帧！ 这是可以肯定的，因为函数的局部变量是由 RBP 的偏移量来获取的，如果 RBP 不变，则您将无法向该函数打印局部变量，甚至可能导致程序崩溃。 在探索 RBP 和 RSP 寄存器时，这可能会引起混乱，因此请始终牢记这一点。 您可以通过选择不同的帧并在 LLDB 控制台中键入 cpx $ rbp 或 cpx $ rsp 在 LLDB 中对此进行验证。</p>\n</blockquote>\n<p>那么，为什么这两个寄存器很重要？ 当使用调试信息编译程序时，调试信息将引用基本指针寄存器中的偏移量以获得变量。 这些偏移量被赋予名称，与您在源代码中为变量赋予的名称相同。<br />\n编译并优化程序以进行发布时，将打包打包到二进制文件中的调试信息。 尽管删除了这些变量和参数的引用的名称，但是您仍然可以使用堆栈指针和基指针的偏移量来查找这些引用的存储位置。</p>\n<h2 id=\"堆栈相关的操作码\"><a class=\"anchor\" href=\"#堆栈相关的操作码\">#</a> 堆栈相关的操作码</h2>\n<p>到目前为止，您已经了解了调用约定以及内存的布局方式，但是还没有真正探究许多操作码在 x64 汇编中的实际作用。 现在是时候更详细地介绍几种与堆栈相关的操作码了。</p>\n<h3 id=\"操作码-push\"><a class=\"anchor\" href=\"#操作码-push\">#</a> 操作码  <code>push</code></h3>\n<p>当需要将诸如 int，Objective-C 实例，Swift 类或引用之类的任何内容保存到堆栈时，将使用  <code>push</code>  操作码。 push 递减堆栈指针（请记住，因为堆栈向下增长），然后存储到新 RSP 指针所指向的内存地址里面。</p>\n<p><code>push</code>  指令后，最新推送的值将位于 RSP 指向的地址。 而先前的值应为 RSP 加上最近推送的值的大小 ----- 对于 64 位体系结构，通常为 8 个字节。<br />\n要查看具体示例，请考虑以下操作码：</p>\n<ul>\n<li>push 0x5</li>\n</ul>\n<p>这将使 RSP 递减，然后将值 5 存储在 RSP 指向的内存地址中。 因此，用 C 伪代码：</p>\n<pre><code>RSP = RSP - 0x8 \n*RSP = 0x5\n</code></pre>\n<h3 id=\"操作码-pop\"><a class=\"anchor\" href=\"#操作码-pop\">#</a> 操作码  <code>pop</code></h3>\n<p><code>pop</code>  操作码与  <code>push</code>  操作码完全相反。 pop 从 RSP 寄存器中获取值并将其存储到目的地。 接下来，RSP 递增 0x8，还是那句话 栈是从大到小的增长，所以递增<br />\n以下是  <code>pop</code>  的示例：</p>\n<ul>\n<li>pop rdx</li>\n</ul>\n<p>这将 RSP 寄存器的值存储到 RDX 寄存器中，然后递增 RSP 寄存器。 这是下面的伪代码：</p>\n<pre><code>RDX = *RSP\nRSP = RSP + 0x8\n</code></pre>\n<h3 id=\"操作码-call\"><a class=\"anchor\" href=\"#操作码-call\">#</a> 操作码  <code>call</code></h3>\n<p><code>call</code>  操作码负责执行功能。  <code>call</code>  将在被调用函数完成后将要返回的地址压入； 然后跳转到该函数。<br />\n想象一下内存中位于 0x7fffb34df410 的函数，如下所示：</p>\n<pre><code>0x7fffb34de913 &lt;+227&gt;: call   0x7fffb34df410            \n0x7fffb34de918 &lt;+232&gt;: mov    edx, eax\n</code></pre>\n<p>当执行一条指令时，首先将 RIP 寄存器递增，然后执行该指令。 因此，当执行调用指令时，RIP 寄存器将递增至 0x7fffb34de918，然后执行 0x7fffb34de913 指向的指令。 由于这是一条调用指令，因此将 RIP 寄存器压入堆栈（就像执行了压入一样），然后将 RIP 寄存器设置为值 0x7fffb34df410，即要执行的功能的地址。<br />\n伪代码类似于以下内容：</p>\n<pre><code>RIP = 0x7fffb34de918\nRSP = RSP - 0x8\n*RSP = RIP\nRIP = 0x7fffb34df410\n</code></pre>\n<p>之后，在位置 0x7fffb34df410 处继续。</p>\n<h3 id=\"操作码-ret\"><a class=\"anchor\" href=\"#操作码-ret\">#</a> 操作码  <code>ret</code></h3>\n<p><code>ret</code>  操作码与  <code>call</code>  相反，它从栈顶弹出栈顶值（如果程序集的 push 和 pops 匹配，它将是调用操作码推入的返回地址），然后将 RIP 寄存器设置为此地址。 因此，该操作可以返回到调用该函数的位置。</p>\n<p>现在，您已经对这四个重要的操作码有了基本的了解，是时候看看它们在起作用了。确保所有  <code>push</code>  操作码都与您的  <code>pop</code>  相匹配非常重要，否则堆栈将不同步。 例如，如果没有相应的  <code>pop</code>  消息用于弹出，则当在函数末尾执行  <code>ret</code>  时将弹出错误的值。 该操作将返回到某个随机位置，甚至可能不在程序中的有效位置。幸运的是，编译器将负责同步您的  <code>push</code>  和  <code>pop</code>  操作码。 您只需要在编写自己的程序集时担心这一点。</p>\n<h2 id=\"在一些操作中观察rbp和rsp寄存器\"><a class=\"anchor\" href=\"#在一些操作中观察rbp和rsp寄存器\">#</a> 在一些操作中观察 RBP 和 RSP 寄存器</h2>\n<p>现在，您已经了解了 RBP 和 RSP 寄存器以及操纵堆栈的四个操作码，现在是时候看看它们的作用了。<br />\n在 Registers 应用程序中，存在一个名为 StackWalkthrough（int）的函数。此 C 函数将一个整数作为参数，并用汇编语言编写（AT＆T 汇编语言，记住要能够找到源操作数和目标操作数的正确位置），并且位于 StackWalkthrough.s 中。打开此文件，环顾四周；无需立即了解所有内容。您将在一分钟内了解其工作原理。<br />\n通过桥接标头 Registers-Bridging-Header.h，Swift 可以使用此函数，因此您可以从 Swift 调用以汇编方式编写的此方法。<br />\n现在利用这一点。<br />\n打开 ViewController.swift，并在 viewDidLoad（）下面添加以下内容：</p>\n<pre><code>viewDidLoad():\noverride func awakeFromNib() &#123;\nsuper.awakeFromNib()\nStackWalkthrough(5)\n&#125;\n</code></pre>\n<p>这将给 StackWalkThrough 传入了参数 5。5 仅是一个用于显示堆栈工作方式的值。<br />\n在深入研究 RSP 和 RBP 之前，最好快速了解一下 StackWalkthrough 中发生的事情。在 StackWalkthrough 函数上创建一个符号断点。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4vuu0ylaj31uc0o44d4.jpg\" alt=\"\" /></p>\n<p>构建并运行。Xcode 会在 StackWalkthrough 中中断。一定要通过 source” 查看 StackWalkthrough 函数 (即使它是汇编)。通过源代码查看函数将显示 AT&amp;T 汇编 (因为它是用 AT&amp;T ASM 编写的)。<br />\nXcode 将显示以下程序集:</p>\n<pre><code>push  %rbp       ; Push contents of RBP onto the stack (*RSP = RBP, RSP decreases)\n\nmovq  %rsp, %rbp ; RBP = RSP\nmovq  $0x0, %rdx ; RDX = 0\nmovq  %rdi, %rdx ; RDX = RDI\npush  %rdx       ; Push contents of RDX onto the stack (*RSP = RDX, RSP decreases)\n\nmovq  $0x0, %rdx ; RDX = 0\npop   %rdx       ; Pop top of stack into RDX (RDX = *RSP, RSP increases)\n\npop   %rbp       ; Pop top of stack into RBP (RBP = *RSP, RSP increases)\n\nret              ; Return from function (RIP = *RSP, RSP increases)\n</code></pre>\n<p>上面的输出中已经为您添加了注释来帮助理解发生了什么。通读一遍，如果可以的话，试着理解它。您已经熟悉了 mov 指令，程序集的其余部分由您刚刚了解的与函数相关的操作码组成。<br />\n这个函数接受传入的整型参数 (您还记得，第一个参数是在 RDI 中传入的)，将其存储到 RDX 寄存器中，并将该参数压入堆栈。然后将 RDX 设置为 0x0，然后将从堆栈中  <code>pop</code>  的值存储回 RDX 寄存器。<br />\n请确保您在心里很好地理解这个函数中发生了什么，因为接下来您将研究 LLDB 中的寄存器。<br />\n回到 Xcode 中，在 ViewController.swift 的 awakeFromNib 函数的 StackWalkthrough (5) 行中使用 Xcode 的 GUI 创建一个断点。保留前面的 StackWalkthrough 符号断点，因为在研究寄存器时，您需要在 StackWalkthrough 函数的开始处停止。<br />\n构建和运行并等待 GUI 断点触发。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4weds4k8j31u807m45t.jpg\" alt=\"\" /></p>\n<p>现在通过  <code>Debug\\Debug Workflow\\Always Show Disassembly</code>  菜单让他以汇编形式展示，您将看到很可怕的东西：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4xdujj78j31uc0qw4qp.jpg\" alt=\"\" /></p>\n<p>哇！ 看那个！ 您已经正确进入了  <code>call</code>  操作码指令。 您是否想知道要输入什么功能？</p>\n<p>从这里开始，您将逐步完成每条汇编指令，同时打印出感兴趣的四个寄存器：RBP，RSP，RDI 和 RDX。 为了解决这个问题，在 LLDB 中输入以下内容</p>\n<ul>\n<li>(lldb) command alias dumpreg register read rsp rbp rdi rdx</li>\n</ul>\n<p>这将创建命令 dumpreg，它将 dump 四个感兴趣的寄存器。现在执行 dumpreg:</p>\n<ul>\n<li>(lldb) dumpreg</li>\n</ul>\n<p>然后你将看到一些熟悉的东西</p>\n<pre><code>rsp = 0x00007fff5fbfe820\nrbp = 0x00007fff5fbfe850\nrdi = 0x0000000000000005\nrdx = 0x0040000000000000\n</code></pre>\n<p>在本节中，dumpreg 的输出将覆盖在每个汇编指令上，以准确显示每个指令期间每个寄存器发生的情况。 同样，即使为您提供了这些值，您自己执行和理解这些命令也很重要。<br />\n您的屏幕将类似于以下内容：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4xion6coj31ue0p2qp1.jpg\" alt=\"\" /></p>\n<p>一旦跳入函数调用，请密切注意 RSP 寄存器，因为一旦 RIP 跳到 StackWalkthrough 的开头，它就会发生变化。 如您先前所知，RDI 寄存器将包含第一个参数的值，在这种情况下为 0x5。<br />\n在 LLDB 中，键入以下内容：</p>\n<ul>\n<li>(lldb) si</li>\n</ul>\n<p>这个命令是单步调试的命令，它告诉 LLDB 执行下一条指令，然后暂停调试器。<br />\n现在，您已进入 StackWalkthrough。 对于每一步，再次使用 dumpreg 转储寄存器。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4xm3o2d4j31ue0bwtjq.jpg\" alt=\"\" /></p>\n<p>请注意 RSP 寄存器中的差异。 RSP 指向的值现在将包含前一个函数的返回地址。 对于此特定示例，指向 0x7fff5fbfe758 的 RSP 将包含值 0x100002455-awakeFromNib 中紧随调用之后的地址。<br />\n现在通过 LLDB 进行验证：</p>\n<ul>\n<li>(lldb) x/gx $rsp</li>\n</ul>\n<p>输出将与 awakeFromNib 中调用操作码之后的地址立即匹配。接下来，执行 si，然后执行下一条指令的 dumpreg。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4xomkvtej31ua0bygwn.jpg\" alt=\"\" /></p>\n<p>RBP 的值被压入堆栈。 这意味着以下两个命令将产生相同的输出。 执行两个都进行验证。</p>\n<ul>\n<li>(lldb) x/gx $rsp</li>\n</ul>\n<p>这将查看栈指针寄存器所指向的内存地址。</p>\n<blockquote>\n<p>注意：等等，我只是在没有上下文的情况下向您抛出了一条新命令。 x 命令是内存读取命令的快捷方式。<br />\n/gx 表示以十六进制格式将内存格式化为一个巨大的字（8 个字节，还记得第 11 章 “汇编和内存” 中的术语吗？）。<br />\n奇怪的格式是由于该命令在 gdb 中的常用，您看到此命令语法已移植到 lldb 中，从而使从调试器的转换更加容易。</p>\n</blockquote>\n<p>现在看一下基础指针寄存器的值</p>\n<ul>\n<li>(lldb) p/x $rbp</li>\n</ul>\n<p>接下来让我继续单步调试</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4xsl5iu3j31ua0bqqdy.jpg\" alt=\"\" /></p>\n<p>基础指针被分配给堆栈指针的值。 使用 dumpreg 以及以下 LLDB 命令验证两者的值相同：</p>\n<ul>\n<li>(lldb) p (BOOL)($rbp == $rsp)</li>\n</ul>\n<p>请务必在表达式两边加上括号，否则 LLDB 无法正确解析它。<br />\n再次执行 si 和 dumpreg。 这次看起来像这样：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4xxevkm7j31ue0c4k2g.jpg\" alt=\"\" /></p>\n<p>RDX 寄存器被清零了，我们继续单步调试</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4xy3cd3bj31uc0bwdr1.jpg\" alt=\"\" /></p>\n<p>RDX 被设置为 RDI，你可以用 dumper 继续验证</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4xypwoucj31uc0byn8d.jpg\" alt=\"\" /></p>\n<p>RDX 被推入堆栈。 这意味着堆栈指针已递减，并且 RSP 指向一个值，该值将指向 0x5 的值。 确认下：</p>\n<ul>\n<li>(lldb) p/x $rsp</li>\n</ul>\n<p>这显示了指向 RSP 的当前值。 这意味着什么？</p>\n<ul>\n<li>(lldb) x/gx $rsp</li>\n</ul>\n<p>您将得到 0x5。 再次输入 si 以执行下一条指令：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4y24mnetj31ue0bygwp.jpg\" alt=\"\" /></p>\n<p>RDX 设置为 0x0。 这里没有什么太令人兴奋的，继续前进... 继续前进。 再次输入 si 和 dumpreg：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4y311lvsj31u60byal3.jpg\" alt=\"\" /></p>\n<p>堆栈的顶部 pop 到 RDX 中，您知道最近将其设置为 0x5。 RSP 递增 0x8。 再次输入 si 和 dumpreg：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4y3pxy7lj31uc0bygwo.jpg\" alt=\"\" /></p>\n<p>基本指针从堆栈中 pop，并重新分配回它进入该函数时的原始值。 调用规则指定 RBP 在函数调用之间应保持一致。 也就是说，RBP 离开职能后便无法更改为其他值，所以我们做一个好公民，恢复它的原来的值。</p>\n<p>进入 ret 操作码。 注意即将更改的 RSP 值。 再次输入 si 和 dumpreg：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4y6koug9j31ue0p0kh7.jpg\" alt=\"\" /></p>\n<p>返回地址从堆栈中 pop 并设置为 RIP 寄存器； 您知道这一点，因为您已经回到了调用该函数的位置。 然后，控制会在 awakeFromNib 中恢复，<br />\n哇！ 那很有趣！ 一个简单的功能，但是它说明了堆栈如何通过调用，推入，弹出和退出指令工作。</p>\n<h2 id=\"栈和7个以上的参数\"><a class=\"anchor\" href=\"#栈和7个以上的参数\">#</a> 栈和 7 个以上的参数</h2>\n<p>如第 10 章所述，x86_64 的调用规则将按顺序使用以下寄存器作为函数参数：RDI，RSI，RDX，RCX，R8，R9。 当一个函数需要六个以上的参数时，需要使用堆栈。<br />\n注意：当将大型结构传递给函数时，可能还需要使用堆栈。 每个参数寄存器只能保存 8 个字节（在 64 位体系结构上），因此，如果该结构需要 8 个以上的字节，则也需要在堆栈上传递该结构。 有严格的规则规定他们的调用方式，所有编译器都必须遵守。</p>\n<p>打开 ViewController.swift 并找到名为 executeLotsOfArguments 的函数。 您在第 10 章中使用了此功能来浏览寄存器。 现在，您将再次使用它，以了解如何将参数 7 及其以后的参数传递给该函数。<br />\n将以下代码添加到 viewDidLoad 的末尾：</p>\n<pre><code>_ = self.executeLotsOfArguments(one: 1, two: 2, three: 3,\n                                four: 4, five: 5, six: 6,\n                                seven: 7, eight: 8, nine: 9,\n                                ten: 10)\n</code></pre>\n<p>接下来，使用 Xcode GUI 在刚添加的行上创建一个断点。 生成并运行该应用程序，然后等待该断点出现。 您应该再次看到反汇编视图，但如果没有，请使用 “始终显示反汇编” 选项。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4yd1n45nj31ug0k81j0.jpg\" alt=\"\" /></p>\n<p>正如您在与堆栈相关的操作码一节中了解到的，call 负责函数的执行。因为在 RIP 现在的位置和 viewDidLoad 的结束之间只有一个调用操作码，这意味着这个调用必须负责调用 executeLotsOfArguments<br />\n 但是调用前的其他指令是什么呢？让我们找出答案。<br />\n这些指令根据需要设置堆栈以传递附加参数。你有你通常的 6 个参数被放入适当的寄存器，正如看到的指令在哪里 RIP 现在，从 mov edx, 0x1 开始。<br />\n但是参数 7 和以上需要在堆栈上传递。这可以通过以下说明来完成:</p>\n<pre><code>0x1000013e2 &lt;+178&gt;: mov    qword ptr [rsp], 0x7\n0x1000013ea &lt;+186&gt;: mov    qword ptr [rsp + 0x8], 0x8\n0x1000013f3 &lt;+195&gt;: mov    qword ptr [rsp + 0x10], 0x9\n0x1000013fc &lt;+204&gt;: mov    qword ptr [rsp + 0x18], 0xa\n</code></pre>\n<p>看起来很吓人，我会解释。<br />\n包含 RSP 和可选值的方括号表示取消引用，就像 C 编程中的 * 一样。上面的第一行说 “将 0x7 放入 RSP 指向的内存地址中。” 第二行说 “将 0x8 放入 RSP 所指向的内存地址加 0x8。” 等等。<br />\n这会将值放入堆栈。但是请注意，没有使用 push 指令显式推送这些值，这会减少 RSP 寄存器。这是为什么？</p>\n<p>嗯，如您所知，在调用指令期间，返回地址被压入堆栈。然后，在函数序言中，将基本指针压入堆栈，然后将基本指针设置为堆栈指针。<br />\n您还没有学到的是，编译器实际上会在堆栈上留出 “暂存空间” 的空间。也就是说，编译器根据需要在堆栈上为局部变量分配空间。<br />\n通过在函数序言中查找 sub rsp，VALUE 指令，可以轻松确定是否为堆栈帧分配了额外的暂存空间。例如，单击 viewDidLoad 堆栈框架并滚动到顶部。观察已创建多少暂存空间：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4ykh1ycej31u80nadpm.jpg\" alt=\"\" /></p>\n<p>看看一个变量指向的值…… 它现在肯定不能保持 0x1 的值。为什么一个引用一个看似随机的值？<br />\n 答案是由嵌入到寄存器应用程序的调试构建中的 DWARF 调试信息存储。你可以把这些信息转储到内存中，帮助你了解一个变量在引用什么。LLDB 中输入以下</p>\n<ul>\n<li>(lldb) image dump symfile Registers</li>\n</ul>\n<p>你会得到大量的输出。搜索 (Cmd + F) 单词 “one”; 在搜索的时候加上引号。然后会有如下输出</p>\n<pre><code>Swift.String, type_uid = 0x300000222\n0x7f9b4633a988:     Block&#123;0x300000222&#125;, ranges = [0x1000035e0-0x100003e7f)\n0x7f9b48171a20:       Variable&#123;0x30000023f&#125;, name = &quot;one&quot;, type = &#123;d50e000003000000&#125; 0x00007f9b4828d2a0 (Swift.Int), scope = parameter, decl = ViewController.swift:39, location =  DW_OP_fbreg(-32)\n</code></pre>\n<p>根据输出，名为 execute.Int 的变量位于 executeLotsOfArguments 中，其位置可以在 DW_OP_fbreg（-32）中找到。 这个相当模糊的代码实际上意味着基本指针减去 40，即 RBP-32。或者以十六进制表示，RBP-0x20。</p>\n<p>这是重要的信息。 它告诉调试器，始终可以在此内存地址中找到名为 one 的变量。 嗯，并非总是如此，但总是在该变量有效时（即它在范围内）。</p>\n<p>您可能想知道为什么它不能只是 RDI，因为那是将值传递给函数的地方，并且它也是第一个参数。 好了，RDI 稍后可能需要在函数中重用，因此使用堆栈是更安全的选择。</p>\n<p>调试器仍应在 executeLotsOfArguments 上停止。 确保您正在查看 “始终显示汇编” 输出并寻找汇编。 应该是第 16 行：</p>\n<pre><code>mov    qword ptr [rbp - 0x20], rdi\n</code></pre>\n<p>一旦在 executeLotsOfArguments 的汇编输出中找到它，就在该程序行上创建一个断点。<br />\n继续执行，以使 LLDB 停止在这一行汇编上。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4yviw6w4j31ue0naql9.jpg\" alt=\"\" /></p>\n<p>打印一个输出</p>\n<ul>\n<li>(lldb) po one</li>\n</ul>\n<p>还是乱码。 mph<br />\n 记住，RDI 将包含传递给函数的第一个参数。 因此，为了使调试器能够看到应该为 1 的值，需要将 RDI 写入存储 1 的地址。 在这种情况下，RBP-0x20。<br />\n现在，在 LLDB 中执行汇编指令步骤：</p>\n<ul>\n<li>(lldb) si</li>\n<li>(lldb) po one</li>\n</ul>\n<p>噢！... 是的！ 工作正常！ 所引用的值 1 正确持有值 0x1。<br />\n您可能想知道如果改变一个会发生什么。 好吧，在这种情况下，RBP-0x20 也需要更改。 这可能是需要在其中写入该值以及在何处使用它的另一条指令。 这就是为什么调试版本比发行版本要慢得多的原因。</p>\n<h2 id=\"栈的探索\"><a class=\"anchor\" href=\"#栈的探索\">#</a> 栈的探索</h2>\n<p>不用担心 本章即将完成。 但是，在堆栈探索中应该记住一些非常重要的要点。<br />\n如果您已经在使用函数，并且该函数已经完成了函数序言，则以下各项将适用于 x64 程序集：</p>\n<ul>\n<li>RBP 将指向此功能的堆栈帧的开始地方。</li>\n<li>RBP 将包含前一个堆栈帧的起始地址。 （在 LLDB 中使用 x /gx $ rbp 进行查看）。</li>\n<li>（RBP + 0x8）将指向堆栈跟踪中前一个函数的返回地址（在 LLDB 中使用 x /gx'$ rbp + 0x8' 进行查看）。</li>\n<li>（RBP + 0x10）将指向第 7 个参数（如果有）。</li>\n<li>（RBP + 0x18）将指向第 8 个参数（如果有）。</li>\n<li>（RBP + 0x20）将指向第 9 个参数（如果有）。</li>\n<li>（RBP + 0x28）将指向第十个参数（如果有）。</li>\n<li>RBP-X，其中 X 是 0x8 的倍数，将引用该函数的局部变量。</li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "https://oliverqueen.cn/2020-11-21-%E6%B1%87%E7%BC%96%E5%92%8C%E5%86%85%E5%AD%98/",
            "url": "https://oliverqueen.cn/2020-11-21-%E6%B1%87%E7%BC%96%E5%92%8C%E5%86%85%E5%AD%98/",
            "title": "汇编和内存",
            "date_published": "2020-11-21T08:50:53.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"汇编和内存\"><a class=\"anchor\" href=\"#汇编和内存\">#</a> 汇编和内存</h1>\n<p>你已经开了汇编学习的旅程，并且在前几章中你已经学习了汇编调用的一些黑魔法，你现在知道了，当一个函数被调用，他的参数和返回值是如何传递的。但是您还没学到的是将代码加载到内存后如何执行代码。</p>\n<p>在本章中，您将探索程序的执行方式。 您将看到一个特殊的寄存器，该寄存器用于告诉处理器应该从何处读取下一条指令，以及不同大小和内存分组如何产生截然不同的结果。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkww85fg8yj30u012ob29.jpg\" alt=\"\" /></p>\n<p><span id=\"more\"></span></p>\n<h2 id=\"设置英特尔风格汇编体验tm\"><a class=\"anchor\" href=\"#设置英特尔风格汇编体验tm\">#</a> 设置英特尔风格汇编体验™</h2>\n<p>如上一章所述，显示汇编有两种主要方法。 一种类型是 AT＆T 程序集，这个也是 LLDB 的默认程序集。 这种格式具有以下格式：</p>\n<pre><code>opcode（操作码）  source（源）  destination（目的地）\n</code></pre>\n<p>看一个具体的例子</p>\n<pre><code>movq  $0x78, %rax\n</code></pre>\n<p>这个操作会将十六进制值  <code>0x78</code>  移动到  <code>RAX</code>  寄存器中。 尽管这种汇编形式对某些人来说很不错，但从现在开始，您将使用英特尔的表示形式。</p>\n<blockquote>\n<p>注意：汇编的选择有点像一场大战，有的人说用 Inter 的格式，有的说是用 AT&amp;T 的格式，在 StackOverflow 中查看以下<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTcyNjAyL2F0dC12cy1pbnRlbC1zeW50YXgtYW5kLWxpbWl0YXRpb25z\">讨论</span><br />\n选择使用英特尔是因为大家都觉得英特尔在阅读方面更好，但有时在写作方面更差。 由于您正在学习调试，因此大部分时间是在阅读汇编而不是编写汇编。</p>\n</blockquote>\n<p>把以下的两行内容添加进  <code>~/.lldbinit file</code>  文件底部</p>\n<ul>\n<li>settings set target.x86-disassembly-flavor intel</li>\n<li>settings set target.skip-prologue false</li>\n</ul>\n<p>第一行告诉 LLDB 以 Intel 风格显示 x86 汇编（32 位和 64 位）。<br />\n第二行告诉 LLDB 不要跳过函数序言。 您在本书的前面已经了解了这一点，从现在开始，请不要跳过序言，因为您将直接从函数的第一条指令检查汇编。</p>\n<p>&lt;font color=#0099ff size=3 face=&quot;黑体&quot;&gt; 关于函数序言和函数尾声可以再参考这篇<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3phbmcxNDE1ODg3NjEvYXJ0aWNsZS9kZXRhaWxzLzEwMzk4NDIyNg==\">文章</span> &lt;/font&gt;</p>\n<p>&lt;font color=#DC143C size=3 face=&quot;黑体&quot;&gt; 注意：在编辑〜/.lldbinit 文件时，请确保您不使用 TextEdit 之类的程序，因为它将在文件中添加不必要的字符，这可能导致 LLDB 无法正确解析该文件。 一种简单（尽管很危险）的添加方法是通过如下的 Terminal 命令：echo“ settings set target.x86-disassembly-flavor intel” &gt;&gt;〜/.lldbinit。<br />\n确保其中有两个 “&gt;&gt;”，否则将覆盖〜/.lldbinit 文件中的所有先前内容。 如果您对终端机不满意，最好的选择是 nano（您之前使用过的编辑器）。&lt;/font&gt;</p>\n<p>英特尔风格将交换源值和目标值，删除 '％' 和 '$' 字符以及进行许多其他许多更改。 由于您还不会使用 AT＆T 语法，因此这里就不解释全部的差异，我们只单单学习 Inter 程序集就够了。</p>\n<p>看下面的示例，就是以 Inter 风格来展示，他看起来比较干净，比较好阅读。</p>\n<pre><code>mov  rax, 0x78\n</code></pre>\n<p>同样，这会将十六进制值 0x78 移到 RAX 寄存器中。<br />\n与前面显示的 AT＆T 风格相比，Intel 风格交换了源操作数和目标操作。 现在，目标操作数在源操作数之前。 在进行汇编时，务必始终确定正确的风格，这很重要，因为如果您不清楚要使用的风格，则可能会采取不同的操作。</p>\n<p>从现在开始，我们就开始使用 Inter 的汇编格式了。 如果您看到以 $ 字符开头的数字十六进制常量或以％开头的寄存器，你就要把他们转换成 Inter 的形式</p>\n<blockquote>\n<p>注：笔者反而觉得 AT&amp;T 的风格更适合中国汉语的语法，只是前面的 % 和 $ 有些奇怪罢了</p>\n</blockquote>\n<h2 id=\"创建cpx命令\"><a class=\"anchor\" href=\"#创建cpx命令\">#</a> 创建 cpx 命令</h2>\n<p>首先，您将创建自己的 LLDB 命令，之后会用到。<br />\n再次打开〜/.lldbinit（vim）。 然后将以下内容添加到文件底部：</p>\n<ul>\n<li>command alias -H &quot;Print value in ObjC context in hexadecimal&quot; -h &quot;Print in hex&quot; -- cpx expression -f x -l objc --</li>\n</ul>\n<p>cpx 是一个便捷命令，您可以使用 Objective-C 上下文以十六进制格式打印出某些内容。 尤其是在打印出寄存器内容时会用到。<br />\n请记住，寄存器在 Swift 上下文中不可用，因此您需要使用 Objective-C 上下文。<br />\n现在，您已经具有从汇编的角度探讨本章内容所需的工具！</p>\n<h2 id=\"位字节和其他术语\"><a class=\"anchor\" href=\"#位字节和其他术语\">#</a> 位，字节和其他术语</h2>\n<p>在开始探索内存之前，您需要了解一些有关内存分组方式的词汇。</p>\n<ul>\n<li>位 ：可以包含 1 或 0 的值称为位。您可以说在 64 位体系结构中每个地址有 64 位。很简单。</li>\n<li>字节：当 8 位组合在一起时，它们称为字节。一个字节可以容纳多少个唯一值？您可以通过计算 2 ^ 8（从 0 开始到 255 的 256 个值）来确定。</li>\n</ul>\n<p>许多信息以字节表示。例如，C 语言中 sizeof（）函数以字节为单位返回对象的大小。</p>\n<p>如果您熟悉 ASCII 字符编码，您会想起所有 ASCII 字符都可以保存在一个字节中。<br />\n现在是时候看看实际操作中的术语并学习一些技巧。<br />\n打开 Registers macOS 应用程序，您将在本章的资源文件夹中找到该应用程序。接下来，构建并运行该应用程序。一旦运行，请暂停程序并启动 LLDB 控制台。这将导致使用非 Swift 调试上下文，因为默认情况下暂停应用程序会带来非 Swift 上下文。<br />\n在 LLDB 中键入以下内容：</p>\n<ul>\n<li>p sizeof('A')</li>\n</ul>\n<p>这将打印出组成 'A' 字符所需的字节数</p>\n<pre><code>(unsigned long) $0 = 1\n</code></pre>\n<p>然后输入如下命令</p>\n<ul>\n<li>p/t 'A'</li>\n</ul>\n<p>你会得到</p>\n<pre><code>(char) $1 = 0b01000001\n</code></pre>\n<p>这是 ASCII 中字符 A 的二进制表示。<br />\n显示信息字节的另一种更常见的方法是使用十六进制值。 需要两个十六进制数字以十六进制表示一个信息字节。</p>\n<p>然后我们输入以下命令来打印出 “A” 的十六进制表示形式：</p>\n<ul>\n<li>p/x 'A'</li>\n</ul>\n<p>你将会得到</p>\n<pre><code>(char) $2 = 0x41\n</code></pre>\n<p>十六进制非常适合查看内存，因为一个十六进制数字恰好代表 4 位。 因此，如果您有 2 个十六进制数字，则您有 1 个字节。 如果您有 8 个十六进制数字，则您有 4 个字节。 等等。<br />\n这里还有一些适用于您的术语，这些术语在以后的章节中会很有用：</p>\n<ul>\n<li>Nybble：4 位，十六进制单个值</li>\n<li>Half word：16 位或 2 个字节</li>\n<li>Word：32 位或 4 个字节</li>\n<li>Double word or Giant word：64 位或 8 字节。</li>\n</ul>\n<p>使用此术语，您将可以探索不同的内存块。</p>\n<h2 id=\"rip寄存器\"><a class=\"anchor\" href=\"#rip寄存器\">#</a> RIP 寄存器</h2>\n<p>当程序执行时，将要执行的代码加载到内存中。 程序中接下来要执行的代码的位置由一个非常重要的寄存器决定：RIP 或指令指针寄存器。<br />\n让我们来看看实际情况。 再次打开 “register demo” 应用程序，然后导航到 AppDelegate.swift 文件。 修改文件，使其包含以下代码：</p>\n<pre><code>@NSApplicationMain\nclass AppDelegate: NSObject, NSApplicationDelegate &#123;\n\nfunc applicationWillBecomeActive(\n    _ notification: Notification) &#123;\n    print(&quot;\\(#function)&quot;)\n    self.aBadMethod()\n&#125;\n\nfunc aBadMethod() &#123;\n    print(&quot;\\(#function)&quot;)\n&#125;\n\nfunc aGoodMethod() &#123;\n    print(&quot;\\(#function)&quot;)\n&#125;\n&#125;\n</code></pre>\n<p>构建并运行该应用程序。 毫无疑问，控制台将会输出 该方法名  <code>applicationWillBecomeActive（_ :)</code>  ，然后输出  <code>aBadMethod</code>  。我们在在 aBadMethod 的开始处创建一个断点：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkwqomut9kj31v30u0h5e.jpg\" alt=\"\" /></p>\n<p>再次构建并运行。 在 aBadMethod 的开头命中断点后，导航至 Debug \\ Debug Workflow \\ Always Show Disassembly in Xcode。 现在，您将看到程序的实际汇编！</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkwqrg4bs4j30u00w8tq1.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkwqpnpyuwj32b30u0b29.jpg\" alt=\"\" /></p>\n<p>然后我们在控制台输入以下命令：</p>\n<pre><code>cpx $rip\n</code></pre>\n<p>这将使用您先前创建的 cpx 命令打印出指令指针寄存器。<br />\n您会注意到输出 LLDB 的地址与 Xcode 中绿线突出显示的地址是一样的：</p>\n<pre><code>(unsigned long) $1 = 0x0000000100008910\n</code></pre>\n<p>当然了每个人的电脑上显示的地址是不同的，而且每次执行时候的地址都可能不一样，但是在单次运行中绿线和控制台上显示的肯定是完全一样的。你试着在控制台下打以下命令：</p>\n<pre><code>(lldb) image lookup -vrn ^Registers.*aGoodMethod\n</code></pre>\n<p>这是一个很常用的查找命令，其中包含典型的正则表达式参数以及添加的参数  <code>-v</code>  ，该参数输出详细信息就像  <code>--verbose</code> 。<br />\n您会看到很多的东西。 在控制台中使用  <code>command + F</code>  来搜索关键字  <code>range = [</code>  其中范围中的第一个值便是</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkwra1dlerj31m00u0hdu.jpg\" alt=\"\" /></p>\n<p>该地址称为加载地址。 这是此函数在内存中的实际物理地址！这与您在 <code>image lookup</code>  命令中看到的常规输出不同，它仅显示函数相对于可执行文件的偏移量，也称为实现偏移量。 寻找函数地址时，区分加载地址和可执行文件中的实现偏移很重要，因为它会有所不同。</p>\n<p>将这个新地址复制到范围括号的开头。 对于此特定示例，aGoodMethod 的加载地址位于 0x0000000100008910。 现在将 aGoodMethod 的地址指向 RIP 寄存器。输入以下指令</p>\n<ul>\n<li>register write rip 0x0000000100008910</li>\n</ul>\n<p>单击继续，使用 Xcode 调试按钮单击 “继续”。 请一定用 Xcode 的按钮来继续，不要是用  <code>continue</code>  命令，因为在修改 RIP 寄存器并在控制台中继续操作时就会崩溃。按下 Xcode 继续按钮后，您会看到神奇的事情 -&gt; 未执行 aBadMethod（），而是执行了 aGoodMethod（）。 通过查看控制台日志中的输出来验证这一点。</p>\n<blockquote>\n<p>注意：修改 RIP 寄存器实际上非常危险。 您需要确 RIP 寄存器上的数据不会再被使用了，因为新功能将对 RIP 寄存器做出不正确的假设。 由于 aGoodMethod 和 aBadMethod 在功能上非常相似，因此您从一开始就停了下来，并且由于没有对 Registers 应用程序进行任何修改，因此不必担心。</p>\n</blockquote>\n<h2 id=\"寄存器和比特分解\"><a class=\"anchor\" href=\"#寄存器和比特分解\">#</a> 寄存器和比特分解</h2>\n<p>如上一章所述，x64 具有 16 个通用寄存器：RDI，RSI，RAX，RDX，RBP，RSP，RCX，RDX，R8，R9，R10，R11，R12，R13，R14 和 R15。<br />\n为了保持与 i386 的 32 位架构等以前的体系结构的兼容性，可以将寄存器分为 32 位，16 位或 8 位值。</p>\n<p>对于具有不同体系结构历史的寄存器，寄存器名称中的最前面的字符确定寄存器的大小。 例如，RIP 寄存器以 R 开头，它表示 64 位。 如果您希望使用等效于 RIP 寄存器的 32 位，则可以将 R 字符换成 E，以获得 EIP 寄存器。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkwsm5uzn1j30wj0u0qf1.jpg\" alt=\"\" /></p>\n<p>为什么这些有用？ 因为使用寄存器时，有时传递到寄存器的值不需要全部使用 64 位。 例如，考虑布尔数据类型：您真正需要的只是 1 或 0 以指示是或否（尽管实际上，布尔值将占用寄存器一个字节）。 基于语言的功能和约束，编译器知道这一点，有时只会将信息写入寄存器的某些部分。<br />\n让我们来看看实际情况。<br />\n删除 Registers 项目中的所有断点。 生成并运行项目。 现在，让程序暂停。输入以下内容：</p>\n<ul>\n<li>register write rdx 0x0123456789ABCDEF</li>\n</ul>\n<p>这会将值写入 RDX 寄存器。让我们停一分钟。 &lt;font color=red size=3&gt; 提示：您应该注意，写入寄存器可能会导致程序崩溃，尤其是当您希望写入的寄存器具有某种类型的数据时 &lt;/font&gt;。 但是你现在是在 demo 上做调试，所以请不要担心您的程序是否崩溃！<br />\n确认此值已成功写入 RDX 寄存器：</p>\n<ul>\n<li>p/x $rdx</li>\n</ul>\n<p>输出</p>\n<pre><code>(unsigned long) $0 = 0x0123456789abcdef\n</code></pre>\n<p>然后输入</p>\n<ul>\n<li>p/x $dx</li>\n</ul>\n<p>这将打印出 DX 寄存器，该寄存器是 EDX 寄存器的最低有效部分。 因此，这是一个半字。 您应该看到以下内容：</p>\n<pre><code>0xcdef\n</code></pre>\n<p>再输入</p>\n<ul>\n<li>p/x $dl</li>\n</ul>\n<p>这将打印出 DL 寄存器，它是 DX 寄存器的最低有效位 - 这次是一个字节。 您应该看到以下内容</p>\n<pre><code>0xef\n</code></pre>\n<p>最后输出如下指令</p>\n<ul>\n<li>p/x $dh</li>\n</ul>\n<p>这为您提供了 DX 寄存器的最高有效部分，即 DL 给出的另一半。 DL 中的 L 代表 “低” 而 DH 中的 H 代表 “高” 也就不足为奇了。<br />\n探索汇编时，请注意不同尺寸的寄存器。 寄存器的大小可以为其中包含的值提供线索。 例如，您可以轻松地查找通过 AL 寄存器返回布尔值的函数，因为布尔值将使用 8 个字节，&lt;font color=red size=3&gt; 而 AL 是 64 位 “返回值寄存器” RAX 的 8 位部分 &lt;/font&gt;</p>\n<h2 id=\"寄存器-r8-到-r15\"><a class=\"anchor\" href=\"#寄存器-r8-到-r15\">#</a> 寄存器 R8 到 R15</h2>\n<p>由于 R8 至 R15 系列寄存器仅针对 64 位架构而创建，因此它们使用完全不同的格式表示较小的寄存器。</p>\n<p>现在，您将看下 R9 的不同大小如何选择。生成并运行 Registers 应用程序，然后暂停调试器。像以前一样，将相同的十六进制值写入 R9 寄存器：</p>\n<ul>\n<li>register write $r9 0x0123456789abcdef</li>\n</ul>\n<p>输入以下内容，以确认您已设置 R9 寄存器成功：</p>\n<ul>\n<li>p/x $ r9</li>\n</ul>\n<p>输入以下内容，这将打印 R9 寄存器的低 32 位。请注意，它与您为 RDX 指定低 32 位（即 EDX）的方式有何不同。</p>\n<ul>\n<li>p/x $ r9d</li>\n</ul>\n<p>然后输入以下内容，这次您获得 R9 的低 16 位。同样，这与您为 RDX 进行此操作的方式不同</p>\n<ul>\n<li>p/x $ r9w</li>\n</ul>\n<p>再输入以下内容，打印出 R9 的低 8 位</p>\n<ul>\n<li>p/x $ r9l</li>\n</ul>\n<p>尽管这看起来有些乏味，但是您正在建立阅读汇编语言的技巧。</p>\n<h2 id=\"内存中断\"><a class=\"anchor\" href=\"#内存中断\">#</a> 内存中断</h2>\n<p>现在，您已经了解了指令指针，是时候进一步探索其背后的内存了。顾名思义，指令指针实际上是一个指针。它不执行 RIP 寄存器中存储的指令，而是执行 RIP 寄存器中指向的指令。</p>\n<p>在 LLDB 中看到这一点也许会更好地描述它。返回 Registers 应用程序中，打开 AppDelegate.swift 并再次在 aBadMethod 上设置一个断点。生成并运行该应用程序。</p>\n<p>命中断点并停止程序后，导航回到汇编视图。如果您忘记了该操作，但尚未为其创建键盘快捷键，则可以在 Debug \\ Debug Workflow \\ Always Show Disassembly 下找到它。<br />\n您会看到一堆汇编指令。看一下 RIP 寄存器的位置，该位置应指向函数的最开始。<br />\n对于该项目，aBadMethod 的起始地址始于 0x100008910。和往常一样，您的地址可能会有所不同。<br />\n在 LLDB 控制台中，键入以下内容：</p>\n<ul>\n<li>cpx $rip</li>\n</ul>\n<p>到现在为止，这将打印出指令指针寄存器的内容。如预期的那样，您将获得 aBadMethod 起始地址。 但是同样，RIP 寄存器指向内存中的值。 它指的是什么？ 嗯，您可以摆脱疯狂的 C 编码技巧（您还记得吗？）并取消引用指针，但是使用 LLDB 可以找到一种更为优雅的方法。<br />\n输入以下内容，将地址替换为您的 aBadMethod 函数的地址：</p>\n<ul>\n<li>memory read -fi -c1 0x100008910</li>\n</ul>\n<p>哇，该命令到底能做什么？  <code>memory read </code>  采用一个值，并读取您提供的内存地址所指向的内容。  <code>-f</code>  命令是一个格式参数。 在这种情况下，它是汇编指令格式。 最后，您说的是只希望使用 count 或 - c 参数打印一条汇编指令。<br />\n您将获得类似于以下内容的输出：</p>\n<pre><code>-&gt;  0x1000017c0: 55  pushq  %rbp\n</code></pre>\n<p>这是一些很好的输出。 它告诉您十六进制（0x55）中提供的汇编指令以及操作码，这些指令是  <code>pushq ％rbp</code>  操作</p>\n<blockquote>\n<p>注意：等等，您看到 '％' 吗？！ LLDB 中存在一个错误，当您以指令格式打印代码时，该错误不符合您的汇编风格。 请记住，如果您看到这种情况，则源和目标操作数将被反转！这就是 inter 指令集和 AT&amp;T 指令集的区别。</p>\n</blockquote>\n<p>让我们再看一下输出中的 “55”。 这是整个指令（即整个 pushq ％rbp）的编码。 不相信我吗？ 您可以验证它。 在 LLDB 中输入以下内容：</p>\n<ul>\n<li>expression -f i -l objc -- 0x55</li>\n</ul>\n<p>这实际上要求 LLDB 将 0x55 解释为 x64 操作码。 您将获得以下输出：</p>\n<pre><code>$1 = 55 pushq％rbp\n</code></pre>\n<p>该命令有点长，但这是因为如果您在 Swift 调试上下文中，则需要切换到 Objective-C 上下文。 但是，如果移至 Objective-C 调试上下文，则可以使用简短得多的便捷表达式。</p>\n<p>尝试单击 Xcode 左侧面板中的其他框架，以进入一个不包含 Swift 或 Objective-C / Swift 桥接代码的 Objective-C 上下文。 单击 Objective-C 函数中的任何框架。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkwvrtvgixj30u01efnix.jpg\" alt=\"\" /></p>\n<p>下一步，在 LLDB 控制台中键入以下内容：</p>\n<ul>\n<li>p/i 0x55</li>\n</ul>\n<p>好多了，对吧？<br />\n现在，回到手中的应用程序。 在 LLDB 中键入以下内容，再次用 aBadMethod 函数地址替换地址：</p>\n<ul>\n<li>memory read -fi -c10 0x1000017c0</li>\n</ul>\n<p>你讲获得以下输出：</p>\n<pre><code>-&gt; 0x100008910: 55                    pushq  %rbp\n0x100008911: 48 89 e5              movq   %rsp, %rbp\n0x100008914: 48 81 ec c0 00 00 00  subq   $0xc0, %rsp\n0x10000891b: 4c 89 6d f8           movq   %r13, -0x8(%rbp)\n0x10000891f: b8 01 00 00 00        movl   $0x1, %eax\n0x100008924: 89 c7                 movl   %eax, %edi\n0x100008926: e8 d5 05 00 00        callq  0x100008f00               ; symbol stub for: generic specialization &lt;preserving fragile attribute, Any&gt; of Swift._allocateUninitializedArray&lt;A&gt;(Builtin.Word) -&gt; (Swift.Array&lt;A&gt;, Builtin.RawPointer)\n0x10000892b: 48 89 c7              movq   %rax, %rdi\n0x10000892e: 48 89 45 a8           movq   %rax, -0x58(%rbp)\n0x100008932: 48 89 55 a0           movq   %rdx, -0x60(%rbp)\n</code></pre>\n<p>这里需要注意一些有趣的事情：汇编指令的长度可以变化。 看一下第一条指令，然后看输出中的其余指令。 第一条指令的长度为 1 个字节，用 0x55 表示。 以下指令的长度为三个字节。<br />\n确保您仍在 Objective-C 上下文中，并尝试打印出负责此指令的操作码。 它只有三个字节，所以您只需将它们连接在一起</p>\n<ul>\n<li>p/i 0x4889e5</li>\n</ul>\n<p>您将获得与  <code>mov ％rsp，％rbp</code>  指令完全无关的另一条指令！ 您会看到以下内容：</p>\n<pre><code>e5 89  inl    $0x89, %eax\n</code></pre>\n<p>是怎么做到的呢？ 也许现在是谈论字节序的好时机。</p>\n<h2 id=\"字节序这东西倒过来了\"><a class=\"anchor\" href=\"#字节序这东西倒过来了\">#</a> 字节序... 这东西倒过来了</h2>\n<p>x64 以及 ARM 系列体系结构设备均使用低位字节序，这意味着数据以最低有效字节在先的形式存储在内存中。 如果要将数字 0xabcd 存储在内存中，则会先存储 0xcd 字节，然后再存储 0xab 字节。<br />\n回到指令示例，这意味着指令 0x4889e5 将以 0xe5、0x89、0x48 的形式存储在存储器中。<br />\n返回到您先前遇到的 mov 指令，请尝试反转用于构成汇编指令的字节。 在 LLDB 中输入以下内容：</p>\n<ul>\n<li>p/i 0xe58948</li>\n</ul>\n<p>您现在将获得预期的汇编表示：</p>\n<pre><code>$2 = 48 89 e5  movq   %rsp, %rbp\n</code></pre>\n<p>让我们再看看一些小端实践的例子。 在 LLDB 中输入以下内容：</p>\n<ul>\n<li>memory read -s1 -c20 -fx 0x100008910</li>\n</ul>\n<p>此命令读取地址为 0x100008910 的内存。 -s1 选项可读取 1 个字节的大小块，-c20 选项可读取 20 个字节的大小块。 您会看到类似这样的内容：</p>\n<pre><code>0x100008910: 0x55 0x48 0x89 0xe5 0x48 0x81 0xec 0xc0\n0x100008918: 0x00 0x00 0x00 0x4c 0x89 0x6d 0xf8 0xb8\n0x100008920: 0x01 0x00 0x00 0x00\n</code></pre>\n<p>现在，将大小增加一倍，数量减少一半，就像这样：</p>\n<ul>\n<li>memory read -s2 -c10 -fx 0x100008910</li>\n</ul>\n<p>你会看到这样的输出</p>\n<pre><code>0x100008910: 0x4855 0xe589 0x8148 0xc0ec 0x0000 0x4c00 0x6d89 0xb8f8\n0x100008920: 0x0001 0x0000\n</code></pre>\n<p>请注意，当将内存值分组在一起时，由于使用了低位字节序，它们将被颠倒。<br />\n现在，将大小再增加一倍，数量再减少一半：</p>\n<ul>\n<li>memory read -s4 -c5 -fx 0x100008910</li>\n</ul>\n<p>然后你会看到如下输出</p>\n<pre><code>0x100008910: 0xe5894855 0xc0ec8148 0x4c000000 0xb8f86d89\n0x100008920: 0x00000001\n</code></pre>\n<p>与之前的输出相比，这些值再次被颠倒。<br />\n记住这一点非常重要，但在探索你自己的记忆时，这会让你变得很混乱。不仅内存的大小会给您一个潜在的错误答案，而且顺序也会给您一个潜在的错误答案。当你开始对着电脑大喊大叫时，当你试图弄清楚某样东西应该如何工作时，请记住这一点！</p>\n",
            "tags": []
        },
        {
            "id": "https://oliverqueen.cn/2020-11-19-%E6%B1%87%E7%BC%96%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E8%A7%84%E5%88%99/",
            "url": "https://oliverqueen.cn/2020-11-19-%E6%B1%87%E7%BC%96%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E8%A7%84%E5%88%99/",
            "title": "汇编寄存器的规则",
            "date_published": "2020-11-19T09:12:10.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"汇编寄存器的规则\"><a class=\"anchor\" href=\"#汇编寄存器的规则\">#</a> 汇编寄存器的规则</h1>\n<p>在本章中，您将了解到 CPU 使用的寄存器，并研究和修改传入函数的参数。您还将了解常见的苹果计算机架构，以及如何在函数中使用它们的寄存器。这就是所谓的架构调用约定。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkulov9q1ej31c10u0x6s.jpg\" alt=\"\" /><br />\n<span id=\"more\"></span><br />\n 了解汇编如何工作以及特定架构的调用约定如何工作是一项极其重要的技能。它可以让您观察没有源代码的函数参数，并允许您修改传入函数的参数。此外，有时转到底层汇编层面会更好，因为您的源代码可能对您不知道的变量有不同的或未知的名称。<br />\n例如，假设您想知道函数调用的第二个参数，但是我并不知道参数的名称是什么。汇编的知识会帮助你来观察这些函数中的参数。</p>\n<h2 id=\"汇编101\"><a class=\"anchor\" href=\"#汇编101\">#</a> 汇编 101</h2>\n<p>等等，所以到底什么是汇编？来看一个场景：您是否曾经打了一个断点，但是中断到没有源代码的地方？然后看到看到大量内存地址和可怕的简短命令？你是不是缩成一团，悄悄地对自己说你再也不会看这些密集的东西了？嗯… 这就是所谓的汇编！<br />\n 这里有一张 Xcode 中的断点调试图，它展示了模拟器中函数的汇编。<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gktboylxxdj322z0li150.jpg\" alt=\"\" /></p>\n<p>通过上图可以看出汇编代码可以被分成几个不同的部分。汇编指令中的每一行都包含一个操作码，可以认为是对计算机来说非常简单的指令。那么操作码是什么样子的呢？操作码是在计算机上执行一项简单任务的指令。例如下面的程序集片段:</p>\n<p><figure class=\"highlight mel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pushq   %rbx</span><br><span class=\"line\">subq    $0x228, %rsp </span><br><span class=\"line\">movq    %rdi, %rbx </span><br></pre></td></tr></table></figure></p>\n<p>在这个汇编模块中，您可以看到三种操作码: <code>pushq</code> 、 <code>subq</code>  和  <code>movq</code>  可以将操作码项看作要执行的操作。操作码后面的内容是源标签和目标标签。也就是说，这些是操作码所作用的对象。在上面的示例中，有几个寄存器，显示为  <code>rbx</code>  、 <code>rsp</code>  、 <code>rdi</code>  和  <code>rbp</code> 。前面的  <code>%</code>  告诉您这是一个寄存器。</p>\n<p>此外，您还可以找到一个十六进制的数字常量，如 0x228。这个常数之前的美元符号告诉你它是一个绝对值。现在不需要知道这段代码在做什么，因为您首先需要了解每个符号的含义。然后你会学到更多关于操作码的知识，并在以后的章节中编写你自己的程序。</p>\n<blockquote>\n<p>注意：在上面的示例中，请注意，在寄存器和常量之前有一堆％和 $。 这就是反汇编程序格式化程序集的展示方式。 但是可以通过两种主要方式展示汇编。 第一个是  <code>英特尔程序集</code>  ，第二个是  <code>AT＆T程序集</code>  。默认情况下，Apple 的反汇编程序工具都会以 AT＆T 格式显示，就如上例所示。 尽管这是一种很好的格式，但在眼睛上可能会有些困难。 在下一章中，您将把汇编格式更改为 Intel，并且从那以后将完全使用 Intel 汇编语法。</p>\n</blockquote>\n<h2 id=\"x86_64-vs-arm64\"><a class=\"anchor\" href=\"#x86_64-vs-arm64\">#</a> x86_64 vs ARM64</h2>\n<p>作为 Apple 平台的开发人员，学习汇编时要处理两种主要架构：x86_64 架构和 ARM64 架构。 x86_64 是最可能在 macOS 计算机上使用的体系结构，除非您运行的是 “古老” 的 Macintosh。x86_64 是 64 位体系结构，这意味着每个地址最多可以容纳 64 个 1 或 0。 另外，较旧的 Mac 使用 32 位架构，但是 Apple 在 2010 年底停止生产 32 位 Mac。 在 macOS 下运行的程序可能是 64 位兼容的，包括 Simulator 上的程序。 话虽如此，即使您的 macOS 是 x86_64，它仍然可以运行 32 位程序。如果对使用的硬件架构有疑问，可以在终端中运行以下命令来获取计算机的硬件架构：</p>\n<ul>\n<li>uname -m</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gktcxe1lm2j30c902xgll.jpg\" alt=\"\" /></p>\n<p>在能耗要求很高的移动设备（如 iPhone）上使用 ARM64 体系结构。ARM 强调节能功能，因此它减少了一组操作码，有助于简化复杂的汇编指令，从而降低了能耗。 这对您来说是个好消息，因为关于 ARM 的体系结构你需要学习的并不多。这是与之前显示的方法相同的屏幕截图，除了这次是在 iPhone 7 上的 ARM64 程序集中：<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gktd6atsyvj32140mv4bh.jpg\" alt=\"\" /><br />\n您现在可能无法区分这两种架构，但是您很快就会知道它们就像手背一样.</p>\n<blockquote>\n<p>Apple 最初在其许多 iOS 设备中都提供了 32 位 ARM 处理器，但此后便转移到了 64 位 ARM 处理器。 32 位 iOS 设备几乎已过时，因为 Apple 已通过各种 iOS 版本逐步淘汰了它们。 例如，iPhone 5 是最终的 32 位 iOS 设备，iOS 11 不支持该设备。支持 iOS 11 的 “最低” iPhone 是 64 位设备 iPhone 5s。近年来，32 位设备已出现在其他 Apple 产品中。 Apple Watch 的前两代是 32 位设备，但是第三代是 64 位设备。 此外，在较新的 macOS 设备上发现的 Apple Touch Bar（无疑是花哨的）也使用 32 位架构。</p>\n</blockquote>\n<p>由于最好专注于您将来的需求，因此本书将主要关注两种架构的 64 位汇编。 此外，您将首先开始学习 x86_64 程序集，然后过渡到学习 ARM64 程序集，以免感到困惑。 好吧，不要太困惑。</p>\n<h2 id=\"x86_64-寄存器调用规则\"><a class=\"anchor\" href=\"#x86_64-寄存器调用规则\">#</a> x86_64 寄存器调用规则</h2>\n<p>您的 CPU 使用一组寄存器来操纵正在运行的程序中的数据。这些是存储的基础，就像计算机中的 RAM 一样。但是，它们位于 CPU 本身上，因此 CPU 的这些部分可以快速访问这些寄存器。效率非常高，大多数指令涉及一个或多个寄存器，并执行一些操作，例如将寄存器的内容写入内存，将存储器的内容读取到寄存器或对两个寄存器执行算术运算例如 加，减等。</p>\n<p>在 x64 中（从现在开始，x64 是 x86_64 的缩写），机器使用 16 个通用寄存器来操纵数据。<br />\n这些寄存器是 RAX，RBX，RCX，RDX，RDI，RSI，RSP，RBP 和 R8 至 R15。这些名称对您现在意义不大，但是您很快就会发现每个寄存器的重要性。“在 x64 中调用函数时，寄存器的方式和使用遵循非常特定的规则。这决定了函数的参数应该去哪里以及函数完成时函数的返回值应该在哪里。这很重要，因此可以将一个编译器编译的代码与另一个编译器编译的代码一起使用。</p>\n<p>比如你看下面这个行代码：</p>\n<pre><code>NSString *name = @&quot;Zoltan&quot;;\nNSLog(@&quot;Hello world, I am %@. I'm %d, and I live in %@.&quot;, name, 30, @&quot;my father's basement&quot;);\n</code></pre>\n<p>NSLog 函数调用中传递了四个参数。 其中一些值按原样传递，而一个参数存储在局部变量中，然后在函数中作为参数引用。 但是，通过汇编查看代码时，计算机并不关心变量的名称 (name)； 它只关心该变量在内存中的位置。</p>\n<p>在 x64 汇编中调用函数时，以下寄存器用作参数。 尝试将它们提交到内存中，因为将来您会经常使用它们：</p>\n<pre><code>第一个参数：RDI\n第二个参数：RSI\n第三个参数：RDX\n第四个参数：RCX\n第五个参数：R8\n第六个参数：R9\n</code></pre>\n<p>如果有六个以上的参数，则使用程序的堆栈将其他参数传递给该函数。</p>\n<p>回到简单的 Objective-C 代码，上面的 OC 代码可以像下面这样的伪代码流程在寄存器中传递：</p>\n<p><figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">RDI</span> = @<span class=\"string\">&quot;Hello world, I am %@. I&#x27;m %d, and I live in %@.&quot;</span><span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"built_in\">RSI</span> = @<span class=\"string\">&quot;Zoltan&quot;</span><span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"built_in\">RDX</span> = <span class=\"number\">30</span><span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"built_in\">RCX</span> = @<span class=\"string\">&quot;my father&#x27;s basement&quot;</span><span class=\"comment\">;</span></span><br><span class=\"line\">NSLog(<span class=\"built_in\">RDI</span>, <span class=\"built_in\">RSI</span>, <span class=\"built_in\">RDX</span>, <span class=\"built_in\">RCX</span>)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure></p>\n<p>NSLog 调用完成后，指定的寄存器将包含如上所述的适当值。但是，一旦函数序言（准备堆栈和寄存器的函数的开始部分）完成执行，这些寄存器中的值就可能改变。生成的程序集可能会覆盖存储在这些寄存器中的值，或者在代码不再需要这些引用时丢弃这些引用。<br />\n这意味着，一旦离开函数的开始，就不能再假定这些寄存器将保存您要观察的期望值，除非您实际查看汇编代码看看它在做什么。<br />\n使用此调用规则的浏览寄存器会严重影响您的调试（和断点）策略。必须在函数调用开始时停止以查看或修改参数，而不必实际进入程序集。</p>\n<h2 id=\"objective-c-和寄存器\"><a class=\"anchor\" href=\"#objective-c-和寄存器\">#</a> Objective-C 和寄存器</h2>\n<p>如上一节所述，寄存器使用特定的调用规则。 您也可以将该知识其应用于其他语言。<br />\n当 Objective-C 执行方法时，将执行一个名为  <code>objc_msgSend</code>  的特殊 C 函数。 这些功能实际上有几种不同的类型，但稍后会介绍更多。 这是 Objective-C 动态消息分发的核心。 作为第一个参数，objc_msgSend 获取在其上发送消息的对象的引用。 随后是一个选择器，它只是一个 char *，用于指定在对象上调用的方法的名称。 最后，如果选择器指定应有参数，则 objc_msgSend 在函数中采用可变数量的参数。<br />\n让我们来看一个在 iOS 环境中的具体示例：</p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">id</span> <span class=\"built_in\">UIApplicationClass</span> = [<span class=\"built_in\">UIApplication</span> <span class=\"keyword\">class</span>];</span><br><span class=\"line\">objc_msgSend(<span class=\"built_in\">UIApplicationClass</span>, <span class=\"string\">&quot;sharedApplication&quot;</span>);</span><br></pre></td></tr></table></figure></p>\n<p>第一个参数是对 UIApplication 类的引用，其后是 sharedApplication 选择器 其实就是需要被调用的方法。 判断是否有参数的一种简单方法是简单地检查 Objective-C 选择器中的冒号。 每个冒号将代表一个方法中的参数。<br />\n我们下面来看一个 OC 的方法：</p>\n<p><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">NSString</span> *helloWorldString = [@<span class=\"string\">&quot;Can&#x27;t Sleep; &quot;</span>stringByAppendingString:@<span class=\"string\">&quot;Clowns will eat me&quot;</span>];</span><br></pre></td></tr></table></figure></p>\n<p>最终编译会变成：</p>\n<p><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">NSString</span> *helloWorldString; </span><br><span class=\"line\"><span class=\"attribute\">helloWorldString</span> = objc_msgSend(@<span class=\"string\">&quot;Can&#x27;t Sleep; &quot;</span>, <span class=\"string\">&quot;stringByAppendingString:&quot;</span>, @<span class=\"string\">&quot;Clowns will eat me&quot;</span>);</span><br></pre></td></tr></table></figure></p>\n<p>第一个参数是 NSString 的实例（@“Can't Sleep;”），后跟方法选择器，然后是方法调用的参数。</p>\n<h2 id=\"将理论付诸实践\"><a class=\"anchor\" href=\"#将理论付诸实践\">#</a> 将理论付诸实践</h2>\n<p>在本节中，您将使用本章资源包中提供的名为 Registers 的项目。<br />\n通过 Xcode 打开该项目，然后运行。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gktgwlp1cuj30x40glgoh.jpg\" alt=\"\" /></p>\n<p>这是一个非常简单的应用程序，仅显示 64 位寄存器里面的内容。 需要注意的是，该应用程序不会实时的显示寄存器的值； 它只能在特定的函数调用期间显示寄存器的值。 这意味着您不会看到这些寄存器的值有太多更改，因为在调用获取寄存器值的函数时它们可能具有相同（或相似）的值。<br />\n现在，您已经了解了 Registers macOS 应用程序背后的功能，为 NSViewController 的 viewDidLoad 方法创建一个符号断点。 记住，因为您正在使用 Mac 应用程序，所以请使用 “NS” 代替 “ UI”。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gktm1acug7j30ws0c8n13.jpg\" alt=\"\" /></p>\n<p>生成并重新运行该应用程序。触发断点后在 LLDB 控制台中键入以下内容：</p>\n<ul>\n<li>(lldb) register read</li>\n</ul>\n<p>这将列出处于暂停执行状态的所有主要寄存器。 但是输出了太多信息。 您应该有选择地打印出寄存器，并将其视为 Objective-C 对象。如果您还记得的话，-[NSViewController viewDidLoad] 将被转换为以下程序集伪代码：</p>\n<p><figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">RDI</span> = UIViewControllerInstance </span><br><span class=\"line\"><span class=\"built_in\">RSI</span> = <span class=\"string\">&quot;viewDidLoad&quot;</span></span><br><span class=\"line\">objc_msgSend(<span class=\"built_in\">RDI</span>, <span class=\"built_in\">RSI</span>)</span><br></pre></td></tr></table></figure></p>\n<p>考虑到 x64 调用规则，并且知道 objc_msgSend 的工作方式，您可以找到要加载的特定 NSViewController。<br />\n在 LLDB 控制台中键入以下内容：</p>\n<ul>\n<li>(lldb) po $rdi</li>\n</ul>\n<p>然后你会看到如下输出：</p>\n<p><figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">&lt;Registers.ViewController: 0x6080000c13b0&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>它输出了 RDI 寄存器中的 NSViewController 引用，您现在知道该引用是该方法的第一个参数的位置。</p>\n<p>在 LLDB 中，为寄存器加上 $ 字符很重要，因此 LLDB 知道您需要的是寄存器的值，而不是源代码中与范围相关的变量。 是的，这与您在刚刚反汇编视图中看到的汇编不同！ 烦人吧？</p>\n<blockquote>\n<p>注：善于观察的你可能已经注意到了在 OC 代码中打断点，在 LLDB 的回溯内看不到 objc_msgSend 的影子。这是因为 objc_msgSend 方法簇执行了 jmp。意思就是说 objc_msgSend 扮演了中转的角色，一但 OC 代码开始执行，所有的关于 objc_msgSend 的栈中的回溯都将消失。这是一种叫做尾递归调用的优化。因为 mesgsend 开始执行证明之前的栈帧已经清空了。</p>\n</blockquote>\n<p>尝试打印出 RSI 寄存器，不出意外的话应该是方法名。 在 LLDB 控制台中输入以下内容：</p>\n<ul>\n<li>(lldb) po $rsi</li>\n</ul>\n<p>结果你会输出这个</p>\n<p><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">140735181830794</span><br></pre></td></tr></table></figure></p>\n<p>为什么是这样？ Objective-C 选择器基本上只是一个 char *。 这意味着，像所有 C 类型一样，LLDB 不知道如何格式化此数据。 因此，您必须将此引用显式转换为所需的数据类型。<br />\n将 RSI 寄存器强制转换为正确的类型使用如下指令</p>\n<ul>\n<li>po (char *)<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mi>s</mi><mi>i</mi><mtext>或者</mtext><mi>p</mi><mi>o</mi><mo stretchy=\"false\">(</mo><mi>S</mi><mi>E</mi><mi>L</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">rsi 或者  po (SEL)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">i</span><span class=\"mord cjk_fallback\">或</span><span class=\"mord cjk_fallback\">者</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">o</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathnormal\">L</span><span class=\"mclose\">)</span></span></span></span>rsi</li>\n</ul>\n<p>便可以得到方法名字</p>\n<p><figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;viewDidLoad&quot;</span></span><br></pre></td></tr></table></figure></p>\n<p>现在，该探讨带有参数的 Objective-C 方法了。 由于您已经断点了 viewDidLoad，因此可以放心地假设 NSView 实例已加载。 感兴趣的方法是 mouseUp：由 NSView 的父类 NSResponder 实现的选择器。<br />\n在 LLDB 中，在 NSResponder 的 mouseUp：选择器上创建一个断点，然后继续执行。 如果您不记得该怎么做，则需要以下命令：</p>\n<ul>\n<li>(lldb) b -[NSResponder mouseUp:]</li>\n<li>(lldb) continue</li>\n</ul>\n<p>现在，点击应用程序窗口。 确保单击 NSScrollView 的外部，因为 NSScrollView 它会拦截您的单击，并且不会命中 -[NSResponder mouseUp：] 断点。</p>\n<p>点击后，LLDB 就会在 mouseUp：断点处停止。 通过在 LLDB 控制台中键入以下内容，打印出 NSResponder 的引用：</p>\n<ul>\n<li>(lldb) po $rdi</li>\n</ul>\n<p>会出现如下的输出</p>\n<p><figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">&lt;NSView: 0x608000120140&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>但是，该方法是带参数的！ 在 LLDB 控制台中输入以下内容：</p>\n<ul>\n<li>(lldb) po $rdx</li>\n</ul>\n<p>输出</p>\n<p><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">“NSEvent: <span class=\"attribute\">type</span>=LMouseUp loc=(351.672,137.914) <span class=\"attribute\">time</span>=175929.4 <span class=\"attribute\">flags</span>=0 <span class=\"attribute\">win</span>=0x6100001e0400 <span class=\"attribute\">winNum</span>=8622 <span class=\"attribute\">ctxt</span>=0x0 <span class=\"attribute\">evNum</span>=10956 <span class=\"attribute\">click</span>=1 <span class=\"attribute\">buttonNumber</span>=0 <span class=\"attribute\">pressure</span>=0 deviceID:0x300000014400000 <span class=\"attribute\">subtype</span>=NSEventSubtypeTouch”</span><br></pre></td></tr></table></figure></p>\n<p>也可以看到参数类型</p>\n<ul>\n<li>po [$rdx class]</li>\n</ul>\n<p><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">NSEvent</span></span><br></pre></td></tr></table></figure></p>\n<p>太酷了，是吗？有时使用寄存器和断点很有用，以便获得内存中还存在的对象的引用。例如，如果您想将前部 NSWindow 更改为红色，但是在代码中没有对该视图的引用，又不想重新编译任何代码怎么办？ 您只需创建一个断点就可以轻松调试，从寄存器中获取引用并根据需要操纵该对象的实例。 您现在将尝试将主窗口更改为红色。”</p>\n<blockquote>\n<p>注：尽管 NSResponder 实现了 mouseDown: 方法，但 NSWindow 重写了它。你可以输出所有实现了 mouseDown: 的类，你就可以看出这个方法被那些类重写了，而不用去看源码。输出所有实现了 mouseDown: 方法的 OC 类的命令是：&lt;u&gt;image lookup -rn '\\ mouseDown:&lt;/u&gt;'</p>\n</blockquote>\n<p>首先使用 LLDB 控制台删除所有以前的断点：</p>\n<ul>\n<li>breakpoint delete</li>\n</ul>\n<p>像如下输出</p>\n<p><figure class=\"highlight n1ql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) breakpoint <span class=\"keyword\">delete</span></span><br><span class=\"line\">About <span class=\"keyword\">to</span> <span class=\"keyword\">delete</span> <span class=\"keyword\">all</span> breakpoints, <span class=\"keyword\">do</span> you want <span class=\"keyword\">to</span> <span class=\"keyword\">do</span> that?: [Y/n] Y</span><br><span class=\"line\"><span class=\"keyword\">All</span> breakpoints removed. (<span class=\"number\">3</span> breakpoints)</span><br><span class=\"line\">(lldb) </span><br></pre></td></tr></table></figure></p>\n<p>然后在 LLDB 控制台中键入以下内容：</p>\n<ul>\n<li>(lldb) breakpoint set -o -S &quot;-[NSWindow mouseDown:]</li>\n<li>(lldb) continue</li>\n</ul>\n<p>这句话的作用是设置一个单发断点，只会触发一次，然后点击应用程序触发断点，在 LLDB 控制台中键入以下内容：</p>\n<ul>\n<li>(lldb) po [$rdi setBackgroundColor:[NSColor redColor]]</li>\n<li>(lldb) continue</li>\n</ul>\n<p>之后就可以看到效果</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkuam4sxojj30qo0i8go0.jpg\" alt=\"\" /></p>\n<h2 id=\"swift和寄存器\"><a class=\"anchor\" href=\"#swift和寄存器\">#</a> Swift 和寄存器</h2>\n<p>在 Swift 中探索寄存器时，您将遇到两个问题，这使汇编调试比 Objective-C 困难。</p>\n<ul>\n<li>\n<p>首先，在 Swift 调试上下文内寄存器不可用。意味着你不得不获取到任何你想要的数据，并使用 OC 调试上下文打印出传入 Swift 函数的寄存器。记住你可以使用 expression -l objc -O 命令，或者使用在书中第八章（“Persisting and Customizing Commands”）的 cpo 命令。幸运的是，register read 命令依然是可以使用的。</p>\n</li>\n<li>\n<p>其次，Swift 相对于 OC 并不是动态的。事实上，有时候最好假设 Swift 像 C 语言一样。如果知道了一个内存地址，你应该显示地强转为你想要的类型。不然 Swift 调试器没有任何线索去解释内存地址。</p>\n</li>\n</ul>\n<p>话虽这么说，但是 Swift 使用了相同的寄存器调用规则。 但是有一个非常重要的区别。 当 Swift 调用一个函数时，它__不需要使用 objc_msgSend__，除非您当然标记了使用动态方法。 这意味着当 Swift 调用函数时，先前分配给选择器的 RSI 寄存器实际上就是函数的第二个参数。好了，足够的理论 - 是时候将其付诸实践了。</p>\n<p>在 Registers 项目中，导航到 ViewController.swift 并将以下函数添加到该类：</p>\n<p><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">executeLotsOfArguments</span>(<span class=\"params\">one</span>: <span class=\"type\">Int</span>, <span class=\"params\">two</span>: <span class=\"type\">Int</span>, <span class=\"params\">three</span>: <span class=\"type\">Int</span>,</span><br><span class=\"line\">                                <span class=\"params\">four</span>: <span class=\"type\">Int</span>, <span class=\"params\">five</span>: <span class=\"type\">Int</span>, <span class=\"params\">six</span>: <span class=\"type\">Int</span>,</span><br><span class=\"line\">                                <span class=\"params\">seven</span>: <span class=\"type\">Int</span>, <span class=\"params\">eight</span>: <span class=\"type\">Int</span>, <span class=\"params\">nine</span>: <span class=\"type\">Int</span>,</span><br><span class=\"line\">                                <span class=\"params\">ten</span>: <span class=\"type\">Int</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;arguments are: <span class=\"subst\">\\(one)</span>, <span class=\"subst\">\\(two)</span>, <span class=\"subst\">\\(three)</span>, <span class=\"subst\">\\(four)</span>, <span class=\"subst\">\\(five)</span>, <span class=\"subst\">\\(six)</span>, <span class=\"subst\">\\(seven)</span>, <span class=\"subst\">\\(eight)</span>, <span class=\"subst\">\\(nine)</span>, <span class=\"subst\">\\(ten)</span>&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在，在 viewDidLoad 中，使用适当的参数调用此函数：</p>\n<p><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">self</span>.<span class=\"title function_ invoke__\">executeLotsOfArguments</span>(<span class=\"attr\">one</span>: <span class=\"number\">1</span>, <span class=\"attr\">two</span>: <span class=\"number\">2</span>, <span class=\"attr\">three</span>: <span class=\"number\">3</span>, <span class=\"attr\">four</span>: <span class=\"number\">4</span>, <span class=\"attr\">five</span>: <span class=\"number\">5</span>, <span class=\"attr\">six</span>: <span class=\"number\">6</span>, <span class=\"attr\">seven</span>: <span class=\"number\">7</span>, <span class=\"attr\">eight</span>: <span class=\"number\">8</span>, <span class=\"attr\">nine</span>: <span class=\"number\">9</span>, <span class=\"attr\">ten</span>: <span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure></p>\n<p>在与 executeLotsOfArguments 声明相同的行上放置一个断点，以便调试器将在函数的开始处停止。 这很重要，否则如果函数已经开始执行，则寄存器可能会被破坏。然后删除您在 -[NSViewController viewDidLoad] 上设置的符号断点。生成并运行该应用程序，然后等待 executeLotsOfArguments 断点停止执行。我们先列出所有的寄存器。 在 LLDB 中，键入以下内容：</p>\n<ul>\n<li>register read -f d</li>\n</ul>\n<p>这将列出所有的寄存器，并使用 - f d 选项以十进制显示格式。 输出将类似于以下内容：</p>\n<p><figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) register read -f d</span><br><span class=\"line\">General Purpose Registers:</span><br><span class=\"line\">       <span class=\"built_in\">rax</span> = <span class=\"number\">10</span></span><br><span class=\"line\">       <span class=\"built_in\">rbx</span> = <span class=\"number\">7</span></span><br><span class=\"line\">       <span class=\"built_in\">rcx</span> = <span class=\"number\">4</span></span><br><span class=\"line\">       <span class=\"built_in\">rdx</span> = <span class=\"number\">3</span></span><br><span class=\"line\">       <span class=\"built_in\">rdi</span> = <span class=\"number\">1</span></span><br><span class=\"line\">       <span class=\"built_in\">rsi</span> = <span class=\"number\">2</span></span><br><span class=\"line\">       <span class=\"built_in\">rbp</span> = <span class=\"number\">140732785005232</span></span><br><span class=\"line\">       <span class=\"built_in\">rsp</span> = <span class=\"number\">140732785004720</span></span><br><span class=\"line\">        <span class=\"built_in\">r8</span> = <span class=\"number\">5</span></span><br><span class=\"line\">        <span class=\"built_in\">r9</span> = <span class=\"number\">6</span></span><br><span class=\"line\">       <span class=\"built_in\">r10</span> = <span class=\"number\">9</span></span><br><span class=\"line\">       <span class=\"built_in\">r11</span> = <span class=\"number\">8</span></span><br><span class=\"line\">       <span class=\"built_in\">r12</span> = <span class=\"number\">140668105198352</span></span><br><span class=\"line\">       <span class=\"built_in\">r13</span> = <span class=\"number\">105553138827696</span></span><br><span class=\"line\">       <span class=\"built_in\">r14</span> = <span class=\"number\">104</span></span><br><span class=\"line\">       <span class=\"built_in\">r15</span> = <span class=\"number\">8</span></span><br><span class=\"line\">       <span class=\"built_in\">rip</span> = <span class=\"number\">4430734802</span>  Registers<span class=\"string\">`Registers.ViewController.executeLotsOfArguments(one: Swift.Int, two: Swift.Int, three: Swift.Int, four: Swift.Int, five: Swift.Int, six: Swift.Int, seven: Swift.Int, eight: Swift.Int, nine: Swift.Int, ten: Swift.Int) -&gt; () + 178 at ViewController.swift:68:15</span></span><br><span class=\"line\"><span class=\"string\">    rflags = 514</span></span><br><span class=\"line\"><span class=\"string\">        cs = 43</span></span><br><span class=\"line\"><span class=\"string\">        fs = 0</span></span><br><span class=\"line\"><span class=\"string\">        gs = 0</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">(lldb) </span></span><br></pre></td></tr></table></figure><br />\n 如您所见，寄存器遵循 x64 调用规则。 RDI，RSI，RDX，RCX，R8 和 R9 保留您的前六个参数。</p>\n<blockquote>\n<p>注意：关于 LLDB，我一直没有告诉您的是，LLDB 可以以<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mi>r</mi><mi>g</mi><mi>X</mi><mtext>形式来引用寄存器，其中</mtext><mi>X</mi><mtext>是参数号。还记得</mtext><mi>R</mi><mi>D</mi><mi>I</mi><mtext>是第一个参数，而</mtext><mi>R</mi><mi>S</mi><mi>I</mi><mtext>是第二个参数吗</mtext><mo stretchy=\"false\">?</mo><mtext>在</mtext><mi>L</mi><mi>L</mi><mi>D</mi><mi>B</mi><mtext>中，可以通过</mtext></mrow><annotation encoding=\"application/x-tex\">arg{X}形式来引用寄存器，其中X是参数号。还记得RDI是第一个参数，而RSI是第二个参数吗?在LLDB中，可以通过</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span><span class=\"mord cjk_fallback\">形</span><span class=\"mord cjk_fallback\">式</span><span class=\"mord cjk_fallback\">来</span><span class=\"mord cjk_fallback\">引</span><span class=\"mord cjk_fallback\">用</span><span class=\"mord cjk_fallback\">寄</span><span class=\"mord cjk_fallback\">存</span><span class=\"mord cjk_fallback\">器</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">其</span><span class=\"mord cjk_fallback\">中</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord cjk_fallback\">是</span><span class=\"mord cjk_fallback\">参</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">号</span><span class=\"mord cjk_fallback\">。</span><span class=\"mord cjk_fallback\">还</span><span class=\"mord cjk_fallback\">记</span><span class=\"mord cjk_fallback\">得</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord cjk_fallback\">是</span><span class=\"mord cjk_fallback\">第</span><span class=\"mord cjk_fallback\">一</span><span class=\"mord cjk_fallback\">个</span><span class=\"mord cjk_fallback\">参</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">而</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord cjk_fallback\">是</span><span class=\"mord cjk_fallback\">第</span><span class=\"mord cjk_fallback\">二</span><span class=\"mord cjk_fallback\">个</span><span class=\"mord cjk_fallback\">参</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">吗</span><span class=\"mclose\">?</span><span class=\"mord cjk_fallback\">在</span><span class=\"mord mathnormal\">L</span><span class=\"mord mathnormal\">L</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord cjk_fallback\">中</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">可</span><span class=\"mord cjk_fallback\">以</span><span class=\"mord cjk_fallback\">通</span><span class=\"mord cjk_fallback\">过</span></span></span></span> arg1 引用第一个参数 (RDI)。随着示例的进行，您可以使用 $arg2 引用第二个参数 (RSI)，以此类推。这些方便值也可以在 ARM64 调用约定中使用，即使 ARM64 使用不同的寄存器。您应该记住寄存器调用规则，以便本书尽量减少使用这些寄存器辅助变量。</p>\n</blockquote>\n<p>您可能还会注意到其他参数存储在其他一些其他寄存器中。 确实如此，但这只是为其余参数设置堆栈的代码中的剩余部分。 请记住，第六个参数之后的参数将进入堆栈。</p>\n<h2 id=\"rax用于返回的寄存器\"><a class=\"anchor\" href=\"#rax用于返回的寄存器\">#</a> RAX，用于返回的寄存器</h2>\n<p>等等 -- 还有呢！到这里，你已经了解了函数中六个寄存器是如何调用的，但是返回值呢？</p>\n<p>幸运的是，只有一个指定的寄存器用于返回值：RAX。回到 executeLotsOfArguments 函数并改变函数的返回值，像这样：</p>\n<p><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">executeLotsOfArguments</span>(<span class=\"params\">one</span>: <span class=\"type\">Int</span>, <span class=\"params\">two</span>: <span class=\"type\">Int</span>, <span class=\"params\">three</span>: <span class=\"type\">Int</span>,</span><br><span class=\"line\">                                <span class=\"params\">four</span>: <span class=\"type\">Int</span>, <span class=\"params\">five</span>: <span class=\"type\">Int</span>, <span class=\"params\">six</span>: <span class=\"type\">Int</span>,</span><br><span class=\"line\">                                <span class=\"params\">seven</span>: <span class=\"type\">Int</span>, <span class=\"params\">eight</span>: <span class=\"type\">Int</span>, <span class=\"params\">nine</span>: <span class=\"type\">Int</span>,</span><br><span class=\"line\">                                <span class=\"params\">ten</span>: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;arguments are: <span class=\"subst\">\\(one)</span>, <span class=\"subst\">\\(two)</span>, <span class=\"subst\">\\(three)</span>, <span class=\"subst\">\\(four)</span>, <span class=\"subst\">\\(five)</span>, <span class=\"subst\">\\(six)</span>, <span class=\"subst\">\\(seven)</span>, <span class=\"subst\">\\(eight)</span>, <span class=\"subst\">\\(nine)</span>, <span class=\"subst\">\\(ten)</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Mom, what happened to the cat?&quot;</span></span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后 viewdidlaod 中调用</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> _ = self.execute<span class=\"constructor\">LotsOfArguments(<span class=\"params\">one</span>: 1, <span class=\"params\">two</span>: 2, <span class=\"params\">three</span>: 3, <span class=\"params\">four</span>: 4, <span class=\"params\">five</span>: 5, <span class=\"params\">six</span>: 6, <span class=\"params\">seven</span>: 7, <span class=\"params\">eight</span>: 8, <span class=\"params\">nine</span>: 9, <span class=\"params\">ten</span>: 10)</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>在 executeLotsOfArguments 中的某处创建一个断点。 再次生成并运行，然后等待函数停止执行。 接下来，在 LLDB 控制台中键入以下内容：</p>\n<ul>\n<li>(lldb) finish</li>\n</ul>\n<p>命令会结束完成函数的执行并停住调试器。这时，函数返回值会在 RAX 内。输入如下命令：</p>\n<ul>\n<li>(lldb) register read rax</li>\n</ul>\n<p>你将会看见如下输出</p>\n<p><figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">rax</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>x0000000100003760  <span class=\"string\">&quot;Mom, what happened to the cat?</span></span><br></pre></td></tr></table></figure><br />\n 了解 RAX 中的返回值非常重要，因为它将构成您将在后面的部分中编写的调试脚本的基础。</p>\n<h2 id=\"改变寄存器值\"><a class=\"anchor\" href=\"#改变寄存器值\">#</a> 改变寄存器值</h2>\n<p>为了巩固您对寄存器的理解，您将在一个已编译的应用程序中修改寄存器。<br />\n关闭 Xcode 和 Registers 项目。 打开终端窗口，然后启动 iPhone X Simulator。 通过键入以下内容来执行此操作：</p>\n<ul>\n<li>xcrun simctl list | grep &quot;iPhone X”</li>\n</ul>\n<p><figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Phone</span>: iPhone <span class=\"number\">12</span> Pro Max (<span class=\"number\">16</span>A6D554-<span class=\"number\">3</span>C10-<span class=\"number\">4</span>A67-<span class=\"number\">9039</span>-<span class=\"number\">31</span>B8BE33871F) (Shutdown)</span><br></pre></td></tr></table></figure></p>\n<p>UDID 就是你要找的。使用它并通过如下命令打开 iOS 模拟器（替换其中的 UDID 部分）：</p>\n<ul>\n<li>open /Applications/Xcode.app/Contents/Developer/Applications/Simulator.app --args -CurrentDeviceUDID 16A6D554-3C10-4A67-9039-31B8BE33871F</li>\n</ul>\n<p>保证模拟器已经启动而且在主屏幕上。你可以通过按下 Command + Shift + H 键回到主屏幕。一旦模拟器准备好了，回到终端窗口将 LLDB 绑定到 SpringBoard 程序上。</p>\n<ul>\n<li>lldb -n SpringBoard</li>\n</ul>\n<p>这样会将 LLDB 绑定到正在模拟器上运行的 SpringBoard 实例上！SpringBoard 就是在 iOS 上控制主屏幕的程序。</p>\n<p>一旦绑定，输入如下命令：</p>\n<ul>\n<li>(lldb) p/x @&quot;Yay! Debugging<br />\n 可以看到类似如下的输出：</li>\n</ul>\n<p><figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(__NSCFString *) $3 = <span class=\"number\">0x0000618000644080</span> @<span class=\"string\">&quot;Yay! Debugging!&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 注意下刚刚创建的这个 NSString 实例，因为很快你会用到它。现在，给 UILabel 的 setText: 方法设置一个断点：</p>\n<ul>\n<li>(lldb) b -[UILabel setText:]</li>\n<li>(lldb) breakpoint command add</li>\n</ul>\n<p>LLDB 会吐出一些输出且进入多行编辑模式。这个命令让你在刚刚打的断点处添加多个额外要执行的命令。输入如下，使用刚才的 NSString 地址替换下面的内存地址：</p>\n<p><figure class=\"highlight node-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">&gt;</span> <span class=\"language-javascript\">po $rdx = <span class=\"number\">0x0000618000644080</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span> <span class=\"language-javascript\"><span class=\"keyword\">continue</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span> <span class=\"language-javascript\"><span class=\"variable constant_\">DONE</span></span></span><br></pre></td></tr></table></figure><br />\n 回去重新看下你刚刚做的。你在 UILabel 的 setText: 方法上添加了一个断点。一旦遇到该方法，你就会用一个叫 Yay! Debugging! 的 NSString 实例替换 RDX--- 第三个参数。</p>\n<p>使用 continue 命令让调试器继续执行：</p>\n<ul>\n<li>(lldb) continue</li>\n</ul>\n<p>看看 SpringBoard 模拟器程序什么发生了改变。从下往上扫带出控制中心，观察改变的地方：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkujcb1fmaj30en0qk0xc.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkujaok2e0j30hf0v2aft.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkujb8rg0aj30k60tj787.jpg\" alt=\"\" /></p>\n<p>尽管这似乎是一个很酷的花招编程技巧，但它却展示了通过有限的汇编和寄存器的知识能够在程序内产生你之前没见过的大的变化。</p>\n<p>从调试的角度来看，这也很有用，因为您可以快速直观地验证 -[UILabel setText：] 在 SpringBoard 应用程序中的执行位置，并运行断点条件以查找设置特定 UILabel 文本的确切代码行。</p>\n<h2 id=\"寄存器和sdk\"><a class=\"anchor\" href=\"#寄存器和sdk\">#</a> 寄存器和 SDK</h2>\n<p>了解寄存器的工作方式以及应用程序的功能可以快速帮助您找到感兴趣的项目。举个简单的例子：通常，我会遇到一个 UIButton，并想知道 IBAction 和接收器，当我点击该按钮时会发生什么。在最高断点处，我可能会发疯…… 认识我自己，我通常在 UIView 或 UIViewController（也许是 UITableViewCell？）中包含 IBAction，并且通常使用某种名称为 “tapped” 的方法。<br />\n因此，也许下面的 LLDB 命令会起作用？</p>\n<ul>\n<li>(lldb) rb View(Controller|Cell)?\\s(?i).*tapped</li>\n</ul>\n<p>但是我错误地假设同事 / 其他开发人员正在使用与我相同的命名约定；这个想法行不通。相反，我知道，每当执行 IBAction 方法时，它都必须经过 UIApplication 单例，在该单例中，它将遍历响应者链来找到合适的接收者。为此，将调用 UIControl 的 - sendAction：to：forEvent：方法。<br />\n我可以在此方法上设置一个断点，并探索 sendAction：和 to：参数以查找 IBAction 正在执行的代码。<br />\n这个想法可以应用到您拥有和没有源代码的应用程序中。我经常发现，即使在我确实有源代码的应用程序中，使用此方法也更快，然后在应用程序中看到数千个 IBAction。</p>\n<p>... 但仅出于演示目的，让我们将其应用于 iOS Maps 应用程序。我对右上方按钮的名称和接收者感到好奇，该按钮可以直接定位用户的具体位置。<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkujmtqa2qj30dz0qoq82.jpg\" alt=\"\" /></p>\n<p>通过 LLDB 附加到 Maps 应用程序并为 -[UIControl sendAction：to：forEvent：] 设置断点后，很容易找到 UIButton 的名称和接收者。<br />\nsendAction：参数（RDX）将使用选择器，而 to：参数将是 IBAction 的接收器（RCX）。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkujqoz7vsj30x50j2q7u.jpg\" alt=\"\" /><br />\n用寄存器知识和轻按 UIButton 查找代码，这有多酷？</p>\n<h2 id=\"下一步\"><a class=\"anchor\" href=\"#下一步\">#</a> 下一步</h2>\n<p>好的，学了这么长时间，来休息下，看看你学到了什么：</p>\n<p>架构（X86）定义了一个调用规则，该规则规定了函数参数及其返回值的存储位置。</p>\n<ul>\n<li>在 Objective-C 中，RDI 寄存器是调用 NSObject 的引用，RSI 是选择器，RDX 是第一个参数，依此类推。</li>\n<li>在 Swift 中，RDI 是第一个参数，RSI 是第二个参数，依此类推，前提是 Swift 方法未使用动态分配。</li>\n<li>RAX 寄存器用于函数中的返回值，无论您使用的是 Objective-C 还是 Swift。</li>\n</ul>\n<p>您可以利用寄存器做很多事情。尝试浏览您没有源代码的应用；将为解决棘手的调试问题奠定良好的基础。</p>\n<p>尝试附加到 iOS Simulator 上的应用程序，并使用程序集，智能断点和断点命令绘制出 UIViewController 的生命周期。</p>\n",
            "tags": []
        }
    ]
}