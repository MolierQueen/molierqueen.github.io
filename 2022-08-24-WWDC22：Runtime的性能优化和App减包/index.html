<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Molier" href="https://oliverqueen.cn/rss.xml"><link rel="alternate" type="application/atom+xml" title="Molier" href="https://oliverqueen.cn/atom.xml"><link rel="alternate" type="application/json" title="Molier" href="https://oliverqueen.cn/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="iOS,WWDC2022"><link rel="canonical" href="https://oliverqueen.cn/2022-08-24-WWDC22%EF%BC%9ARuntime%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%92%8CApp%E5%87%8F%E5%8C%85/"><title>WWDC22：Runtime 的性能优化和 App 减包 - 译文 | Molier = Molier = Tomorrow is another day</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">WWDC22：Runtime 的性能优化和 App 减包</h1><div class="meta"><span class="item" title="创建时间：2022-08-24 15:04:39"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-08-24T15:04:39+08:00">2022-08-24</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>8.2k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>7 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Molier</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202301102017223.png"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/translate/" itemprop="item" rel="index" title="分类于 译文"><span itemprop="name">译文</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://oliverqueen.cn/2022-08-24-WWDC22%EF%BC%9ARuntime%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%92%8CApp%E5%87%8F%E5%8C%85/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Molier"><meta itemprop="description" content="Tomorrow is another day, iOS 开发 移动 App 博客 杂谈 随笔 相册"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Molier"></span><div class="body md" itemprop="articleBody"><p>本 Session 讲了为了让你的应用包体积更小，运行更快，启动速度更快，我们对 Swift 和 Objective-C 运行时做了怎样的优化。同时通过本 Session 你将发现如何通过高效的协议检查，更小的消息发送，以及优化后的 ARC 机制，来提高你的 App 性能。</p><p><img data-src="https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202301102018054.png" alt=""></p><p><span id="more"></span></p><p></p><div class="media-container"><div class="player" data-type="audio" data-src='["https://music.163.com/#/song?id=1929370102"]'></div></div><p></p><h2 id="前言"><a class="anchor" href="#前言">#</a> 前言</h2><p>WWDC2022 上苹果更新了 Xcode14，里面提到了一些相关的优化。其中讲了通过对 Swift 和 Objective-C 运行时做了一些优化，达到了包体积变得更小、运行速度更快，启动速度更快的目的。如果你是用 Xcode14 来构建 App，那么会有其中三点优化</p><ul><li>高效的协议检查（针对 Swift protocol check）</li><li>更快的消息发送机制（message send）</li><li>release 和 retain 调用优化（release &amp; retain）</li><li>Autorelease elision 的优化（自动释放省略）</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202301102019048.png" alt=""></p><p>当你用 Swift 或 Objective-C 编写代码时，其实是会经历三个个步骤。</p><ul><li>编码，通过 Xcode 编写代码</li><li>编译，使用了 Swift 和 Clang 编译器</li><li>运行，通过 Swift 和 Objective-C 运行时中完成</li></ul><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gp9rcbq1j215t0u0754.jpg" alt="image-20220823144936761"></p><p>此次的这些关键优化其实就是在第三步骤运行时来完成的，运行时嵌入在我们所有平台的操作系统中。编译器在构建时不能做的事情，运行时可以做。而此次所有的修改其实对于开发者来说是无感透明的，所以任何代码都不用改动，只要你使用 Xcode14 来进行打包编译，便会享受的这些优化点。</p><h2 id="swift协议检查protocol-checks"><a class="anchor" href="#swift协议检查protocol-checks">#</a> Swift 协议检查（Protocol checks）</h2><p>先来看一个例子！</p><p></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个协议</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">CustomLoggable</span> &#123;</span><br><span class="line">  <span class="comment">// 协议中定义一个属性 customString，只读属性</span></span><br><span class="line">    <span class="keyword">var</span> customLogString: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个log函数，参数为Any类型</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">log</span>(<span class="params">value</span>: <span class="keyword">Any</span>) &#123;</span><br><span class="line"><span class="comment">//如果value遵循CustomLoggable协议，就输出字符串</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> value <span class="operator">=</span> value <span class="keyword">as?</span> <span class="type">CustomLoggable</span> &#123;</span><br><span class="line">        <span class="built_in">debugPrint</span>(value.customLogString)        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="operator">...</span>        </span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个Event类型 遵循协议，并实现customLogString</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Event</span>: <span class="title class_">CustomLoggable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> date: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> customLogString: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(<span class="keyword">self</span>.name)</span>, on <span class="subst">\(<span class="keyword">self</span>.date)</span>&quot;</span>    </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>看上面代码，因为 log 函数的参数需要输出字符串，所以在输出前要先判断这个 value 是否遵循 CustomLoggable 协议，Swift 是静态语言，所以一般来说这样的检查都是发生在编译时期。但是编译器不一定能拿到足够的协议元数据信息来完成检查。比如这里并不知道每次传入的 Any 类型是哪个确定类型，也就无法确定是否遵循 <code>CustomLoggable</code> 协议。所以这种检查常常发生运行时，系统借助计算好的协议检查元数据 (protocol check metadata)，运行库知道这个特殊对象是否符合协议。</p><p>这些元数据的构建虽然大部分在编译期间，但是还是有一部分是要在运行时完成，比如上面的例子，而且一个项目中肯定不止有一个协议，所以随着协议越多运行时的效率就越低，对于用户来说这个时间大部分是启动时间，所以用户感知为启动时间变长。而 Xcode14 新推的的 Swift Runtime 解决了这个问题，只要你是用 Xcode14 编译且运行在 iOS16 及以上版即可。</p><p>按照苹果的说法，他们会把 <code>是否遵循协议</code> 的这个判断前置到 build 时期，也就是把 <code>协议元数据计算</code> 的步骤前置到 build 中，具体就是他把这些操作放在 App 可执行文件和启动时任何动态库的 dyld 闭包的一部分</p><p>为什么这样做可以节省启动时间，需要先了解下 app 启动流程，需要一个知识背景 <code>从iOS11开始dyld3被加入，iOS13第三方库也开始使用dyld3加载。</code> 所以我们要看下 dyld3 的加载流程</p><p><img data-src="https://upload-images.jianshu.io/upload_images/2438680-b5edfa4c2bcdb205.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1044/format/webp" alt="img"></p><p><em>dyld 3</em> 主要包含了两个过程 进程外（启动前）和进程内（启动后），我们来看启动前做了那些事情</p><ul><li>进程外 <em>Mach-O</em> 分析器和编译器 （<em>out-of-process mach-o parser</em>）<br><em>dyld 3</em> 中将采用提前写入把结果数据缓存成文件的方式构成一个 <em>lauch closure</em>（可以理解为缓存文件）</li><li>分析依赖库</li><li>执行符号查找</li><li><em>Write closure</em> 缓存服务 (<em>launch closure cache</em> )<br>系统程序的 <em>closure</em> 直接内置在 <em>shared cache</em> 中，而对于第三方 APP，将在 APP 安装或更新时生成，这样就能保证 <em>closure</em> 总是在 APP 打开之前准备好。说白了就是把上面做的结果全都缓存起来</li></ul><p>综上看来以前需要在 in-process 中做的事情，现在在 out-of-process 就可以完成，启动时或者运行时直接读取缓存数据即可，加快了启动速度和运行时的性能。其实在笔者看来当我们下载或者更新 App 的时候 App 上的进度条其实是分两部分 <code>正在下载</code> 和 <code>正在安装</code> ，此次的优化可能略微提高安装的时长来降低启动速度，提高运行时性能。</p><p><code>on apps that rely heavily in Swift, this could add up to half the launch time</code> 如果有条件的同学可以试下是否可以提高这么多的启动耗时。</p><h2 id="消息发送优化message-send"><a class="anchor" href="#消息发送优化message-send">#</a> 消息发送优化（Message send）</h2><p>直接抛结果，苹果这边给到的数据是使用 Xcode14 编译打包的数据可以让 ARM64 上发送消息消耗从 12 字节降低到 8 字节，二进制大小也有 2% 的降低，也就是苹果对包大小和性能都做了优化，默认是同时开启的，由苹果来平衡两者的关系，当然也可以使用 <code>objc_stubs_small</code> 来仅仅优化包大小。</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5grqpljrej215t0u0aax.jpg" alt="image-20220823161510950"></p><p>下面我们看下是怎么优化的，同样使用官方代码举例</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个日历对象</span><br><span class="line">NScalendar *cal = [self makeCalendar];</span><br><span class="line"></span><br><span class="line">// 声明一个日期对象并赋值</span><br><span class="line">NSDateComponents *dateComponents = [[NSDateComponents alloc] init];</span><br><span class="line">dateComponents.year = 2022;</span><br><span class="line">dateComponents.month = 2022;</span><br><span class="line">dateComponents.day = 2022;</span><br><span class="line">S</span><br><span class="line">// 把日期转换为date</span><br><span class="line">NSDate *theDate = [cal dateFromComponents: dateComponents];</span><br><span class="line"></span><br><span class="line">// 返回date</span><br><span class="line">return theDate;</span><br></pre></td></tr></table></figure><p></p><p>大家知道 OC 调用方法最终会走到 <code>_objc_msgSend</code> ，所以上面代码不算最终的 return，会走 7 个 <code>_objc_msgSend</code> ，其中每一个都需要一条指令来调用就是 bl 如下图</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gsa0ef9kj20n00gidgx.jpg" alt="image-20220823163343886"></p><p>该函数定义为 <code>Id objc_msgSend(id self, SEL _cmd, ...)</code> ，参数定义为 self 是函数的调用方，SEL 为具体调用哪个函数，具体的方法查找流程就不在这里赘述。</p><p>我们拿其中具体的一个函数调用来分析</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSDate *theDate = [cal dateFromComponents: dateComponents]; </span><br></pre></td></tr></table></figure><p></p><p>比如这个函数调用，转化为 mesagesend 的时候就变成这样</p><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(cal, @selector(dateFromComponents))</span><br></pre></td></tr></table></figure><p></p><p>为了告诉运行时调用哪个方法，我们必须传递一个 Selector 给这些 objc_msgSend 调用，就如上图的 <code>@selector(dateFromComponents)</code></p><p>我们再来看 <code>Id objc_msgSend(id self, SEL _cmd, ...)</code> 执行后他是怎么执行汇编指令的。</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使用adrp找到该方法的地址   消耗4字节</span><br><span class="line">adrp x1, [selector &quot;dateFromComponents&quot;]  </span><br><span class="line"></span><br><span class="line">// 将 地址加载到X1寄存器中  消耗4字节</span><br><span class="line">ldr  x1, [x1, selector &quot;dateFromComponents&quot;] </span><br><span class="line"></span><br><span class="line">// 执行bl指令跳转到该方法并执行  消耗4字节</span><br><span class="line">bl _objc_msgSend</span><br></pre></td></tr></table></figure><p></p><p>从上面的代码看出每次执行方法调用都会 走以上三个步骤，每个步骤消耗 4 字节 一共消耗 12 字节，而前两步是准备 selector，任何一次方法调用都会执行他，目前的策略是每调一个方法都会生成上面三步，那么此时优化空间就来了。</p><p>因为这里存在相同的代码（前两步）， <code>我们可以考虑共享它，并且只在每个 selector 中触发它一次，而不是每次发送消息时都生成这段指令代码</code> 。所以我们可以把这部分相同代码提取出来，放到一个小助手函数中 (helper function), 并调用该函数。通过使用同一 selector 进行多次调用 (通过传递参数不同，内部指令是相同的，现在封装成一个存根函数，以前是散落在各个 _objc_msgSend 调用处)，我们可以保存所有这些指令字节。所以可以理解为 <code>把前两步封装一下</code></p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gvtbfnh1j20n00git9h.jpg" alt="image-20220823183604633"></p><p>所以原来的调用就变成了</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bl _objc_msgSend$dateFromComponents 4字节</span><br><span class="line">bl _objc_msgSend    4字节</span><br></pre></td></tr></table></figure><p></p><p>这也就是苹果说的从 12 字节优化到 8 字节，其中 <code>_objc_msgSend$dateFromComponents</code> 也被称为 <code>selector stub 存根函数</code></p><p>同样 <code>_objc_msgSend</code> 本身也有一个存根函数写法</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gw1kpzuzj20n00giwfd.jpg" alt="image-20220823184401200"></p><p>这样一来我们现在就有两个存根函数</p><ul><li>_objc_msgSend$dateFromComponents:</li><li>_objc_msgSend:</li></ul><p>这两个函数封装了一些通用的东西，共享了最多的代码，使代码尽可能的小，但是这样带来的不足是我需要连着两个 bl 跳转，这对操作系统来说开销较大。所以为了平衡包体积和性能，我们可以使用下面这种方法来提升这一点。我们可以把前面调用的两个存根函数封装成一个 (都封装成_objc_msgSend$dateFromComponents)，这样，我们可以使代码更紧凑，不需要那么多调用。如下图这样</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gwei63esj20bo07u74l.jpg" alt="image-20220823185626349"></p><p>这就回到了之前的问题，你可以通过 <code>_objc_stubs_small</code> 标记了只降低包大小，或者采用默认的方式让系统自动平衡，两者的区别在汇编层面就体现在如下图</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gwg7hnugj20n00gidhc.jpg" alt="image-20220823185804687"></p><p>综上：这就是 Meesage send 占用从 12 bytes 降低到 8 bytes 和二进制大小下降 12% 的原因</p><h2 id="retain-and-release"><a class="anchor" href="#retain-and-release">#</a> Retain and release</h2><p>这个优化是苹果这边使 Retain and release 的开销更小，苹果的说法是 Retain and release 的调用开销从 8 字节降低到 4 字节，同时包体积也会有 2% 的优化</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gwkqxaenj20n00gidg9.jpg" alt="image-20220823190226429"></p><p>我们知道 ARC 相比于 MRC 是开发者不需要再写 retain、release 这些代码，其实并不是不需要，而是编译器帮我们自动在需要的位置插入了这些代码，所以换句话说他们还是存在的，只是你看不到也不用在关心他们。</p><p>还是拿之前的例子来说</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Retain/release calls inserted by ARC</span><br><span class="line">NScalendar *cal = [self makeCalendar]; // bl    _objc_retain</span><br><span class="line"></span><br><span class="line">NSDateComponents *dateComponents = [[NSDateComponents alloc] init]; // bl    _objc_retain</span><br><span class="line">dateComponents.year = 2022; </span><br><span class="line">dateComponents.month = 2022;</span><br><span class="line">dateComponents.day = 2022;</span><br><span class="line"></span><br><span class="line">NSDate *theDate = [cal dateFromComponents: dateComponents]; // bl    _objc_retain</span><br><span class="line">return theDate;</span><br><span class="line">// bl    _objc_release </span><br><span class="line">// bl    _objc_release </span><br><span class="line">// bl    _objc_release </span><br></pre></td></tr></table></figure><p></p><p>在变量创建的时候我们使用 retain 来增加的他的引用计数不被销毁，在方法结束后我们使用 release 来销毁不需要的变量，这也是 iOS 的内存管理机制。在 ARC 下这些都是编译器我们插入的代码，我们无需关心。</p><p>retain 和 release 都是 C 语言的函数，他们携带一个参数就是被操作的对象，同时他遵循 C 语言的 ABI，所以当你调用这些方法的时候系统还会为你做一些额外的事情，比如下图中的 mov 操作，而这些操正是我们优化的用武之地，通过自定义调用重新约定 retain/release 接口，我们可以根据对象指针的位置，适当的使用正确的变量，这样就可以不用移动它。简单的说， <code>就是修改了底层 ABI</code> 。</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gwylzjkuj20n00giab1.jpg" alt="image-20220823191546398"></p><p>我们是怎么做的优化呢？看下之前的流程，我们用下面这行代码举例</p><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objc_release(dateComponents); </span><br><span class="line"><span class="comment">// mov  x0, x20                    消耗4 字节                                                                                                                                                           </span></span><br><span class="line"><span class="comment">// bl    _objc_release         消耗4字节</span></span><br></pre></td></tr></table></figure><p></p><p>流程为</p><ul><li>先执行 mov 把副本地址（X20, 也就是对象的地址）存到寄存器 x0</li><li>然后 bl 跳转到 <code>_objc_release</code> 函数进行释放</li></ul><p>根据之前讲的每个指令消耗 4 字节，所以这里消耗 8 字节</p><p>我们修改 ABI 之后其省掉调用 mov 指令 然后原本跳转到_objc_release 函数 改为跳转到 <code>_objc_release_x20</code> 函数，而 mov 的指令放到 C 语言更底层的 ABI 里面去做，你可以理解为 <code>我们封装了一个新的retain、release函数，你只要传入一个寄存器地址我就去更底层的地方完成mov操作，所以效率更高了</code> 。现在因为只用执行一条指令，所以内存消耗为 4 字节。现在的流程看起来为</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gx83ebs8j20n00giab9.jpg" alt="image-20220823192452605"></p><p>这么看来我们代码里大量的 release 和 retain 都经过这样的样的优化所以整体的二进制包降低 2% 同时调用内存消耗游 8 字节变为 4 字节，同时 ABI 接口修改，去除冗余 mov 指令调用，下沉到 ABI。 <code>由于 ABI 是内嵌系统</code> ，这里新增 mov 指令占用可以忽略不计。</p><p><code>Apple 果然是坚持用户体验优先，为了更好体验不惜修改 c 的 ABI</code></p><h2 id="autorelease-elision自动释放省略优化"><a class="anchor" href="#autorelease-elision自动释放省略优化">#</a> Autorelease elision（自动释放省略优化）</h2><p>iOS 中除了使用 release 之外还有另一个 就是 autorelease 自动释放机制，同样在这个地方苹果也做了自动释放省略的优化让自动释放机制效率更高。我们来看下面这个例子</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Return Value Autoreleases </span><br><span class="line"></span><br><span class="line">theWWDCDate = [event getWWDCDate];</span><br><span class="line"></span><br><span class="line">-(NSDate*)getWWDCDate &#123;</span><br><span class="line">    ...</span><br><span class="line">    return theDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>创建一个临时对象 (theDate)，并将其返回给调用方 (event)。 <code>getWWDCDate()</code> 方法中返回临时的 theDate，然后调用完成 (返回 theDate 之后，getWWDCDate 就调用完成)。这时调用方（event）将其保存到自己的变量中（theWWDCDate 中）。</p><p>根据系统插入 retain 和 release 的机制来说应该是这样的，但是明显 retain 处不能进行 release，因为我需要吧 theDate 返回回去，如果这里释放了我就没办法呢返回了。</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gy19928nj20n00gi3yz.jpg" alt="image-20220823195254398"></p><p>因此，为了解决上述问题，需要使用一个特殊的约定用来返回这个临时返回值。这就引入了 Autorelease，这样调用者能够 retain 它。autorelease 在这里保证在调用方可以正常返回该值，而不被提前释放，延长释放生命周期。你之前可能看到过 autorelease 和 autoreleasePools：其实这是一种将 release 操作推迟到稍后某个时间的方法。所以上面的代码改为 Autorelease</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Return Value Autoreleases </span><br><span class="line"></span><br><span class="line">theWWDCDate = [[event getWWDCDate] retain];</span><br><span class="line"></span><br><span class="line">-(NSDate*)getWWDCDate &#123;</span><br><span class="line">    ...</span><br><span class="line">    return [theDate autorelease]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>系统并不知道他在什么时候会被释放，反正只要不在 retain 的时候释放就行，所以我在 retain 的时候先打个标记，标记他之后可能会被释放。但是这样的操作目前会带来一些开销，其实就是 <code>我虽然打了release标记，但是我明明一会还要retain，没必要多此一举</code> ，所以基于此我们之前引入了 <code>Autorelease elision</code> 来减少这部分开销（ <code>如果Autorelease后紧接一个retain我就都不做了</code> ）。我们先从汇编层面看下 Autorelease elision 做了什么</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gy8n9wnzj20n00giwf7.jpg" alt="image-20220823195959365"></p><p>提炼出以下代码</p><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// What the compiler emits</span></span><br><span class="line"> bl    _getWWDCDate </span><br><span class="line"> mov   x29, x29</span><br><span class="line"> bl    _objc_retainAutoreleasedReturnValue</span><br><span class="line"></span><br><span class="line"> b    _objc_autoreleaseReturnValue   <span class="comment">// autorelease -&gt; runtime -&gt; _objc_autoreleaseReturnValue</span></span><br></pre></td></tr></table></figure><p></p><p>其实就是以下步骤</p><ul><li>当我们返回值调用 Autorelease 时候系统会调用 <code>_objc_autoreleaseReturnValue</code> 来返回一个 <code>autoreleased value</code></li><li>执行 Autorelease 后编译器会添加个标记 <code>mov x29, x29</code> 而这句指令在实际运行中这个指令会变为二进制的形式变为 <code>0xAA1D03FD</code></li><li>后续的操作就运行时会先判断是否有对应的标记 <code>0xAA1D03FD</code> ，如果有，这意味着编译器告诉 runtime, 我们将返回一个已经被标记，但是将立即被持有（retain） 的临时变量，后面就不需要再 retain 操作了</li></ul><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5h056kleej20n00gigm5.jpg" alt="image-20220823210550374"></p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE bool </span><br><span class="line">callerAcceptsOptimizedReturn(const void *ra)</span><br><span class="line">&#123;</span><br><span class="line">    // fd 03 1d aa    mov fp, fp</span><br><span class="line">    // arm64 instructions are well-aligned</span><br><span class="line">    if (*(uint32_t *)ra == 0xaa1d03fd) &#123;</span><br><span class="line">        return true;</span><br><span class="line">        // 返回true 需要优化 把release、rentain删掉</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>说白了就是在返回值身上调用 <code>objc_autoreleaseReturnValue</code> 方法时，runtime 将这个返回值 object 标记（储存在 TLS 中），然后直接返回这个 object（不调用 autorelease）；同时，在外部接收这个返回值的 <code>objc_retainAutoreleasedReturnValue</code> 里，发现有之前的标记（TLS 中正好存了这个对象），那么直接返回这个 object（清楚之前的标记且不再调用 retain）。</p><p>注意：TLS 相关的含义可以参考 [这里](<span class="exturl" data-url="aHR0cDovL3NlYW5jaGVuc2UuZ2l0aHViLmlvLzIwMTgvMDkvMjAvZWFybGdyZXktc291cmNlLWNvZGUtcmVhZC0xLyNUTFM=">EarlGrey 源码阅读（一） | SeanChense</span>)</p><p>但是这里有一个问题，以二进制的形式来加载代码并不是很常见，而且我们不但要加载它还要比较他尤其在 CPU 上并不是最优策略，所以这里还是有开销的，因此我们看下如何优化。</p><p>同样执行流程，当执行完 <code>_objc_autoreleaseReturnValue</code> 函数时候我们会获得一个返回地址，这个地址是一个指针，指向了被标记为 Autorelease 的对象。然后代码继续执行到 <code>_objc_retainAutoreleasedReturnValue</code> 这里要进行 reatin，而被 reatain 的变量地址我们也可以拿到，所以只要比较这两个指针即可，这样一来我们也不再需要 mov 操作</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5h0ws62g0j20n00gidg3.jpg" alt="image-20220823213224122"></p><p>优化点</p><ul><li>把原来的比较二进制数据改为比较指针。速度更快效率更高</li><li>减少 mov 指令 减少 4 字节，二进制大小预计降低 2%</li></ul><h2 id="总结"><a class="anchor" href="#总结">#</a> 总结</h2><p>这就是 Xcode14+iOS16 的编译期间优化，可以看出苹果也在帮我们完成 OKR 减少包体积，提高启动速度，增加代码执行效率，同时也能看出苹果在追求极致用户体验道路上所做的事情。本文部分翻译自<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL3ZpZGVvcy9wbGF5L3d3ZGMyMDIyLzExMDM2My8="> Improve app size and runtime performance</span>，同时也添加了自己的思考。</p><div class="tags"><a href="/tags/iOS/" rel="tag"><i class="ic i-tag"></i> iOS</a> <a href="/tags/WWDC2022/" rel="tag"><i class="ic i-tag"></i> WWDC2022</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-12-30 22:16:08" itemprop="dateModified" datetime="2023-12-30T22:16:08+08:00">2023-12-30</time> </span><span id="2022-08-24-WWDC22：Runtime的性能优化和App减包/" class="item leancloud_visitors" data-flag-title="WWDC22：Runtime 的性能优化和 App 减包" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Molier 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Molier 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Molier <i class="ic i-at"><em>@</em></i>Molier</li><li class="link"><strong>本文链接：</strong> <a href="https://oliverqueen.cn/2022-08-24-WWDC22%EF%BC%9ARuntime%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%92%8CApp%E5%87%8F%E5%8C%85/" title="WWDC22：Runtime 的性能优化和 App 减包">https://oliverqueen.cn/2022-08-24-WWDC22：Runtime的性能优化和App减包/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022-06-13-WWDC2022-iOS%E7%AF%87%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;cdn.cdnjson.com&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;e6c9d24egy1h6c5cnka7dj218m0t40t8.jpg" title="WWDC2022-iOS篇完全解析"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> iOS 开发</span><h3>WWDC2022-iOS篇完全解析</h3></a></div><div class="item right"><a href="/iPa%E9%80%86%E5%90%91%E4%B9%8B%E8%B7%AF/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;cdn.cdnjson.com&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;008vxvgGgy1h861sxytvij30ka0aoq3b.jpg" title="iPa逆向之路"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> iOS 开发</span><h3>iPa逆向之路</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#swift%E5%8D%8F%E8%AE%AE%E6%A3%80%E6%9F%A5protocol-checks"><span class="toc-number">2.</span> <span class="toc-text">Swift 协议检查（Protocol checks）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E4%BC%98%E5%8C%96message-send"><span class="toc-number">3.</span> <span class="toc-text">消息发送优化（Message send）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#retain-and-release"><span class="toc-number">4.</span> <span class="toc-text">Retain and release</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#autorelease-elision%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E7%9C%81%E7%95%A5%E4%BC%98%E5%8C%96"><span class="toc-number">5.</span> <span class="toc-text">Autorelease elision（自动释放省略优化）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2018-01-24-iOS%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/" rel="bookmark" title="iOS端自动内存泄漏检测工具">iOS端自动内存泄漏检测工具</a></li><li><a href="/2018-05-08-RX-Swift-Study-One/" rel="bookmark" title="关于RxSwift的一点理解">关于RxSwift的一点理解</a></li><li class="active"><a href="/2022-08-24-WWDC22%EF%BC%9ARuntime%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%92%8CApp%E5%87%8F%E5%8C%85/" rel="bookmark" title="WWDC22：Runtime的性能优化和App减包">WWDC22：Runtime的性能优化和App减包</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Molier" data-src="/images/avatar.jpeg"><p class="name" itemprop="name">Molier</p><div class="description" itemprop="description">iOS 开发 移动 App 博客 杂谈 随笔 相册</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">40</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">6</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">53</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item 新浪微博" data-url="aHR0cHM6Ly93ZWliby5jb20vemhhbmduaW5naGFvP3JlZmVyX2ZsYWc9MTAwNTA1NTAxMF8=" title="https:&#x2F;&#x2F;weibo.com&#x2F;zhangninghao?refer_flag&#x3D;1005055010_"><i class="ic i-weibo"></i></span> <span class="exturl item jianshu" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vdS9mZDIxZjQxZmI1MjI=" title="https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;fd21f41fb522"><i class="ic i-link"></i></span> <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL01vbGllclF1ZWVu" title="https:&#x2F;&#x2F;github.com&#x2F;MolierQueen"><i class="ic i-github"></i></span> <span class="exturl item juejin" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vdXNlci81ODZjNjI0YmFjNTAyZTEyZDYzMTU0NWY=" title="https:&#x2F;&#x2F;juejin.im&#x2F;user&#x2F;586c624bac502e12d631545f"><i class="ic i-link"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjM3MTA5OTY5NEBxcS5jb20=" title="mailto:371099694@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>朋友们</a></li></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022-06-13-WWDC2022-iOS%E7%AF%87%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/iPa%E9%80%86%E5%90%91%E4%B9%8B%E8%B7%AF/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/2022-05-26-Apple%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/" title="Apple登录流程详解">Apple登录流程详解</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/2018-06-19-MusicAbout/" title="关于实现唱吧清唱功能的理解">关于实现唱吧清唱功能的理解</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/note/" title="分类于 闲谈">闲谈</a></div><span><a href="/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E9%80%89%E6%8B%A9/" title="程序员如何进阶">程序员如何进阶</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/2021-07-27-%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E4%B8%80%E5%9C%BAPresentation/" title="如何做好一场Presentation">如何做好一场Presentation</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/2018-01-24-%E8%AE%B0%E4%B8%80%E6%AC%A1Runtime-Hook%E7%9A%84%E9%97%AE%E9%A2%98/" title="记一次Runtime Hook的问题">记一次Runtime Hook的问题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/2018-01-23-%E5%9C%A8iOS11%E4%B8%8Bapp%E5%9B%BE%E6%A0%87%E5%8F%98%E7%A9%BA%E7%99%BD%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" title="在iOS11下app图标变空白的问题解决">在iOS11下app图标变空白的问题解决</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机基础">计算机基础</a></div><span><a href="/2020-11-21-%E6%B1%87%E7%BC%96%E5%92%8C%E5%86%85%E5%AD%98/" title="汇编和内存">汇编和内存</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/2018-01-24-%E5%9C%A8iOS%E5%B7%A5%E7%A8%8B%E4%B8%ADCocoapods%E7%9A%84%E4%BD%BF%E7%94%A8/" title="在iOS工程中Cocoapods的使用">在iOS工程中Cocoapods的使用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/2018-08-22-GitFlow/" title="GitFlow流程">GitFlow流程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/2021-05-05-iOS-Crash%E9%98%B2%E6%8A%A4%E4%BD%A0%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%B0%B1%E5%A4%9F%E4%BA%86-%E4%B8%8B%E7%AF%87/" title="iOS Crash防护你看这个就够了-下篇">iOS Crash防护你看这个就够了-下篇</a></span></li></ul></div></div><div class="status"><div class="copyright">&copy; 1992 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-"></i> </span><span class="author" itemprop="copyrightHolder">Molier @ Molier</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">217k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">3:18</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022-08-24-WWDC22：Runtime的性能优化和App减包/",favicon:{show:"MolierBolg",hide:"MolierBolg"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>