{
    "version": "https://jsonfeed.org/version/1",
    "title": "Molier • All posts by \"webview\" tag",
    "description": "iOS 开发 移动App 博客 杂谈 随笔 相册",
    "home_page_url": "https://oliverqueen.cn",
    "items": [
        {
            "id": "https://oliverqueen.cn/2018-01-24-NSURLProtocol%E5%AF%B9WKWebView%E7%9A%84%E5%A4%84%E7%90%86/",
            "url": "https://oliverqueen.cn/2018-01-24-NSURLProtocol%E5%AF%B9WKWebView%E7%9A%84%E5%A4%84%E7%90%86/",
            "title": "NSURLProtocol对WKWebView的处理",
            "date_published": "2018-01-24T04:24:06.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>之前写过一篇<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5qaWFuc2h1LmNvbS9wL2NkNGMxYmYxZmQ1Zg==\">文章</span>是关于基于 NSURLProtocol 做的 DNS 解析，其中对 NSURLProtocol 也有了简单的介绍，我们都知道他可以拦截所有基于 URL Loading System 中的请求，但是对于 WKWebview 里面所发出的请求即使他是 http/https 也无能为力，先来简单的了解下 WKWebView.<br />\n<span id=\"more\"></span></p>\n<h5 id=\"wkwebview\"><a class=\"anchor\" href=\"#wkwebview\">#</a> WKWebview</h5>\n<p>iOS8 以后，苹果推出了新框架 Webkit，提供了替换 UIWebView 的组件 WKWebView。各种 UIWebView 的问题没有了，速度更快了，占用内存少了，一句话，WKWebView 是 App 内部加载网页的最佳选择！我们做开发最关系的是内存问题，基本上网上所有的资料都在说 WKWebview 的内存占用会更少，但是到底少了多少我这边做了下测试，同样是加载 163 的首页</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k80vn82j3087036wem.jpg\" alt=\"使用UIWebView的内存\" /><br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k8agxuoj308002smx3.jpg\" alt=\"使用WKWebview的内存\" /></p>\n<p>从上图看出内存大概能优化百分之八十左右，而且从网页的滑动上也确实有所改善。这么明显的性能提升但是苹果并没有完全放弃 UIWebView 也一定有他的道理，就拿本文要讲的 NSURLProtocol 拦截请求来说，WKWebview 的兼容并不 UIWebView 好，还需要开发者做一些操作。</p>\n<h5 id=\"webkit源码分析\"><a class=\"anchor\" href=\"#webkit源码分析\">#</a> WebKit 源码分析</h5>\n<p>由于 WKWebview 是基于 webkit 内核来做的，所以我们在使用的时候需要导入一个这样的东西。<br />\n#import &lt;WebKit/WebKit.h&gt;<br />\n 通过这个我们可以猜到 WKWebview 中所有的请求以及一些逻辑肯定走的都是 webkit 里面的东西，所以他对于网页的加载之之类的操作也不会走系统本省的 URL Loading System，这么说来他的请求不能被 NSURLProtocol 拦截也是理所当然的了。不过 WKWebview 是否真的和 NSURLProtocol 一点关系都没有还需要去研究，幸好 webkit 是开源的，github 上很容易找到<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL1dlYktpdC93ZWJraXQ=\">源码</span>（大小大概是 1G 多点的 zip，花了我将近一天时间来看）。拉下代码直接搜索 NSURLProtocol，看看有没有有关的信息<br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k8kigkxj30i80t0tg8.jpg\" alt=\"搜索结果\" /></p>\n<p>看来的确是有和 NSURLProtocol 有关系，后面通过断点的调用栈中也找到了<br />\n + [NSURLProtocol canInitWithRequest:]<br />\n 这样的字样，再通过网上查一些资料也证实了我的猜想，其实 WKWebview 在一开始时候是会调用到 NSURLProtocol 中的入口方法 canInitWithRequest 的，但是就没有然后了，也就是说 WKWebview 是和 NSURLProtocol 有一定关联，只是在 NSURLProtocol 的入口处返回 NO 所以导致 NSURLProtocol 不接管 WKWebview 的请求。我们点进 webkit 源码中的 CustomProtocol 可以看到，整体的结构我们都差不多，但是我注意到每个 CustomProtocol 的入口函数都有这样一个判断：<br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k8wgu6tj30yg04x40p.jpg\" alt=\"入口函数1\" /></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k93edfij30rw05ijsb.jpg\" alt=\"入口函数2\" /><br />\n (粉色的可以暂时认定为是它内部的一个 custom 字符串) 通过这个可以猜想，WKWebview 并不是不走 NSURLProtocol，而是需要满足他的一个规则，他才会在入口函数这里返回 YES 来给你放行，这个规则便是你所请求的 URL 的 Scheme 要和它内部配置的 CustomScheme 相同。不过这里有一个疑问，苹果在使用 webkit 时候为什么会把 http/https 这样大众化的 scheme 过滤掉，看来他是不建议开发者来使用 NSURLProtocol。接下来我们来看这个 CustomScheme，既然苹果内部规定好的那么一定能通过某种方式来注册一个自己的 scheme，实在不行就 hook 嘛。通过翻他的源码发现最终都指向一句代码</p>\n<pre><code>[WKBrowsingContextController registerSchemeForCustomProtocol:testScheme];\n</code></pre>\n<p>方法实现为<br />\n + (void) registerSchemeForCustomProtocol:(NSString *) scheme<br />\n{<br />\nWebProcessPool::registerGlobalURLSchemeAsHavingCustomProtocolHandlers(scheme);<br />\n}<br />\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void WebProcessPool::<span class=\"built_in\">registerGlobalURLSchemeAsHavingCustomProtocolHandlers</span>(const String&amp; urlScheme)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!urlScheme)</span><br><span class=\"line\">        return;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">globalURLSchemesWithCustomProtocolHandlers</span>()<span class=\"selector-class\">.add</span>(urlScheme);</span><br><span class=\"line\">    for (auto* processPool : allProcessPools())</span><br><span class=\"line\">        processPool-&gt;<span class=\"built_in\">registerSchemeForCustomProtocol</span>(urlScheme);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 通过方法名字可以看出这个就是那个向 webkit 注册 CustomScheme 的方法，只要我们在注册完我们自己的 CustomProtocol 之后在调用该方法应该就可以了。通过他的源码也进一步印证了我的猜想 (他也是这么写的)<br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k9nobq7j30yg04tmzt.jpg\" alt=\"webkit源码\" /></p>\n<h5 id=\"具体实施\"><a class=\"anchor\" href=\"#具体实施\">#</a> 具体实施</h5>\n<p>找到了方法就要去实施，不过因为 registerSchemeForCustomProtocol 是 WKBrowsingContextController 的类方法，所以只能用 WKBrowsingContextController 去调用，但是在 webkit 的头文件发现 WKBrowsingContextController 并没有开放出来，所以我们采用 NSClassFromString 和 NSSelectorFromString 方法来拿到类和对应的方法，整体代码如下<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注册自己的protocol</span></span><br><span class=\"line\">[<span class=\"built_in\">NSURLProtocol</span> registerClass:[CustomProtocol <span class=\"keyword\">class</span>]];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建WKWebview</span></span><br><span class=\"line\"><span class=\"built_in\">WKWebViewConfiguration</span> * config = [[<span class=\"built_in\">WKWebViewConfiguration</span> alloc] init];</span><br><span class=\"line\"><span class=\"built_in\">WKWebView</span> * wkWebView = [[<span class=\"built_in\">WKWebView</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, [<span class=\"built_in\">UIScreen</span> mainScreen].bounds.size.width, [<span class=\"built_in\">UIScreen</span> mainScreen].bounds.size.height) configuration:config];</span><br><span class=\"line\">[wkWebView loadRequest:webViewReq];</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:wkWebView];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注册scheme</span></span><br><span class=\"line\">Class cls = <span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@&quot;WKBrowsingContextController&quot;</span>);</span><br><span class=\"line\">SEL sel = <span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@&quot;registerSchemeForCustomProtocol:&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> ([cls respondsToSelector:sel]) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过http和https的请求，同理可通过其他的Scheme 但是要满足ULR Loading System</span></span><br><span class=\"line\">    [cls performSelector:sel withObject:<span class=\"string\">@&quot;http&quot;</span>];</span><br><span class=\"line\">    [cls performSelector:sel withObject:<span class=\"string\">@&quot;https&quot;</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n  实现效果。我将网页中所有的图片替换成了柴犬图片</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6ka7rv18g307o0ds7wl.gif\" alt=\"效果\" /></p>\n<h5 id=\"值得注意\"><a class=\"anchor\" href=\"#值得注意\">#</a> 值得注意</h5>\n<ul>\n<li>关于私有 API</li>\n</ul>\n<p>因为 WKBrowsingContextController 和 registerSchemeForCustomProtocol 应该是私有的所以使用时候需要对字符串做下处理，用加密的方式或者其他就可以了，实测可以过审核的。</p>\n<ul>\n<li>关于 post 请求<br />\n大家会发现拦截不了 post 请求 (拦截到的 post 请求 body 体为空)，这个其实和 WKWebview 没有关系，这个是苹果为了提高效率加快流畅度所以在 NSURLProtocol 拦截之后索性就不复制 body 体内的东西，因为 body 的大小没有限制，开发者可能会把很大的数据放进去那就不好办了。我们可以采取 httpbodystream 的方式拿到 body，这个在之前的<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5qaWFuc2h1LmNvbS9wL2NkNGMxYmYxZmQ1Zg==\">文章</span>也有提过</li>\n</ul>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark -</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark 处理POST请求相关POST  用HTTPBodyStream来处理BODY体</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSMutableURLRequest</span> *)handlePostRequestBodyWithRequest:(<span class=\"built_in\">NSMutableURLRequest</span> *)request &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableURLRequest</span> * req = [request mutableCopy];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([request.HTTPMethod isEqualToString:<span class=\"string\">@&quot;POST&quot;</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!request.HTTPBody) &#123;</span><br><span class=\"line\">            uint8_t d[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">            <span class=\"built_in\">NSInputStream</span> *stream = request.HTTPBodyStream;</span><br><span class=\"line\">            <span class=\"built_in\">NSMutableData</span> *data = [[<span class=\"built_in\">NSMutableData</span> alloc] init];</span><br><span class=\"line\">            [stream open];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ([stream hasBytesAvailable]) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">NSInteger</span> len = [stream read:d maxLength:<span class=\"number\">1024</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (len &gt; <span class=\"number\">0</span> &amp;&amp; stream.streamError == <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">                    [data appendBytes:(<span class=\"type\">void</span> *)d length:len];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            req.HTTPBody = [data <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">            [stream close];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> req;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n",
            "tags": [
                "webview",
                "hook"
            ]
        }
    ]
}