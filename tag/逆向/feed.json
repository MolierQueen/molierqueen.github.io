{
    "version": "https://jsonfeed.org/version/1",
    "title": "Molier • All posts by \"逆向\" tag",
    "description": "iOS 开发 移动App 博客 杂谈 随笔 相册",
    "home_page_url": "https://oliverqueen.cn",
    "items": [
        {
            "id": "https://oliverqueen.cn/iPa%E9%80%86%E5%90%91%E4%B9%8B%E8%B7%AF/",
            "url": "https://oliverqueen.cn/iPa%E9%80%86%E5%90%91%E4%B9%8B%E8%B7%AF/",
            "title": "iPa逆向之路",
            "date_published": "2022-11-15T11:40:49.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景</h2>\n<p>逆向工程相对于正向的开发，可能关注的没有那么高，尤其是相比于安卓或者其他平台，苹果的安全机制更严格，逆向的流程也会更繁琐，除了有 ASLR（地址空间布局随机化），还有 FairPlay DRM 的 iPA 加密方式，也就是我们俗称的壳。这个给逆向工作带来了更多的挑战。但是 <code>更好更安全的加密方式也只是增加破解的成本，并不是绝对的安全</code> ，这也是逆向的前提。</p>\n<p>最近也正在做一些调研的工作，需要从技术层面去分析其他 App 的一些底层逻辑，要用到 iOS 的逆向相关的技术，但是由于笔者做这些工作的时候正处于 MacOS、iOS、Xcode 三个系统的大版本更新期间，一些系统的运行方式和逻辑发生变化，所以导致网上能找到的资料基本都失效了，所以写文档记录下。</p>\n<h2 id=\"前置工作\"><a class=\"anchor\" href=\"#前置工作\">#</a> 前置工作</h2>\n<h3 id=\"环境\"><a class=\"anchor\" href=\"#环境\">#</a> 环境</h3>\n<ul>\n<li>Mac 架构： Intel 架构</li>\n<li>MacOS： 13.0.1 (22A400)</li>\n<li>Xcode 版本：Version 14.1 (14B47b)</li>\n<li>iOS 系统版本：iOS 16.0</li>\n</ul>\n<h3 id=\"相关工具\"><a class=\"anchor\" href=\"#相关工具\">#</a> 相关工具</h3>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zb3VyY2Vmb3JnZS5uZXQvcHJvamVjdHMvbWFjaG92aWV3Lw==\">MachOView</span>\n<ul>\n<li>用来查看 Mach-o 的文件结构，以及各个部分的信息</li>\n</ul>\n</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3N0ZXZlbnlnYXJkLmNvbS9wcm9qZWN0cy9jbGFzcy1kdW1wLw==\">class-dump</span>\n<ul>\n<li>class-dump，顾名思义，就是用来 dump 目标对象 的 class 信息的工具。它利用 Objective-C 语言的 runtime 特性，将存储在 Mach-O 文件中的头文件信息提取出 来，并生成对应的.h 文件。</li>\n</ul>\n</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0Fsb25lTW9ua2V5L01vbmtleURldg==\">MonkeyDev</span>\n<ul>\n<li>非越狱开发插件，可以进行动态库注入，hook 相关操作</li>\n</ul>\n</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaG9wcGVyYXBwLmNvbS8=\">Hopper Disassembler</span>\n<ul>\n<li>Hopper Disassembler 是 Mac 上的一款二进制反汇编器，基本上满足了工作上的反汇编的需要，包括伪代码以及控制流图 (Control Flow Graph)，支持 ARM 指令集并针对 Objective-C 的做了优化。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"ipa下载\"><a class=\"anchor\" href=\"#ipa下载\">#</a> iPa 下载</h2>\n<p>iOS App 的逆向的所有操作都是基于 iPa 的操作，所以大前提是要有目标 iPa，这里提供三种方式来进行 iPa 下载，大家可以选择适合自己的方式下载。</p>\n<h3 id=\"方式1三方应用市场\"><a class=\"anchor\" href=\"#方式1三方应用市场\">#</a> 方式 1：三方应用市场</h3>\n<p>现在这样的应用市场比较多，多是平替 iTunes 的一些软件</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaTQuY24v\">爱思助手</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaXRvb2xzLmNuLw==\">iTools</span></li>\n</ul>\n<p>使用如上的三方软件可以很快的下载对应的 ipa 包，但是由于上述市场都是镜像自 AppStore 的内容，并且自己重签名，所以更新的及时性可能没有那么快，也没有那么全，而且因为是被第三方进行了修改重签，所以内容也不一定保证和官方的一致。如果不在乎这些的话还是可以采取这类的方式下载。</p>\n<h3 id=\"方式2apple-configuration\"><a class=\"anchor\" href=\"#方式2apple-configuration\">#</a> 方式 2：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdXBwb3J0LmFwcGxlLmNvbS9hcHBsZS1jb25maWd1cmF0b3I=\">Apple Configuration</span></h3>\n<p>可以直接从 Mac 上的 Apple Store 上下载，官方出品，原本是给手机上安装 app 的。用此方式其实是利用了该 App 的 App 下载机制来进行 ipa 导出的</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84np4us32j310y0io75z.jpg\" alt=\"image-20221114144926709\" /></p>\n<p>选择添加 App，然后在弹出的弹窗中选择 App 并且下载</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84nq4zkpwj30ys0na0vm.jpg\" alt=\"image-20221114145027227\" /></p>\n<p>这个时候如果你手机上没有安装该 App，则直接会安装成功，此时我们再点击安装下载，然后就会收到 <code>设备上已经存在相同的App，是否覆盖安装的提示</code> 的弹窗，此时我们 &lt;font color='red'&gt; 不要理会 &lt;/font &gt; 这个弹窗。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84nvzsytmj30u00y6mz0.jpg\" alt=\"image-20221114145604307\" /></p>\n<p>然后到如下路径就可以取到对应的 ipa</p>\n<p><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~<span class=\"regexp\">/Library/</span>Group Containers<span class=\"regexp\">/K36BKF7T3D.group.com.apple.configurator/</span>Library<span class=\"regexp\">/Caches/</span>Assets<span class=\"regexp\">/TemporaryItems/</span>MobileApps/</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"方式3-dumpapp\"><a class=\"anchor\" href=\"#方式3-dumpapp\">#</a> 方式 3 <a href=\"%5Bhttps://dumpapp.com%5D(https://dumpapp.com/)\">DumpApp</a></h3>\n<p>是一个第三的网站，同在线砸壳 + ipa 下载的服务，因为我们最终想要的就是一个砸壳之后的 ipa，所以这个网站直接帮我们做好了，只不过是收费的，每个 app 是 9 元，但是有多个境外的 App 市场，比较全面。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84par73tqj30be07saa1.jpg\" alt=\"image-20221114154450405\" /></p>\n<h2 id=\"ipa砸壳\"><a class=\"anchor\" href=\"#ipa砸壳\">#</a> iPa 砸壳</h2>\n<p>如果 iPa 的获取方式选择方式 3，则可以略过砸壳步骤</p>\n<p>app 上传到 AppStore 后   苹果使用 fairplay DRM 来加密，就是我们所说的壳 DRM 全称 Digital Rights Management，即数字版权保护。苹果为了保护 App Store 分发的音乐 / 视频 / 书籍 / App 免于盗版，开发了 Fairplay DRM 技术。</p>\n<p>所有逆向都是建立在砸壳的前提下，砸壳的方式有两种：</p>\n<h3 id=\"静态砸壳\"><a class=\"anchor\" href=\"#静态砸壳\">#</a> 静态砸壳</h3>\n<p>就是不依赖程序运行，直接用 ipa 包就可以进行砸壳解密，比如说我已经知道了他的加密算法，或者我通过暴力破解了他的加密算法，然后对 ipa 进行解密，但是这样的方法难度较大，而且如果人家一旦换了加密方式或者有其他的改动，那解密方式就不生效了，常见的静态砸壳工具有以下</p>\n<ul>\n<li>[fouldecrypt](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL055YU1pc3R5L2ZvdWxkZWNyeXB0\">NyaMisty/fouldecrypt: A lightweight and simpling iOS binary decryptor (github.com)</span>)</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0xha3IyMzMvSXJpZGl1bQ==\">Iridium</span></li>\n</ul>\n<h3 id=\"动态砸壳\"><a class=\"anchor\" href=\"#动态砸壳\">#</a> 动态砸壳</h3>\n<p>与静态相反，动态砸壳就是依赖运行时的原理来进行解密，不过与其说是解密，倒不如说是内存提取，因为无论 ipa 包用什么加密方式，最终都是解密后运行到内存里面的，所以我们可以认为 <code>一个ipa在内存上的数据是未加密的</code> ，所以此时我们只要把内存上的数据提取出来即可，整个过程也不涉及到解密操作，及时后面 Apple 更换加密方式，也不影响动态砸壳的过程。</p>\n<p>动态砸壳的方式和工具有很多，现在基本已经流水线化了，可以使用以下方式和工具来进行处理，前提是要有一个越狱的手机。</p>\n<ul>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzODkzNDk5OTA0MDA4\">dumpdecrypted</span></p>\n</li>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzODkzNDk5OTA0MDE0\">Clutch</span></p>\n</li>\n</ul>\n<h3 id=\"成果检验\"><a class=\"anchor\" href=\"#成果检验\">#</a> 成果检验</h3>\n<p>砸壳后需要检查是否砸壳成功，找到对应砸壳后的的 ipa，点进去找到 mach-o 文件，执行如下命令，然后在输出查看 <code>cryptid</code>  字段如果为 <code>0</code>  就说明砸壳成功。XXX = mach-o 名字</p>\n<p><figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">otool -l XXXXX <span class=\"string\">|grep cry</span></span><br></pre></td></tr></table></figure></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84ripqxklj30tx02imxg.jpg\" alt=\"image-20221114170141723\" /></p>\n<h2 id=\"头文件导出\"><a class=\"anchor\" href=\"#头文件导出\">#</a> 头文件导出</h2>\n<p>砸壳后的的第一步就是将 ipa 文件的头.h 文件导出，然后根据 头文件的方法和属性进行逆向分析，在找到对应的 hook 点。通常我们使用 class-dump，可以去他的官网下载对应的文件，然后将文件拷贝到对应的目录下。</p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo cp class-dump /usr/local/bin   </span><br></pre></td></tr></table></figure></p>\n<p>这一步没什么问题，拷贝完成重启终端就可以调用 class-dump 的方法了.</p>\n<h3 id=\"导出\"><a class=\"anchor\" href=\"#导出\">#</a> 导出</h3>\n<p>执行下面的命令，导出头文件，需要注意的是：导出后会有上万个个文件，所以目标目录最好不要选 Desktop 或者其他的根目录</p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class-dump -S -s -H XXXXX -o /path/to/headers/</span><br></pre></td></tr></table></figure></p>\n<p>有的时候会收到这样的错误</p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error:Cannot find offset for address 0xd80000000101534a in stringAtAddress:</span><br></pre></td></tr></table></figure></p>\n<p>这是因为项目使用了 Oc 和 Swift 的混编，需要赋予 class-dump 文件权限即可</p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chmod 777 /usr/local/bin/class-dump</span><br></pre></td></tr></table></figure></p>\n<p>之后就可以导出成功了。</p>\n<h2 id=\"monkeydev\"><a class=\"anchor\" href=\"#monkeydev\">#</a> MonkeyDev</h2>\n<p>这是一个为越狱和非越狱开发人员准备的工具，主要包括四个模块:</p>\n<ul>\n<li>\n<p>Logos Tweak</p>\n<ul>\n<li>使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RoZW9zL3RoZW9zL3dpa2kvSW5zdGFsbGF0aW9u\"> theos</span> 提供的 <code>logify.pl</code>  工具将 <code>*.xm</code>  文件转成 <code>*.mm</code>  文件进行编译，集成了 <code>CydiaSubstrate</code> ，可以使用 <code>MSHookMessageEx</code>  和 <code>MSHookFunction</code>  来 <code>Hook</code>  OC 函数和指定地址。</li>\n</ul>\n</li>\n<li>\n<p>CaptainHook Tweak</p>\n<ul>\n<li>使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3JwZXRyaWNoL0NhcHRhaW5Ib29rLw==\"> CaptainHook</span> 提供的头文件进行 OC 函数的 Hook 以及属性的获取。</li>\n</ul>\n</li>\n<li>\n<p>Command-line Tool</p>\n<ul>\n<li>可以直接创建运行于越狱设备的命令行工具</li>\n</ul>\n</li>\n<li>\n<p>MonkeyApp</p>\n<ul>\n<li>这是自动给第三方应用集成 Reveal、Cycript 和注入 dylib 的模块，支持调试 dylib 和第三方应用，支持 Pod 给第三放应用集成 SDK，只需要准备一个砸壳后的 ipa 或者 app 文件即可。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"安装\"><a class=\"anchor\" href=\"#安装\">#</a> 安装</h3>\n<p>Monkeydev 依赖<span class=\"exturl\" data-url=\"aHR0cHM6Ly90aGVvcy5kZXYvZG9jcy9pbnN0YWxsYXRpb24=\"> Theos</span>.Theos 是一个越狱开发工具包，由 iOS 越狱界知名人士 Dustin Howett 开发并分享到 GitHub 上。Theos 与其他越狱开发工具相比，最大特点就是简单：下载安装简单、Logos 语法简单、编译发布简单，可以让使用者将精力都放在开发工作上去。</p>\n<h4 id=\"安装thoes\"><a class=\"anchor\" href=\"#安装thoes\">#</a> 安装 Thoes</h4>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo git clone --recursive https://github.com/theos/theos.git /opt/theos</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"安装monkeydev\"><a class=\"anchor\" href=\"#安装monkeydev\">#</a> 安装 Monkeydev</h4>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo /bin/sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/AloneMonkey/MonkeyDev/master/bin/md-install)&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"卸载monkeydev\"><a class=\"anchor\" href=\"#卸载monkeydev\">#</a> 卸载 Monkeydev</h4>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo /bin/sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/AloneMonkey/MonkeyDev/master/bin/md-uninstall)&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"更新monkeydev\"><a class=\"anchor\" href=\"#更新monkeydev\">#</a> 更新 Monkeydev</h4>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo /bin/sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/AloneMonkey/MonkeyDev/master/bin/md-update)&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"安装问题\"><a class=\"anchor\" href=\"#安装问题\">#</a> 安装问题</h4>\n<p>在安装过程中，修改用户  <code>profile</code>  文件时，找不到  <code>MacOSX Package Types.xcspec</code>  和  <code>MacOSX Product Types.xcspec</code>  文件</p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/Library/Xcode/Specifications/MacOSX Package Types.xcspec not found</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>这个是因为最新的 Xcode14 中 这个路径已经改变，所以原路径无法找到，不过如果大家需要逆向的事 iOS 的 App 到这一步可以不用关心，这个是 MacOS 相关的模板文件。此时打开 Xcode 如果有以下模版文件，并能成功创建工程即可。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84skm4dlej30li0fbjsb.jpg\" alt=\"image-20221114173807449\" /></p>\n<h4 id=\"编译报错\"><a class=\"anchor\" href=\"#编译报错\">#</a> 编译报错</h4>\n<p>通过上一步的模板文件创建好工程后，直接真机编译运行，这个时候会提示编译错误</p>\n<p><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iOS <span class=\"keyword\">file</span> not found: <span class=\"regexp\">/usr/</span>lib/libstdc++.dylib</span><br></pre></td></tr></table></figure></p>\n<p>这是因为 <code>Xcode 10</code>  之后删除的 <code>libstdc++</code>  库。可以参考此<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2RibXo1MDIvTW9ua2V5RGV2X1hjb2RlMTQ=\">解决方案</span>。之后就可以编译成功了，并且手机上可以跑起来。</p>\n<p>第二个错误是 Fishhook 中的错误，这个是是由于 Fishhook 用的是比较老的版本，本身存在 bug，只要去 github 官网找到 fishhook 最新代码 copy 过来即可。</p>\n<h3 id=\"文件结构\"><a class=\"anchor\" href=\"#文件结构\">#</a> 文件结构</h3>\n<p>文件结构如下如图</p>\n<p><img data-src=\"https://upload-images.jianshu.io/upload_images/1609369-0a4b973075bc5df2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/854/format/webp\" alt=\"image-20221114174320781\" /></p>\n<p>这是一个标准的 MonkeyDemo 的结构</p>\n<ul>\n<li>\n<p><code>TargetApp</code> ：放目标 <code>ipa</code>  的文件，将需要逆向的破壳 <code>ipa</code>  放在此处</p>\n</li>\n<li>\n<p><code>Logos</code> ：编写相关 <code>hook</code>  的文件，所有 <code>hook</code>  操作在此处，但是因为该文件下要用了 logos 语句，有一定的学习成本，所以后面的 hook 函数可以直接写在上面的 MonkeyDeomDyLib.m 中</p>\n</li>\n<li>\n<p><code>fishhook</code> ：用来 <code>hook</code>  系统函数的库</p>\n</li>\n</ul>\n<p>上方的 MonkeyDeomDyLib 就是我们即将注入进去的动态库。</p>\n<h3 id=\"动态库注入\"><a class=\"anchor\" href=\"#动态库注入\">#</a> 动态库注入</h3>\n<p>运行 demo 后动态库注入成功，控制台会有如下输出</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84swti61vj31le0qn43z.jpg\" alt=\"image-20221114174950556\" /></p>\n<p><figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">🎉!!！congratulations!!！🎉\\n👍----------------insert dylib success----------------👍</span><br></pre></td></tr></table></figure></p>\n<p>但是如果是和我一样的运行环境，你是大概率看不到的，因为会注入失败。这里尝试了两种方式</p>\n<ul>\n<li>insert_dylib 同样注入失败，</li>\n<li>optool 注入成功</li>\n</ul>\n<p>下面说下 optool 使用</p>\n<ul>\n<li>\n<p>下载编译 optool</p>\n<p><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https:<span class=\"regexp\">//gi</span>thub.com<span class=\"regexp\">/alexzielenski/</span>optool.git</span><br><span class=\"line\">cd optool</span><br><span class=\"line\">git submodule update --init --recursive</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>找到编译产物</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84t2mlrmaj30aa0b7wer.jpg\" alt=\"image-20221114175525945\" /></p>\n</li>\n<li>\n<p>把编译产物拷贝到 <code>/opt/MonkeyDev/bin</code>  下</p>\n</li>\n<li>\n<p>修改 <code>/opt/MonkeyDev/Tools/pack.sh</code></p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">顶部插入</span><br><span class=\"line\">OPTOOL=&quot;$&#123;MONKEYDEV_PATH&#125;/bin/optool&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">同上面一样</span><br><span class=\"line\">修改插入动态库工具代码</span><br><span class=\"line\">&quot;$OPTOOL&quot; install -c load -p &quot;@executable_path/Frameworks/lib&quot;&quot;$&#123;TARGET_NAME&#125;&quot;&quot;Dylib.dylib&quot; -t &quot;$&#123;BUILD_APP_PATH&#125;/$&#123;APP_BINARY&#125;&quot;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>然后保存重新运行即可注入成功</p>\n</li>\n</ul>\n<h3 id=\"pod使用\"><a class=\"anchor\" href=\"#pod使用\">#</a> pod 使用</h3>\n<p>在调试 App 时候我们会用到类似 lookIn 或者 FLEX 的等工具来看 App 的层级结构和 沙盒文件，同样需要 pod 来接入。</p>\n<ul>\n<li>\n<p>像平时创建 podfile 文件一样 进入到工程目录 <code>pod init</code></p>\n</li>\n<li>\n<p>在生成的 podfile 中添加 pod，但是要注意是在 &lt;font color='red'&gt; DemoLib &lt;/font &gt; 的 trarget 中添加，因为我们的 pod 是打入动态库的，然后由动态库带入 App</p>\n<p><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Uncomment the next line to define a global platform for your project</span></span><br><span class=\"line\"><span class=\"comment\"># platform :ios, &#x27;9.0&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">target <span class=\"string\">&#x27;Demo&#x27;</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">  <span class=\"comment\"># Comment the next line if you don&#x27;t want to use dynamic frameworks</span></span><br><span class=\"line\">  use_frameworks!</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">target <span class=\"string\">&#x27;DemoDylib&#x27;</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">  <span class=\"comment\"># Comment the next line if you don&#x27;t want to use dynamic frameworks</span></span><br><span class=\"line\">  use_frameworks!</span><br><span class=\"line\"></span><br><span class=\"line\">    pod <span class=\"string\">&#x27;FLEX&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    pod <span class=\"string\">&#x27;LookinServer&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>然后 <code>pod install</code>  即可看到效果</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h85lo8xilij31b90u0ada.jpg\" alt=\"image-20221115102451908\" /></p>\n</li>\n</ul>\n<h3 id=\"代码hook\"><a class=\"anchor\" href=\"#代码hook\">#</a> 代码 Hook</h3>\n<p>通过 Lookin 我们可以找到入手点和对应的类名，然后通过之前导出的头文件可以查看类名对应的函数，接下来就是要看下函数里面做了哪些事情，就要用到 Hook 手段，MonkeyDev 给我们封装好了 Hook 相关的方法，包括 OC 和 C 的 Hook 函数</p>\n<ul>\n<li>\n<p>CHDeclareClass</p>\n<p>注册类名。也就是注册要被 hook 的函数所在的类，比如</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CHDeclareClass(MYViewController)</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>CHOptimizedMethod1</p>\n<p>hook 实例方法，你会发现后面跟了数字 1~10，代表被 hook 的函数的参数的个数，比如我将要 hook 的函数只有一个参数 那么就使用 CHOptimizedMethod1 参数含义为</p>\n<ul>\n<li>\n<p>第一个参数，一般传 self</p>\n</li>\n<li>\n<p>第二个参数，传返回值类型，没有返回值就是 void</p>\n</li>\n<li>\n<p>第三个参数，函数所在的类名</p>\n</li>\n<li>\n<p>第四个参数，方法名</p>\n</li>\n<li>\n<p>第五个参数，函数参数的类型</p>\n</li>\n<li>\n<p>第六个参数，函数参数的变量</p>\n<p>其中第五第六个参数在 CHOptimizedMethod1 ~10 中会重复 1~10 次</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CHOptimizedMethod1(self, void, MYViewController, appMethod, id, para) &#123;</span><br><span class=\"line\">    NSLog(@&quot;appMethod被Hook = %@&quot;, para);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n</li>\n<li>\n<p>CHOptimizedClassMethod3</p>\n<p>hook 类方法，所有函数定义同上</p>\n</li>\n<li>\n<p>CHConstructor 结构</p>\n<p>用来注册刚才的 hook 操作</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CHConstructor&#123;</span><br><span class=\"line\">  // 注册将要hook的类</span><br><span class=\"line\">    CHLoadLateClass(MYViewController);</span><br><span class=\"line\">\t// 注册将要hook 的方法</span><br><span class=\"line\">    CHHook1(MYViewController, appMethod);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面流程执行完成后就可以看到函数被 Hook 了</p>\n</li>\n</ul>\n<h2 id=\"hopper-disassembler\"><a class=\"anchor\" href=\"#hopper-disassembler\">#</a> Hopper Disassembler</h2>\n<p>上面的步骤讲了如何通过 lookin 或者 reveal 等工具来定位类名，然后通过类名在头文件中找到函数名，然后通过 hook 手段来改变函数的一些表现，但是在如何没有拿到.m 文件的前提下看到某个函数的实现呢？比如一个函数中都做了哪些操作，调用了哪些其他函数，以及调用链是怎样的？</p>\n<p>这个时候就需要用到 <code>Hopper Disassembler</code>  或者 <code>IDA Pro</code>  这样的工具了，不过目前遇到的困难是在笔者的系统环境下，这两个软件的破解版无法安装，而且 <code>IDA Pro</code>  的官方试用版还不支持 Arm 的汇编，所以只能使用 Hopper Disassembler 来举例子。打开软件，将 <code>对应App 的Mach-o</code>  文件拖入 Hopper 中等待它分析完成</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h85mc4b62oj31ec0u075n.jpg\" alt=\"image-20221115104755241\" /></p>\n<p>处理完后的界面左边会显示方法名，支持搜索查询，中间区域显示的是汇编代码，我们搜索一个在之前 dump 出的头文件中的一个函数名试下。</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[XXXXXXXX listenerDownloadLyricWithSongId:resultBlock:]</span><br></pre></td></tr></table></figure></p>\n<p>可以看到中间的部分显示出来函数所对应的汇编代码</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h861n7q3isj317b0u0dlg.jpg\" alt=\"image-20221115193733635\" /></p>\n<p>然后按快捷键 <code>Option+enter</code>  即可转为伪 OC 代码，虽然包含一些的寄存器信息，但是也足以分析了。同时双击可以跳转到对应的函数内部。</p>\n<h2 id=\"最后\"><a class=\"anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>以上就是目前的逆向调研过程，这里先记录下，后面还会深入研究，有新的发现会同步更新此文章。</p>\n",
            "tags": [
                "iOS",
                "逆向"
            ]
        }
    ]
}