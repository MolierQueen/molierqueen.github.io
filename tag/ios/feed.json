{
    "version": "https://jsonfeed.org/version/1",
    "title": "Molier • All posts by \"ios\" tag",
    "description": "iOS 开发 移动App 博客 杂谈 随笔 相册",
    "home_page_url": "https://oliverqueen.cn",
    "items": [
        {
            "id": "https://oliverqueen.cn/2021-05-03-iOS%20Crash%E9%98%B2%E6%8A%A4%E4%BD%A0%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%B0%B1%E5%A4%9F%E4%BA%86-%E4%B8%8A%E7%AF%87/",
            "url": "https://oliverqueen.cn/2021-05-03-iOS%20Crash%E9%98%B2%E6%8A%A4%E4%BD%A0%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%B0%B1%E5%A4%9F%E4%BA%86-%E4%B8%8A%E7%AF%87/",
            "title": "iOS Crash防护你看这个就够了 - 上篇",
            "date_published": "2023-12-30T14:16:08.546Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"0x1-为什么要做crash防护\"><a class=\"anchor\" href=\"#0x1-为什么要做crash防护\">#</a> 0x1 为什么要做 Crash 防护</h1>\n<p>在产品开发过程中 Crash 率是一个很重要的指标，也是一个团队中几乎所有的部门都应该关注或者去参与提升的一个指标，他不仅代表着整个产品的质量，也是一个团队整体技术能力的体现。更低的 Crash 率不但能让产品获得更好的用户口碑，在整个流程中也能让团队成员获得更多的成长，加深对 iOS 系统底层的理解，为今后的开发带了更大的帮助。</p>\n<p><img data-src=\"https://image-1256056152.cos.ap-nanjing.myqcloud.com/1111111111.jpeg\" alt=\"\" /></p>\n<p><span id=\"more\"></span></p>\n<h1 id=\"0x2-为什么要写这篇文章\"><a class=\"anchor\" href=\"#0x2-为什么要写这篇文章\">#</a> 0x2 为什么要写这篇文章</h1>\n<p>起因也是因为自己的项目踩了 FB 的 SDK 的坑：2020.7.10，FB 后台下发数据错误，导致大量使用 FB SDK 的 App 发生启动 Crash，影响用户之多，范围之大，再加上当时包括我们的大部分 App 也缺乏相关的防护或者是容错处理，Crash 率瞬间飙升，重新发版又要走发布流程，只能依赖 FB 后台的修复，当时束手无策十分被动，所以决定自己做一套较为完整的 Crash 防护体系，来避免这样的场景再次发生。第二个目的就是，发生问题后我也第一之间查阅了网上的一些资料和其他团队的做法，发现大家的方式各有千秋，方法不同，效果不同，所以我也决定把市面上能找到的好的思路和方法再结合自己的一些想法和经验记录下来。最后也是因为知识是要沉淀、积累和分享的，也算是巩固和加深自己的理解吧。</p>\n<h1 id=\"0x3-怎么做\"><a class=\"anchor\" href=\"#0x3-怎么做\">#</a> 0x3 怎么做</h1>\n<p>其实当时 Crash 的场景很简单，本来一个 Dictionary 参数 FB 后台却下发了个 String 类型的数据，这样一来解析时候必然会 Crash，解决的话其实只要做一层参数安全校验即可。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq58dki0g7j31ai0u01fd.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq58c923pfj31020t8k5g.jpg\" alt=\"\" /></p>\n<p>但是这么简单的问题，大部分 App 都没处理好，证明在流程上一定有大家注意不到的地方，暴露出来的只是冰山一角，我们机制一定存在着某种问题，或者存在可以优化的地方。</p>\n<p>要想避免这种情况，就要先梳理出处理 Crash 的流程：</p>\n<h2 id=\"icrash处理流程\"><a class=\"anchor\" href=\"#icrash处理流程\">#</a> I：Crash 处理流程</h2>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6lcsxy6jj31bw0u0n1w.jpg\" alt=\"\" /></p>\n<p>在 iOS 系统中基本可以总结出这四个步骤，</p>\n<ul>\n<li>\n<p>Crash 防护 - 通过 Hook 等手段，对一些类似容器类进行入参校验等措施，来进来避免 Crash 的发生</p>\n</li>\n<li>\n<p>Crash 拦截 - 如果第一步防护失败，那么在 Crash 走到这一步就要进行拦截，要让我们发现异常</p>\n</li>\n<li>\n<p>Crash 上报 - 对防护的、捕获的 Crash 进行防护，生成有效的日志进行上报，尽可能的还原堆栈。</p>\n</li>\n<li>\n<p>Crash 后续流程 - Crash 发生后如何做才能最大限度的保护用户体验，如何优雅的 Crash</p>\n</li>\n</ul>\n<h2 id=\"iicrash防护\"><a class=\"anchor\" href=\"#iicrash防护\">#</a> II：Crash 防护</h2>\n<p>Crash 防护方式主要分两种：针对非内存问题通常采用 AOP 方式，内存问题采用 zombie 对象的方式，</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6lrlbl0vj30qi07mdg5.jpg\" alt=\"\" /><br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6ls764zyj30qm06cjrq.jpg\" alt=\"\" /></p>\n<h3 id=\"aopbr\"><a class=\"anchor\" href=\"#aopbr\">#</a> AOP：&lt;br&gt;</h3>\n<p>iOS 中 AOP 的相关知识网上线程的代码也很多，这里就不在赘述，但是在 AOP 这种频繁调用的场景中就需要注意的地方和坑点比较多。</p>\n<ul>\n<li>\n<p>AOP 的影响范围问题：当时用了普通的方式对数组相关的方法进行了 Hook，结果上线后发现大量的类似 Crash。 <code>[UIKeyboardLayoutStar release]: message sent to deallocated instance UIKeyboardLayoutStar</code></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6m6njbm8j30o40d0q8q.jpg\" alt=\"\" /><br />\n在通过一些其他场景可以判断出是因为 HookNSMutableArr 的相关方法，导致系统类的调用受到了影响。</p>\n<p>通过 Xcode 调试发现，因为 Hook 的本质就是在原有的系统调用前插入一个用户自定义的函数进行方法交换，那么在某种极端情况下（比如多线程），传入该函数的变量被释放，这样一来再走到原本系统调用的时候正常释放时就会出现重复释放的情况。大概的流程为</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6mhmeprhj31hm0fu75v.jpg\" alt=\"\" /></p>\n<p>该场景在测试过程中很难复现，但是一旦到了线上，用户量覆盖够大后该问题就会显现出来。解决方式很简单，Hook 尽量在 MRC 下进行，使用 autorelease pool 进行包装。保证内部变量在当前的 runloop 结束时候进行释放。</p>\n</li>\n<li>\n<p>AOP 的性能问题：上面说了 AOP 的原理是会多一层方法调用，那么再结合 iOS 的方法转发流程可想而知，AOP 必定会造成性能的损耗，而且在 Crash 防护场景下频繁调用，性能问题一定不能忽略。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6mswloauj310o0u0jx8.jpg\" alt=\"\" /></p>\n<p>通过上图看出，方法调用流程最终会返回出对应的 IMP 指针供外部调用，作为动态语言，OC 无法确定开发者会再什么时候插入或者交换哪个函数，所以必须通过这一套流程进行类似校验的逻辑。</p>\n<p>使用过 AOP 的同学一定知道在 AOP 前会先做一层校验</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+(void)hookClass:(Class)classObject isClassMetohd:(BOOL)classMethod fromSelector:(SEL)fromSelector toSelector:(SEL)toSelector </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Class <span class=\"keyword\">class</span> = classObject;</span><br><span class=\"line\">    Method fromMethod = <span class=\"keyword\">class</span><span class=\"constructor\">_getInstanceMethod(<span class=\"params\">class</span>, <span class=\"params\">fromSelector</span>)</span>;</span><br><span class=\"line\">    Method toMethod = <span class=\"keyword\">class</span><span class=\"constructor\">_getInstanceMethod(<span class=\"params\">class</span>, <span class=\"params\">toSelector</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">//  添加前进行检测</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (classMethod) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">class</span> = <span class=\"keyword\">object</span><span class=\"constructor\">_getClass(<span class=\"params\">classObject</span>)</span>;</span><br><span class=\"line\">        fromMethod = <span class=\"keyword\">class</span><span class=\"constructor\">_getClassMethod(<span class=\"params\">class</span>, <span class=\"params\">fromSelector</span>)</span>;</span><br><span class=\"line\">        toMethod = <span class=\"keyword\">class</span><span class=\"constructor\">_getClassMethod(<span class=\"params\">class</span>, <span class=\"params\">toSelector</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">class</span><span class=\"constructor\">_addMethod(<span class=\"params\">class</span>, <span class=\"params\">fromSelector</span>, <span class=\"params\">method_getImplementation</span>(<span class=\"params\">toMethod</span>)</span>, <span class=\"keyword\">method</span><span class=\"constructor\">_getTypeEncoding(<span class=\"params\">toMethod</span>)</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">class</span><span class=\"constructor\">_replaceMethod(<span class=\"params\">class</span>, <span class=\"params\">toSelector</span>, <span class=\"params\">method_getImplementation</span>(<span class=\"params\">fromMethod</span>)</span>, <span class=\"keyword\">method</span><span class=\"constructor\">_getTypeEncoding(<span class=\"params\">fromMethod</span>)</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">method</span><span class=\"constructor\">_exchangeImplementations(<span class=\"params\">fromMethod</span>, <span class=\"params\">toMethod</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 所以在方法我们在上面代码中的 toSelector 中 当我们需要调用回原方法时直接调用对应的函数指针即可</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6rm11f7dj30nm05a74e.jpg\" alt=\"\" /></p>\n<p>最终我对直接调用 IMP 的方法做了测试，分别是 Demo 中和 App 中的某一个场景，测试数据如下，对比结果还是较为明显。这也就是为什么 Swift 或者一些其他静态语言比 OC 快的原因。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6rw5k68mj313c0r6n13.jpg\" alt=\"\" /></p>\n</li>\n</ul>\n<h3 id=\"zombiebr\"><a class=\"anchor\" href=\"#zombiebr\">#</a> Zombie：&lt;br&gt;</h3>\n<p>使用僵尸对象来解决内存问题一直是苹果主推的方式，Xcode 也有相关设置，在 Debug 下打开相应开关，但是一旦把该功能放到线上做防护或监控就要考虑很多的问题。</p>\n<ul>\n<li>\n<p>zombie 入口问题：换句话说就是在哪个地方生成 zombie 对象，看了一些相关的 SDK 都是采用 Dealloc 作为入口函数，不是不行，只是不是最优。原因有两点:</p>\n<ul>\n<li>\n<p>1: 苹果已经不建议在 ARC 下主动调用 dealloc，目前只能采用 performSelector 或者其他动态调用的方式。</p>\n</li>\n<li>\n<p>2: 容易漏掉  <code>Objc_destructInstance</code> ，所有的成员变量、属性都会在这个函数中释放，如果漏掉这个函数就会生成一个并不干净的僵尸对象，内存占用过高，白白浪费内存空间。</p>\n</li>\n</ul>\n<p>综上两点我最终选择在 Free 函数中生成僵尸对象</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6sr4ebj5j30vx0u0dhq.jpg\" alt=\"\" /></p>\n</li>\n<li>\n<p>zombie 内存阈值问题：僵尸对象会占用内存空间，然而在线上环境操作内存一定要小心且一定要有一套完整的逻辑，当超过某一个内存阈值后需要及时清空僵尸对象。内存阈值的确定便成了关键，这里会遇到两个问题：</p>\n<ul>\n<li>\n<p>&lt;font color='red'&gt; 1：内存问题一定会和机型强相关，如何根据不同的机型调整不同的阈值？ &lt;/font&gt;</p>\n</li>\n<li>\n<p>&lt;font color='red'&gt; 2：如何做到根据线上情况灵活动态调整？&lt;/font&gt;</p>\n</li>\n</ul>\n<p>我们的底线是在加入 zombie 后不能触发 memorywarning，所以我先对大部分机型做了 memorywarning 阈值测试：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6t2xweqcj312g0sg0xq.jpg\" alt=\"\" /></p>\n<p>从上图可以看出当 App 占用内存达到总内存的 57%~69% 时候会触发内存警告，而且由于 iphone 中有一部分内存是系统保留内存并不会给到开发者，所以我们可用的也就 50% 左右，我总结出如下公式：</p>\n<p>公式 1：不能触发内存警告  <code>Y = 0.5 * deviceMem – currentAppMem</code></p>\n<p>公式 2: 僵尸对象的内存占用再大也不会超过 App 本身的内存  <code>Y = min ( ( 0.5 * deviceMem – currentAppMem ) , currentAppMem)</code></p>\n<p>上面两个公式看似完美，但是还是有优化的地方，因为并不是 APP 中所有的变量都有可能成为僵尸对象，可能只是其中的某一部分需要被监控，所以得到最终的内存阈值计算公式：</p>\n<p>&lt;font color=red size=5 face=&quot;黑体&quot;&gt;Y = min ( ( 0.5 * deviceMem – currentAppMem ) , currentAppMem / N )&lt;/font&gt;</p>\n<p>因为 app 占用内存随时在变，所以可以加一个定时器每隔一定时间去更新该值。</p>\n<p>上面公式的 N 还有一个好处就是我们可以后台动态下发，根据线上内存引起 Crash 量，如果 Crash 量大，那可能就需要更大的内存阈值去保存僵尸对象，就可以把 N 调小，反正调大，这样就可以无视机型的差异根据 Crash 的情况进行远程配置。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6tozx4odj316l0u079c.jpg\" alt=\"\" /></p>\n<p>通过如图的线上数据可以看出 随着 N 的减小，zombie 的内存阈值在增加，但是并不会超过内存警告阈值，确保了内存健康。</p>\n<p>下图表示了不同的 N 值对应不同的捕获野指针问题的数量，各自 App 可以根据自己的业务情况进行调整。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6tse6e79j31zo0kkk0x.jpg\" alt=\"\" /></p>\n</li>\n<li>\n<p>zombie 更新策略问题：目前大家的做法都是在加入新的 zombie 对象时候检查是否超过阈值，达到阈值后删掉之前的 zombie 对象再加入新的对象，这样的清理逻辑是依赖于新 zombie 对象的加入，如果没有新对象的加入那么缓存空间也不会有变化，zombie 空间一旦生成就无法删掉，无法做到缓存的自清理，等于 App 无故增大了内存占用。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6u18gh6cj30wa0saad2.jpg\" alt=\"\" /></p>\n<p>同样借鉴 LRU 最近最久未使用的逻辑，每隔 30s 会检测下缓存情况，超过 30s 还未被使用的 zombie 对象将被删除，30s 是一个经验值，通过大量测试发现，内存问题一般会发生在对象被销毁的 30s 内，超过 30s 再出现的概率及小。这样可以做到缓存自清理的逻辑。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6u92wzy3j30n00si41c.jpg\" alt=\"\" /></p>\n<p>通过 Instrument 测试发现该 zombie 逻辑并不会对 App 本身的内存造成太大的影响。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq6ucxjfn5j31c60u078q.jpg\" alt=\"\" /></p>\n</li>\n</ul>\n<p>\n\t\t\t<script>\n\t\t\t\tconsole.error(\"Error: [hexo-tag-aplayer] Specified asset file not found ( https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E5%B0%B9%E6%98%94%E7%9C%A0%20-%20%E5%A5%94%E8%B5%B4%E6%98%9F%E7%A9%BA.mp3)\");\n\t\t\t</script></p>\n",
            "tags": [
                "iOS",
                "Crash防护"
            ]
        },
        {
            "id": "https://oliverqueen.cn/iPa%E9%80%86%E5%90%91%E4%B9%8B%E8%B7%AF/",
            "url": "https://oliverqueen.cn/iPa%E9%80%86%E5%90%91%E4%B9%8B%E8%B7%AF/",
            "title": "iPa逆向之路",
            "date_published": "2022-11-15T11:40:49.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景</h2>\n<p>逆向工程相对于正向的开发，可能关注的没有那么高，尤其是相比于安卓或者其他平台，苹果的安全机制更严格，逆向的流程也会更繁琐，除了有 ASLR（地址空间布局随机化），还有 FairPlay DRM 的 iPA 加密方式，也就是我们俗称的壳。这个给逆向工作带来了更多的挑战。但是 <code>更好更安全的加密方式也只是增加破解的成本，并不是绝对的安全</code> ，这也是逆向的前提。</p>\n<p>最近也正在做一些调研的工作，需要从技术层面去分析其他 App 的一些底层逻辑，要用到 iOS 的逆向相关的技术，但是由于笔者做这些工作的时候正处于 MacOS、iOS、Xcode 三个系统的大版本更新期间，一些系统的运行方式和逻辑发生变化，所以导致网上能找到的资料基本都失效了，所以写文档记录下。</p>\n<h2 id=\"前置工作\"><a class=\"anchor\" href=\"#前置工作\">#</a> 前置工作</h2>\n<h3 id=\"环境\"><a class=\"anchor\" href=\"#环境\">#</a> 环境</h3>\n<ul>\n<li>Mac 架构： Intel 架构</li>\n<li>MacOS： 13.0.1 (22A400)</li>\n<li>Xcode 版本：Version 14.1 (14B47b)</li>\n<li>iOS 系统版本：iOS 16.0</li>\n</ul>\n<h3 id=\"相关工具\"><a class=\"anchor\" href=\"#相关工具\">#</a> 相关工具</h3>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zb3VyY2Vmb3JnZS5uZXQvcHJvamVjdHMvbWFjaG92aWV3Lw==\">MachOView</span>\n<ul>\n<li>用来查看 Mach-o 的文件结构，以及各个部分的信息</li>\n</ul>\n</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3N0ZXZlbnlnYXJkLmNvbS9wcm9qZWN0cy9jbGFzcy1kdW1wLw==\">class-dump</span>\n<ul>\n<li>class-dump，顾名思义，就是用来 dump 目标对象 的 class 信息的工具。它利用 Objective-C 语言的 runtime 特性，将存储在 Mach-O 文件中的头文件信息提取出 来，并生成对应的.h 文件。</li>\n</ul>\n</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0Fsb25lTW9ua2V5L01vbmtleURldg==\">MonkeyDev</span>\n<ul>\n<li>非越狱开发插件，可以进行动态库注入，hook 相关操作</li>\n</ul>\n</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaG9wcGVyYXBwLmNvbS8=\">Hopper Disassembler</span>\n<ul>\n<li>Hopper Disassembler 是 Mac 上的一款二进制反汇编器，基本上满足了工作上的反汇编的需要，包括伪代码以及控制流图 (Control Flow Graph)，支持 ARM 指令集并针对 Objective-C 的做了优化。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"ipa下载\"><a class=\"anchor\" href=\"#ipa下载\">#</a> iPa 下载</h2>\n<p>iOS App 的逆向的所有操作都是基于 iPa 的操作，所以大前提是要有目标 iPa，这里提供三种方式来进行 iPa 下载，大家可以选择适合自己的方式下载。</p>\n<h3 id=\"方式1三方应用市场\"><a class=\"anchor\" href=\"#方式1三方应用市场\">#</a> 方式 1：三方应用市场</h3>\n<p>现在这样的应用市场比较多，多是平替 iTunes 的一些软件</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaTQuY24v\">爱思助手</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaXRvb2xzLmNuLw==\">iTools</span></li>\n</ul>\n<p>使用如上的三方软件可以很快的下载对应的 ipa 包，但是由于上述市场都是镜像自 AppStore 的内容，并且自己重签名，所以更新的及时性可能没有那么快，也没有那么全，而且因为是被第三方进行了修改重签，所以内容也不一定保证和官方的一致。如果不在乎这些的话还是可以采取这类的方式下载。</p>\n<h3 id=\"方式2apple-configuration\"><a class=\"anchor\" href=\"#方式2apple-configuration\">#</a> 方式 2：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdXBwb3J0LmFwcGxlLmNvbS9hcHBsZS1jb25maWd1cmF0b3I=\">Apple Configuration</span></h3>\n<p>可以直接从 Mac 上的 Apple Store 上下载，官方出品，原本是给手机上安装 app 的。用此方式其实是利用了该 App 的 App 下载机制来进行 ipa 导出的</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84np4us32j310y0io75z.jpg\" alt=\"image-20221114144926709\" /></p>\n<p>选择添加 App，然后在弹出的弹窗中选择 App 并且下载</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84nq4zkpwj30ys0na0vm.jpg\" alt=\"image-20221114145027227\" /></p>\n<p>这个时候如果你手机上没有安装该 App，则直接会安装成功，此时我们再点击安装下载，然后就会收到 <code>设备上已经存在相同的App，是否覆盖安装的提示</code> 的弹窗，此时我们 &lt;font color='red'&gt; 不要理会 &lt;/font &gt; 这个弹窗。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84nvzsytmj30u00y6mz0.jpg\" alt=\"image-20221114145604307\" /></p>\n<p>然后到如下路径就可以取到对应的 ipa</p>\n<p><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~<span class=\"regexp\">/Library/</span>Group Containers<span class=\"regexp\">/K36BKF7T3D.group.com.apple.configurator/</span>Library<span class=\"regexp\">/Caches/</span>Assets<span class=\"regexp\">/TemporaryItems/</span>MobileApps/</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"方式3-dumpapp\"><a class=\"anchor\" href=\"#方式3-dumpapp\">#</a> 方式 3 <a href=\"%5Bhttps://dumpapp.com%5D(https://dumpapp.com/)\">DumpApp</a></h3>\n<p>是一个第三的网站，同在线砸壳 + ipa 下载的服务，因为我们最终想要的就是一个砸壳之后的 ipa，所以这个网站直接帮我们做好了，只不过是收费的，每个 app 是 9 元，但是有多个境外的 App 市场，比较全面。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84par73tqj30be07saa1.jpg\" alt=\"image-20221114154450405\" /></p>\n<h2 id=\"ipa砸壳\"><a class=\"anchor\" href=\"#ipa砸壳\">#</a> iPa 砸壳</h2>\n<p>如果 iPa 的获取方式选择方式 3，则可以略过砸壳步骤</p>\n<p>app 上传到 AppStore 后   苹果使用 fairplay DRM 来加密，就是我们所说的壳 DRM 全称 Digital Rights Management，即数字版权保护。苹果为了保护 App Store 分发的音乐 / 视频 / 书籍 / App 免于盗版，开发了 Fairplay DRM 技术。</p>\n<p>所有逆向都是建立在砸壳的前提下，砸壳的方式有两种：</p>\n<h3 id=\"静态砸壳\"><a class=\"anchor\" href=\"#静态砸壳\">#</a> 静态砸壳</h3>\n<p>就是不依赖程序运行，直接用 ipa 包就可以进行砸壳解密，比如说我已经知道了他的加密算法，或者我通过暴力破解了他的加密算法，然后对 ipa 进行解密，但是这样的方法难度较大，而且如果人家一旦换了加密方式或者有其他的改动，那解密方式就不生效了，常见的静态砸壳工具有以下</p>\n<ul>\n<li>[fouldecrypt](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL055YU1pc3R5L2ZvdWxkZWNyeXB0\">NyaMisty/fouldecrypt: A lightweight and simpling iOS binary decryptor (github.com)</span>)</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0xha3IyMzMvSXJpZGl1bQ==\">Iridium</span></li>\n</ul>\n<h3 id=\"动态砸壳\"><a class=\"anchor\" href=\"#动态砸壳\">#</a> 动态砸壳</h3>\n<p>与静态相反，动态砸壳就是依赖运行时的原理来进行解密，不过与其说是解密，倒不如说是内存提取，因为无论 ipa 包用什么加密方式，最终都是解密后运行到内存里面的，所以我们可以认为 <code>一个ipa在内存上的数据是未加密的</code> ，所以此时我们只要把内存上的数据提取出来即可，整个过程也不涉及到解密操作，及时后面 Apple 更换加密方式，也不影响动态砸壳的过程。</p>\n<p>动态砸壳的方式和工具有很多，现在基本已经流水线化了，可以使用以下方式和工具来进行处理，前提是要有一个越狱的手机。</p>\n<ul>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzODkzNDk5OTA0MDA4\">dumpdecrypted</span></p>\n</li>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzODkzNDk5OTA0MDE0\">Clutch</span></p>\n</li>\n</ul>\n<h3 id=\"成果检验\"><a class=\"anchor\" href=\"#成果检验\">#</a> 成果检验</h3>\n<p>砸壳后需要检查是否砸壳成功，找到对应砸壳后的的 ipa，点进去找到 mach-o 文件，执行如下命令，然后在输出查看 <code>cryptid</code>  字段如果为 <code>0</code>  就说明砸壳成功。XXX = mach-o 名字</p>\n<p><figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">otool -l XXXXX <span class=\"string\">|grep cry</span></span><br></pre></td></tr></table></figure></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84ripqxklj30tx02imxg.jpg\" alt=\"image-20221114170141723\" /></p>\n<h2 id=\"头文件导出\"><a class=\"anchor\" href=\"#头文件导出\">#</a> 头文件导出</h2>\n<p>砸壳后的的第一步就是将 ipa 文件的头.h 文件导出，然后根据 头文件的方法和属性进行逆向分析，在找到对应的 hook 点。通常我们使用 class-dump，可以去他的官网下载对应的文件，然后将文件拷贝到对应的目录下。</p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo cp class-dump /usr/local/bin   </span><br></pre></td></tr></table></figure></p>\n<p>这一步没什么问题，拷贝完成重启终端就可以调用 class-dump 的方法了.</p>\n<h3 id=\"导出\"><a class=\"anchor\" href=\"#导出\">#</a> 导出</h3>\n<p>执行下面的命令，导出头文件，需要注意的是：导出后会有上万个个文件，所以目标目录最好不要选 Desktop 或者其他的根目录</p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class-dump -S -s -H XXXXX -o /path/to/headers/</span><br></pre></td></tr></table></figure></p>\n<p>有的时候会收到这样的错误</p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error:Cannot find offset for address 0xd80000000101534a in stringAtAddress:</span><br></pre></td></tr></table></figure></p>\n<p>这是因为项目使用了 Oc 和 Swift 的混编，需要赋予 class-dump 文件权限即可</p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chmod 777 /usr/local/bin/class-dump</span><br></pre></td></tr></table></figure></p>\n<p>之后就可以导出成功了。</p>\n<h2 id=\"monkeydev\"><a class=\"anchor\" href=\"#monkeydev\">#</a> MonkeyDev</h2>\n<p>这是一个为越狱和非越狱开发人员准备的工具，主要包括四个模块:</p>\n<ul>\n<li>\n<p>Logos Tweak</p>\n<ul>\n<li>使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RoZW9zL3RoZW9zL3dpa2kvSW5zdGFsbGF0aW9u\"> theos</span> 提供的 <code>logify.pl</code>  工具将 <code>*.xm</code>  文件转成 <code>*.mm</code>  文件进行编译，集成了 <code>CydiaSubstrate</code> ，可以使用 <code>MSHookMessageEx</code>  和 <code>MSHookFunction</code>  来 <code>Hook</code>  OC 函数和指定地址。</li>\n</ul>\n</li>\n<li>\n<p>CaptainHook Tweak</p>\n<ul>\n<li>使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3JwZXRyaWNoL0NhcHRhaW5Ib29rLw==\"> CaptainHook</span> 提供的头文件进行 OC 函数的 Hook 以及属性的获取。</li>\n</ul>\n</li>\n<li>\n<p>Command-line Tool</p>\n<ul>\n<li>可以直接创建运行于越狱设备的命令行工具</li>\n</ul>\n</li>\n<li>\n<p>MonkeyApp</p>\n<ul>\n<li>这是自动给第三方应用集成 Reveal、Cycript 和注入 dylib 的模块，支持调试 dylib 和第三方应用，支持 Pod 给第三放应用集成 SDK，只需要准备一个砸壳后的 ipa 或者 app 文件即可。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"安装\"><a class=\"anchor\" href=\"#安装\">#</a> 安装</h3>\n<p>Monkeydev 依赖<span class=\"exturl\" data-url=\"aHR0cHM6Ly90aGVvcy5kZXYvZG9jcy9pbnN0YWxsYXRpb24=\"> Theos</span>.Theos 是一个越狱开发工具包，由 iOS 越狱界知名人士 Dustin Howett 开发并分享到 GitHub 上。Theos 与其他越狱开发工具相比，最大特点就是简单：下载安装简单、Logos 语法简单、编译发布简单，可以让使用者将精力都放在开发工作上去。</p>\n<h4 id=\"安装thoes\"><a class=\"anchor\" href=\"#安装thoes\">#</a> 安装 Thoes</h4>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo git clone --recursive https://github.com/theos/theos.git /opt/theos</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"安装monkeydev\"><a class=\"anchor\" href=\"#安装monkeydev\">#</a> 安装 Monkeydev</h4>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo /bin/sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/AloneMonkey/MonkeyDev/master/bin/md-install)&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"卸载monkeydev\"><a class=\"anchor\" href=\"#卸载monkeydev\">#</a> 卸载 Monkeydev</h4>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo /bin/sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/AloneMonkey/MonkeyDev/master/bin/md-uninstall)&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"更新monkeydev\"><a class=\"anchor\" href=\"#更新monkeydev\">#</a> 更新 Monkeydev</h4>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo /bin/sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/AloneMonkey/MonkeyDev/master/bin/md-update)&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"安装问题\"><a class=\"anchor\" href=\"#安装问题\">#</a> 安装问题</h4>\n<p>在安装过程中，修改用户  <code>profile</code>  文件时，找不到  <code>MacOSX Package Types.xcspec</code>  和  <code>MacOSX Product Types.xcspec</code>  文件</p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/Library/Xcode/Specifications/MacOSX Package Types.xcspec not found</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>这个是因为最新的 Xcode14 中 这个路径已经改变，所以原路径无法找到，不过如果大家需要逆向的事 iOS 的 App 到这一步可以不用关心，这个是 MacOS 相关的模板文件。此时打开 Xcode 如果有以下模版文件，并能成功创建工程即可。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84skm4dlej30li0fbjsb.jpg\" alt=\"image-20221114173807449\" /></p>\n<h4 id=\"编译报错\"><a class=\"anchor\" href=\"#编译报错\">#</a> 编译报错</h4>\n<p>通过上一步的模板文件创建好工程后，直接真机编译运行，这个时候会提示编译错误</p>\n<p><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iOS <span class=\"keyword\">file</span> not found: <span class=\"regexp\">/usr/</span>lib/libstdc++.dylib</span><br></pre></td></tr></table></figure></p>\n<p>这是因为 <code>Xcode 10</code>  之后删除的 <code>libstdc++</code>  库。可以参考此<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2RibXo1MDIvTW9ua2V5RGV2X1hjb2RlMTQ=\">解决方案</span>。之后就可以编译成功了，并且手机上可以跑起来。</p>\n<p>第二个错误是 Fishhook 中的错误，这个是是由于 Fishhook 用的是比较老的版本，本身存在 bug，只要去 github 官网找到 fishhook 最新代码 copy 过来即可。</p>\n<h3 id=\"文件结构\"><a class=\"anchor\" href=\"#文件结构\">#</a> 文件结构</h3>\n<p>文件结构如下如图</p>\n<p><img data-src=\"https://upload-images.jianshu.io/upload_images/1609369-0a4b973075bc5df2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/854/format/webp\" alt=\"image-20221114174320781\" /></p>\n<p>这是一个标准的 MonkeyDemo 的结构</p>\n<ul>\n<li>\n<p><code>TargetApp</code> ：放目标 <code>ipa</code>  的文件，将需要逆向的破壳 <code>ipa</code>  放在此处</p>\n</li>\n<li>\n<p><code>Logos</code> ：编写相关 <code>hook</code>  的文件，所有 <code>hook</code>  操作在此处，但是因为该文件下要用了 logos 语句，有一定的学习成本，所以后面的 hook 函数可以直接写在上面的 MonkeyDeomDyLib.m 中</p>\n</li>\n<li>\n<p><code>fishhook</code> ：用来 <code>hook</code>  系统函数的库</p>\n</li>\n</ul>\n<p>上方的 MonkeyDeomDyLib 就是我们即将注入进去的动态库。</p>\n<h3 id=\"动态库注入\"><a class=\"anchor\" href=\"#动态库注入\">#</a> 动态库注入</h3>\n<p>运行 demo 后动态库注入成功，控制台会有如下输出</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84swti61vj31le0qn43z.jpg\" alt=\"image-20221114174950556\" /></p>\n<p><figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">🎉!!！congratulations!!！🎉\\n👍----------------insert dylib success----------------👍</span><br></pre></td></tr></table></figure></p>\n<p>但是如果是和我一样的运行环境，你是大概率看不到的，因为会注入失败。这里尝试了两种方式</p>\n<ul>\n<li>insert_dylib 同样注入失败，</li>\n<li>optool 注入成功</li>\n</ul>\n<p>下面说下 optool 使用</p>\n<ul>\n<li>\n<p>下载编译 optool</p>\n<p><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https:<span class=\"regexp\">//gi</span>thub.com<span class=\"regexp\">/alexzielenski/</span>optool.git</span><br><span class=\"line\">cd optool</span><br><span class=\"line\">git submodule update --init --recursive</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>找到编译产物</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h84t2mlrmaj30aa0b7wer.jpg\" alt=\"image-20221114175525945\" /></p>\n</li>\n<li>\n<p>把编译产物拷贝到 <code>/opt/MonkeyDev/bin</code>  下</p>\n</li>\n<li>\n<p>修改 <code>/opt/MonkeyDev/Tools/pack.sh</code></p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">顶部插入</span><br><span class=\"line\">OPTOOL=&quot;$&#123;MONKEYDEV_PATH&#125;/bin/optool&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">同上面一样</span><br><span class=\"line\">修改插入动态库工具代码</span><br><span class=\"line\">&quot;$OPTOOL&quot; install -c load -p &quot;@executable_path/Frameworks/lib&quot;&quot;$&#123;TARGET_NAME&#125;&quot;&quot;Dylib.dylib&quot; -t &quot;$&#123;BUILD_APP_PATH&#125;/$&#123;APP_BINARY&#125;&quot;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>然后保存重新运行即可注入成功</p>\n</li>\n</ul>\n<h3 id=\"pod使用\"><a class=\"anchor\" href=\"#pod使用\">#</a> pod 使用</h3>\n<p>在调试 App 时候我们会用到类似 lookIn 或者 FLEX 的等工具来看 App 的层级结构和 沙盒文件，同样需要 pod 来接入。</p>\n<ul>\n<li>\n<p>像平时创建 podfile 文件一样 进入到工程目录 <code>pod init</code></p>\n</li>\n<li>\n<p>在生成的 podfile 中添加 pod，但是要注意是在 &lt;font color='red'&gt; DemoLib &lt;/font &gt; 的 trarget 中添加，因为我们的 pod 是打入动态库的，然后由动态库带入 App</p>\n<p><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Uncomment the next line to define a global platform for your project</span></span><br><span class=\"line\"><span class=\"comment\"># platform :ios, &#x27;9.0&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">target <span class=\"string\">&#x27;Demo&#x27;</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">  <span class=\"comment\"># Comment the next line if you don&#x27;t want to use dynamic frameworks</span></span><br><span class=\"line\">  use_frameworks!</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">target <span class=\"string\">&#x27;DemoDylib&#x27;</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">  <span class=\"comment\"># Comment the next line if you don&#x27;t want to use dynamic frameworks</span></span><br><span class=\"line\">  use_frameworks!</span><br><span class=\"line\"></span><br><span class=\"line\">    pod <span class=\"string\">&#x27;FLEX&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    pod <span class=\"string\">&#x27;LookinServer&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>然后 <code>pod install</code>  即可看到效果</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h85lo8xilij31b90u0ada.jpg\" alt=\"image-20221115102451908\" /></p>\n</li>\n</ul>\n<h3 id=\"代码hook\"><a class=\"anchor\" href=\"#代码hook\">#</a> 代码 Hook</h3>\n<p>通过 Lookin 我们可以找到入手点和对应的类名，然后通过之前导出的头文件可以查看类名对应的函数，接下来就是要看下函数里面做了哪些事情，就要用到 Hook 手段，MonkeyDev 给我们封装好了 Hook 相关的方法，包括 OC 和 C 的 Hook 函数</p>\n<ul>\n<li>\n<p>CHDeclareClass</p>\n<p>注册类名。也就是注册要被 hook 的函数所在的类，比如</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CHDeclareClass(MYViewController)</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>CHOptimizedMethod1</p>\n<p>hook 实例方法，你会发现后面跟了数字 1~10，代表被 hook 的函数的参数的个数，比如我将要 hook 的函数只有一个参数 那么就使用 CHOptimizedMethod1 参数含义为</p>\n<ul>\n<li>\n<p>第一个参数，一般传 self</p>\n</li>\n<li>\n<p>第二个参数，传返回值类型，没有返回值就是 void</p>\n</li>\n<li>\n<p>第三个参数，函数所在的类名</p>\n</li>\n<li>\n<p>第四个参数，方法名</p>\n</li>\n<li>\n<p>第五个参数，函数参数的类型</p>\n</li>\n<li>\n<p>第六个参数，函数参数的变量</p>\n<p>其中第五第六个参数在 CHOptimizedMethod1 ~10 中会重复 1~10 次</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CHOptimizedMethod1(self, void, MYViewController, appMethod, id, para) &#123;</span><br><span class=\"line\">    NSLog(@&quot;appMethod被Hook = %@&quot;, para);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n</li>\n<li>\n<p>CHOptimizedClassMethod3</p>\n<p>hook 类方法，所有函数定义同上</p>\n</li>\n<li>\n<p>CHConstructor 结构</p>\n<p>用来注册刚才的 hook 操作</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CHConstructor&#123;</span><br><span class=\"line\">  // 注册将要hook的类</span><br><span class=\"line\">    CHLoadLateClass(MYViewController);</span><br><span class=\"line\">\t// 注册将要hook 的方法</span><br><span class=\"line\">    CHHook1(MYViewController, appMethod);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面流程执行完成后就可以看到函数被 Hook 了</p>\n</li>\n</ul>\n<h2 id=\"hopper-disassembler\"><a class=\"anchor\" href=\"#hopper-disassembler\">#</a> Hopper Disassembler</h2>\n<p>上面的步骤讲了如何通过 lookin 或者 reveal 等工具来定位类名，然后通过类名在头文件中找到函数名，然后通过 hook 手段来改变函数的一些表现，但是在如何没有拿到.m 文件的前提下看到某个函数的实现呢？比如一个函数中都做了哪些操作，调用了哪些其他函数，以及调用链是怎样的？</p>\n<p>这个时候就需要用到 <code>Hopper Disassembler</code>  或者 <code>IDA Pro</code>  这样的工具了，不过目前遇到的困难是在笔者的系统环境下，这两个软件的破解版无法安装，而且 <code>IDA Pro</code>  的官方试用版还不支持 Arm 的汇编，所以只能使用 Hopper Disassembler 来举例子。打开软件，将 <code>对应App 的Mach-o</code>  文件拖入 Hopper 中等待它分析完成</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h85mc4b62oj31ec0u075n.jpg\" alt=\"image-20221115104755241\" /></p>\n<p>处理完后的界面左边会显示方法名，支持搜索查询，中间区域显示的是汇编代码，我们搜索一个在之前 dump 出的头文件中的一个函数名试下。</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[XXXXXXXX listenerDownloadLyricWithSongId:resultBlock:]</span><br></pre></td></tr></table></figure></p>\n<p>可以看到中间的部分显示出来函数所对应的汇编代码</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008vxvgGgy1h861n7q3isj317b0u0dlg.jpg\" alt=\"image-20221115193733635\" /></p>\n<p>然后按快捷键 <code>Option+enter</code>  即可转为伪 OC 代码，虽然包含一些的寄存器信息，但是也足以分析了。同时双击可以跳转到对应的函数内部。</p>\n<h2 id=\"最后\"><a class=\"anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>以上就是目前的逆向调研过程，这里先记录下，后面还会深入研究，有新的发现会同步更新此文章。</p>\n",
            "tags": [
                "iOS",
                "逆向"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2022-08-24-WWDC22%EF%BC%9ARuntime%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%92%8CApp%E5%87%8F%E5%8C%85/",
            "url": "https://oliverqueen.cn/2022-08-24-WWDC22%EF%BC%9ARuntime%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%92%8CApp%E5%87%8F%E5%8C%85/",
            "title": "WWDC22：Runtime的性能优化和App减包",
            "date_published": "2022-08-24T07:04:39.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>本 Session 讲了为了让你的应用包体积更小，运行更快，启动速度更快，我们对 Swift 和 Objective-C 运行时做了怎样的优化。同时通过本 Session 你将发现如何通过高效的协议检查，更小的消息发送，以及优化后的 ARC 机制，来提高你的 App 性能。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202301102018054.png\" alt=\"\" /></p>\n<p><span id=\"more\"></span></p>\n<p><div class=\"media-container\"><div class=\"player\" data-type=\"audio\" data-src='[\"https://music.163.com/#/song?id=1929370102\"]'></div></div></p>\n<h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>WWDC2022 上苹果更新了 Xcode14，里面提到了一些相关的优化。其中讲了通过对 Swift 和 Objective-C 运行时做了一些优化，达到了包体积变得更小、运行速度更快，启动速度更快的目的。如果你是用 Xcode14 来构建 App，那么会有其中三点优化</p>\n<ul>\n<li>高效的协议检查（针对 Swift protocol check）</li>\n<li>更快的消息发送机制（message send）</li>\n<li>release 和 retain 调用优化（release &amp; retain）</li>\n<li>Autorelease elision 的优化（自动释放省略）</li>\n</ul>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202301102019048.png\" alt=\"\" /></p>\n<p>当你用 Swift 或 Objective-C 编写代码时，其实是会经历三个个步骤。</p>\n<ul>\n<li>编码，通过 Xcode 编写代码</li>\n<li>编译，使用了 Swift 和 Clang 编译器</li>\n<li>运行，通过 Swift 和 Objective-C 运行时中完成</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gp9rcbq1j215t0u0754.jpg\" alt=\"image-20220823144936761\" /></p>\n<p>此次的这些关键优化其实就是在第三步骤运行时来完成的，运行时嵌入在我们所有平台的操作系统中。编译器在构建时不能做的事情，运行时可以做。而此次所有的修改其实对于开发者来说是无感透明的，所以任何代码都不用改动，只要你使用 Xcode14 来进行打包编译，便会享受的这些优化点。</p>\n<h2 id=\"swift协议检查protocol-checks\"><a class=\"anchor\" href=\"#swift协议检查protocol-checks\">#</a> Swift 协议检查（Protocol checks）</h2>\n<p>先来看一个例子！</p>\n<p><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个协议</span></span><br><span class=\"line\"><span class=\"keyword\">protocol</span> <span class=\"title class_\">CustomLoggable</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 协议中定义一个属性 customString，只读属性</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> customLogString: <span class=\"type\">String</span> &#123; <span class=\"keyword\">get</span> &#125;        </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个log函数，参数为Any类型</span></span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">log</span>(<span class=\"params\">value</span>: <span class=\"keyword\">Any</span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">//如果value遵循CustomLoggable协议，就输出字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> value <span class=\"operator\">=</span> value <span class=\"keyword\">as?</span> <span class=\"type\">CustomLoggable</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">debugPrint</span>(value.customLogString)        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"operator\">...</span>        </span><br><span class=\"line\">    &#125;       </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个Event类型 遵循协议，并实现customLogString</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Event</span>: <span class=\"title class_\">CustomLoggable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> date: <span class=\"type\">String</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> customLogString: <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;<span class=\"subst\">\\(<span class=\"keyword\">self</span>.name)</span>, on <span class=\"subst\">\\(<span class=\"keyword\">self</span>.date)</span>&quot;</span>    </span><br><span class=\"line\">    &#125;        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>看上面代码，因为 log 函数的参数需要输出字符串，所以在输出前要先判断这个 value 是否遵循 CustomLoggable 协议，Swift 是静态语言，所以一般来说这样的检查都是发生在编译时期。但是编译器不一定能拿到足够的协议元数据信息来完成检查。比如这里并不知道每次传入的 Any 类型是哪个确定类型，也就无法确定是否遵循  <code>CustomLoggable</code>  协议。所以这种检查常常发生运行时，系统借助计算好的协议检查元数据 (protocol check metadata)，运行库知道这个特殊对象是否符合协议。</p>\n<p>这些元数据的构建虽然大部分在编译期间，但是还是有一部分是要在运行时完成，比如上面的例子，而且一个项目中肯定不止有一个协议，所以随着协议越多运行时的效率就越低，对于用户来说这个时间大部分是启动时间，所以用户感知为启动时间变长。而 Xcode14 新推的的 Swift Runtime 解决了这个问题，只要你是用 Xcode14 编译且运行在 iOS16 及以上版即可。</p>\n<p>按照苹果的说法，他们会把 <code>是否遵循协议</code> 的这个判断前置到 build 时期，也就是把 <code>协议元数据计算</code> 的步骤前置到 build 中，具体就是他把这些操作放在 App 可执行文件和启动时任何动态库的 dyld 闭包的一部分</p>\n<p>为什么这样做可以节省启动时间，需要先了解下 app 启动流程，需要一个知识背景 <code>从iOS11开始dyld3被加入，iOS13第三方库也开始使用dyld3加载。</code> 所以我们要看下 dyld3 的加载流程</p>\n<p><img data-src=\"https://upload-images.jianshu.io/upload_images/2438680-b5edfa4c2bcdb205.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1044/format/webp\" alt=\"img\" /></p>\n<p><em>dyld 3</em> 主要包含了两个过程 进程外（启动前）和进程内（启动后），我们来看启动前做了那些事情</p>\n<ul>\n<li>进程外 <em>Mach-O</em> 分析器和编译器 （<em>out-of-process mach-o parser</em>）<br />\n<em>dyld 3</em> 中将采用提前写入把结果数据缓存成文件的方式构成一个 <em>lauch closure</em>（可以理解为缓存文件）</li>\n<li>分析依赖库</li>\n<li>执行符号查找</li>\n<li><em>Write closure</em> 缓存服务 (<em>launch closure cache</em> )<br />\n 系统程序的 <em>closure</em> 直接内置在 <em>shared cache</em> 中，而对于第三方 APP，将在 APP 安装或更新时生成，这样就能保证 <em>closure</em> 总是在 APP 打开之前准备好。说白了就是把上面做的结果全都缓存起来</li>\n</ul>\n<p>综上看来以前需要在 in-process 中做的事情，现在在 out-of-process 就可以完成，启动时或者运行时直接读取缓存数据即可，加快了启动速度和运行时的性能。其实在笔者看来当我们下载或者更新 App 的时候 App 上的进度条其实是分两部分 <code>正在下载</code> 和 <code>正在安装</code> ，此次的优化可能略微提高安装的时长来降低启动速度，提高运行时性能。</p>\n<p><code>on apps that rely heavily in Swift, this could add up to half the launch time</code>  如果有条件的同学可以试下是否可以提高这么多的启动耗时。</p>\n<h2 id=\"消息发送优化message-send\"><a class=\"anchor\" href=\"#消息发送优化message-send\">#</a> 消息发送优化（Message send）</h2>\n<p>直接抛结果，苹果这边给到的数据是使用 Xcode14 编译打包的数据可以让 ARM64 上发送消息消耗从 12 字节降低到 8 字节，二进制大小也有 2% 的降低，也就是苹果对包大小和性能都做了优化，默认是同时开启的，由苹果来平衡两者的关系，当然也可以使用 <code>objc_stubs_small</code>  来仅仅优化包大小。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5grqpljrej215t0u0aax.jpg\" alt=\"image-20220823161510950\" /></p>\n<p>下面我们看下是怎么优化的，同样使用官方代码举例</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 声明一个日历对象</span><br><span class=\"line\">NScalendar *cal = [self makeCalendar];</span><br><span class=\"line\"></span><br><span class=\"line\">// 声明一个日期对象并赋值</span><br><span class=\"line\">NSDateComponents *dateComponents = [[NSDateComponents alloc] init];</span><br><span class=\"line\">dateComponents.year = 2022;</span><br><span class=\"line\">dateComponents.month = 2022;</span><br><span class=\"line\">dateComponents.day = 2022;</span><br><span class=\"line\">S</span><br><span class=\"line\">// 把日期转换为date</span><br><span class=\"line\">NSDate *theDate = [cal dateFromComponents: dateComponents];</span><br><span class=\"line\"></span><br><span class=\"line\">// 返回date</span><br><span class=\"line\">return theDate;</span><br></pre></td></tr></table></figure></p>\n<p>大家知道 OC 调用方法最终会走到 <code>_objc_msgSend</code> ，所以上面代码不算最终的 return，会走 7 个  <code>_objc_msgSend</code> ，其中每一个都需要一条指令来调用就是 bl 如下图</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gsa0ef9kj20n00gidgx.jpg\" alt=\"image-20220823163343886\" /></p>\n<p>该函数定义为 <code>Id objc_msgSend(id self, SEL _cmd, ...) </code> ，参数定义为 self 是函数的调用方，SEL 为具体调用哪个函数，具体的方法查找流程就不在这里赘述。</p>\n<p>我们拿其中具体的一个函数调用来分析</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSDate *theDate = [cal dateFromComponents: dateComponents]; </span><br></pre></td></tr></table></figure></p>\n<p>比如这个函数调用，转化为 mesagesend 的时候就变成这样</p>\n<p><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_msgSend(cal, @selector(dateFromComponents))</span><br></pre></td></tr></table></figure></p>\n<p>为了告诉运行时调用哪个方法，我们必须传递一个 Selector 给这些 objc_msgSend 调用，就如上图的 <code>@selector(dateFromComponents)</code></p>\n<p>我们再来看 <code>Id objc_msgSend(id self, SEL _cmd, ...)</code>  执行后他是怎么执行汇编指令的。</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用adrp找到该方法的地址   消耗4字节</span><br><span class=\"line\">adrp x1, [selector &quot;dateFromComponents&quot;]  </span><br><span class=\"line\"></span><br><span class=\"line\">// 将 地址加载到X1寄存器中  消耗4字节</span><br><span class=\"line\">ldr  x1, [x1, selector &quot;dateFromComponents&quot;] </span><br><span class=\"line\"></span><br><span class=\"line\">// 执行bl指令跳转到该方法并执行  消耗4字节</span><br><span class=\"line\">bl _objc_msgSend</span><br></pre></td></tr></table></figure></p>\n<p>从上面的代码看出每次执行方法调用都会 走以上三个步骤，每个步骤消耗 4 字节 一共消耗 12 字节，而前两步是准备 selector，任何一次方法调用都会执行他，目前的策略是每调一个方法都会生成上面三步，那么此时优化空间就来了。</p>\n<p>因为这里存在相同的代码（前两步）， <code>我们可以考虑共享它，并且只在每个 selector 中触发它一次，而不是每次发送消息时都生成这段指令代码</code> 。所以我们可以把这部分相同代码提取出来，放到一个小助手函数中 (helper function), 并调用该函数。通过使用同一 selector 进行多次调用 (通过传递参数不同，内部指令是相同的，现在封装成一个存根函数，以前是散落在各个 _objc_msgSend 调用处)，我们可以保存所有这些指令字节。所以可以理解为 <code>把前两步封装一下</code></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gvtbfnh1j20n00git9h.jpg\" alt=\"image-20220823183604633\" /></p>\n<p>所以原来的调用就变成了</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bl _objc_msgSend$dateFromComponents 4字节</span><br><span class=\"line\">bl _objc_msgSend    4字节</span><br></pre></td></tr></table></figure></p>\n<p>这也就是苹果说的从 12 字节优化到 8 字节，其中 <code>_objc_msgSend$dateFromComponents</code>  也被称为 <code>selector stub 存根函数</code></p>\n<p>同样 <code>_objc_msgSend</code>  本身也有一个存根函数写法</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gw1kpzuzj20n00giwfd.jpg\" alt=\"image-20220823184401200\" /></p>\n<p>这样一来我们现在就有两个存根函数</p>\n<ul>\n<li>_objc_msgSend$dateFromComponents:</li>\n<li>_objc_msgSend:</li>\n</ul>\n<p>这两个函数封装了一些通用的东西，共享了最多的代码，使代码尽可能的小，但是这样带来的不足是我需要连着两个 bl 跳转，这对操作系统来说开销较大。所以为了平衡包体积和性能，我们可以使用下面这种方法来提升这一点。我们可以把前面调用的两个存根函数封装成一个 (都封装成_objc_msgSend$dateFromComponents)，这样，我们可以使代码更紧凑，不需要那么多调用。如下图这样</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gwei63esj20bo07u74l.jpg\" alt=\"image-20220823185626349\" /></p>\n<p>这就回到了之前的问题，你可以通过 <code>_objc_stubs_small</code>  标记了只降低包大小，或者采用默认的方式让系统自动平衡，两者的区别在汇编层面就体现在如下图</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gwg7hnugj20n00gidhc.jpg\" alt=\"image-20220823185804687\" /></p>\n<p>综上：这就是 Meesage send 占用从 12 bytes 降低到 8 bytes 和二进制大小下降 12% 的原因</p>\n<h2 id=\"retain-and-release\"><a class=\"anchor\" href=\"#retain-and-release\">#</a> Retain and release</h2>\n<p>这个优化是苹果这边使 Retain and release 的开销更小，苹果的说法是 Retain and release 的调用开销从 8 字节降低到 4 字节，同时包体积也会有 2% 的优化</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gwkqxaenj20n00gidg9.jpg\" alt=\"image-20220823190226429\" /></p>\n<p>我们知道 ARC 相比于 MRC 是开发者不需要再写 retain、release 这些代码，其实并不是不需要，而是编译器帮我们自动在需要的位置插入了这些代码，所以换句话说他们还是存在的，只是你看不到也不用在关心他们。</p>\n<p>还是拿之前的例子来说</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Retain/release calls inserted by ARC</span><br><span class=\"line\">NScalendar *cal = [self makeCalendar]; // bl    _objc_retain</span><br><span class=\"line\"></span><br><span class=\"line\">NSDateComponents *dateComponents = [[NSDateComponents alloc] init]; // bl    _objc_retain</span><br><span class=\"line\">dateComponents.year = 2022; </span><br><span class=\"line\">dateComponents.month = 2022;</span><br><span class=\"line\">dateComponents.day = 2022;</span><br><span class=\"line\"></span><br><span class=\"line\">NSDate *theDate = [cal dateFromComponents: dateComponents]; // bl    _objc_retain</span><br><span class=\"line\">return theDate;</span><br><span class=\"line\">// bl    _objc_release </span><br><span class=\"line\">// bl    _objc_release </span><br><span class=\"line\">// bl    _objc_release </span><br></pre></td></tr></table></figure></p>\n<p>在变量创建的时候我们使用 retain 来增加的他的引用计数不被销毁，在方法结束后我们使用 release 来销毁不需要的变量，这也是 iOS 的内存管理机制。在 ARC 下这些都是编译器我们插入的代码，我们无需关心。</p>\n<p>retain 和 release 都是 C 语言的函数，他们携带一个参数就是被操作的对象，同时他遵循 C 语言的 ABI，所以当你调用这些方法的时候系统还会为你做一些额外的事情，比如下图中的 mov 操作，而这些操正是我们优化的用武之地，通过自定义调用重新约定 retain/release 接口，我们可以根据对象指针的位置，适当的使用正确的变量，这样就可以不用移动它。简单的说， <code>就是修改了底层 ABI</code> 。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gwylzjkuj20n00giab1.jpg\" alt=\"image-20220823191546398\" /></p>\n<p>我们是怎么做的优化呢？看下之前的流程，我们用下面这行代码举例</p>\n<p><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_release(dateComponents); </span><br><span class=\"line\"><span class=\"comment\">// mov  x0, x20                    消耗4 字节                                                                                                                                                           </span></span><br><span class=\"line\"><span class=\"comment\">// bl    _objc_release         消耗4字节</span></span><br></pre></td></tr></table></figure></p>\n<p>流程为</p>\n<ul>\n<li>先执行 mov 把副本地址（X20, 也就是对象的地址）存到寄存器 x0</li>\n<li>然后 bl 跳转到 <code>_objc_release</code>  函数进行释放</li>\n</ul>\n<p>根据之前讲的每个指令消耗 4 字节，所以这里消耗 8 字节</p>\n<p>我们修改 ABI 之后其省掉调用 mov 指令 然后原本跳转到_objc_release 函数 改为跳转到 <code>_objc_release_x20</code>  函数，而 mov 的指令放到 C 语言更底层的 ABI 里面去做，你可以理解为 <code>我们封装了一个新的retain、release函数，你只要传入一个寄存器地址我就去更底层的地方完成mov操作，所以效率更高了</code> 。现在因为只用执行一条指令，所以内存消耗为 4 字节。现在的流程看起来为</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gx83ebs8j20n00giab9.jpg\" alt=\"image-20220823192452605\" /></p>\n<p>这么看来我们代码里大量的 release 和 retain 都经过这样的样的优化所以整体的二进制包降低 2% 同时调用内存消耗游 8 字节变为 4 字节，同时 ABI 接口修改，去除冗余 mov 指令调用，下沉到 ABI。 <code>由于 ABI 是内嵌系统</code> ，这里新增 mov 指令占用可以忽略不计。</p>\n<p><code>Apple 果然是坚持用户体验优先，为了更好体验不惜修改 c 的 ABI</code></p>\n<h2 id=\"autorelease-elision自动释放省略优化\"><a class=\"anchor\" href=\"#autorelease-elision自动释放省略优化\">#</a> Autorelease elision（自动释放省略优化）</h2>\n<p>iOS 中除了使用 release 之外还有另一个 就是 autorelease 自动释放机制，同样在这个地方苹果也做了自动释放省略的优化让自动释放机制效率更高。我们来看下面这个例子</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Return Value Autoreleases </span><br><span class=\"line\"></span><br><span class=\"line\">theWWDCDate = [event getWWDCDate];</span><br><span class=\"line\"></span><br><span class=\"line\">-(NSDate*)getWWDCDate &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    return theDate;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>创建一个临时对象 (theDate)，并将其返回给调用方 (event)。 <code>getWWDCDate()</code>  方法中返回临时的 theDate，然后调用完成 (返回 theDate 之后，getWWDCDate 就调用完成)。这时调用方（event）将其保存到自己的变量中（theWWDCDate 中）。</p>\n<p>根据系统插入 retain 和 release 的机制来说应该是这样的，但是明显 retain 处不能进行 release，因为我需要吧 theDate 返回回去，如果这里释放了我就没办法呢返回了。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gy19928nj20n00gi3yz.jpg\" alt=\"image-20220823195254398\" /></p>\n<p>因此，为了解决上述问题，需要使用一个特殊的约定用来返回这个临时返回值。这就引入了 Autorelease，这样调用者能够 retain 它。autorelease 在这里保证在调用方可以正常返回该值，而不被提前释放，延长释放生命周期。你之前可能看到过 autorelease 和 autoreleasePools：其实这是一种将 release 操作推迟到稍后某个时间的方法。所以上面的代码改为 Autorelease</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Return Value Autoreleases </span><br><span class=\"line\"></span><br><span class=\"line\">theWWDCDate = [[event getWWDCDate] retain];</span><br><span class=\"line\"></span><br><span class=\"line\">-(NSDate*)getWWDCDate &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    return [theDate autorelease]; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>系统并不知道他在什么时候会被释放，反正只要不在 retain 的时候释放就行，所以我在 retain 的时候先打个标记，标记他之后可能会被释放。但是这样的操作目前会带来一些开销，其实就是 <code>我虽然打了release标记，但是我明明一会还要retain，没必要多此一举</code> ，所以基于此我们之前引入了 <code>Autorelease elision</code>  来减少这部分开销（ <code>如果Autorelease后紧接一个retain我就都不做了</code> ）。我们先从汇编层面看下 Autorelease elision 做了什么</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gy8n9wnzj20n00giwf7.jpg\" alt=\"image-20220823195959365\" /></p>\n<p>提炼出以下代码</p>\n<p><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// What the compiler emits</span></span><br><span class=\"line\"> bl    _getWWDCDate </span><br><span class=\"line\"> mov   x29, x29</span><br><span class=\"line\"> bl    _objc_retainAutoreleasedReturnValue</span><br><span class=\"line\"></span><br><span class=\"line\"> b    _objc_autoreleaseReturnValue   <span class=\"comment\">// autorelease -&gt; runtime -&gt; _objc_autoreleaseReturnValue</span></span><br></pre></td></tr></table></figure></p>\n<p>其实就是以下步骤</p>\n<ul>\n<li>当我们返回值调用 Autorelease 时候系统会调用 <code>_objc_autoreleaseReturnValue</code>  来返回一个 <code>autoreleased value</code></li>\n<li>执行 Autorelease 后编译器会添加个标记 <code>mov x29, x29</code>   而这句指令在实际运行中这个指令会变为二进制的形式变为 <code>0xAA1D03FD</code></li>\n<li>后续的操作就运行时会先判断是否有对应的标记 <code>0xAA1D03FD</code> ，如果有，这意味着编译器告诉 runtime, 我们将返回一个已经被标记，但是将立即被持有（retain） 的临时变量，后面就不需要再 retain 操作了</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5h056kleej20n00gigm5.jpg\" alt=\"image-20220823210550374\" /></p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static ALWAYS_INLINE bool </span><br><span class=\"line\">callerAcceptsOptimizedReturn(const void *ra)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // fd 03 1d aa    mov fp, fp</span><br><span class=\"line\">    // arm64 instructions are well-aligned</span><br><span class=\"line\">    if (*(uint32_t *)ra == 0xaa1d03fd) &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">        // 返回true 需要优化 把release、rentain删掉</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>说白了就是在返回值身上调用 <code>objc_autoreleaseReturnValue</code>  方法时，runtime 将这个返回值 object 标记（储存在 TLS 中），然后直接返回这个 object（不调用 autorelease）；同时，在外部接收这个返回值的 <code>objc_retainAutoreleasedReturnValue</code>  里，发现有之前的标记（TLS 中正好存了这个对象），那么直接返回这个 object（清楚之前的标记且不再调用 retain）。</p>\n<p>注意：TLS 相关的含义可以参考 [这里](<span class=\"exturl\" data-url=\"aHR0cDovL3NlYW5jaGVuc2UuZ2l0aHViLmlvLzIwMTgvMDkvMjAvZWFybGdyZXktc291cmNlLWNvZGUtcmVhZC0xLyNUTFM=\">EarlGrey 源码阅读（一） | SeanChense</span>)</p>\n<p>但是这里有一个问题，以二进制的形式来加载代码并不是很常见，而且我们不但要加载它还要比较他尤其在 CPU 上并不是最优策略，所以这里还是有开销的，因此我们看下如何优化。</p>\n<p>同样执行流程，当执行完 <code> _objc_autoreleaseReturnValue</code>  函数时候我们会获得一个返回地址，这个地址是一个指针，指向了被标记为 Autorelease 的对象。然后代码继续执行到 <code>_objc_retainAutoreleasedReturnValue</code>  这里要进行 reatin，而被 reatain 的变量地址我们也可以拿到，所以只要比较这两个指针即可，这样一来我们也不再需要 mov 操作</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5h0ws62g0j20n00gidg3.jpg\" alt=\"image-20220823213224122\" /></p>\n<p>优化点</p>\n<ul>\n<li>把原来的比较二进制数据改为比较指针。速度更快效率更高</li>\n<li>减少 mov 指令 减少 4 字节，二进制大小预计降低 2%</li>\n</ul>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>这就是 Xcode14+iOS16 的编译期间优化，可以看出苹果也在帮我们完成 OKR 减少包体积，提高启动速度，增加代码执行效率，同时也能看出苹果在追求极致用户体验道路上所做的事情。本文部分翻译自<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL3ZpZGVvcy9wbGF5L3d3ZGMyMDIyLzExMDM2My8=\"> Improve app size and runtime performance</span>，同时也添加了自己的思考。</p>\n",
            "tags": [
                "iOS",
                "WWDC2022"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2022-06-13-WWDC2022-iOS%E7%AF%87%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/",
            "url": "https://oliverqueen.cn/2022-06-13-WWDC2022-iOS%E7%AF%87%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/",
            "title": "WWDC2022-iOS篇完全解析",
            "date_published": "2022-06-13T09:05:31.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景</h1>\n<p>Apple 于北京时间 2022 年 6 月 7 日举办了 WWDC2022，作为一名 Apple 开发者，不仅仅是为了保持技术敏感度，同时也希望在第一时间将新的内容呈现在大家眼前。本文对发布会内容做了整理归纳，并着重对 iOS 的新内容进行分析。希望这篇文章对大家有所帮助的同时也给我们的产品带来更多的可能性。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h344hz8cl3j21g20pswhk.jpg\" alt=\"9690f67c1bc2cc62bd8729e5182ef19a\" /></p>\n<p><span id=\"more\"></span></p>\n<p>相对于 iOS15 来说，iOS16 的整体变化比较大，尤其是在我们看得见的地方，比如一些 UI 样式，交互行为和一些新增的功能。下面会按照 WWDC 的出厂顺序来介绍，其中包含了每个改动点的细节以及个人的理解和后面的展望。</p>\n<h1 id=\"developer\"><a class=\"anchor\" href=\"#developer\">#</a> Developer</h1>\n<h2 id=\"xcode相关\"><a class=\"anchor\" href=\"#xcode相关\">#</a> Xcode 相关</h2>\n<p>新版的 Xcode 同样也跟新了相关的内容，帮助开发者提高开发效率。</p>\n<h4 id=\"方法吸顶以及代码提示\"><a class=\"anchor\" href=\"#方法吸顶以及代码提示\">#</a> 方法吸顶以及代码提示</h4>\n<p>在之前的版本中，如果方法函数过多超了一屏展示，随着滚动函数名不可见，而新版的 Xcode 提供了类似 TableViewHeader 的效果，让方法名和实现名字固定在顶部，方便随时查看和复制。对小屏还是比较友好的。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342t0jx5qj215h0u040m.jpg\" alt=\"enter image description here\" /></p>\n<p>同样在使用初始化方法的时候如果是支持传入参数的初始化方法也会通过斜体来进行参数提示 (Swift 专属)</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342t2czj8j20u00akt9s.jpg\" alt=\"enter image description here\" /></p>\n<h4 id=\"xcode安装体积\"><a class=\"anchor\" href=\"#xcode安装体积\">#</a> Xcode 安装体积</h4>\n<p>新版的 Xcode 优化了包体积，同时在进行安装的时候可以自定义需要哪些平台，需要哪些模拟器，笔者亲测相比之前的无脑把 AppleTV、Apple Watch、ipad 等都安装下来的情况来看，整个包体积减少了十几个 G 左右。对于小存储的 MacBook 是一个福音。</p>\n<h4 id=\"xcode编译与调试\"><a class=\"anchor\" href=\"#xcode编译与调试\">#</a> Xcode 编译与调试</h4>\n<p>根据苹果的描述新版 Xcode 优化项目的编译速度， <code>得益于更强大的并行编译能力，项目构建速度提升至高可达 25%</code> 。</p>\n<ul>\n<li>改善前：先编译 framework 里的代码，然后生成 module，然后编译 app 里的代码，最终经过链接完成了构建。</li>\n<li>改善后：通过提高并发，缩短了构建的关键的路径</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tn4mxij20yl0u0415.jpg\" alt=\"enter image description here\" /></p>\n<p>同时单元测试的效率也提高了 30%</p>\n<p>Xcode14 还支持输出编译期间每个阶段的耗时和详细信息，相比之前的只能通过控制台的名字描述要直观不少。<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342x91jz4j21910u0wir.jpg\" alt=\"编译耗时\" /></p>\n<p>对于 LLDB，现在还可以看到执行的过程和信息，对于一些需要长时间跑的命令较为友好，类似于 <code>--verbose</code>  参数的含义</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tgt828j21dg0323yy.jpg\" alt=\"enter image description here\" /></p>\n<p>在新版的 Xcode 中除了 App 和系统的日志，同样支持 LLDB 的日志输出，当时在用 LLDB 调试的时候发生 Crash，便可以到相关路径中找到对应日志。<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342t3pka9j21ay02kjrp.jpg\" alt=\"enter image description here\" /></p>\n<h2 id=\"开发者模式\"><a class=\"anchor\" href=\"#开发者模式\">#</a> 开发者模式</h2>\n<p>新版的 iOS 和 Watch OS 引入了新的开发者模式，原理和安卓的开发者模式类似，用苹果的话说是为了 <code>开发者模式可防止人们无意中在其设备上安装可能有害的软件，并减少开发者专用功能所暴露的攻击媒介。</code> ，对于普通人来说确实可以提高安全性，之前只要是加入了开发者账号的手机都可以从 Xcode 编译运行第三方的 App，或者按照企业证书的签名包，而不这些手机主人都是无感的，现在需要手机主人通过多重确认来打开此功能后才可以进行安装非 <code>App Store</code>  和 <code>Testfilght</code>  渠道的包。</p>\n<p>但是这个对于开发者来说并不友好，首先是调试过程有会多增加一些步骤，而且在自动化测试方面，所有的手机都要先通过命令来打开开发者模式，并且根据苹果的说法，使用命令行进行开关要确保手机没有密码，否则会被拒绝运行。这里笔者也尝试在未打开 <code>开发者模式</code> 的情况下进行 Xcode 编译，确实会失败。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342ygml7gj208y01kdfo.jpg\" alt=\"enter image description here\" /></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3358k3glij207s087aaa.jpg\" alt=\"\" /></p>\n<p>笔者预测该功能可能是为后续的第三方 App 市场做准备，因为现在虽然苹果不支持三方市场，但是普通用户还是可以通过一些三方网站安装重签包，同时他们并不知道这些包会带来潜在的危险，再加上欧盟一些反垄断政策的施压，所以苹果决定逐步开放三方应用市场，这应该就是第一步吧，先让用户意识到这样做可能会有一些危害。</p>\n<p><code>无论是美国的《美国选择与创新法案》、还是欧盟的《数字市场法案》，都要求苹果在App Store之外为用户提供额外的应用下载渠道。现在看来，苹果方面可能已经认为改变欧盟与美国的态度已经不太可能了，那么既然支持侧载或许无法避免，那么让用户更难发现侧载功能的入口就成为了备选项。</code></p>\n<h1 id=\"lockscreen\"><a class=\"anchor\" href=\"#lockscreen\">#</a> LockScreen</h1>\n<h2 id=\"锁屏样式\"><a class=\"anchor\" href=\"#锁屏样式\">#</a> 锁屏样式</h2>\n<p>重新修改了锁屏的样式，在优化了时间显示的字体的同时也在锁屏上提供了更多能力，展示更多的信息，并加入了一些新的交互样式，通过在锁屏界面长按来进入锁屏界面的编辑状态，这个动画效果有点类似安卓的编辑桌面的效果。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3430h983bg208a0gnhe7.gif\" alt=\"image\" /></p>\n<p>iOS16 的锁屏样式可以大致分为两类</p>\n<ul>\n<li>动态锁屏<br />\n比如在 Beta1 中可以看到的天气锁屏，依赖于天气 App 的信息，在点亮屏幕的一瞬间可以在锁定屏幕上动态显示天气的效果，比如雨雪风晴等，持续几秒钟后停止。笔者预测该能力后续会和 Livephoto 关联起来，实现用户自定义动态照片，毕竟现在的 livephoto 设置锁屏之后只有在长按才会触发播放，到时候长按的手势会和设置锁屏的手势冲突，所以 livephoto 必然会变成自动播放，</li>\n</ul>\n<p>再长远预测的话也可能后续会把该能力开放给第三方 App 来定制动态锁屏的图片，类型于现在的天气 App。比如 QQ 音乐的专辑封面，歌手的演唱动图等。目前动态背景只支持锁屏界面，解锁后进入桌面便会停止，估计是处于性能考虑，动态桌面的可能性不大，应该仅限于锁屏。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tiho1zg207u0gou0z.gif\" alt=\"image\" /></p>\n<ul>\n<li>静态照片<br />\n iPhone 一直可以支持设置静态照片为锁屏壁纸，但是 iOS16 给静态照片锁屏提供了更多的玩法。</li>\n<li>照片随机切换：用户可以选定一组照片来作为锁屏壁纸，类似于幻灯片放映的样式，切换的频率可以设置为  <code>每次点亮</code>  、  <code>每次点击</code>  、  <code>每小时</code>  、  <code>每天</code>  。</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tuul3fg207z0gnqvl.gif\" alt=\"image\" /></p>\n<ul>\n<li>照片景深：这个能力算是 iOS16 更新比较大的，通过机器学习模型将照片中的主体突出，可以遮挡在时间上，这里的主体可以是图片中任何可区分的物体，不仅仅是人像模式的照片。(在实际使用中，经常会失败，beta1 还是不够稳定)</li>\n</ul>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzExYno5bmoyMGkyMTJ5YWNpLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h34311bz9nj20i212yaci.jpg</span>&quot; alt=&quot;image#268px #578px&quot; style=&quot;zoom:50%;&quot; /&gt; &lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzI0OHBnOWoyMG11MTh1ZG1oLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h343248pg9j20mu18udmh.jpg</span>&quot; alt=&quot;image#292px #574px&quot; style=&quot;zoom:43%;&quot; /&gt;</p>\n<ul>\n<li>表情壁纸：将 IPhone 输入法中自带的表情进行一定规律的排列组合形成一张壁纸，最多支持输入六个表情。</li>\n<li>颜色壁纸：可以定义一些渐变颜色</li>\n<li>官方背景图壁纸。一些官方图片，支持景深效果</li>\n</ul>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MnRxcXZldWoyMGh3MTB3cTViLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tqqveuj20hw10wq5b.jpg</span>&quot; alt=&quot;image#189px #390px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h2 id=\"锁屏组件\"><a class=\"anchor\" href=\"#锁屏组件\">#</a> 锁屏组件</h2>\n<p>iOS16 在锁屏界面可以展示更多的信息，其中就包括了锁屏小组件的加入。可以看到锁屏顶部分三个区域。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzJkMTZoc2oyMGllMTNhZGllLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3432d16hsj20ie13adie.jpg</span>&quot; alt=&quot;image#270px #577px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<ul>\n<li>顶部：顶部区域是一个小的小组件区域，同时只能容纳一种小组件放置，🇳信息量有限。</li>\n<li>中部：中部区域是固定展示时间的区域，不可放置自定义小组件。只能展示时间信息，但是用户可自定义字体（包括阿拉伯文、天成文）和颜色。</li>\n<li>底部：底部区域为第二个小组件区域，范围较大，最多可容纳 4 个正方形（1*1）的小组件。同时支持排列组合。</li>\n</ul>\n<p>目前小组件的支持非常有限，目前只能将系统级的 App 的组件放上去，并不支持第三方 App，笔者尝试写了一个小组件，在主屏幕上可以正常添加，但是在锁定屏幕无法使用，猜测两个原因，一是目前是 Beta1 版可能还没有开放三方 App 的小组件，后续会陆续优化上来；第二个原因可能是处于性能或者其他因素考虑锁频组件和主屏组件不是一套逻辑，并不互通，但是通过查看 Xcode Beta 版本的代码，没有看到相关线索，不过 WWDC 也提到了，一些功能在后续会以 API 的形式像开发者提供。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MnR5bThndGoyMGk2MTMwNzdoLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tym8gtj20i613077h.jpg</span>&quot; alt=&quot;image#266px #571px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h2 id=\"锁屏通知\"><a class=\"anchor\" href=\"#锁屏通知\">#</a> 锁屏通知</h2>\n<p>iOS16 调整了锁屏的样式，增加了锁屏界面所展示的信息和交互，所以希望锁屏界面不要被大量的通知遮挡，因此从新调整了通知推送的位置和出现动画。iOS16 之前：通知铺满锁屏，同时新的通知会插到到最上面。从上往下依次排列。iOS16 之后：锁屏区域被限定在底部一小块区域，新来的通知会插到第一层，但是默认只展示 3 个（叠放的形式），想看更多的话跟之前一样，上拉即可。任何新增的通知，包括常驻的音乐播放调都是从下往上增长，通知增长到一定高度就会开始折叠，这样的好处就是可以给锁屏留出空间，不至于被占满。</p>\n<p>这样的修改确实可以让锁屏界面看的更整洁，且能让用户看到自己喜欢的锁屏画面，但是带来一个问题是用户想要查看通知内容时候需要多做一步上拉的操作，可能会稍微影响到 Push 的效果，比如点击率之类的指标。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3432t13nsg207m0go7wr.gif\" alt=\"image\" /></p>\n<h2 id=\"live-activities\"><a class=\"anchor\" href=\"#live-activities\">#</a> Live Activities</h2>\n<p>上面说的苹果弱化了通知展示的样式，默认采用了折叠策略给锁屏留出了更大的空间，但是为了让用户实时的追踪想要的信息便推出了  <code>Live Activities</code>  。该控件可以常驻在锁屏界面，且能够实时刷更新的一个 UI 控件，</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tq7i9qj214g0mg3zz.jpg\" alt=\"image\" /></p>\n<p>WWDC 上举了一个恰当的例子，比如我在追踪一场比赛，我需要知道实时的比分信息，但是又不方便拿着手机 app 观看直播，所以支持了  <code>Live Activities</code>  能力的 App 可以再锁屏界面来实时展示比赛信息，同时不需要解锁屏幕，还有优步的信息。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzMxbGNyM2oyMHdjMG13bjFnLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h34331lcr3j20wc0mwn1g.jpg</span>&quot; alt=&quot;image#321px #227px&quot; style=&quot;zoom: 33%;&quot; /&gt;&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzM3NWh2ZWoyMHc2MG0wanZhLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h343375hvej20w60m0jva.jpg</span>&quot; alt=&quot;image#334px #228px&quot; style=&quot;zoom: 35%;&quot; /&gt;</p>\n<p>这有点类似于锁屏的音乐播放条。同时 IOS16 针对音乐播放调界面也做 UI 优化，可以通过点击来实现封面图展开，同时背景设置为封面的魔法色，实现全屏沉浸式播放。但是笔者实测时候并未在 beta 版上成功使用该功能，SDK 中也没有看到相关代码。应该是在后续的版本开放更新。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzVsb3c4Z2oyMGhrMHhlNDFqLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3435low8gj20hk0xe41j.jpg</span>&quot; alt=&quot;image#305px #580px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h2 id=\"专注模式\"><a class=\"anchor\" href=\"#专注模式\">#</a> 专注模式</h2>\n<p>苹果去年推出了  <code>专注模式</code>  ，但是专注模式的切换需要到控制中心，或者设置菜单中进行切换，隐藏较深，在这次的 iOS16 中，苹果将专注模式和锁定屏幕绑定起来，也就是实现专注模式和锁定屏幕  <code>一一对应</code>  的关系，一个锁屏对应一套锁屏组件和一个专注模式。</p>\n<p>比如我下图中两个锁定屏幕分别对应两种模式，工作模式可以设置只接受某些 App 的推送（比如企业微信。WeSing 等），忽略某些不重要的通知。右边的游戏模式可以吧比较关注的电量信息放到锁屏，同时屏蔽通知避免游戏误操作。关键是在 iOS16 上两种模式的切换只要在锁屏上长按就可以进行更改，方便很多。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzV0a3QxZWoyMGcyMHpnYWQxLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3435tkt1ej20g20zgad1.jpg</span>&quot; alt=&quot;image#337px #744px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h1 id=\"信息app\"><a class=\"anchor\" href=\"#信息app\">#</a> 信息 App</h1>\n<h2 id=\"消息编辑\"><a class=\"anchor\" href=\"#消息编辑\">#</a> 消息编辑</h2>\n<p>根据 WWDC 的描述，信息 App 带来的三个呼声最高的功能（应该是国外用户）</p>\n<ul>\n<li>动态编辑信息：对于已经发送出去的信息，如果发现错别字，可以直接在自己刚刚发送的对话气泡上进行修改，像这样，就不需要再撤回然后重新辑后发送。</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3436v6e47g20go080e86.gif\" alt=\"image\" /></p>\n<ul>\n<li>\n<p>标记未读（国内玩腻了的）</p>\n</li>\n<li>\n<p>消息撤回（国内玩腻了的）</p>\n</li>\n</ul>\n<h2 id=\"shareapi\"><a class=\"anchor\" href=\"#shareapi\">#</a> ShareApi</h2>\n<p>iOS15 中提到了  <code>SharePlay</code>  的能力，但是当时该能力必须基于 FaceTime。在 iOS16 中，该能力已经扩展的信息 App 中。笔者认为，  <code>SharePlay</code>  的能力后续会形成套单独的 SDK（类似于 AirPlay 的 SDK），供第三方 App 接入，且不依赖 Facetim 和信息等系统 App。这对于音视频的 App 是有比较大的帮助，可以一起听歌、看视频。但是对于版权的管理要更为严格。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM3cmhidXc2Y2oyMGkyMGx3YWJ3LmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h37rhbuw6cj20i20lwabw.jpg</span>&quot; alt=&quot;image#389px #472px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h1 id=\"语音输入\"><a class=\"anchor\" href=\"#语音输入\">#</a> 语音输入</h1>\n<p>苹果在很早的版本就支持语音输入，但是有一个弊端就是语音输入和键盘输入是两个独立的过程。而在 iOS16 中输入文本时，可在语音和触控这两种方式间无缝切换。无需中断听写，照样可用键盘打字、轻点文本栏、移动光标，或插入快速输入建议。<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h37rautdseg20go080e89.gif\" alt=\"image\" /></p>\n<h1 id=\"coreml\"><a class=\"anchor\" href=\"#coreml\">#</a> CoreML</h1>\n<h2 id=\"livetext\"><a class=\"anchor\" href=\"#livetext\">#</a> LiveText</h2>\n<p>CoreML 是苹果早期发布的机型学习 API，通过他可训练一些人工智能相关的东西，其中 iOS15 推出的  <code>LiveText</code>  便是其中之一，他可以让我们对图片里面的一些文字做提取操作，在 iOS16 中，apple 增强了  <code>LiveText</code>  的能力，除了静态图片，还加入了视频帧的支持。  <code>Live Text in Video</code>  , 根据 WWDC 的描述，在播放视频的时候进行暂停，便可以提取当前帧上的文字内容。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h37rfclnkvj21mp0u0dkd.jpg\" alt=\"image\" /></p>\n<p>选中后除了对文字进行复制操作外，iOS16 还提供了一些其他的快捷功能，其中包括汇率转换、翻译。更重要的是，实况文本的 API 已经开发给开发者使用，很快我们就能从 app 的照片和视频中提取相关的文字信息。</p>\n<h2 id=\"visual-look-up\"><a class=\"anchor\" href=\"#visual-look-up\">#</a> Visual Look Up</h2>\n<p>也是苹果之前基于机器学习提供的一个能力，可以检测照片中的物体，来识别是什么东西，在 iOS16 中，该能力被大幅加强，同时集成到了照片 App 中。用户可以打开一个照片，通过长按，把照片主体拖动出来到相应的 App 中。（拖出的图片为 png 图片）</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3437xq1cag207n0gnkk7.gif\" alt=\"image\" /></p>\n<p>该能力已经提供独立的 API，目前的 Apple 的  <code>可立拍</code>   App 里面将 Core ML 的能力运用到视频处理中，大家可以下载体验。</p>\n<h1 id=\"apple-pay\"><a class=\"anchor\" href=\"#apple-pay\">#</a> Apple Pay</h1>\n<h2 id=\"apple-pay-later\"><a class=\"anchor\" href=\"#apple-pay-later\">#</a> Apple pay later</h2>\n<p>类似于国内的京东白条、蚂蚁花呗，不同的是   <code>Apple pay later</code>   只提供 4 周或者 6 周的分期还款，且无息。</p>\n<h2 id=\"钥匙共享\"><a class=\"anchor\" href=\"#钥匙共享\">#</a> 钥匙共享</h2>\n<p>通过常用的通讯类 app，安全地共享钱包 app 中的钥匙（智能家居钥匙，汽车钥匙等）。你可以决定钥匙的使用地点和时间，并能随时撤销。</p>\n<h2 id=\"追踪订单\"><a class=\"anchor\" href=\"#追踪订单\">#</a> 追踪订单</h2>\n<p>可以查看票据，还能直接在钱包 app 中追踪你的 Apple Pay 订单。商户可以将订单的相续信息推送到消费者的钱包里</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzhlcnF1ZmoyMGVnMHNrZ243LmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3438erqufj20eg0skgn7.jpg</span>&quot; alt=&quot;image#304px #601px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h1 id=\"apple-map\"><a class=\"anchor\" href=\"#apple-map\">#</a> Apple Map</h1>\n<h2 id=\"增加途经点规划\"><a class=\"anchor\" href=\"#增加途经点规划\">#</a> 增加途经点规划</h2>\n<p>国内高德百度已经玩了很久的功能，在导航的时候可以在起点和终点之间增加途经点。快车顺风车经常要用的功能。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzhzZjJlZ2oyMGR5MHQwbjA4LmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3438sf2egj20dy0t0n08.jpg</span>&quot; alt=&quot;image#297px #618px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h2 id=\"实时公交信息\"><a class=\"anchor\" href=\"#实时公交信息\">#</a> 实时公交信息</h2>\n<p>可以查看公交出行的公交信息，包括公交时间，公交线路，公交价格等，同样也是国内使用了很久的能力。</p>\n<h2 id=\"共享交通工具查看\"><a class=\"anchor\" href=\"#共享交通工具查看\">#</a> 共享交通工具查看</h2>\n<p>可以在地图上看到附近的共享汽车、共享滑板车、共享单车等。同样也是国能很多共享单车厂商实现了的能力。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzliM21lb2oyMGhxMHcwNzZxLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3439b3meoj20hq0w076q.jpg</span>&quot; alt=&quot;image#307px #554px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h1 id=\"apple-tv-amp-apple-news\"><a class=\"anchor\" href=\"#apple-tv-amp-apple-news\">#</a> Apple TV &amp;amp; Apple News</h1>\n<p>Apple TV 和 Apple News 是两个不同的东西，之所以放到一起说是因为他们在 iOS16 中提供了相同的能力，都新增了体育板块，可以每周免费观看两场比赛，同时可以和 iPhone 联动，在锁屏上展示   <code>Live Activities</code></p>\n<h1 id=\"家长控制\"><a class=\"anchor\" href=\"#家长控制\">#</a> 家长控制</h1>\n<p>家长控制的粒度更细，除了是否可以启动某个 App，还可以详细控制某个 App 的权限，比如禁止某个 App 访问摄像头权限，来避免儿童色情的问题。之后的开发者可能要在权限控制这里做额外的判断。除了允许、拒绝、未决定外，新增了家长控制的枚举条件。</p>\n<h1 id=\"homekit\"><a class=\"anchor\" href=\"#homekit\">#</a> HomeKit</h1>\n<p>接入了更多智能家居品牌。同时和其他主流品牌一起在 HomeKit 的基础上创立了新的智能家居协议标准   <code>matter</code>  。可以让智能家居跨平台协同操作。目前已经有一部分厂商支持了   <code>matter</code></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3439rmf5bj21sq0sqtcw.jpg\" alt=\"image\" /></p>\n<h1 id=\"crarplay\"><a class=\"anchor\" href=\"#crarplay\">#</a> CrarPlay</h1>\n<p>苹果也看出了现在汽车发展的趋势就是大屏幕，而且一辆车往往不止一块屏幕，所以在 iOS16 上，苹果针对这个现象重新优化了 CraePlay，新的 CarPlay 不仅仅可以通过车机来控制 iPhone，还可以通过 iPhone 来设置车机的主题。 支持新 CarPlay 的车型将于 2023 年下半年生产，前期支持的车型为</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h343a6xc3bj21vm0tmtbn.jpg\" alt=\"image\" /></p>\n<p><code>新一代 CarPlay 车载将出类拔萃的 iPhone 体验带入车内。它可为车内所有的驾驶员屏幕提供内容，包括仪表盘在内，让你的爱车和 iPhone 在体验上融为一体。车载的收音机、空调等功能可直接通过 CarPlay 车载来控制。而多种个性化选项，包括小组件以及精选的仪表盘设计，更带来独特的驾驶体验。</code></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h343ak4evxj221o0t60ya.jpg\" alt=\"\" /></p>\n<h1 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h1>\n<p>以上就是 WWDC 中关于 iOS 的相关内容，笔者第一时间更新了 iOS16 的 Beta 版本，但也遇到一些问题</p>\n<ul>\n<li>iOS16 官方最低支持到 iPhone 8 系列，但是 iPhone 8 更新后，很多功能无法使用，建议使用 iPhoneXs 以及以上机型体验。</li>\n<li>WWDC 中提到的大部分功能现在都无法在 Beta1 中体验。且最新的 XcodeBeta 中也没有相关的新 Api，不过 WWDC 上也说了，iOS16 上的功能会在后续稍晚的时候以 API 的形式提供。</li>\n<li>Beta1 耗电发热非常夸张，尤其是在锁屏界面。可能还需相关优化，目前手机必须连着电源使用。</li>\n</ul>\n<p>文中提到得到一些功能更新虽然和国内开发者关系不大，但是毕竟都是业务层面的东西，底层都是通用的，毕竟技术无国界，也希望能将更新的技术用到自己的项目中，提高用户的产品体验，向用户展示出我们的专业能力和创新能力。希望这篇文章能对 iOS 开发者和产品同学在后续的技术、产品规划上有一定的帮助。</p>\n",
            "tags": [
                "iOS",
                "WWDC2022"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2022-05-26-Apple%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/",
            "url": "https://oliverqueen.cn/2022-05-26-Apple%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/",
            "title": "Apple登录流程详解",
            "date_published": "2022-05-26T02:53:20.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"1背景\"><a class=\"anchor\" href=\"#1背景\">#</a> 1：背景</h2>\n<p>2019 年苹果推出 苹果登录（Sign in with Apple）方式，要求 2020 年 4 月之后运行在 iOS13 及以上系统的 APP 如果使用第三方或社交登录服务（如 Facebook、谷歌、 Twitter、Linkedln 或亚马逊等），必须向用户提供 “以苹果账号登录” 服务的选项。其中苹果的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDJmempqd3d1YWoyMTY0MHA0NDRkLmpwZw==\">审核细则 4.8</span> 也明确的规定了这一点。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2lmep99kij21ns0rkaba.jpg\" alt=\"\" /></p>\n<p><span id=\"more\"></span></p>\n<p>&lt;font color=&quot;#dd0000&quot;&gt; 不过需要注意的一点是腾讯系列的产品如果只是使用微信、QQ 登录并不算第三方登录，所以可以添加 AppleID 登录方式。&lt;/font&gt;&lt;br /&gt;</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2fzjjwwuaj21640p444d.jpg\" alt=\"\" /></p>\n<h2 id=\"2前置配置\"><a class=\"anchor\" href=\"#2前置配置\">#</a> 2：前置配置</h2>\n<h4 id=\"21-xcode工程配置\"><a class=\"anchor\" href=\"#21-xcode工程配置\">#</a> 2.1 Xcode 工程配置</h4>\n<p>选中工程 trager，在 capabilities 中添加 AppleID 登录的能力</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g28b5w8aj21960u0769.jpg\" alt=\"\" /></p>\n<h4 id=\"22-开发者账号配置\"><a class=\"anchor\" href=\"#22-开发者账号配置\">#</a> 2.2 开发者账号配置</h4>\n<p>基于授权码的后端验证方式需要此步骤，如果使用 JWT 验证方式则不依赖此步骤，不过建议按顺序看完多做了解。</p>\n<p>该步骤的最终目的是获取用于校验客户端身份的所需内容，其中包括以下三个内容</p>\n<ul>\n<li>\n<p>生成一个用于校验客户端身份的密钥文件</p>\n</li>\n<li>\n<p>获取 KeyID</p>\n</li>\n<li>\n<p>获取 iss（TeamID）</p>\n</li>\n</ul>\n<p>&lt;font color=&quot;#dd0000&quot;&gt; 注意：该步骤需要登录 Apple 开发者账号并对其进行功能的配置、开启、以及描述文件更新等操作，可能需要证书管理团队或者有相关权限的人员来处理，并由他们将对应信息输出 &lt;/font&gt;&lt;br /&gt;</p>\n<h5 id=\"步骤一能力开启\"><a class=\"anchor\" href=\"#步骤一能力开启\">#</a> <strong>步骤一：能力开启</strong></h5>\n<p>进入开发者账号，选择需要支持 AppleID 登录能力的应用并进入打开其 AppleID 登录的功能<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g335dozbj219o0kiwg6.jpg\" alt=\"\" /><br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g36gha89j216x0u0gnx.jpg\" alt=\"\" /></p>\n<h5 id=\"步骤二更新profile\"><a class=\"anchor\" href=\"#步骤二更新profile\">#</a> <strong>步骤二：更新 profile</strong></h5>\n<p>对 app 的任何更改都会导致现有的 profile 文件失效，所以需要重新生成 profile 描述文件。<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g38wg6kij20ia08qmxk.jpg\" alt=\"\" /><br />\n按照如下路径操作，点进已经 <code>invalid</code>  的描述文件并重新生成<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g3em4u2oj21fq0lc75x.jpg\" alt=\"\" /></p>\n<h5 id=\"步骤三生成密钥文件\"><a class=\"anchor\" href=\"#步骤三生成密钥文件\">#</a> <strong>步骤三：生成密钥文件</strong></h5>\n<p>进入如下界面点击 <code>加号</code> 进行生成<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g3hh2cz2j216m0ms406.jpg\" alt=\"\" /></p>\n<p>填完并勾选 <code>Sigin with apple</code>  后点击右侧的 <code>Configure</code>  进行配置，在配置页面选择需要开启苹果登录的 app 并保存，然后回到上一页并开始注册<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g3kyolw0j21m10u043i.jpg\" alt=\"\" /><br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g3ps0bfjj21v70u0td1.jpg\" alt=\"\" /><br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g3qw6gvmj22120s0dkq.jpg\" alt=\"\" /></p>\n<p>最终注册成功后会有 KeyID、TeamID 和可供下载的密钥文件<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g3umbtqzj21wg0s4gqg.jpg\" alt=\"\" /></p>\n<p>密钥文件格式为.p8 实际是文本文件<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g3yn74llj212g0badht.jpg\" alt=\"\" /></p>\n<p>&lt;font color=&quot;#dd0000&quot;&gt; 注意：密钥文件只能被下载一次，下载后保存在安全的地方，丢了的话只能重新申请了 &lt;/font&gt;&lt;br /&gt;</p>\n<h2 id=\"3登录流程\"><a class=\"anchor\" href=\"#3登录流程\">#</a> 3：登录流程</h2>\n<p>登录流程分两大块，一个是客户端部分，一个是后端部分，其中后端部分有两种校验方式 <code>基于授权码的后端验证</code> 、 <code>基于JWT的算法验证</code> ，稍后会一一讲解。总体流程如下图：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h2g4un5dizj20ve0u0dip.jpg\" alt=\"\" /></p>\n<h4 id=\"31-客户端侧\"><a class=\"anchor\" href=\"#31-客户端侧\">#</a> 3.1 客户端侧</h4>\n<h5 id=\"步骤一授权\"><a class=\"anchor\" href=\"#步骤一授权\">#</a> <strong>步骤一：授权</strong></h5>\n<p>对于客户端来说 AppleID 登录与传统的三方登录流程一样，分为 <code>调用接口</code> 与 <code>回调信息获取</code> 两步，唯一不同点是苹果登录的 API 是在 iOS SDK 内部封装，只用导入对应头文件即可<br />\n <code>#import &lt;AuthenticationServices/AuthenticationServices.h&gt; </code></p>\n<p>关于登录入口，苹果对 AppleID 登录的 UI 有严格的限制，因此专门提供了提供了一套继承于 <code>UIControl</code>  等控件来供开发者使用 <code>ASAuthorizationAppleIDButton</code></p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ASAuthorizationAppleIDButton * appleIDBtn = [ASAuthorizationAppleIDButton buttonWithType:ASAuthorizationAppleIDButtonTypeDefault style:ASAuthorizationAppleIDButtonStyleWhite];</span><br><span class=\"line\">appleIDBtn.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">100</span>, <span class=\"number\">60</span>);</span><br><span class=\"line\">[appleIDBtn addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(didAppleIDBtnClicked) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:appleIDBtn];</span><br></pre></td></tr></table></figure></p>\n<p>其中按钮的 <code>文案类型</code> 和 <code>UI风格</code> 可以通过枚举进行配置<br />\n <figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//  文案类型</span><br><span class=\"line\">typedef <span class=\"type\">NS_ENUM</span>(<span class=\"type\">NSInteger</span>, <span class=\"type\">ASAuthorizationAppleIDButtonType</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationAppleIDButtonTypeSignIn</span>,</span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationAppleIDButtonTypeContinue</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationAppleIDButtonTypeSignUp</span> <span class=\"type\">API_AVAILABLE</span>(ios(13.2), macos(10.15.1), tvos(13.1)) <span class=\"type\">API_UNAVAILABLE(watchos)</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationAppleIDButtonTypeDefault</span> = <span class=\"type\">ASAuthorizationAppleIDButtonTypeSignIn</span>,</span><br><span class=\"line\">&#125; <span class=\"type\">NS_SWIFT_NAME</span>(<span class=\"type\">ASAuthorizationAppleIDButton</span>.<span class=\"type\">ButtonType</span>) <span class=\"type\">API_AVAILABLE</span>(ios(13.0), macos(10.15), tvos(13.0)) <span class=\"type\">API_UNAVAILABLE</span>(watchos);</span><br><span class=\"line\"></span><br><span class=\"line\">//  <span class=\"type\">UI</span>风格</span><br><span class=\"line\">typedef <span class=\"type\">NS_ENUM</span>(<span class=\"type\">NSInteger</span>, <span class=\"type\">ASAuthorizationAppleIDButtonStyle</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationAppleIDButtonStyleWhite</span>,</span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationAppleIDButtonStyleWhiteOutline</span>,</span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationAppleIDButtonStyleBlack</span>,</span><br><span class=\"line\">&#125; <span class=\"type\">NS_SWIFT_NAME</span>(<span class=\"type\">ASAuthorizationAppleIDButton</span>.<span class=\"type\">Style</span>) <span class=\"type\">API_AVAILABLE</span>(ios(13.0), macos(10.15), tvos(13.0)) <span class=\"type\">API_UNAVAILABLE</span>(watchos);</span><br></pre></td></tr></table></figure><br />\n 但是并不推荐这种方式使用，原因如下：</p>\n<ul>\n<li>1：固定 UI 无法满足业务的定制化需求</li>\n<li>2：文案固定，多语言配置需要在单独的地方去配置文案</li>\n</ul>\n<p>所以建议自己写 UI，直接在点击事件中调用 AppleID 的相关 API 进行授权登陆操作，具体代码为，其中 <code>ASAuthorizationAppleIDRequest</code>  为是否使用 Keychain 信息，如果如果 KeyChain 里面也有登录信息的话，可以直接使用里面保存的用户名和密码进行登录。可以根据实际业务需求来<br />\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">KINFO</span>(@<span class=\"string\">&quot;[AppleLoginWrapper]开始苹果登录鉴权&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">@available</span>(<span class=\"keyword\">iOS</span> <span class=\"number\">13.0</span>, <span class=\"operator\">*</span>)) &#123;</span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationAppleIDProvider</span> <span class=\"operator\">*</span>provider <span class=\"operator\">=</span> [<span class=\"type\">ASAuthorizationAppleIDProvider</span> new];</span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationAppleIDRequest</span> <span class=\"operator\">*</span>request <span class=\"operator\">=</span> [provider createRequest];</span><br><span class=\"line\">    request.requestedScopes <span class=\"operator\">=</span> @[ <span class=\"type\">ASAuthorizationScopeFullName</span>, <span class=\"type\">ASAuthorizationScopeEmail</span> ]; <span class=\"comment\">//请求的用户信息</span></span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationPasswordRequest</span> <span class=\"operator\">*</span> keychainRequest <span class=\"operator\">=</span> [[[<span class=\"type\">ASAuthorizationPasswordProvider</span> alloc] <span class=\"keyword\">init</span>] createRequest];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ASAuthorizationController</span> <span class=\"operator\">*</span>vc <span class=\"operator\">=</span> [[<span class=\"type\">ASAuthorizationController</span> alloc] initWithAuthorizationRequests:@[ request ,keychainRequest]];</span><br><span class=\"line\">    vc.delegate <span class=\"operator\">=</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    vc.presentationContextProvider <span class=\"operator\">=</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    [vc performRequests];</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Fallback on earlier versions</span></span><br><span class=\"line\">    <span class=\"type\">KINFO</span>(@<span class=\"string\">&quot;[AppleLoginWrapper]iOS系统低于13&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"步骤二信息回调\"><a class=\"anchor\" href=\"#步骤二信息回调\">#</a> <strong>步骤二：信息回调</strong></h5>\n<p>依赖的两个 delegate<br />\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark- 代理 ASAuthorizationControllerDelegate</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)authorizationController:(ASAuthorizationController *)controller didCompleteWithAuthorization:(ASAuthorization *)authorization &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  成功</span></span><br><span class=\"line\">    <span class=\"comment\">//  其中`authorization.credential`包含了Token，用户ID等授权所需信息，可上报到后台</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"type\">void</span>)authorizationController:(ASAuthorizationController *)controller didCompleteWithError:(<span class=\"built_in\">NSError</span> *)error &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  失败</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark- 代理ASAuthorizationControllerPresentationContextProviding</span></span><br><span class=\"line\">- (ASPresentationAnchor)presentationAnchorForAuthorizationController:(ASAuthorizationController *)controller &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  展示在哪个Window上</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.view.window;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"步骤三用户id状态校验\"><a class=\"anchor\" href=\"#步骤三用户id状态校验\">#</a> <strong>步骤三：用户 ID 状态校验</strong></h5>\n<p>防止用户注销 AppleId 或 停止使用 Apple ID 的状态处理<br />\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">-</span> (<span class=\"type\">BOOL</span>)application:(<span class=\"type\">UIApplication</span> <span class=\"operator\">*</span>)application didFinishLaunchingWithOptions:(<span class=\"type\">NSDictionary</span> <span class=\"operator\">*</span>)launchOptions &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Override point for customization after application launch.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">@available</span>(<span class=\"keyword\">iOS</span> <span class=\"number\">13.0</span>, <span class=\"operator\">*</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 注意 存储用户标识信息需要使用钥匙串来存储 这里使用NSUserDefaults 做的简单示例</span></span><br><span class=\"line\">        <span class=\"type\">NSString</span> <span class=\"operator\">*</span> userIdentifier <span class=\"operator\">=</span> [[<span class=\"type\">NSUserDefaults</span> standardUserDefaults] valueForKey:@<span class=\"string\">&quot;appleID&quot;</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (userIdentifier) &#123;</span><br><span class=\"line\">            <span class=\"type\">ASAuthorizationAppleIDProvider</span> <span class=\"operator\">*</span> appleIDProvider <span class=\"operator\">=</span> [[<span class=\"type\">ASAuthorizationAppleIDProvider</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">            [appleIDProvider getCredentialStateForUserID:userIdentifier</span><br><span class=\"line\">                                              completion:<span class=\"operator\">^</span>(<span class=\"type\">ASAuthorizationAppleIDProviderCredentialState</span> credentialState, <span class=\"type\">NSError</span> <span class=\"operator\">*</span> _Nullable error) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">switch</span> (credentialState) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"type\">ASAuthorizationAppleIDProviderCredentialAuthorized</span>:</span><br><span class=\"line\">                        <span class=\"comment\">// 授权状态有效</span></span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"type\">ASAuthorizationAppleIDProviderCredentialRevoked</span>:</span><br><span class=\"line\">                        <span class=\"comment\">// 苹果账号登录的凭据已被移除，需解除绑定并重新引导用户使用苹果登录</span></span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"type\">ASAuthorizationAppleIDProviderCredentialNotFound</span>:</span><br><span class=\"line\">                        <span class=\"comment\">// 未登录授权，直接弹出登录页面，引导用户登录</span></span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"type\">ASAuthorizationAppleIDProviderCredentialTransferred</span>:</span><br><span class=\"line\">                        <span class=\"comment\">// 授权AppleID提供者凭据转移</span></span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">YES</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"32-sever侧\"><a class=\"anchor\" href=\"#32-sever侧\">#</a> 3.2 Sever 侧</h4>\n<p>基于上面流程图，Sever 侧校验 Token 有效性的方式有两种：</p>\n<h5 id=\"方式一基于授权码的后端验证\"><a class=\"anchor\" href=\"#方式一基于授权码的后端验证\">#</a> <strong>方式一：基于授权码的后端验证</strong></h5>\n<p>后端在收到客户端传递的包含 token 的信息后进行验证</p>\n<ul>\n<li>构建 client_secret<br />\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----BEGIN PRIVATE KEY-----</span><br><span class=\"line\">BASE64编码后的密钥 (步骤<span class=\"number\">2.2</span>中获得)</span><br><span class=\"line\">-----END PRIVATE KEY-----</span><br><span class=\"line\"> </span><br><span class=\"line\">public  byte<span class=\"literal\">[]</span> read<span class=\"constructor\">Key()</span> throws Exception &#123;</span><br><span class=\"line\">    String temp = <span class=\"string\">&quot;密钥文件中间的编码字符串&quot;</span>;</span><br><span class=\"line\">    return <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Base64</span>.</span></span>decode<span class=\"constructor\">Base64(<span class=\"params\">temp</span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">构建client_secret关键代码：</span><br><span class=\"line\"></span><br><span class=\"line\">String client_id = <span class=\"string\">&quot;...&quot;</span>; <span class=\"comment\">// 被授权的APP ID(步骤2.2中获得)</span></span><br><span class=\"line\">Map&lt;String, Object&gt; header = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;<span class=\"literal\">()</span>;</span><br><span class=\"line\">header.put(<span class=\"string\">&quot;kid&quot;</span>, <span class=\"string\">&quot;密钥id&quot;</span>); <span class=\"comment\">// 参考后台配置(步骤2.2中获得)</span></span><br><span class=\"line\">Map&lt;String, Object&gt; claims = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;<span class=\"literal\">()</span>;</span><br><span class=\"line\">claims.put(<span class=\"string\">&quot;iss&quot;</span>, <span class=\"string\">&quot;team id&quot;</span>); <span class=\"comment\">// 参考后台配置 team id(步骤2.2中获得)</span></span><br><span class=\"line\">long now = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>current<span class=\"constructor\">TimeMillis()</span><span class=\"operator\"> / </span><span class=\"number\">1000</span>;</span><br><span class=\"line\">claims.put(<span class=\"string\">&quot;iat&quot;</span>, now);</span><br><span class=\"line\">claims.put(<span class=\"string\">&quot;exp&quot;</span>, now + <span class=\"number\">86400</span><span class=\"operator\"> * </span><span class=\"number\">30</span>); <span class=\"comment\">// 最长半年，单位秒</span></span><br><span class=\"line\">claims.put(<span class=\"string\">&quot;aud&quot;</span>, <span class=\"string\">&quot;https://appleid.apple.com&quot;</span>); <span class=\"comment\">// 默认值</span></span><br><span class=\"line\">claims.put(<span class=\"string\">&quot;sub&quot;</span>, client_id);</span><br><span class=\"line\">PKCS8EncodedKeySpec pkcs8EncodedKeySpec = <span class=\"keyword\">new</span> <span class=\"constructor\">PKCS8EncodedKeySpec(<span class=\"params\">readKey</span>()</span>);</span><br><span class=\"line\">KeyFactory keyFactory = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">KeyFactory</span>.</span></span>get<span class=\"constructor\">Instance(<span class=\"string\">&quot;EC&quot;</span>)</span>;</span><br><span class=\"line\">PrivateKey privateKey = keyFactory.generate<span class=\"constructor\">Private(<span class=\"params\">pkcs8EncodedKeySpec</span>)</span>;</span><br><span class=\"line\">String client_secret = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Jwts</span>.</span></span>builder<span class=\"literal\">()</span>.set<span class=\"constructor\">Header(<span class=\"params\">header</span>)</span>.set<span class=\"constructor\">Claims(<span class=\"params\">claims</span>)</span>.sign<span class=\"constructor\">With(SignatureAlgorithm.ES256, <span class=\"params\">privateKey</span>)</span>.compact<span class=\"literal\">()</span>;       </span><br></pre></td></tr></table></figure></li>\n<li>验证客户端 Token<br />\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span> <span class=\"built_in\">url</span> = <span class=\"string\">&quot;https://appleid.apple.com/auth/token&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// POST 请求</span></span><br><span class=\"line\">HttpSynClient client = <span class=\"keyword\">new</span> HttpSynClient(<span class=\"number\">5000</span>, <span class=\"number\">5000</span>, <span class=\"number\">5000</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">String</span>&gt; form = <span class=\"keyword\">new</span> HashMap&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">String</span>&gt;();</span><br><span class=\"line\">form.put(<span class=\"string\">&quot;client_id&quot;</span>, client_id);</span><br><span class=\"line\">form.put(<span class=\"string\">&quot;client_secret&quot;</span>, client_secret);</span><br><span class=\"line\">form.put(<span class=\"string\">&quot;code&quot;</span>, code);form.put(<span class=\"string\">&quot;grant_type&quot;</span>,<span class=\"string\">&quot;authorization_code&quot;</span>);</span><br><span class=\"line\">form.put(<span class=\"string\">&quot;redirect_uri&quot;</span>, redirectUrl);</span><br><span class=\"line\">HttpResponse result = client.excutePost(<span class=\"built_in\">url</span>, form);</span><br><span class=\"line\">System.out.println(result);</span><br></pre></td></tr></table></figure></li>\n<li>上述步骤结束后即可将结果回调给客户端，进行登录或者是错误处理\n<ul>\n<li>成功示例<br />\n <figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\"><span class=\"attr\">&quot;access_token&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;a0996b16cfb674c0eb0d29194c880455b.0.nsww.5fi5MVC-i3AVNhddrNg7Qw&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;token_type&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;Bearer&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;expires_in&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">3600</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;refresh_token&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;r9ee922f1c8b048208037f78cd7dfc91a.0.nsww.KlV2TeFlTr7YDdZ0KtvEQQ&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;id_token&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;eyJraWQiOiJBSURPUEsxIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL2FwcGxlaWQuYXBwbGUuY29tIiwiYXVkIjoiY29tLnNreW1pbmcuYXBwbGVsb2dpbmRlbW8iLCJleHAiOjE1NjU2NjU1OTQsImlhdCI6MTU2NTY2NDk5NCwic3ViIjoiMDAwMjY2LmRiZTg2NWIwYWE3MjRlMWM4ODM5MDIwOWI5YzdkNjk1LjAyNTYiLCJhdF9oYXNoIjoiR0ZmODhlX1ptc0pqQ2VkZzJXem85ZyIsImF1dGhfdGltZSI6MTU2NTY2NDk2M30.J6XFWmbr0a1hkJszAKM2wevJF57yZt-MoyZNI9QF76dHfJvAmFO9_RP9-tz4pN4ua3BuSJpUbwzT2xFD_rBjsNWkU-ZhuSAONdAnCtK2Vbc2AYEH9n7lB2PnOE1mX5HwY-dI9dqS9AdU4S_CjzTGnvFqC9H5pt6LVoCF4N9dFfQnh2w7jQrjTic_JvbgJT5m7vLzRx-eRnlxQIifEsHDbudzi3yg7XC9OL9QBiTyHdCQvRdsyRLrewJT6QZmi6kEWrV9E21WPC6qJMsaIfGik44UgPOnNnjdxKPzxUAa-Lo1HAzvHcAX5i047T01ltqvHbtsJEZxAB6okmwco78JQA&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></li>\n<li>失败示例<br />\n <figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\"><span class=\"attr\">&quot;error&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;invalid_client&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"方式二基于jwt验证原理\"><a class=\"anchor\" href=\"#方式二基于jwt验证原理\">#</a> <strong>方式二：基于 JWT 验证原理</strong></h5>\n<ul>\n<li>\n<p>获取苹果公钥，并保存</p>\n<p>用到公钥接口  <code>https://appleid.apple.com/auth/keys</code> <br />\n 返回值样例<br />\n <figure class=\"highlight prolog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"string\">&quot;keys&quot;</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;kty&quot;</span>: <span class=\"string\">&quot;RSA&quot;</span>, </span><br><span class=\"line\">        <span class=\"string\">&quot;kid&quot;</span>: <span class=\"string\">&quot;AIDOPK1&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;use&quot;</span>: <span class=\"string\">&quot;sig&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;alg&quot;</span>: <span class=\"string\">&quot;RS256&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;n&quot;</span>: <span class=\"string\">&quot;lxrwmuYSAsTfn-lUu4goZSXBD9ackM9OJuwUVQHmbZo6GW4Fu_auUdN5zI7Y1dEDfgt7m7QXWbHuMD01HLnD4eRtY-RNwCWdjNfEaY_esUPY3OVMrNDI15Ns13xspWS3q-13kdGv9jHI28P87RvMpjz_JCpQ5IM44oSyRnYtVJO-320SB8E2Bw92pmrenbp67KRUzTEVfGU4-obP5RZ09OxvCr1io4KJvEOjDJuuoClF66AT72WymtoMdwzUmhINjR0XSqK6H0MdWsjw7ysyd_JhmqX5CAaT9Pgi0J8lU_pcl215oANqjy7Ob-VMhug9eGyxAWVfu_1u6QJKePlE-w&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;e&quot;</span>: <span class=\"string\">&quot;AQAB&quot;</span></span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>验证客户端的 Token 有效性</p>\n<p>客户端会传以下几个值给服务端</p>\n<ul>\n<li>\n<p>userID：授权的用户唯一标识</p>\n</li>\n<li>\n<p>email、fullName：授权的用户资料</p>\n</li>\n<li>\n<p>authorizationCode：授权 code</p>\n</li>\n<li>\n<p>identityToken：授权用户的 JWT 凭证<br />\n示例 identityToken：授权用户的 JWT 凭证<br />\n <figure class=\"highlight smali\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eyJraWQiOiJBSURPUEsxIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL2FwcGxlaWQuYXBwbGUuY29tIiwiYXVkIjoiY29tLmZ1bi5BcHBsZUxvZ2luIiwiZXhwIjoxNTY4NzIxNzY5LCJpYXQiOjE1Njg3MjExNjksInN1YiI6IjAwMDU4MC4wODdjNTU0ZGNlMzU0NjZmYTg1YzVhNWQ1OTRkNTI4YS4wODAxIiwiY19oYXNoIjoiel9KY0RscFczQjJwN3ExR0Nna1JaUSIsImF1dGhfdGltZSI6MTU2ODcyMTE2OX0.WmSa4LzOzYsdwTqAJ_8mub4Ls3eyFkxZoGLoy-U7DatsTd_JEwAs3_OtV4ucmj6ENT3153iCpYY6vBxSQromOMcXsN74IrUQew24y_zflN2g4yU8ZVvBCbTrR_6p9f2fbeWjZiyNcbPCha0dv45E3vBjyHhmffWnk3vyndBBiwwuqod4pyCZ3UECf6Vu-o7dygKFpMHPS1ma60fEswY5d-_TJAFk1HaiOfFo0XbL6kwqAGvx8HnraIxyd0n8SbBVxV_KDxf15hdotUizJDW7N2XMdOGQpNFJim9SrEeBhn9741LWqkWCgkobcvYBZsrvnUW6jZ87SLi15rvIpq8_fw</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\ntoken 被解密后分为三个部分</p>\n</li>\n<li>\n<p>header: 包括了 key id 与加密算法</p>\n</li>\n<li>\n<p>payload:</p>\n<ul>\n<li>iss: 签发机构，苹果</li>\n<li>aud: 接收者，目标 app</li>\n<li>exp：过期时间</li>\n<li>iat: 签发时间</li>\n<li>sub: 用户 id</li>\n<li>c_hash: 一个哈希数列</li>\n<li>auth_time: 签名时间</li>\n</ul>\n</li>\n<li>\n<p>signature: 用于验证 JWT 的签名</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Token 验证原理：</p>\n<p>因为 idnetityToken 使用非对称加密 RSASSA【RSA 签名算法】 和 ECDSA【椭圆曲线数据签名算法】，当验证签名的时候，利用公钥来解密 Singature，当解密内容与 base64UrlEncode (header) + “.” + base64UrlEncode (payload) 的内容完全一样的时候，表示验证通过。</p>\n</li>\n<li>\n<p>防止中间人攻击原理：</p>\n<p>该 token 是苹果利用私钥生成的一段 JWT，并给出公钥我们对 token 进行验证，由于中间人并没有苹果的私钥，所以它生成出来的 token 是没有办法利用苹果给出的公钥进行验证的，确保的 token 的安全性。</p>\n</li>\n</ul>\n<h2 id=\"4-总结\"><a class=\"anchor\" href=\"#4-总结\">#</a> 4 总结</h2>\n<p>目前使用的是基于授权码的后端验证方式，每次收到客户端登录请求后都会像苹果服务器发送 post 请求来验证，导致受网络影响较大。如果改成第一种方式后，除了获取公钥外不再依赖网络请求，可降低网络异常情况带来的损失。但是服务端要定期刷新公钥，防止公钥变化带来的验证失败</p>\n<h2 id=\"5-参考文档\"><a class=\"anchor\" href=\"#5-参考文档\">#</a> 5 参考文档</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIub2t0YS5jb20vYmxvZy8yMDE5LzA2LzA0L3doYXQtdGhlLWhlY2staXMtc2lnbi1pbi13aXRoLWFwcGxl\">https://developer.okta.com/blog/2019/06/04/what-the-heck-is-sign-in-with-apple</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2NuL3NpZ24taW4td2l0aC1hcHBsZS8=\">https://developer.apple.com/cn/sign-in-with-apple/</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2RvY3VtZW50YXRpb24vc2lnbmlud2l0aGFwcGxlcmVzdGFwaS9nZW5lcmF0ZV9hbmRfdmFsaWRhdGVfdG9rZW5z\">https://developer.apple.com/documentation/signinwithapplerestapi/generate_and_validate_tokens</span></p>\n",
            "tags": [
                "iOS",
                "Apple登录"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2021-05-05-iOS-Crash%E9%98%B2%E6%8A%A4%E4%BD%A0%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%B0%B1%E5%A4%9F%E4%BA%86-%E4%B8%8B%E7%AF%87/",
            "url": "https://oliverqueen.cn/2021-05-05-iOS-Crash%E9%98%B2%E6%8A%A4%E4%BD%A0%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%B0%B1%E5%A4%9F%E4%BA%86-%E4%B8%8B%E7%AF%87/",
            "title": "iOS Crash防护你看这个就够了-下篇",
            "date_published": "2021-05-05T02:23:42.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"0x1-previously\"><a class=\"anchor\" href=\"#0x1-previously\">#</a> 0x1: Previously</h1>\n<p><a href=\"https://oliverqueen.cn/2021/05/03/iOS%20Crash%E9%98%B2%E6%8A%A4%E4%BD%A0%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%B0%B1%E5%A4%9F%E4%BA%86-%E4%B8%8A%E7%AF%87/\">上篇</a> 中讲到了 Crash 处理流程分为四个环节，也分析了 Crash 防护的方法，本章来讲下其余三个环节。</p>\n<h1 id=\"0x2-crash的拦截\"><a class=\"anchor\" href=\"#0x2-crash的拦截\">#</a> 0x2: Crash 的拦截</h1>\n<p>所有的未被防护住的 Crash 最终会走到这里，在这里我们必须要保证拦截的  <code>全面性</code> 、 <code>稳定性</code> 尽可能多的拦截到所有类型的异常，同时拦截逻辑本身不能产生异常。那么我们需要通过以下几个方面去考虑。</p>\n<p><img data-src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fdingyue.ws.126.net%2F2020%2F0504%2Fa0ef0444j00q9saus002gc000xc00irm.jpg&amp;refer=http%3A%2F%2Fdingyue.ws.126.net&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1622826899&amp;t=2b1dd016c1ac10c52097431b7fa9af7d\" alt=\"\" /></p>\n<p><span id=\"more\"></span></p>\n<h2 id=\"i-crash类型\"><a class=\"anchor\" href=\"#i-crash类型\">#</a> I: Crash 类型</h2>\n<p>和多数操作系统一样，iOS 的异常也基本分为  <code>用户层</code>   <code>系统底层</code>   <code>信号</code>  这三个类别，接下来我们看下每种异常都做了哪些事情</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq7dqhr2e2j31860qg79l.jpg\" alt=\"\" /></p>\n<ul>\n<li>\n<p>Mach Exception &lt;br&gt;<br />\nMach 异常，分为两种情况，第一种是本身就是硬件层面或者系统层面的异常，这个大家比较好理解，因为 mach 是微内核，所以底层的内核级别的包括硬件的异常都是 mach 异常。另一种是 iOS 系统独有的逻辑或者说是苹果独有的。就是用户层面的异常也都首先下沉到 mach 层再发出来，也等于是另一种意义上的 mach 异常。苹果官方文档上写的是为了统一机制才做了这样的处理，但是没有说具体原因。他的触发流程大概为下图</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq7yp0q2aaj30f60uqtaf.jpg\" alt=\"\" /></p>\n<p>然后我去看 Runtime 的源码进一步证明了这个说法，runloop 中大量使用这种方式监听 mach 异常消息，一旦 Crash 随时准备打破循环，因为系统也需要监听 crash，统一出口将对监听来说对系统将变得非常方便。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq7yvd5gpvj30pc02mt9o.jpg\" alt=\"\" /></p>\n<p>根据代码上下文可以判断出，苹果会监听统一的异常端口，在出现异常后进行相应的操作，也印证了我当时的推断。</p>\n</li>\n<li>\n<p>Exception &lt;br&gt;<br />\n 很常见的异常，触发流程大概为<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq7z1qkeksj30g60lkaax.jpg\" alt=\"\" /></p>\n</li>\n<li>\n<p>signal &lt;br&gt;</p>\n<p>signal 的产生流程大概分为几种情况</p>\n<ul>\n<li>\n<p>由于  <code>MachExcption</code>  转换而成的 signal</p>\n</li>\n<li>\n<p>由于 Exception 而发出的 abort 信号</p>\n</li>\n<li>\n<p>用户自定义的信号</p>\n</li>\n</ul>\n<p>但是需要注意一点：&lt;font color=red size=3 face=&quot;黑体&quot;&gt; 收到 signal 不一定会 Crash，但是 Crash 一定会有 Signal 发出 &lt;/font&gt;</p>\n</li>\n</ul>\n<h2 id=\"ii-crash传递流程\"><a class=\"anchor\" href=\"#ii-crash传递流程\">#</a> II: Crash 传递流程</h2>\n<p>上面分析了每种 Crash 的类型，那么这三种类型的 Crash 是如何在 App 生命周期中传递的呢？他们又是如何相互转化以及相互之间有什么关系呢？</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq7z8sxdxoj313o0n07hs.jpg\" alt=\"\" /></p>\n<p>帮大家提取下上图中的几个关键信息</p>\n<ul>\n<li>\n<p>1：Exception 最终会转化为 Mach Exception</p>\n</li>\n<li>\n<p>2：通过 Mach 端口拦截的较为全面</p>\n</li>\n<li>\n<p>3：如果发生了 exception 那么就不会抛出对应的 signal 只能抛出 abort ();</p>\n</li>\n<li>\n<p>4：通过捕获 signal 是无法拦截到 exception。</p>\n</li>\n</ul>\n<h2 id=\"iii-拦截的选择\"><a class=\"anchor\" href=\"#iii-拦截的选择\">#</a> III: 拦截的选择</h2>\n<p>通过上面的分析大家一定会说通过 Mach 端口的拦截更加全面，毕竟苹果自己也在用。但是在实际使用中有一个问题，mach 会拦截所有的异常以及信号量，也就是随便一个操作（比如发一个自定义 signal 等）可能都被 mach 捕获，那么如果在其捕获回调中再进行捕获就会很容易发生死锁，而且容易和系统的处理产生冲突。当时看了 PLCrash 的文档，也看到了开发者写的一句话：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq7znanxjrj315y03odjv.jpg\" alt=\"\" /></p>\n<p>这样说明了大家确实被坑过。</p>\n<p>那接下来只剩 signal 和 exception，其实细心的同学早已发现这两个的优缺点是一个互补的状态</p>\n<ul>\n<li>\n<p>singal 能捕获除 Exception 之外的所有异常。</p>\n</li>\n<li>\n<p>exception 只能获取应用层的异常而对信号量无法处理</p>\n</li>\n</ul>\n<p>那么最终的方式采用 singnal + exception 的方式进行捕获，最终的流程为：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq7zrbfy5xj30c40okdgu.jpg\" alt=\"\" /></p>\n<h2 id=\"iv-坑点\"><a class=\"anchor\" href=\"#iv-坑点\">#</a> IV: 坑点</h2>\n<p>上面的流程图可以看出在每一个 CustomHandle 之前都会有一个 PreviousHandle，其实是因为在 iOS 系统中只能存在一个 customHandel，如果你的项目中接入了或者准备接入多个 Crash 防护相关的 SDK（虽然不建议这么做），那么多个 Handle 之间一定会产生冲突，导致堆栈不明确，或者丢失。所以在注册我们的 handle 前先将之前的 handle 指针保存下来，等我们的 handle 处理完后在通过函数指针调用回去，这样就能保证每一个 handle 都能被正常调用。</p>\n<ul>\n<li>\n<p>exception：通过 <code>NSGetUncaughtExceptionHandler</code>  获得之前 handle 指针，之后再通过 <code>NSSetUncaughtExceptionHandler(oldHandler);</code>  调用回去。</p>\n</li>\n<li>\n<p>signal: 使用 <code>sigaction</code>  函数获得之前的 handle 指针。</p>\n</li>\n</ul>\n<h1 id=\"0x3-堆栈获取\"><a class=\"anchor\" href=\"#0x3-堆栈获取\">#</a> 0x3: 堆栈获取</h1>\n<p>因为苹果使用了 (Address Space Layout Randomization) 地址空间配置随机加载技术，所以线上堆栈必须要通过符号表堆栈还原进行解读，不然的话就是内存地址。所以当我们使用 NSThread 的相关函数在 Debug 下虽然能看到可读性行的堆栈，但是在线上包上并不可取，那我们要怎么获取堆栈呢？先来看下符号表的构造：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq80i60uhsj30ya0eih1g.jpg\" alt=\"\" /></p>\n<p>之前拿到这样的符号表，我们通常手动还原，找一个相同系统的真机，找到对应库的基地址按照符号表上函数的偏移量进行计算（通过 LLDB 的相关函数）</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq80lfgy0hj30q208i0te.jpg\" alt=\"\" /></p>\n<p>通过看 Mach-o 相关接口可以找到相关函数进行端内符号表还原，大致流程为：</p>\n<ul>\n<li>\n<p>获取函数地址：</p>\n<ul>\n<li>\n<p>遍历 Mach-o 中的所有 image</p>\n</li>\n<li>\n<p>获取每个 image 的基地址</p>\n</li>\n<li>\n<p>通过堆栈偏移地址获取栈帧函数地址</p>\n</li>\n</ul>\n</li>\n<li>\n<p>将函数地址翻译成函数名</p>\n<ul>\n<li>\n<p>找到对应 Image 的 symple table 段的 nlist_64 结构体</p>\n</li>\n<li>\n<p>通过 nlist_64.n_un.n_strx 获取函数对应的字符串</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>最终的效果:</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq80unfse1j31fc0cin8n.jpg\" alt=\"\" /></p>\n<h1 id=\"0x4-crash后续\"><a class=\"anchor\" href=\"#0x4-crash后续\">#</a> 0x4: Crash 后续</h1>\n<p>通常在 AppCrash 后会在 handle 中做些上报操作.</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq80xn75voj31cc04ydg7.jpg\" alt=\"\" /></p>\n<p>但是这样做有两个问题：</p>\n<ul>\n<li>\n<p>苹果不推荐在 Handle 中做太多操作，而且数据上报等网络请求属于耗时操作，有可能没有完成 App 就被杀死。</p>\n</li>\n<li>\n<p>App 直接闪退，体验不好</p>\n</li>\n</ul>\n<p>通过查看 runloop 源码可以看出，在 Crash 发生后当前 runloop 中断</p>\n<p>&lt;font color='red'&gt; 注意：runloop 本次循环还在继续，但是循环已经被打破，本次循环结束后 app 才退出 &lt;/font&gt; 既下图的 retVal 被置为 NO<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq810qv4osj317e0nawla.jpg\" alt=\"\" /></p>\n<p>iOS Crash 发生后   runloop 中的 do-while 循环的条件会被置为 NO，然后 Handler 函数走完之后当前循环后直接结束，不会在进行下一次循环了，此时我们只需要再 handler 中再重启 runloop，便可以继续执行代码，通过观察 runloop 源码可以看出 这样的操作是在之前已经中断但是还没结束的 runloop 中开启一个新的 runloop，他依然可以接受各种事件，比如交互事件等，前提是每个 model 都要开启，因为不同操作是发生在不同阶段的。  但是之前 runloop 中的内容处于不可控状态，且之前的东西被永远的留在内存中，不可恢复，所以在做完相关操作后要立即结束 App，避免其他异常情况，这种做法类似于一种安全模式，在安全模式中处理相关的东西。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq814a1gryj31f00ac3zo.jpg\" alt=\"\" /></p>\n<p>函数调用：</p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> continueAfterCrash()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopRef</span> runLoop = <span class=\"built_in\">CFRunLoopGetCurrent</span>();</span><br><span class=\"line\">    <span class=\"built_in\">CFArrayRef</span> allModes = <span class=\"built_in\">CFRunLoopCopyAllModes</span>(runLoop);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *mode <span class=\"keyword\">in</span> (__bridge <span class=\"built_in\">NSArray</span> *)allModes)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CFRunLoopRunInMode</span>((<span class=\"built_in\">CFStringRef</span>)mode, <span class=\"number\">1.0e10</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/008i3skNly1gq81k7k7xcj30cq0um0wg.jpg\" alt=\"\" /></p>\n<p>在新的 runloop 中我们做一些操作后再调用 abort 退出 App，比如弹出友好提示之类的操作，告知用户 app 即将退出，但是该操作存在风险，需要注意以下情况</p>\n<ul>\n<li>\n<p>新开 runloop 后之前的 runloop 内容便会永远的留在内存中变成不可控的状态如果一旦被访问可能会有异常，所以在做完我们必要的操作后要及时结束 App。</p>\n</li>\n<li>\n<p>安全模式必须保证稳定，在新 runloop 中执行的上报、弹窗或者其他逻辑必须要使用系统原生的 API，不能依赖任何第三方。</p>\n</li>\n<li>\n<p>尽量不要做太多的操作，及时结束。</p>\n</li>\n</ul>\n<h1 id=\"0x5-参考资料\"><a class=\"anchor\" href=\"#0x5-参考资料\">#</a> 0x5: 参考资料</h1>\n<ul>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2RvY3VtZW50YXRpb24=\">Apple iOS Api</span></p>\n</li>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9vcGVuc291cmNlLmFwcGxlLmNvbS8=\">iOS Open Sourcre</span></p>\n</li>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9vcGVuc291cmNlLmFwcGxlLmNvbS9zb3VyY2UvQ0YvQ0YtMTE1MS4xNi8=\">CFRunloop</span></p>\n</li>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL29wZW5zb3VyY2UuYXBwbGUuY29tL3RhcmJhbGxzL3hudS94bnUtMzI0OC42MC4xMC50YXIuZ3o=\">XNU 3248.60.10 源码</span></p>\n</li>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2RvY3VtZW50YXRpb24veGNvZGUvZGlhZ25vc2luZ19pc3N1ZXNfdXNpbmdfY3Jhc2hfcmVwb3J0c19hbmRfZGV2aWNlX2xvZ3MvYW5hbHl6aW5nX2FfY3Jhc2hfcmVwb3J0\">Understanding Crash Reports on iPhone OS</span></p>\n</li>\n<li>\n<p>《深入解析 MAC OS X &amp; IOS 操作系统》</p>\n</li>\n</ul>\n<h1 id=\"0x6-最后\"><a class=\"anchor\" href=\"#0x6-最后\">#</a> 0x6: 最后</h1>\n<p>大概这就是所有 Crash 防护的流程，通过两篇文章讲解，希望大家对 iOS 系统的 Crash 流程能有些许的了解，并没有贴太多的源码，其实还是解耦度不够，思路有了代码就很简单了。</p>\n<p>\n        <div id=\"aplayer-yREUnHKW\" class=\"aplayer aplayer-tag-marker\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t  <script>\n\t\t\t\t  var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":0,\"mutex\":true,\"music\":[{\"title\":\"错位时空\",\"author\":\"艾辰\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E8%89%BE%E8%BE%B0%20-%20%E9%94%99%E4%BD%8D%E6%97%B6%E7%A9%BA.mp3\",\"pic\":\"https://bkimg.cdn.bcebos.com/pic/a8ec8a13632762d0f7037ac288a71ffa513d26976830?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2UxMTY=,g_7,xp_5,yp_5/format,f_auto\",\"lrc\":\"https://歌词.lrc\"}]};\n\t\t\t\t  options.element = document.getElementById(\"aplayer-yREUnHKW\");\n\t\t\t\t  var ap = new APlayer(options);\n\t\t\t    window.aplayers || (window.aplayers = []);\n\t\t\t\t  window.aplayers.push(ap);\n\t\t\t  </script></p>\n",
            "tags": [
                "iOS",
                "Crash防护"
            ]
        }
    ]
}