{
    "version": "https://jsonfeed.org/version/1",
    "title": "Molier • All posts by \"httpdns\" tag",
    "description": "iOS 开发 移动App 博客 杂谈 随笔 相册",
    "home_page_url": "https://oliverqueen.cn",
    "items": [
        {
            "id": "https://oliverqueen.cn/2018-01-24-%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%85%A8%E7%9A%84iOS%E7%AB%AFHttpDns%E9%9B%86%E6%88%90%E6%96%B9%E6%A1%88/",
            "url": "https://oliverqueen.cn/2018-01-24-%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%85%A8%E7%9A%84iOS%E7%AB%AFHttpDns%E9%9B%86%E6%88%90%E6%96%B9%E6%A1%88/",
            "title": "可能是最全的iOS端HttpDns集成方案",
            "date_published": "2018-01-24T05:54:36.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"科普片\"><a class=\"anchor\" href=\"#科普片\">#</a> 科普片</h1>\n<h5 id=\"1-dns劫持的危害\"><a class=\"anchor\" href=\"#1-dns劫持的危害\">#</a> 1、DNS 劫持的危害</h5>\n<p>不知道大家有没有发现这样一个现象，在打开一些网页的时候会弹出一些与所浏览网页不相关的内容比如这样奇 (se) 怪 (qing) 的东西</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6jm5b190j30h60ugqkg.jpg\" alt=\"图一\" /></p>\n<p>或者这样<br />\n<span id=\"more\"></span></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6jmr1afuj30ww0ue4qp.jpg\" alt=\"图二\" />，</p>\n<p>其实造成这样的原因就是 DNS 劫持，在我们正常浏览的网页链接里面被恶意插入一些奇怪的东西。不止是这些，DNS 劫持还会对我们的个人信息安全造成很大的伤害，钓鱼网站之类的，也许我们所访问的网站根本不是我们需要的网站，或者根本打不开网页，有时还会消耗我们过多的流量。</p>\n<h5 id=\"2-什么是dns解析\"><a class=\"anchor\" href=\"#2-什么是dns解析\">#</a> 2、什么是 DNS 解析</h5>\n<p>现在假如我们访问一个网站 www.baidu.com 从按下回车到百度页面显示到我们的电脑上会经历如下几个步骤</p>\n<ul>\n<li>1：计算机会向我们的运营商 (移动、电信、联通等) 发出打开 www.baidu.com 的请求。</li>\n<li>2：运营商收到请求后会到自己的 DNS 服务器中找 www.baidu.com 这个域名所对应的服务器的 IP 地址 (也就是百度的服务器的 IP 地址)，这里比如是 180.149.132.47。</li>\n<li>3：运营商用第二步得到的 IP 地址去找到百度的服务器请求得到数据后返回给我们。</li>\n</ul>\n<p>其中第二步就是我们所说的 DNS 解析过程，域名和 IP 地址的关系其实就是我们的身份证号和姓名的关系，都是来标记一个人或者是一个网站的，只是 IP 地址 \\ 身份证号只是一串没有意义的数字，辨识度低，又不好记，所以就会在 IP 上加上一个域名以便区分，或是做的更加个性化，但是如果真的要来准确的区分还是要靠身份证号码或者是 IP 的，所以 DNS 解析就应运而生了。</p>\n<h5 id=\"3什么是dns劫持\"><a class=\"anchor\" href=\"#3什么是dns劫持\">#</a> 3：什么是 DNS 劫持</h5>\n<p>DNS 劫持，是指在 DNS 解析过程中拦截域名解析的请求，然后做一些自己的处理，比如返回假的 IP 地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能反应或访问的是假网址。根本原因就是以下两点：</p>\n<ul>\n<li>1：恶意攻击，拦截运营商的解析过程，把自己的非法东西嵌入其中。</li>\n<li>2：运营商为了利益或者一些其他的因素，允许一些第三方在自己的链接里打打广告之类的。</li>\n</ul>\n<h5 id=\"4防止dns劫持\"><a class=\"anchor\" href=\"#4防止dns劫持\">#</a> 4：防止 DNS 劫持</h5>\n<p>了解了 DNS 劫持的相关资料后我们就知道了，防止 NDS 劫持就要从第二步入手，因为 DNS 解析过程是运营商来操作的，我们不能去干涉他们，不然我们也就成了劫持者了，所以我们要做的就是在我们请求之前对我们的请求链接做一些修改，<span class=\"exturl\" data-url=\"aHR0cDovL3huLS13d3ctb3Q5ZHg4c3k0bm9qa284Y2c2azl1bmtwMWF3ODBkb3N5YS5iYWlkdS5jb20=\">将我们原本的请求链接 www.baidu.com</span> 修改为 180.149.132.47，然后请求出去，这样的话就运营商在拿到我们的请求后发现我们直接用的就是 IP 地址就会直接给我们放行，而不会去走他自己 DNS 解析了，也就是说我们把运营商要做的事情自己先做好了。不走他的 DNS 解析也就不会存在 DNS 被劫持的问题，从根本是解决了。</p>\n<h1 id=\"技术篇\"><a class=\"anchor\" href=\"#技术篇\">#</a> 技术篇</h1>\n<h5 id=\"5项目中的实际操作\"><a class=\"anchor\" href=\"#5项目中的实际操作\">#</a> 5：项目中的实际操作</h5>\n<h6 id=\"51dnspod相关\"><a class=\"anchor\" href=\"#51dnspod相关\">#</a> 5.1：DNSPOD 相关</h6>\n<p>我们知道要要把项目中请求的接口替换成成 IP 其实很简单，URL 是字符串，域名替换 IP，无非就是一个字符串替换而已，的确这块其实没有什么技术含量，而且现在像阿里云 (没开源)，七牛云 (开源)，等一些比较大的平台在这方面也都有了比较成熟的解决方案，一个 SDK，传个普通的 URL 进去就会返回一个域名被替换成 IP 的 URL 出来，也比较好用，这里要说一下 IP 地址的来源，如何拿到一个域名所对应的 IP 呢？这里就是需要用到另一个服务 ——HTTPDNS，国内比较有名的就是 DNSPOD，包括阿里，七牛等也是使用他们的 DNS 服务来解析，就是这个</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6jnbe2zhj30sa0i8dwv.jpg\" alt=\"DNSPOD logo\" /></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6jnt2uw9j31kw0icava.jpg\" alt=\"简介\" /></p>\n<p>他会给我们提供一个接口，我们使用 HTTP 请求的方式去请求这个接口，参数带上我们的域名，他们就会把域名对应的 IP 列表返回回来。类似这样：<br />\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///这个请求URL的结构是固定的119.29.29.29是DNSPOD固定的服务器地址，ttl参数的意思是返回结果是否带ttl是个BOOL，dn就是我们需要解析的域名，id就是我们在dnspod上注册时候他给我们的一个KEY</span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *url = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@&quot;http://119.29.29.29/d?ttl=1&amp;dn=www.baidu.com&amp;id=KEY&quot;</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSMutableURLRequest</span> * request = [<span class=\"built_in\">NSMutableURLRequest</span> requestWithURL:[<span class=\"built_in\">NSURL</span> URLWithString:url] cachePolicy:<span class=\"built_in\">NSURLRequestUseProtocolCachePolicy</span> timeoutInterval:<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSData</span> * data = [<span class=\"built_in\">NSURLConnection</span> sendSynchronousRequest:request returningResponse:<span class=\"literal\">nil</span> error:&amp;networkError];</span><br></pre></td></tr></table></figure></p>\n<p>这里使用同步还是异步都是可以的，具体根据你们业务需求。</p>\n<h6 id=\"52项目中的使用\"><a class=\"anchor\" href=\"#52项目中的使用\">#</a> 5.2：项目中的使用</h6>\n<p>其实 dnspod 最难的部分是接入的部分，因为不同的 APP 不同的网络环境会导致各种各样的问题，如果你是一个新的项目那么接入难度会大大降低，因为你完全可以自己封装一套网络请求，把 DNS 解析相关的逻辑都封装到自己的网络请求中，这样你就可以得到 APP 所有的网络层的控制权，想干什么就干什么，但是如果是在一个已经比较完善的 APP 中加入 DNS 防劫持的话那就是比较困难，因为你不能拿到所有网络请求的控制权这篇文章中我主要使用是 NSURLProtocol + Runtime hook 方式来处理这些东西的，NSURLProtocol 属于 iOS 黑魔法的一种可以拦截任何从 APP 的 URL Loading System 系统中发出的请求，其中包括如下</p>\n<ul>\n<li>File Transfer Protocol (ftp://)</li>\n<li>Hypertext Transfer Protocol (http://)</li>\n<li>Hypertext Transfer Protocol with encryption (https://)</li>\n<li>Local file URLs (file:///)</li>\n<li>Data URLs (data://)</li>\n</ul>\n<p>如果你的请求不在以上列表中就不能进行拦截了，比如 WKWebview，AVPlayer (比较特殊，虽然请求也是 http/https 但是就是不走这套系统，苹果爸爸就是这样～) 等，其实对于正常来说光用已经 NSURLProtocol 足够了。<br />\n  NSURLProtocol 这个类我们不能直接使用，我们需要自己创建一个他的子类然后在我们的子类中操作他们像这样<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 注册自定义protocol</span></span><br><span class=\"line\">[<span class=\"built_in\">NSURLProtocol</span> registerClass:[CustomURLProtocol <span class=\"keyword\">class</span>]];</span><br><span class=\"line\"> <span class=\"built_in\">NSURLSessionConfiguration</span> *configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">configuration.protocolClasses = @[[CustomURLProtocol <span class=\"keyword\">class</span>]];</span><br></pre></td></tr></table></figure><br />\n 在这个类中我们可以拦截到请求，然后进行处理。这个类中有四个非常重要的方法<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"type\">BOOL</span>)canInitWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLRequest</span> *)canonicalRequestForRequest:(<span class=\"built_in\">NSURLRequest</span> *)request;</span><br><span class=\"line\">- (<span class=\"type\">void</span>)startLoading;</span><br><span class=\"line\"><span class=\"comment\">//对于拦截的请求，NSURLProtocol对象在停止加载时调用该方法</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)stopLoading;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"boolcaninitwithrequestnsurlrequest-request\"><a class=\"anchor\" href=\"#boolcaninitwithrequestnsurlrequest-request\">#</a> + (BOOL)canInitWithRequest:(NSURLRequest *)request;</h6>\n<p>通过返回值来告诉 NSUrlProtocol 对进来的请求是否拦截，比如我只拦截 HTTP 的，或者是某个域名的请求之类</p>\n<h6 id=\"nsurlrequest-canonicalrequestforrequestnsurlrequest-request\"><a class=\"anchor\" href=\"#nsurlrequest-canonicalrequestforrequestnsurlrequest-request\">#</a> + (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request;</h6>\n<p>如果上面的方法返回 YES 那么 request 会传到这里，这个地方通常不做处理 直接返回 request</p>\n<h6 id=\"-voidstartloading\"><a class=\"anchor\" href=\"#-voidstartloading\">#</a> - (void)startLoading;</h6>\n<p>这个地方就是对我们拦截的请求做一些处理，我们文中所做的 IP 对域名的替换就在这里进行，处理完之后将请求转发出去，比如这样<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)startLoading &#123;</span><br><span class=\"line\"><span class=\"comment\">///其中customRequest是处理过的请求(域名替换后的)</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLSession</span> *session = [<span class=\"built_in\">NSURLSession</span> sessionWithConfiguration:[[<span class=\"built_in\">NSURLSessionConfiguration</span> alloc] init] delegate:<span class=\"keyword\">self</span> delegateQueue:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:customRequest];</span><br><span class=\"line\">    [task resume];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 你可以在 - startLoading 中使用任何方法来对协议对象持有的 request 进行转发，包括 NSURLSession、 NSURLConnection 甚至使用 AFNetworking 等网络库，只要你能在回调方法中把数据传回 client，帮助其正确渲染就可以，比如这样：<br />\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session dataTask:(<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTask didReceiveResponse:(<span class=\"built_in\">NSURLResponse</span> *)response completionHandler:(<span class=\"type\">void</span> (^)(<span class=\"built_in\">NSURLSessionResponseDisposition</span>))completionHandler &#123;</span><br><span class=\"line\">    [[<span class=\"keyword\">self</span> client] URLProtocol:<span class=\"keyword\">self</span> didReceiveResponse:response cacheStoragePolicy:<span class=\"built_in\">NSURLCacheStorageAllowed</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    completionHandler(<span class=\"built_in\">NSURLSessionResponseAllow</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session dataTask:(<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class=\"built_in\">NSData</span> *)data &#123;</span><br><span class=\"line\">    [[<span class=\"keyword\">self</span> client] URLProtocol:<span class=\"keyword\">self</span> didLoadData:data];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\nclient 在后面会有讲解。</p>\n<h6 id=\"-voidstoploading\"><a class=\"anchor\" href=\"#-voidstoploading\">#</a> - (void)stopLoading;</h6>\n<p>请求完毕后调用<br />\n大概的执行流程是这样</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6jtpp3z0j30ze1by122.jpg\" alt=\"流程\" /></p>\n<p>在 NSURLProtocol 中有一个贯穿始终的变量<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*!</span></span><br><span class=\"line\"><span class=\"comment\">    @method client</span></span><br><span class=\"line\"><span class=\"comment\">    @abstract Returns the NSURLProtocolClient of the receiver.</span></span><br><span class=\"line\"><span class=\"comment\">    @result The NSURLProtocolClient of the receiver.  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">readonly</span>, <span class=\"keyword\">retain</span>) <span class=\"type\">id</span> &lt;<span class=\"built_in\">NSURLProtocolClient</span>&gt; client;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 你可以认为是这个是请求的发送者，打个比方，A 想给 B 发送一个消息，由于距离遥远于是 A 去了邮局，A 把消息内容告诉了邮局，并且 A 在邮局登记了自己名字方便 B 有反馈的时候邮局来通知 A 查收。这个例子中邮局就是 NSURLProtocol，A 在邮局登记的名字就是 client。所有的 client 都实现了 NSURLProtocolClient 协议，协议的作用就是在 HTTP 请求发出以及接受响应时向其它对象传输数据：<br />\n<figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@protocol NSURLProtocolClient &lt;NSObject&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">- <span class=\"params\">(void)</span>URLProtocol:<span class=\"params\">(NSURLProtocol *)</span>protocol didReceiveResponse:<span class=\"params\">(NSURLResponse *)</span>response cacheStoragePolicy:<span class=\"params\">(NSURLCacheStoragePolicy)</span>policy;</span><br><span class=\"line\"></span><br><span class=\"line\">- <span class=\"params\">(void)</span>URLProtocol:<span class=\"params\">(NSURLProtocol *)</span>protocol didLoadData:<span class=\"params\">(NSData *)</span>data;</span><br><span class=\"line\"></span><br><span class=\"line\">- <span class=\"params\">(void)</span>URLProtocolDidFinishLoading:<span class=\"params\">(NSURLProtocol *)</span>protocol;</span><br><span class=\"line\">...</span><br><span class=\"line\">@<span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure><br />\n 当然这个协议中还有很多其他的方法，比如 HTTPS 验证、重定向以及响应缓存相关的方法，你需要在合适的时候调用这些代理方法，对信息进行传递。<br />\n到此正常情况下的 DNS 的解析过程已经结束，如果你发现按照如上操作之后并没有达到预期效果那么请往下看，(通常情况下完成以上操作 原有的 URL 的就会变成 http://123.456.789.123/XXX/XXX/XXX 的格式。如果发现请求不成功就往下看吧)</p>\n<h5 id=\"6遇到的坑点\"><a class=\"anchor\" href=\"#6遇到的坑点\">#</a> 6：遇到的坑点</h5>\n<h6 id=\"61我们知道运营商本来是根据域名来确定一个url的我们将域名改为ip之后虽然不用运营商帮我们解析了但是运营商在收到一串数字的时候也是懵逼状态我们还是需要将域名传给他们但是不能用正常的方式传我们需要把原来的域名加到http请求的header中的host字段下根据http协议的规定如果在url中无法找到域名的话就会去header中找这样一来我们既把域名告诉了运营商同时也直接制定了ip地址这个是必须配置的不然的话是请求不成功的\"><a class=\"anchor\" href=\"#61我们知道运营商本来是根据域名来确定一个url的我们将域名改为ip之后虽然不用运营商帮我们解析了但是运营商在收到一串数字的时候也是懵逼状态我们还是需要将域名传给他们但是不能用正常的方式传我们需要把原来的域名加到http请求的header中的host字段下根据http协议的规定如果在url中无法找到域名的话就会去header中找这样一来我们既把域名告诉了运营商同时也直接制定了ip地址这个是必须配置的不然的话是请求不成功的\">#</a> 6.1：我们知道运营商本来是根据域名来确定一个 URL 的，我们将域名改为 IP 之后虽然不用运营商帮我们解析了，但是运营商在收到一串数字的时候也是懵逼状态，我们还是需要将域名传给他们，但是不能用正常的方式传，我们需要把原来的域名加到 http 请求的 Header 中的 host 字段下，根据 Http 协议的规定，如果在 URL 中无法找到域名的话就会去 Header 中找，这样一来我们既把域名告诉了运营商同时也直接制定了 IP 地址，这个是必须配置的，不然的话是请求不成功的。</h6>\n<p><figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mutableRequest <span class=\"built_in\">set</span>Value:<span class=\"literal\">self</span>.request.URL.host <span class=\"keyword\">for</span>HTTPHeaderField:@<span class=\"string\">&quot;HOST&quot;</span>];</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"加上header再去请求就没问题了不过有些特殊的情况下会需要带上cookie同样也是加到header中\"><a class=\"anchor\" href=\"#加上header再去请求就没问题了不过有些特殊的情况下会需要带上cookie同样也是加到header中\">#</a> 加上 Header 再去请求就没问题了，不过有些特殊的情况下会需要带上 cookie，同样也是加到 Header 中</h6>\n<p><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">mutableRequest setValue:YOUR Cookie forHTTPHeaderField:@<span class=\"string\">&quot;Cookie&quot;</span></span>];</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"62关于afnetworking的问题现在大部分网络请求是基于afnetworking的这里有一个坑我们知道我们注册customprotocol的时候是这样\"><a class=\"anchor\" href=\"#62关于afnetworking的问题现在大部分网络请求是基于afnetworking的这里有一个坑我们知道我们注册customprotocol的时候是这样\">#</a> 6.2：关于 AfNetworking 的问题，现在大部分网络请求是基于 Afnetworking 的，这里有一个坑，我们知道我们注册 CustomProtocol 的时候是这样</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 注册自定义protocol</span></span><br><span class=\"line\">[<span class=\"built_in\">NSURLProtocol</span> registerClass:[CustomURLProtocol <span class=\"keyword\">class</span>]];</span><br><span class=\"line\"> <span class=\"built_in\">NSURLSessionConfiguration</span> *configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">configuration.protocolClasses = @[[CustomURLProtocol <span class=\"keyword\">class</span>]];</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"在系统的configuration加入我们的customprotocolprotocolclasses是一个数组里面可以放很多各种不同的customprotocol我们看一下afnetworking的初始化方法\"><a class=\"anchor\" href=\"#在系统的configuration加入我们的customprotocolprotocolclasses是一个数组里面可以放很多各种不同的customprotocol我们看一下afnetworking的初始化方法\">#</a> 在系统的 configuration 加入我们的 CustomProtocol，protocolClasses 是一个数组里面可以放很多各种不同的 CustomProtocol，我们看一下 afnetworking 的初始化方法。</h6>\n<p><figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AFHTTPSessionManager * sessionManager <span class=\"operator\">=</span> [AFHTTPSessionManager manager]<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure></p>\n<h6 id=\"我相信大家通常都会这么来创建但是这里我要说下manager并不是一个单利最后都会调到一个方法\"><a class=\"anchor\" href=\"#我相信大家通常都会这么来创建但是这里我要说下manager并不是一个单利最后都会调到一个方法\">#</a> 我相信大家通常都会这么来创建，但是这里我要说下 manager 并不是一个单利，最后都会调到一个方法</h6>\n<p><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">-</span> (instancetype)initWithSessionConfiguration:(<span class=\"type\">NSURLSessionConfiguration</span> <span class=\"operator\">*</span>)configuration &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> <span class=\"operator\">=</span> [<span class=\"keyword\">super</span> <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"operator\">!</span><span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"operator\">!</span>configuration) &#123;</span><br><span class=\"line\">        configuration <span class=\"operator\">=</span> [<span class=\"type\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.sessionConfiguration <span class=\"operator\">=</span> configuration;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.operationQueue <span class=\"operator\">=</span> [[<span class=\"type\">NSOperationQueue</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.operationQueue.maxConcurrentOperationCount <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.session <span class=\"operator\">=</span> [<span class=\"type\">NSURLSession</span> sessionWithConfiguration:<span class=\"keyword\">self</span>.sessionConfiguration delegate:<span class=\"keyword\">self</span> delegateQueue:<span class=\"keyword\">self</span>.operationQueue];</span><br><span class=\"line\">    .</span><br><span class=\"line\">    .</span><br><span class=\"line\">    .</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h6 id=\"大家注意第二个判断如果没有传入configuration的话他会创建一个默认的这样以至于我们之前在configuration的protocolclasses中注册类全部被这个新的configuration替换掉了所以无法解析-这里我采取的办法就是runtime-hook因为hook第三方的代码并不是一个很好的办法所以我直接hook-nsurlsession的sessionwithconfiguration方法因为通过观察afnetworking的源码最终都是走到这里的-hook之后把自己的configuration换进去像这样\"><a class=\"anchor\" href=\"#大家注意第二个判断如果没有传入configuration的话他会创建一个默认的这样以至于我们之前在configuration的protocolclasses中注册类全部被这个新的configuration替换掉了所以无法解析-这里我采取的办法就是runtime-hook因为hook第三方的代码并不是一个很好的办法所以我直接hook-nsurlsession的sessionwithconfiguration方法因为通过观察afnetworking的源码最终都是走到这里的-hook之后把自己的configuration换进去像这样\">#</a> 大家注意第二个判断，如果没有传入 configuration 的话他会创建一个默认的，这样以至于我们之前在 configuration 的 protocolClasses 中注册类全部被这个新的 configuration 替换掉了，所以无法解析。这里我采取的办法就是 runtime hook，因为 hook 第三方的代码并不是一个很好的办法，所以我直接 hook NSURLSession 的 sessionWithConfiguration 方法，因为通过观察 Afnetworking 的源码最终都是走到这里的。Hook 之后把自己的 configuration 换进去，像这样</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">NSURLSession</span> *)swizzle_sessionWithConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionConfiguration</span> *newConfiguration = configuration;</span><br><span class=\"line\">    <span class=\"comment\">// 在现有的Configuration中插入我们自定义的protocol</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (configuration) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSMutableArray</span> *protocolArray = [<span class=\"built_in\">NSMutableArray</span> arrayWithArray:configuration.protocolClasses];</span><br><span class=\"line\">        [protocolArray insertObject:[CustomProtocol <span class=\"keyword\">class</span>] atIndex:<span class=\"number\">0</span>];</span><br><span class=\"line\">        newConfiguration.protocolClasses = protocolArray;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newConfiguration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">        <span class=\"built_in\">NSMutableArray</span> *protocolArray = [<span class=\"built_in\">NSMutableArray</span> arrayWithArray:configuration.protocolClasses];</span><br><span class=\"line\">        [protocolArray insertObject:[CustomProtocol <span class=\"keyword\">class</span>] atIndex:<span class=\"number\">0</span>];</span><br><span class=\"line\">        newConfiguration.protocolClasses = protocolArray;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> swizzle_sessionWithConfiguration:newConfiguration];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"然后就完美解决了-不过要注意下系统的是有两个方法的\"><a class=\"anchor\" href=\"#然后就完美解决了-不过要注意下系统的是有两个方法的\">#</a> 然后就完美解决了。不过要注意下系统的是有两个方法的</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Customization of NSURLSession occurs during creation of a new session.</span></span><br><span class=\"line\"><span class=\"comment\"> * If you only need to use the convenience routines with custom</span></span><br><span class=\"line\"><span class=\"comment\"> * configuration options it is not necessary to specify a delegate.</span></span><br><span class=\"line\"><span class=\"comment\"> * If you do specify a delegate, the delegate will be retained until after</span></span><br><span class=\"line\"><span class=\"comment\"> * the delegate has been sent the URLSession:didBecomeInvalidWithError: message.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLSession</span> *)sessionWithConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLSession</span> *)sessionWithConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration delegate:(<span class=\"keyword\">nullable</span> <span class=\"type\">id</span> &lt;<span class=\"built_in\">NSURLSessionDelegate</span>&gt;)delegate delegateQueue:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSOperationQueue</span> *)queue;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"这两个方法不能确定最终会走那个所以为了保险起见都hook下hook的方式是一样的\"><a class=\"anchor\" href=\"#这两个方法不能确定最终会走那个所以为了保险起见都hook下hook的方式是一样的\">#</a> 这两个方法不能确定最终会走那个，所以为了保险起见都 hook 下，hook 的方式是一样的</h6>\n<h6 id=\"63avplayer请求avplayer是我们ios系统中系统自带的播放视频的框架用到地方也很多但是这个是比较坑的因为avplayer虽然也有httphttpsfile请求这个概念但是avplayer所有的请求都不会走url-loading-system也就是说所有由avplayer发出的请求都不能被我们的customprotocol拦截这时候大家也许会问不对呀我们正常调试的时候可以被拦截到的啊-其实苹果官方上是说avplayer在真机调试和模拟器调试时候走的完全不是一套策略也就是说在模拟器运行时候是完全正常的可以被拦截到也可以被解析但是在真机上面就恰恰相反了因为我们最后还是以真机为准所以我们采取的办法还是hook因为我们需要在媒体url传给avplayer前就要将相关东西配置好域名替换啊加host啊之类的所以我们要找avplayer的入口先看初始化方法我发现项目中使用一个avurlasset来初始化avplayer那么avurlasset又是什么呢继续查到avurlasset的初始化方法可以发现这个方法\"><a class=\"anchor\" href=\"#63avplayer请求avplayer是我们ios系统中系统自带的播放视频的框架用到地方也很多但是这个是比较坑的因为avplayer虽然也有httphttpsfile请求这个概念但是avplayer所有的请求都不会走url-loading-system也就是说所有由avplayer发出的请求都不能被我们的customprotocol拦截这时候大家也许会问不对呀我们正常调试的时候可以被拦截到的啊-其实苹果官方上是说avplayer在真机调试和模拟器调试时候走的完全不是一套策略也就是说在模拟器运行时候是完全正常的可以被拦截到也可以被解析但是在真机上面就恰恰相反了因为我们最后还是以真机为准所以我们采取的办法还是hook因为我们需要在媒体url传给avplayer前就要将相关东西配置好域名替换啊加host啊之类的所以我们要找avplayer的入口先看初始化方法我发现项目中使用一个avurlasset来初始化avplayer那么avurlasset又是什么呢继续查到avurlasset的初始化方法可以发现这个方法\">#</a> 6.3：AVPlayer 请求，AVPlayer 是我们 iOS 系统中系统自带的播放视频的框架，用到地方也很多，但是这个是比较坑的，因为 AVPlayer 虽然也有 http/https/file…… 请求这个概念，但是 AVPlayer 所有的请求都不会走 URL Loading System，也就是说所有由 AVPlayer 发出的请求都不能被我们的 CustomProtocol 拦截，这时候大家也许会问，不对呀，我们正常调试的时候可以被拦截到的啊。其实苹果官方上是说 AVPlayer 在真机调试和模拟器调试时候走的完全不是一套策略，也就是说在模拟器运行时候是完全正常的，可以被拦截到也可以被解析，但是在真机上面就恰恰相反了，因为我们最后还是以真机为准，所以我们采取的办法还是 hook，因为我们需要在媒体 URL 传给 AVPlayer 前就要将相关东西配置好，域名替换啊，加 host 啊之类的，所以我们要找 AVPlayer 的入口，先看初始化方法，我发现项目中使用一个 AVURLAsset 来初始化 AVPlayer，那么 AVURLAsset 又是什么呢？继续查到 AVURLAsset 的初始化方法，可以发现这个方法：</h6>\n<p><figure class=\"highlight smali\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*!</span><br><span class=\"line\">  @method\t\tinitWithURL:options:</span><br><span class=\"line\">  @abstract\t\tInitializes an<span class=\"built_in\"> instance </span>of AVURLAsset for inspection of a media resource.</span><br><span class=\"line\">  @param\t\tURL</span><br><span class=\"line\">\t\t\t\tAn<span class=\"built_in\"> instance </span>of NSURL that references a media resource.</span><br><span class=\"line\">  @param\t\toptions</span><br><span class=\"line\">\t\t\t\tAn<span class=\"built_in\"> instance </span>of NSDictionary that contains keys for specifying options for the initialization of the AVURLAsset. See AVURLAssetPreferPreciseDurationAndTimingKey<span class=\"built_in\"> and </span>AVURLAssetReferenceRestrictionsKey above.</span><br><span class=\"line\">  @result\t\tAn<span class=\"built_in\"> instance </span>of AVURLAsset.</span><br><span class=\"line\">*/</span><br><span class=\"line\">- (instancetype)initWithURL:(NSURL *)URL options:(nullable NSDictionary&lt;NSString *, id&gt; *)options NS_DESIGNATED_INITIA<span class=\"class\">LIZER;</span></span><br></pre></td></tr></table></figure></p>\n<h6 id=\"其中url就是我们传给avplayer播放的url找到目标就hook下就可以了具体过程就不多说了还是字符串替换但是有一点需要注意的是我之前上文说过做完ip对域名的替换之后还需要设置下request的host但是这个地方只有一个url并没有request该如何处理呢其实这个方法里面的opinion参数就是处理这个的可以添加cookie之类的类似与httpheader的东西可以添加这几个key\"><a class=\"anchor\" href=\"#其中url就是我们传给avplayer播放的url找到目标就hook下就可以了具体过程就不多说了还是字符串替换但是有一点需要注意的是我之前上文说过做完ip对域名的替换之后还需要设置下request的host但是这个地方只有一个url并没有request该如何处理呢其实这个方法里面的opinion参数就是处理这个的可以添加cookie之类的类似与httpheader的东西可以添加这几个key\">#</a> 其中 URL 就是我们传给 AVPlayer 播放的 URL，找到目标就 Hook 下就可以了，具体过程就不多说了还是字符串替换，但是有一点需要注意的是，我之前上文说过做完 IP 对域名的替换之后还需要设置下 request 的 Host，但是这个地方只有一个 URL 并没有 Request 该如何处理呢？其实这个方法里面的 opinion 参数就是处理这个的，可以添加 cookie 之类的类似与 httpheader 的东西，可以添加这几个 Key</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">AVF_EXPORT</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">AVURLAssetPreferPreciseDurationAndTimingKey</span> <span class=\"built_in\">NS_AVAILABLE</span>(<span class=\"number\">10</span>_7, <span class=\"number\">4</span>_0);</span><br><span class=\"line\"><span class=\"built_in\">AVF_EXPORT</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">AVURLAssetReferenceRestrictionsKey</span> <span class=\"built_in\">NS_AVAILABLE</span>(<span class=\"number\">10</span>_7, <span class=\"number\">5</span>_0);</span><br><span class=\"line\"><span class=\"built_in\">AVF_EXPORT</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">AVURLAssetHTTPCookiesKey</span> <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0);</span><br><span class=\"line\"><span class=\"built_in\">AVF_EXPORT</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">AVURLAssetAllowsCellularAccessKey</span> <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">10</span>_0);</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"但是并没有发现和host相关的key其实这个key是有的就是avurlassethttpheaderfieldskey只是因为这个key没暴露出来-这个地方不太确定是不是苹果的私有api网上查了大量的资料也没有个说法甚至我亲自去苹果开发者去问苹果也没有给任何答复各种说法都有具体使用的话就是\"><a class=\"anchor\" href=\"#但是并没有发现和host相关的key其实这个key是有的就是avurlassethttpheaderfieldskey只是因为这个key没暴露出来-这个地方不太确定是不是苹果的私有api网上查了大量的资料也没有个说法甚至我亲自去苹果开发者去问苹果也没有给任何答复各种说法都有具体使用的话就是\">#</a> 但是并没有发现和 Host 相关的 Key，其实这个 key 是有的就是 AVURLAssetHTTPHeaderFieldsKey 只是因为这个 Key 没暴露出来。这个地方不太确定是不是苹果的私有 API，网上查了大量的资料也没有个说法，甚至我亲自去苹果开发者去问，苹果也没有给任何答复，各种说法都有，具体使用的话就是</h6>\n<p><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"variable language_\">self</span> <span class=\"symbol\">swizzle_initWithURL:</span>videoURL <span class=\"symbol\">options:</span>@&#123;AVURLAssetHTTPHeaderFieldsKey : @&#123;@<span class=\"string\">&quot;Host&quot;</span><span class=\"symbol\">:host</span>&#125;&#125;]</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"这样使用是没有任何问题的但是毕竟是没有暴露出来的方法我们不能这样明目张胆的使用其实对于字符串来说还是比较好规避的只要不要明文出现这个key就可以我在这里使用了一个加密吧key变成密文然后这个地方通过解密获取就像这样\"><a class=\"anchor\" href=\"#这样使用是没有任何问题的但是毕竟是没有暴露出来的方法我们不能这样明目张胆的使用其实对于字符串来说还是比较好规避的只要不要明文出现这个key就可以我在这里使用了一个加密吧key变成密文然后这个地方通过解密获取就像这样\">#</a> 这样使用是没有任何问题的，但是毕竟是没有暴露出来的方法，我们不能这样明目张胆的使用，其实对于字符串来说还是比较好规避的，只要不要明文出现这个 KEY 就可以，我在这里使用了一个加密，吧 key 变成密文然后这个地方通过解密获取，就像这样：</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//加密后的KEY</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">NSString</span> * headerKey = <span class=\"string\">@&quot;35905FF45AFA4C579B7DE2403C7CA0CCB59AA83D660E60C9D444AFE13323618F&quot;</span>;</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\"><span class=\"comment\">//getRequestHeaderKey方法为解密方法</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> swizzle_initWithURL:videoURL options:@&#123;[<span class=\"keyword\">self</span> getRequestHeaderKey] : @&#123;<span class=\"string\">@&quot;Host&quot;</span>:host&#125;&#125;];</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"这样之后就大功告成了avplayer可以在dns被劫持的情况下播放了\"><a class=\"anchor\" href=\"#这样之后就大功告成了avplayer可以在dns被劫持的情况下播放了\">#</a> 这样之后就大功告成了，AVPlayer 可以在 DNS 被劫持的情况下播放了，</h6>\n<h6 id=\"64post请求这块也算是一个大坑我们知道http的post请求会包含一个body体里面包含我们需要上传的参数等一些资料对于post请求我们的nsurlprotocol是可以正常拦截的但是我们拦截之后发现无论怎么样我们获得的body体都为nil后来查了一些资料发下又是苹果爸爸在做手脚-nsurlprotocol在拦截nsurlsession的post请求时不能获取到request中的httpbody这个貌似早就国外的论坛上传开了但国内好像还鲜有人知据苹果官方的解释是body是nsdata类型即可能为二进制内容而且还没有大小限制所以可能会很大为了性能考虑索性就拦截时就不拷贝了内流满面脸-为了解决这个问题我们可以通过把body数据放到header中不过header的大小好像是有限制的我试过2m是没有问题不过超过10m就直接request-timeout了-而且当body数据为二进制数据时这招也没辙了因为header里都是文本数据另一种方案就是用一个nsdictionary或nscache保存没有请求的body数据用url为key最后方法就是别用nsurlsession老老实实用古老的nsurlconnection算了-你以为这么就结束了吗并没有后来查了大量的资料发现既然post请求的httpbody没有苹果复制下来那我们就不用httpbody我们再往底层去看就会发现httpbodystream这个东西我们可以通过他来获取请求的body体具体代吗如下\"><a class=\"anchor\" href=\"#64post请求这块也算是一个大坑我们知道http的post请求会包含一个body体里面包含我们需要上传的参数等一些资料对于post请求我们的nsurlprotocol是可以正常拦截的但是我们拦截之后发现无论怎么样我们获得的body体都为nil后来查了一些资料发下又是苹果爸爸在做手脚-nsurlprotocol在拦截nsurlsession的post请求时不能获取到request中的httpbody这个貌似早就国外的论坛上传开了但国内好像还鲜有人知据苹果官方的解释是body是nsdata类型即可能为二进制内容而且还没有大小限制所以可能会很大为了性能考虑索性就拦截时就不拷贝了内流满面脸-为了解决这个问题我们可以通过把body数据放到header中不过header的大小好像是有限制的我试过2m是没有问题不过超过10m就直接request-timeout了-而且当body数据为二进制数据时这招也没辙了因为header里都是文本数据另一种方案就是用一个nsdictionary或nscache保存没有请求的body数据用url为key最后方法就是别用nsurlsession老老实实用古老的nsurlconnection算了-你以为这么就结束了吗并没有后来查了大量的资料发现既然post请求的httpbody没有苹果复制下来那我们就不用httpbody我们再往底层去看就会发现httpbodystream这个东西我们可以通过他来获取请求的body体具体代吗如下\">#</a> 6.4：POST 请求这块也算是一个大坑，我们知道 http 的 post 请求会包含一个 body 体，里面包含我们需要上传的参数等一些资料，对于 POST 请求我们的 NSURLProtocol 是可以正常拦截的，但是我们拦截之后发现无论怎么样我们获得的 body 体都为 nil！后来查了一些资料发下又是苹果爸爸在做手脚。NSURLProtocol 在拦截 NSURLSession 的 POST 请求时不能获取到 Request 中的 HTTPBody，这个貌似早就国外的论坛上传开了，但国内好像还鲜有人知，据苹果官方的解释是 Body 是 NSData 类型，即可能为二进制内容，而且还没有大小限制，所以可能会很大，为了性能考虑，索性就拦截时就不拷贝了（内流满面脸）。为了解决这个问题，我们可以通过把 Body 数据放到 Header 中，不过 Header 的大小好像是有限制的，我试过 2M 是没有问题，不过超过 10M 就直接 Request timeout 了。。。而且当 Body 数据为二进制数据时这招也没辙了，因为 Header 里都是文本数据，另一种方案就是用一个 NSDictionary 或 NSCache 保存没有请求的 Body 数据，用 URL 为 key，最后方法就是别用 NSURLSession，老老实实用古老的 NSURLConnection 算了。。。你以为这么就结束了吗？并没有，后来查了大量的资料发现，既然 post 请求的 httpbody 没有苹果复制下来，那我们就不用 httpbody，我们再往底层去看就会发现 HTTPBodyStream 这个东西我们可以通过他来获取请求的 body 体具体代吗如下</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark -</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark 处理POST请求相关POST  用HTTPBodyStream来处理BODY体</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSMutableURLRequest</span> *)handlePostRequestBodyWithRequest:(<span class=\"built_in\">NSMutableURLRequest</span> *)request &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableURLRequest</span> * req = [request mutableCopy];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([request.HTTPMethod isEqualToString:<span class=\"string\">@&quot;POST&quot;</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!request.HTTPBody) &#123;</span><br><span class=\"line\">            uint8_t d[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">            <span class=\"built_in\">NSInputStream</span> *stream = request.HTTPBodyStream;</span><br><span class=\"line\">            <span class=\"built_in\">NSMutableData</span> *data = [[<span class=\"built_in\">NSMutableData</span> alloc] init];</span><br><span class=\"line\">            [stream open];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ([stream hasBytesAvailable]) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">NSInteger</span> len = [stream read:d maxLength:<span class=\"number\">1024</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (len &gt; <span class=\"number\">0</span> &amp;&amp; stream.streamError == <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">                    [data appendBytes:(<span class=\"type\">void</span> *)d length:len];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            req.HTTPBody = [data <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">            [stream close];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> req;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h6 id=\"这样之后的req就是携带了body体的request啦可以愉快地做post请求啦\"><a class=\"anchor\" href=\"#这样之后的req就是携带了body体的request啦可以愉快地做post请求啦\">#</a> 这样之后的 req 就是携带了 body 体的 request 啦，可以愉快地做 post 请求啦。</h6>\n<h6 id=\"65wkwebview是新出的浏览器控件这里就不多说了wkwebview不走url-loading-system所以也不会被拦截不过也是有办法的但是因为这次项目中没有用到所以没有过多的去研究后续我会写一篇关于这个博客不是很难依旧是runtime大法\"><a class=\"anchor\" href=\"#65wkwebview是新出的浏览器控件这里就不多说了wkwebview不走url-loading-system所以也不会被拦截不过也是有办法的但是因为这次项目中没有用到所以没有过多的去研究后续我会写一篇关于这个博客不是很难依旧是runtime大法\">#</a> 6.5：WKWebview 是新出的浏览器控件，这里就不多说了，WKWebview 不走 URL Loading System，所以也不会被拦截，不过也是有办法的，但是因为这次项目中没有用到，所以没有过多的去研究，后续我会写一篇关于这个博客，不是很难，依旧是 runtime 大法。</h6>\n<h6 id=\"66sni环境这个可是坑了我好久好久的东西所以我会放在最后去说sni环境因为涉及到证书验证所以是在https的基础上来说的sniserver-name-indication是为了解决一个服务器使用多个域名和证书的扩展-一句话简述它的工作原理就是在连接到服务器建立ssl链接之前先发送要访问站点的域名hostname这样服务器根据这个域名返回一个合适的证书-其实关于sni环境在这里就不过多解释阿里云文档有很明白的解释同时他也有安卓和ios在sni环境下的处理文档我们发现安卓部分写的很详细可是已到了ios这边就这样了\"><a class=\"anchor\" href=\"#66sni环境这个可是坑了我好久好久的东西所以我会放在最后去说sni环境因为涉及到证书验证所以是在https的基础上来说的sniserver-name-indication是为了解决一个服务器使用多个域名和证书的扩展-一句话简述它的工作原理就是在连接到服务器建立ssl链接之前先发送要访问站点的域名hostname这样服务器根据这个域名返回一个合适的证书-其实关于sni环境在这里就不过多解释阿里云文档有很明白的解释同时他也有安卓和ios在sni环境下的处理文档我们发现安卓部分写的很详细可是已到了ios这边就这样了\">#</a> 6.6：SNI 环境，这个可是坑了我好久好久的东西，所以我会放在最后去说，SNI 环境因为涉及到证书验证所以是在 https 的基础上来说的，SNI（Server Name Indication）是为了解决一个服务器使用多个域名和证书的扩展。一句话简述它的工作原理就是，在连接到服务器建立 SSL 链接之前先发送要访问站点的域名（Hostname），这样服务器根据这个域名返回一个合适的证书。其实关于 SNI 环境在这里就不过多解释，**<span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vZG9jdW1lbnRfZGV0YWlsLzMwMTQzLmh0bWw=\"> 阿里云文档</span> ** 有很明白的解释，同时他也有安卓和 iOS 在 SNI 环境下的处理文档，我们发现安卓部分写的很详细，可是已到了 iOS 这边就这样了：</h6>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6juzsqdqj31kw0bbn5v.jpg\" alt=\"阿里云文档截图\" /></p>\n<h6 id=\"三行文字加三个链接就完事了-其实在遇到这个坑的时候我也查过很多相关资料无非就是这三行话加这三个链接复制来复制去没有实质性的进展大部分公司或者是项目没有这么重的httpdns需求所以也就不会有这个环境即使遇到了也就直接关闭httpdns了后来只能自己去用cfnetwork一点点实现-具体代码就不跟大家粘贴了因为涉及到一些公司内部的代码不过我会把我主要的参考资料发给大家-这里有个小技巧因为都在说cfnetwork是比较底层的网络实现好多东西需要开发者自行处理比如一些变量的释放之类的所以我们能少用尽量少用因为cfnetwork是为snihttps环境服务所以我们在拦截判断的时候可以区分是用上层的网络请求转发还是用底层的cfnetwork来转发\"><a class=\"anchor\" href=\"#三行文字加三个链接就完事了-其实在遇到这个坑的时候我也查过很多相关资料无非就是这三行话加这三个链接复制来复制去没有实质性的进展大部分公司或者是项目没有这么重的httpdns需求所以也就不会有这个环境即使遇到了也就直接关闭httpdns了后来只能自己去用cfnetwork一点点实现-具体代码就不跟大家粘贴了因为涉及到一些公司内部的代码不过我会把我主要的参考资料发给大家-这里有个小技巧因为都在说cfnetwork是比较底层的网络实现好多东西需要开发者自行处理比如一些变量的释放之类的所以我们能少用尽量少用因为cfnetwork是为snihttps环境服务所以我们在拦截判断的时候可以区分是用上层的网络请求转发还是用底层的cfnetwork来转发\">#</a> 三行文字加三个链接就完事了。其实在遇到这个坑的时候我也查过很多相关资料，无非就是这三行话加这三个链接复制来复制去，没有实质性的进展，大部分公司或者是项目没有这么重的 Httpdns 需求，所以也就不会有这个环境，即使遇到了也就直接关闭 httpdns 了，后来只能自己去用 CFNetwork 一点点实现。具体代码就不跟大家粘贴了因为涉及到一些公司内部的代码，不过我会把我 **<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0RhdmUxOTkxL2FsaWNsb3VkLWlvcy1kZW1vL2Jsb2IvbWFzdGVyL2h0dHBkbnNfaW9zX2RlbW8vaHR0cGRuc19pb3NfZGVtby9DRkh0dHBNZXNzYWdlVVJMUHJvdG9jb2wubQ==\"> 主要的参考资料</span> ** 发给大家。这里有个小技巧，因为都在说 CFNetwork 是比较底层的网络实现，好多东西需要开发者自行处理比如一些变量的释放之类的，所以我们能少用尽量少用，因为 Cfnetwork 是为 SNI (https) 环境服务，所以我们在拦截判断的时候可以区分是用上层的网络请求转发还是用底层的 cfnetwork 来转发，</h6>\n<p><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span>.request.<span class=\"type\">URL</span>.scheme isEqualToString:@<span class=\"string\">&quot;https&quot;</span>] ) &#123;</span><br><span class=\"line\"><span class=\"comment\">//使用CFnetwork</span></span><br><span class=\"line\">        curRequest <span class=\"operator\">=</span> req;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.task <span class=\"operator\">=</span> [[<span class=\"type\">CustomCFNetworkRequestTask</span> alloc] initWithURLRequest:originalRequest swizzleRequest:curRequest delegate:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.task) &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span>.task startLoading];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//使用普通网络请求</span></span><br><span class=\"line\">        <span class=\"type\">NSURLSessionConfiguration</span> <span class=\"operator\">*</span>configuration <span class=\"operator\">=</span> [<span class=\"type\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.session <span class=\"operator\">=</span> [<span class=\"type\">NSURLSession</span> sessionWithConfiguration:configuration delegate:<span class=\"keyword\">self</span> delegateQueue:[<span class=\"type\">NSOperationQueue</span> mainQueue]];</span><br><span class=\"line\">        <span class=\"type\">NSURLSessionTask</span> <span class=\"operator\">*</span>task <span class=\"operator\">=</span> [<span class=\"keyword\">self</span>.session dataTaskWithRequest:req];</span><br><span class=\"line\">        [task resume];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"我是这么做的\"><a class=\"anchor\" href=\"#我是这么做的\">#</a> 我是这么做的。</h6>\n<h6 id=\"67在nsurlprotocol中的那几个类方法中是可以发送同步请求的但是在实例方法发送同步请求就会卡死所以实例方法中不能有任何的阻塞进行同步操作-不然就卡死\"><a class=\"anchor\" href=\"#67在nsurlprotocol中的那几个类方法中是可以发送同步请求的但是在实例方法发送同步请求就会卡死所以实例方法中不能有任何的阻塞进行同步操作-不然就卡死\">#</a> 6.7：在 NSURLProtocol 中的那几个类方法中是可以发送同步请求的，但是在实例方法发送同步请求就会卡死，所以实例方法中不能有任何的阻塞，进行同步操作。不然就卡死。</h6>\n<h5 id=\"7总结\"><a class=\"anchor\" href=\"#7总结\">#</a> 7：总结</h5>\n<p>完成了以上的步骤之后你回发现在 DNS 坏掉的情况下手机里面除了微信 QQ (他们也做了 DNS 解析) 之外其他应用都不能上网了但是你的 App 依然可以正常浏览网络数据。这就是我最近在做的时候遇到的一些问题，有什么问题及时与我交流吧</p>\n",
            "tags": [
                "网络",
                "底层",
                "httpdns"
            ]
        }
    ]
}