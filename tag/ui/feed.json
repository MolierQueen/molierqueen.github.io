{
    "version": "https://jsonfeed.org/version/1",
    "title": "Molier • All posts by \"ui\" tag",
    "description": "iOS 开发 移动App 博客 杂谈 随笔 相册",
    "home_page_url": "https://oliverqueen.cn",
    "items": [
        {
            "id": "https://oliverqueen.cn/2018-02-08-%E5%85%B3%E4%BA%8EiPhone-X%E4%B8%8BHome%E9%94%AE%E7%9A%84%E9%9A%90%E8%97%8F%E5%92%8C%E5%BB%B6%E8%BF%9F%E5%93%8D%E5%BA%94/",
            "url": "https://oliverqueen.cn/2018-02-08-%E5%85%B3%E4%BA%8EiPhone-X%E4%B8%8BHome%E9%94%AE%E7%9A%84%E9%9A%90%E8%97%8F%E5%92%8C%E5%BB%B6%E8%BF%9F%E5%93%8D%E5%BA%94/",
            "title": "关于iPhone X下Home键的隐藏和延迟响应",
            "date_published": "2018-02-08T02:15:57.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"ios-11通用相关\"><a class=\"anchor\" href=\"#ios-11通用相关\">#</a> iOS 11 通用相关</h1>\n<h2 id=\"edge-protect\"><a class=\"anchor\" href=\"#edge-protect\">#</a> Edge Protect</h2>\n<p>iPhone X 刚出来的时候苹果第一时间更新了新设备的交互文档，其中针对了大家最关心的 “系统手势和 App 自带手势冲突” 的问题也给出了相应的解决办法:</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo8u9uqjehj31kw0t7h2q.jpg\" alt=\"\" /></p>\n<p>虽然苹果用黑体字写着强烈不建议开发者干涉系统的手势，但是为了增强用户体验还是开出了接口，苹果管这个叫做 &quot;edge protect&quot; 因为进入 App 后系统手势都是从边缘触发，引起冲突的地方也会是在边缘中。</p>\n<p><span id=\"more\"></span></p>\n<p>根据官方文档描述，在冲突区域第一次执行手势的时候会优先触发 App 的内部手势，当短时间内再次进行同样的操作则会触发系统手势。也就是将系统手势延迟到下一次执行。</p>\n<h2 id=\"api-discussion\"><a class=\"anchor\" href=\"#api-discussion\">#</a> API Discussion</h2>\n<p>根据官方文档找到对应的 API</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Override to return a child view controller or nil. If non-nil, that view controller&#x27;s screen edges deferring system gestures will be used. If nil, self is used. Whenever the return value changes, -setNeedsScreenEdgesDeferringSystemGesturesUpdate should be called.</span></span><br><span class=\"line\">- (nullable UIViewController *)childViewControllerForScreenEdgesDeferringSystemGestures <span class=\"constructor\">API_AVAILABLE(<span class=\"params\">ios</span>(11.0)</span>) <span class=\"constructor\">API_UNAVAILABLE(<span class=\"params\">watchos</span>, <span class=\"params\">tvos</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Controls the application&#x27;s preferred screen edges deferring system gestures when this view controller is shown. Default is UIRectEdgeNone.</span></span><br><span class=\"line\">- (UIRectEdge)preferredScreenEdgesDeferringSystemGestures <span class=\"constructor\">API_AVAILABLE(<span class=\"params\">ios</span>(11.0)</span>) <span class=\"constructor\">API_UNAVAILABLE(<span class=\"params\">watchos</span>, <span class=\"params\">tvos</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This should be called whenever the return values for the view controller&#x27;s screen edges deferring system gestures have changed.</span></span><br><span class=\"line\">- (void)setNeedsUpdateOfScreenEdgesDeferringSystemGestures <span class=\"constructor\">API_AVAILABLE(<span class=\"params\">ios</span>(11.0)</span>) <span class=\"constructor\">API_UNAVAILABLE(<span class=\"params\">watchos</span>, <span class=\"params\">tvos</span>)</span>;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"childviewcontrollerforscreenedgesdeferringsystemgestures\"><a class=\"anchor\" href=\"#childviewcontrollerforscreenedgesdeferringsystemgestures\">#</a> childViewControllerForScreenEdgesDeferringSystemGestures</h4>\n<p>该方法是用来控制子试图控制器是否允许开发者控制 edge protect 的开启或是关闭。如果实现了这个方法并且返回值不为空那么子 VC 的 edge protect 设置就会遵循父 VC 的设置，跟随父 VC 是否延迟执行系统手势。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo917ycqy6j319i0bqjtr.jpg\" alt=\"\" /></p>\n<h4 id=\"preferredscreenedgesdeferringsystemgestures\"><a class=\"anchor\" href=\"#preferredscreenedgesdeferringsystemgestures\">#</a> preferredScreenEdgesDeferringSystemGestures</h4>\n<p>该方法是设置 edge protect 的方法，返回值是一个边界的枚举</p>\n<p><figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_OPTIONS</span>(<span class=\"type\">NSUInteger</span>, <span class=\"type\">UIRectEdge</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeNone</span>   = 0,</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeTop</span>    = 1 &lt;&lt; 0,</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeLeft</span>   = 1 &lt;&lt; 1,</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeBottom</span> = 1 &lt;&lt; 2,</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeRight</span>  = 1 &lt;&lt; 3,</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeAll</span>    = <span class=\"type\">UIRectEdgeTop</span> | <span class=\"type\">UIRectEdgeLeft</span> | <span class=\"type\">UIRectEdgeBottom</span> | <span class=\"type\">UIRectEdgeRight</span></span><br><span class=\"line\">&#125; <span class=\"type\">NS_ENUM_AVAILABLE_IOS</span>(7_0);</span><br></pre></td></tr></table></figure></p>\n<p>因为不论我们从 shang、左、下、右边都可触发系统手势，所以方法保护了四个边框，将边界触发的手势延迟执行，这个方法从 iOS11 开始使用，不过枚举中虽然有左右的边界保护，但是系统手势中还不清楚左右滑动会触发什么效果，实验发现对于 VC 的左边界右滑动 pop 手势是无效的，也就是说这个 pop 手势一直有着最高的优先级。不过上下就很好理解，底部上拉出控制中心，顶部下拉是通知中心。</p>\n<ul>\n<li>\n<p>无限制</p>\n<p>当不做任何限制时候在顶部和底部很容易触发到系统的手势，他们会优先于 Tab.eView 的 scroll 手势执行，虽说屏幕大部分的界面还是执行 TableView 手势的，但是当用户误触到边界的时候还是会稍稍影响体验，尤其是在全屏模式下、相机、视频、游戏等</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo909u85fpg308k0goe8d.gif\" alt=\"\" /></p>\n</li>\n<li>\n<p>Edge Protent</p>\n<p>在对应的 ViewControll 中添加如下代码，我们这边开启的是所有边界限制其中包括了上、下边界。在下拉或者上拉的话会先触发 App 内部手势，同时出现一个小箭头然后在箭头消失之前再次滑动就会触发系统手势。<br />\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"built_in\">UIRectEdge</span>)preferredScreenEdgesDeferringSystemGestures</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">UIRectEdgeAll</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo90rfo0dig308k0go7wu.gif\" alt=\"\" /></p>\n</li>\n</ul>\n<h4 id=\"setneedsupdateofscreenedgesdeferringsystemgestures\"><a class=\"anchor\" href=\"#setneedsupdateofscreenedgesdeferringsystemgestures\">#</a> setNeedsUpdateOfScreenEdgesDeferringSystemGestures</h4>\n<p>这个方法是在应用内部动态控制 edge protect，我们可以在上个方法中返回一个 BOOL 变量，然后根据需要改变该变量的值，然后调用该方法进行刷新。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo912yvhsag308k0goe8h.gif\" alt=\"\" /></p>\n<h1 id=\"iphone-x使用相关\"><a class=\"anchor\" href=\"#iphone-x使用相关\">#</a> iPhone X 使用相关</h1>\n<p>iPhone X 在系统手势上面交互和其他设备还是有一定区别的，因为加入了 Home Indicator 的原因，引入了新的手势，同时对以往的手势也做了相应的调整。</p>\n<h2 id=\"iphone-x-edge-protect\"><a class=\"anchor\" href=\"#iphone-x-edge-protect\">#</a> iPhone X Edge Protect</h2>\n<p>在 iPhone X 中通知中心和控制中心全部都移动到了由顶部刘海处下拉和右上角下拉来触发。原本底部的所有手势都被 Home Indicator 占用。其实 Edge Protect 在这里依然适用，只是对于 Home Indicator 的手势有一个小插曲。正常来说他在底部，就应该受到 UIRectEdgeBottom 或者是 UIRectEdgeAll 控制，但是一开始苹果并没有这么做，不论怎么写代码，他都有着最高的优先级，在 iPhone X 刚发布我就试图去处理交互问题，因为海报工厂并没有传统的 UITabBarController，且里面所有的 tableView 都是直通到底，但是始终都无法延迟执行与 Home Indicator 相关的任何手势。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo920zedwnj308w0j9gxa.jpg\" alt=\"\" /></p>\n<p>后来看了其他游戏，视频类 App 在 iPhone X 上的表现也都是如此。腾讯的王者荣耀，网易的吃鸡都是一样。腾讯官方给出的解释是暂时开起引导式访问，也仍然不方便。后来在今年 1 月 25 日苹果推送了 iOS 11.2.5 的版本更新，然后王者荣耀也跟着进行了一波更新，在进入游戏时候就会发现，底部的 Home Indicator 当你一段时间不去触碰它的时候由黑色或者白色 (根据当前的屏幕显示的内容来决定) 变成非常透明的灰色，当你第一次进行操作会默认执行 App 内手势，同时激活 Home Indicator，短时间内进行第二次操作就可以返回桌面</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo935pn8dsg30go07s1l2.gif\" alt=\"\" /></p>\n<p>一开以为是有新的 API 出现，不过看了交互文档并没有新的东西，而且小版本的系统更新应该也不会出现新的东西。所以找到了之前的 edge protect 代码运行后确实可以达到效果。对于视频，游戏等 App，确实可以起到很好的防误触的效果。遗憾的是并没有太多的人使用这个功能。目前主流的大型游戏，包括 Gameloft 出品的游戏都没做相应的处理。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo943bx7sog308h0gox6z.gif\" alt=\"\" /></p>\n<h2 id=\"iphone-x-home-indicator-hidden\"><a class=\"anchor\" href=\"#iphone-x-home-indicator-hidden\">#</a> iPhone X Home Indicator Hidden</h2>\n<p>如果说上面的 Edge Protect 适合在游戏中使用，那么 Home Indicator Hidden 则更适合在非游戏环境下增强 App 的沉浸感，尤其是全屏视屏播放、录制的时候。同样三个 API，和 Edge protect 的用法完全一样。</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Override to return a child view controller or nil. If non-nil, that view controller&#x27;s home indicator auto-hiding will be used. If nil, self is used. Whenever the return value changes, -setNeedsHomeIndicatorAutoHiddenUpdate should be called.</span></span><br><span class=\"line\">- (nullable UIViewController *)childViewControllerForHomeIndicatorAutoHidden <span class=\"constructor\">API_AVAILABLE(<span class=\"params\">ios</span>(11.0)</span>) <span class=\"constructor\">API_UNAVAILABLE(<span class=\"params\">watchos</span>, <span class=\"params\">tvos</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Controls the application&#x27;s preferred home indicator auto-hiding when this view controller is shown.</span></span><br><span class=\"line\">- (BOOL)prefersHomeIndicatorAutoHidden <span class=\"constructor\">API_AVAILABLE(<span class=\"params\">ios</span>(11.0)</span>) <span class=\"constructor\">API_UNAVAILABLE(<span class=\"params\">watchos</span>, <span class=\"params\">tvos</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This should be called whenever the return values for the view controller&#x27;s home indicator auto-hiding have changed.</span></span><br><span class=\"line\">- (void)setNeedsUpdateOfHomeIndicatorAutoHidden <span class=\"constructor\">API_AVAILABLE(<span class=\"params\">ios</span>(11.0)</span>) <span class=\"constructor\">API_UNAVAILABLE(<span class=\"params\">watchos</span>, <span class=\"params\">tvos</span>)</span>;</span><br></pre></td></tr></table></figure><br />\n 上面写的是自动隐藏，也就是说系统会根据当时的使用情况来进行显示或者隐藏，而不是永久的隐藏掉，实际测试发当界面两秒内没有进行任何交互操作的时候 Home Indicator 会逐渐隐去，直达屏幕上出现了点击的操作，注意是点击，TableView 的滑动并不能触发显示，不过只是是隐藏，但是手势依然可以使用。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo94hujx35g308h0go4qy.gif\" alt=\"\" /></p>\n<p>如果是 feed 流界面搭配酷一点的 UI 就会提高沉浸感，比如这样：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo94p0bmoqg308h0gox6t.gif\" alt=\"\" /></p>\n<p>有的人可能会问如果说点击的手势会触发它再次显示那我获取 window 上的交互每次在它即将显示的时候通过<strong> setNeedsUpdateOfHomeIndicatorAutoHidden</strong> 在让他隐藏不就好了吗？这样一来既不影响系统手势也不会让它在显示出来，其实我自己试过不行的，毕竟苹果不会让你这样改。</p>\n<h2 id=\"坑点\"><a class=\"anchor\" href=\"#坑点\">#</a> 坑点</h2>\n<p>需要注意的是：prefersHomeIndicatorAutoHidden 和 preferredScreenEdgesDeferringSystemGestures 不可一起使用，如果一起使用的话后者是不生效的。</p>\n",
            "tags": [
                "UI",
                "屏幕适配",
                "iOS 11"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-24-%E8%87%AA%E5%AE%9A%E4%B9%89AlertView/",
            "url": "https://oliverqueen.cn/2018-01-24-%E8%87%AA%E5%AE%9A%E4%B9%89AlertView/",
            "title": "自定义AlertView",
            "date_published": "2018-01-24T04:37:20.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"customalertview\"><a class=\"anchor\" href=\"#customalertview\">#</a> CustomAlertView</h1>\n<p>一个自定义的 AlertView，用户可以根据自己的需求来设置。</p>\n<h2 id=\"使用方法\"><a class=\"anchor\" href=\"#使用方法\">#</a> 使用方法</h2>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k50sh34j30hy084abf.jpg\" alt=\"初始化方法\" /></p>\n<p>类似于系统的初始化方法，如果没有值的话就传 nil 就好，不要传空字符串。最后一个参数传 title 数组就好了。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k5axspej30r702rmy0.jpg\" alt=\"使用\" /></p>\n<p>然后调用 showInViewWithAction 方法显示出来<br />\n<span id=\"more\"></span></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k5idk8ij30mp041aai.jpg\" alt=\"显示\" /></p>\n<p>最后一个参数是 button 的点击事件，根据 tag 值来区分不同的 button 点击，只有取消 button 的 tag 是 0，其他的是 1.2.3... 依次往下排列就好</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k5q4o6nj30kr0ox78u.jpg\" alt=\"可自定义的一些属性\" /></p>\n<p>这些属性可以自定义，这里就不细说了，大家可以使试试。</p>\n<h2 id=\"样式截图\"><a class=\"anchor\" href=\"#样式截图\">#</a> 样式截图</h2>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k5zfyi2j30dc0notac.jpg\" alt=\"样式截图\" /></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6k66fmogg308o0figvd.gif\" alt=\"使用截图\" /></p>\n<p>大概就这么多，很简单的有问题随时联系我吧。</p>\n",
            "tags": [
                "UI",
                "AlertView"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-23-iOS%E4%B8%AD%E4%BD%BF%E7%94%A8OpenGL%E5%AE%9E%E7%8E%B0%E5%A2%9E%E9%AB%98%E5%8A%9F%E8%83%BD/",
            "url": "https://oliverqueen.cn/2018-01-23-iOS%E4%B8%AD%E4%BD%BF%E7%94%A8OpenGL%E5%AE%9E%E7%8E%B0%E5%A2%9E%E9%AB%98%E5%8A%9F%E8%83%BD/",
            "title": "iOS中使用OpenGL实现增高功能",
            "date_published": "2018-01-23T13:23:49.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"功能效果\"><a class=\"anchor\" href=\"#功能效果\">#</a> 功能效果</h3>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6lpd4q64g308u0fqnpe.gif\" alt=\"demo示例\" /><br />\n<span id=\"more\"></span></p>\n<h3 id=\"功能分析\"><a class=\"anchor\" href=\"#功能分析\">#</a> 功能分析</h3>\n<ul>\n<li>\n<p>功能：渲染一张传入的图片 -&gt; 手动选择编辑区域 -&gt; 通过滑块来编辑区域的增高或者缩短</p>\n</li>\n<li>\n<p>OpenGL 原理：</p>\n<ul>\n<li>\n<p>因为 OpenGL 只能绘制三角形，所以在处理图像或者图形的时候我们需要将被处理的对象用三角行来分割转换为三角形和顶点的组成的对象。</p>\n</li>\n<li>\n<p>OpenGL 里面坐标是以左下角为原点 X 轴向上为正，Y 轴向右为正</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"功能实现\"><a class=\"anchor\" href=\"#功能实现\">#</a> 功能实现</h3>\n<ul>\n<li>渲染图片拆分图片：\n<ul>\n<li>拆分方法 1：通过图形看出是一个矩形，而矩形是可以分成两个三角形和四个顶点，通过此可以用 GL 渲染出图片。</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6lpjw6g3j30dw0ee7ft.jpg\" alt=\"拆分三角形\" /></p>\n<p>这样拆分之后虽然可以正常渲染，但是带来的问题是我的四个顶点都是死的，也就是四个顶点必须是画布的四个顶点，改变顶点的坐标后只能导致整张画布的变动，而不是某一个区域的变动，拉伸的话也是整张图片的拉伸，所以想要实现局部处理的话这种分割方式不可行。</p>\n<ul>\n<li>拆分方法 2：将整张图片先拆分为三个矩形，然后再把每个矩形拆分成两个三角形，得到 6 个三角形，8 个顶点，如下图：</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6lprpvrrj30dw0eddrh.jpg\" alt=\"拆分2\" /></p>\n<p>这样一来就可以保证中间的矩形的高度可以任意变化而上下两部分的高度不变只改变位置，也就是说我们这个 DEMO 中所做的任何拉伸操作都是对中间矩形的操作，换而言之就是改变最上面的矩形和最下面的矩形之间的距离来达到对中间区域的拉伸和压缩的目的。根据拆分的方式我们用顶点的坐标创建一个数组<br />\n <figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">//</span>顶点数组</span><br><span class=\"line\">GLfloat vertices[] = &#123;   </span><br><span class=\"line\">    -1.2, -1.2,     <span class=\"string\">//</span>左下</span><br><span class=\"line\">    1.2, -1.2,      <span class=\"string\">//</span>右下</span><br><span class=\"line\">    -1.2, -0.4,     <span class=\"string\">//</span>小矩形左下</span><br><span class=\"line\">    1.2, -0.4,      <span class=\"string\">//</span>小矩形右下</span><br><span class=\"line\">    -1.2,  0.4,     <span class=\"string\">//</span>小矩形左上</span><br><span class=\"line\">    1.2,  0.4,      <span class=\"string\">//</span>小矩形右上</span><br><span class=\"line\">    -1.2,  1.2,     <span class=\"string\">//</span>左上</span><br><span class=\"line\">    1.2,  1.2,      <span class=\"string\">//</span>右上</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"string\">//</span>填充纹理的数组</span><br><span class=\"line\">GLfloat texCoords[] = &#123;     </span><br><span class=\"line\">    0, 0,        <span class=\"string\">//</span>左下                  <span class=\"string\">//</span>下标为 0 1</span><br><span class=\"line\">    1, 0,        <span class=\"string\">//</span>右下                  <span class=\"string\">//</span>下标为2 3</span><br><span class=\"line\">    0, 1.0/3.0,  <span class=\"string\">//</span>小矩形左下             <span class=\"string\">//</span>下标为4 5</span><br><span class=\"line\">    1, 1.0/3.0,  <span class=\"string\">//</span>小矩形右下             <span class=\"string\">//</span>下标为6 7</span><br><span class=\"line\">    0, 2.0/3.0,  <span class=\"string\">//</span>小矩形左上角           <span class=\"string\">//</span>下标为8 9</span><br><span class=\"line\">    1, 2.0/3.0,  <span class=\"string\">//</span>小矩形右上角           <span class=\"string\">//</span>下标为10 11</span><br><span class=\"line\">    0, 1,        <span class=\"string\">//</span>左上                  <span class=\"string\">//</span>下标为12 13</span><br><span class=\"line\">    1, 1,        <span class=\"string\">//</span>右上                  <span class=\"string\">//</span>下标为14 15</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>手动选择区域：通过添加带有自定义手势的 UIView 来实现拖动修改选择区域。</li>\n</ul>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*****************CustomPanView代码******************</span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">CustomPanViewDelegate</span> &lt;<span class=\"title\">NSObject</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  开始拖拽</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param customPanView 自身</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param centerY       自身所在的y坐标</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)beginDragWithCoustomPanView:(<span class=\"built_in\">UIView</span> *)customPanView centerY:(<span class=\"built_in\">CGFloat</span>)centerY;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CustomPanView</span> : <span class=\"title\">UIView</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"type\">id</span>&lt;CustomPanViewDelegate&gt; delegate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*****************CustomPanViewDelegate代码******************</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark -</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark 拖拽View的代理方法</span></span><br><span class=\"line\">-(<span class=\"type\">void</span>)beginDragWithCoustomPanView:(<span class=\"built_in\">UIView</span> *)customPanView centerY:(<span class=\"built_in\">CGFloat</span>)centerY &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 限制范围：裁剪区不能大于图片区域</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (customPanView.center.y &gt;= imageBottom) &#123;</span><br><span class=\"line\">        customPanView.center = <span class=\"built_in\">CGPointMake</span>(customPanView.center.x, imageBottom);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (customPanView.center.y &lt;= imageTop) &#123;</span><br><span class=\"line\">        customPanView.center = <span class=\"built_in\">CGPointMake</span>(customPanView.center.x, imageTop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    获取两条线的坐标</span></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> topY = _topView.center.y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> bottomY = _bottomView.center.y;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    根据两条线的坐标刷新裁剪区域UI</span></span><br><span class=\"line\">    [_cutLabel setFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, topY &lt; bottomY ? topY : bottomY, SCREEN_WIDTH, fabs(bottomY - topY))];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    算出裁剪起始坐标和结束坐标</span></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> fromPoint = topY &lt; bottomY ? (imageBottom - bottomY) / imageHeight : (imageBottom - topY) / imageHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> toPoint = topY &lt; bottomY ? (imageBottom - topY) / imageHeight : (imageBottom - bottomY) / imageHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//将中间的矩形的顶点坐标和坐标联系裁剪区域联系起来。</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> sendFromePoint:fromPoint endPoint:toPoint];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_cutLabel.frame.size.height &lt; <span class=\"number\">30</span>) &#123;  <span class=\"comment\">//隐藏文字</span></span><br><span class=\"line\">        _cutLabel.text = <span class=\"string\">@&quot;&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        _cutLabel.text = <span class=\"string\">@&quot;编辑区域&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.slider setValue:<span class=\"number\">0.0</span> animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    tmpHeight = <span class=\"number\">0.0</span>f;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 使用一个 Delegate 将拖移后的 Y 坐标返回，因为是竖直运动的所以我们只关心 Y 轴坐标。</p>\n<ul>\n<li>改变大小：通过将 UISliderBar 的 ValueChange 和顶点坐标关联来实现改变顶点坐标，之后调用 GLKView 的 display 的方法来刷新 UI，将变化的过程展现出来。</li>\n</ul>\n<p><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)action:(UISlider *)sender &#123;</span><br><span class=\"line\">    <span class=\"regexp\">//</span>判断是否是向右滑动</span><br><span class=\"line\">    isRightDirection = sender.value &gt;= judgeDirection ? YES : NO;</span><br><span class=\"line\">    <span class=\"regexp\">//</span>所改变的高度</span><br><span class=\"line\">    changeHeight = sender.value - tmpHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"regexp\">//</span>遍历数组</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (int i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">16</span>; i ++) &#123;</span><br><span class=\"line\">        <span class=\"regexp\">//</span>将Y坐标筛选出来</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i % <span class=\"number\">2</span> != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"regexp\">//</span>下半部分矩形</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt;= <span class=\"number\">7</span>) &#123;</span><br><span class=\"line\">                <span class=\"regexp\">//</span>下半部分矩形Y轴做减法减去变化的高度</span><br><span class=\"line\">                vertices[i] = verticesCopy[i] - changeHeight;</span><br><span class=\"line\">                <span class=\"regexp\">//</span>上半部分矩形</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">9</span>) &#123;</span><br><span class=\"line\">                <span class=\"regexp\">//</span>上半部分矩形Y轴做加法加上变化的高度</span><br><span class=\"line\">                vertices[i] = verticesCopy[i] + changeHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"regexp\">//</span>缩小时候如果编辑区域已经成为一条线了就不能在缩小了</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vertices[<span class=\"number\">11</span>] &gt; vertices[<span class=\"number\">7</span>]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        [self.glView display];</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>通过 glReadPixels 来从内存中读取像素数据，GLubyte -&gt; CGImageRef -&gt; UIimage 然后最相关的保存或者其他操作。</li>\n</ul>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#pragma mark -</span><br><span class=\"line\">#pragma mark 获取处理后的图片</span><br><span class=\"line\">- (UIImage *) createImage &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> imageY = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> imgHeight = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isRightDirection) &#123; <span class=\"comment\">// 判断slider滑动方向</span></span><br><span class=\"line\"></span><br><span class=\"line\">        imageY = fabs(imageTop - fabs(changeHeight<span class=\"operator\"> * </span>perOpengleseCoordinate))<span class=\"operator\"> * </span>screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">        imgHeight = fabs(imageHeight + <span class=\"number\">2</span><span class=\"operator\"> * </span>fabs(changeHeight<span class=\"operator\"> * </span>perOpengleseCoordinate))<span class=\"operator\"> * </span>screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        imageY = fabs(imageTop + fabs(changeHeight<span class=\"operator\"> * </span>perOpengleseCoordinate))<span class=\"operator\"> * </span>screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">        imgHeight = fabs(imageHeight - <span class=\"number\">2</span><span class=\"operator\"> * </span>fabs(changeHeight<span class=\"operator\"> * </span>perOpengleseCoordinate))<span class=\"operator\"> * </span>screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> imageWidth = SCREEN_WIDTH<span class=\"operator\"> * </span>screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> dataLength = imageWidth<span class=\"operator\"> * </span>imgHeight<span class=\"operator\"> * </span><span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    GLubyte *data = (GLubyte*)malloc(dataLength<span class=\"operator\"> * </span>sizeof(GLubyte));</span><br><span class=\"line\"></span><br><span class=\"line\">    gl<span class=\"constructor\">PixelStorei(GL_PACK_ALIGNMENT, 4)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    gl<span class=\"constructor\">ReadPixels(0, <span class=\"params\">imageY</span>, <span class=\"params\">imageWidth</span>, <span class=\"params\">imgHeight</span>, GL_RGBA, GL_UNSIGNED_BYTE, <span class=\"params\">data</span>)</span>;  <span class=\"comment\">//从内存中读取像素</span></span><br><span class=\"line\">    CGDataProviderRef <span class=\"built_in\">ref</span> = <span class=\"constructor\">CGDataProviderCreateWithData(NULL, <span class=\"params\">data</span>, <span class=\"params\">dataLength</span>, NULL)</span>;</span><br><span class=\"line\">    CGColorSpaceRef colorspace = <span class=\"constructor\">CGColorSpaceCreateDeviceRGB()</span>;</span><br><span class=\"line\">    CGImageRef iref = <span class=\"constructor\">CGImageCreate(<span class=\"params\">imageWidth</span>, <span class=\"params\">imgHeight</span>, 8, 32, <span class=\"params\">imageWidth</span> <span class=\"operator\">*</span> 4, <span class=\"params\">colorspace</span>, <span class=\"params\">kCGBitmapByteOrder32Big</span> | <span class=\"params\">kCGImageAlphaPremultipliedLast</span>,<span class=\"params\">ref</span>, NULL, <span class=\"params\">true</span>, <span class=\"params\">kCGRenderingIntentDefault</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"constructor\">UIGraphicsBeginImageContext(CGSizeMake(<span class=\"params\">imageWidth</span>, <span class=\"params\">imgHeight</span>)</span>);</span><br><span class=\"line\">    CGContextRef cgcontext = <span class=\"constructor\">UIGraphicsGetCurrentContext()</span>;</span><br><span class=\"line\">    <span class=\"constructor\">CGContextSetBlendMode(<span class=\"params\">cgcontext</span>, <span class=\"params\">kCGBlendModeCopy</span>)</span>;</span><br><span class=\"line\">    <span class=\"constructor\">CGContextDrawImage(<span class=\"params\">cgcontext</span>, CGRectMake(0, 0, <span class=\"params\">imageWidth</span>, <span class=\"params\">imgHeight</span>)</span>, iref);</span><br><span class=\"line\"></span><br><span class=\"line\">    CGImageRef imageMasked = <span class=\"constructor\">CGBitmapContextCreateImage(<span class=\"params\">cgcontext</span>)</span>;</span><br><span class=\"line\">    UIImage<span class=\"operator\"> * </span>image = <span class=\"literal\">[UII<span class=\"identifier\">mage</span> <span class=\"identifier\">imageWithCGImage</span>:<span class=\"identifier\">imageMasked</span> <span class=\"identifier\">scale</span>:<span class=\"identifier\">screenScale</span> <span class=\"identifier\">orientation</span>:UII<span class=\"identifier\">mageOrientationUp</span>]</span>;</span><br><span class=\"line\">    <span class=\"constructor\">UIGraphicsEndImageContext()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    free(data);</span><br><span class=\"line\">    <span class=\"constructor\">CFRelease(<span class=\"params\">ref</span>)</span>;</span><br><span class=\"line\">    <span class=\"constructor\">CFRelease(<span class=\"params\">colorspace</span>)</span>;</span><br><span class=\"line\">    <span class=\"constructor\">CGImageRelease(<span class=\"params\">iref</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    return image;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n",
            "tags": [
                "底层",
                "OpenGL",
                "UI"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-23-%E5%85%B3%E4%BA%8E%E7%89%A9%E7%90%86%E6%95%88%E6%9E%9C%E7%9A%84%E5%8A%A8%E7%94%BB%E5%BC%95%E6%93%8EUIDynamic%E4%BB%8B%E7%BB%8D/",
            "url": "https://oliverqueen.cn/2018-01-23-%E5%85%B3%E4%BA%8E%E7%89%A9%E7%90%86%E6%95%88%E6%9E%9C%E7%9A%84%E5%8A%A8%E7%94%BB%E5%BC%95%E6%93%8EUIDynamic%E4%BB%8B%E7%BB%8D/",
            "title": "关于物理效果的动画引擎UIDynamic介绍",
            "date_published": "2018-01-23T13:18:42.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>这几天事情超多，实在很难静下心来研究一个东西，但是这个类我也是关注好久了，早就想总结下写出来， 可能这篇文章并不会像之前额那样那么详细，按理说写动画相关的东西应该是配 gif 的，但是真的是没有心思再去搞那些东西，代码并不难，大家可以照着代码写一下看下效果。<br />\n        为了实现动力 UI，需要注册一套 UI 行为的体系，之后 UI 便会按照预先的设定进行运动了。我们应该了解的新的基本概念有如下四个：<br />\nUIDynamicItem：用来描述一个力学物体的状态，其实就是实现了 UIDynamicItem 委托的对象，或者抽象为有面积有旋转的质点； 简单的说就是一个控件，就是你想往谁上面加动画，这个就是谁。<br />\nUIDynamicBehavior：动力行为的描述，用来指定 UIDynamicItem 应该如何运动，即定义适用的物理规则。一般我们使用这个类的子类对象来对一组 UIDynamicItem 应该遵守的行为规则进行描述；简单的说就是动画效果，这个类是动画效果的一个父类，它的子类大家可以用运行时的方法输出一下看一下，或者一会看我介绍，一个子类是一个效果，各种效果比如重力啊碰撞啊，链接啊之类的。<br />\nUIDynamicAnimator；动画的播放者，动力行为（UIDynamicBehavior）的容器，添加到容器内的行为将发挥作用；<br />\nReferenceView：等同于力学参考系，如果你的初中物理不是语文老师教的话，我想你知道这是啥.. 只有当想要添加力学的 UIView 是 ReferenceView 的子 view 时，动力 UI 才发生作用。下面看下我们给一个 button 加一个重力下坠的动画 使用 self.View 做参考系来建立动画<br />\n<span id=\"more\"></span><br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6m073lu9j30ft02n74g.jpg\" alt=\"\" /></p>\n<p>然后</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6m0h0bvej307900s0si.jpg\" alt=\"\" /></p>\n<p>你可以吧这里航代码写到 button 的点击事件中，这样你一点就会下坠。很简单吧。<br />\n        再看下一个碰撞</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6m1auc65j30mx02ht92.jpg\" alt=\"\" /></p>\n<p>我这里写碰撞动画的时候用了两个 button，其实大家可以猜到我是让两个 button 来碰撞的，碰撞的过程中也是会走代理方法的，开始碰撞啊，碰撞结束啊之类的。最后那句话的意思是吧他的参考系 (这里是的 self.view) 的边界作为碰撞边界，就是说这段代码运行后这两个 这两控件撞到屏幕 self.view 的边框会发生物理的碰撞反弹效果。想这样 (点我开始那个按钮)</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6m1l2ecwg308r0fl75h.gif\" alt=\"\" /></p>\n<p>除了重力和碰撞，iOS SDK 还预先帮我们实现了一些其他的有用的物理行为，它们包括<br />\n UIAttachmentBehavior 描述一个 view 和一个锚相连接的情况，也可以描述 view 和 view 之间的连接。attachment 描述的是两个点之间的连接情况，可以通过设置来模拟无形变或者弹性形变的情况（再次希望你还记得这些概念，简单说就是木棒连接和弹簧连接两个物体）。当然，在多个物体间设定多个；UIAttachmentBehavior，就可以模拟多物体连接了.. 有了这些，似乎可以做个老鹰捉小鸡的游戏了 - -…<br />\nUISnapBehavior 将 UIView 通过动画吸附到某个点上。初始化的时候设定一下 UISnapBehavior 的 initWithItem:snapToPoint: 就行，因为 API 非常简单，视觉效果也很棒，估计它是今后非游戏 app 里会被最常用的效果之一了；<br />\nUIPushBehavior 可以为一个 UIView 施加一个力的作用，这个力可以是持续的，也可以只是一个冲量。当然我们可以指定力的大小，方向和作用点等等信息。<br />\nUIDynamicItemBehavior 其实是一个辅助的行为，用来在 item 层级设定一些参数，比如 item 的摩擦，阻力，角阻力，弹性密度和可允许的旋转等等</p>\n<p>其实流程很简单创建 animator  然后创建 behivator   设置 behivator 属性 然后 animator addBehivator 。就是这个么流程。写代码要学会举一反三触类旁通。    这篇博客写的比较急，但是总体上来说功能没问题，细节上有什么问题，大家找我一起交流</p>\n",
            "tags": [
                "UI",
                "动画"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-23-%E5%85%B3%E4%BA%8E%E8%A7%86%E5%9B%BE%E5%9C%A8%E5%88%87%E5%9C%86%E8%A7%92%E6%97%B6%E5%80%99%E7%9A%84%E5%AF%BC%E8%87%B4%E7%9A%84%E6%80%A7%E8%83%BD%E4%B8%8B%E9%99%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A2%E8%AE%A8/",
            "url": "https://oliverqueen.cn/2018-01-23-%E5%85%B3%E4%BA%8E%E8%A7%86%E5%9B%BE%E5%9C%A8%E5%88%87%E5%9C%86%E8%A7%92%E6%97%B6%E5%80%99%E7%9A%84%E5%AF%BC%E8%87%B4%E7%9A%84%E6%80%A7%E8%83%BD%E4%B8%8B%E9%99%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A2%E8%AE%A8/",
            "title": "关于视图在切圆角时候的导致的性能下降的一些探讨",
            "date_published": "2018-01-23T13:08:48.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>iOS 中有的时候我们控件要做成圆形 或者是切成圆角，这个时候我们一般都会使用.layer.cornerRadius  -&gt;  clipsToBounds = YES 的属性来切，这样完全能达到我们的效果，但是如果一个界面上需要切圆角的控件很多，并且列表很长的时候，尤其是像 tableView 那样如果每一个 cell 上都有大量的控件需要切，那么就会非常卡顿，帧数严重下降 。其实原因就是这样设置会触发离屏渲染，比较消耗性能。注意：png 图片 UIImageView 处理圆角是不会产生离屏渲染的。（ios9.0 之后不会离屏渲染，ios9.0 之前还是会离屏渲染）。这里先说下离屏渲染：<br />\n ###### iOS 的渲染机制：<br />\n   CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。GPU 屏幕渲染有以下两种方式：<br />\nOn-Screen Rendering<br />\n 意为当前屏幕渲染，指的是 GPU 的渲染操作是在当前用于显示的屏幕缓冲区中进行。<br />\nOff-Screen Rendering<br />\n 意为离屏渲染，指的是 GPU 在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。<br />\n<span id=\"more\"></span><br />\n 由以上可以看出离屏渲染需要重新开辟新的缓存空间，必定要更加消耗资源。<br />\n通过查资料目前知道了设置了以下属性时，都会触发离屏绘制：<br />\nshouldRasterize（光栅化）<br />\nmasks（遮罩）<br />\nshadows（阴影）<br />\nedge antialiasing（抗锯齿）<br />\ngroup opacity（不透明）<br />\n复杂形状设置圆角等<br />\n渐变<br />\n我用一个现有的小 DEMO 来测试下，因为这个 demo 中没有切圆角，但是有阴影，一样可以出发离屏渲染，所以效果是一样的，在 tableView 中的自定义 cell 类中我设置了阴影如图：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6makjj7sj30f2025aac.jpg\" alt=\"\" /></p>\n<p>使用 Instruments 测试得到当前帧数在二三十左右</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6maqxgt6j30uf03874d.jpg\" alt=\"\" /></p>\n<p>同时屏幕是也出现了黄色图层</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mb1epsnj30dx0ou40r.jpg\" alt=\"\" /></p>\n<p>所有黄色的高亮的图层都进行了离屏渲染，也表示这些图层存在着问题，影响性能。而且帧数过低也会直接影响我们对 APP 的体验。</p>\n<h6 id=\"如何避免离屏渲染\"><a class=\"anchor\" href=\"#如何避免离屏渲染\">#</a> 如何避免离屏渲染：</h6>\n<ul>\n<li>\n<p>方法一：使用光栅化，.layer.shouldRasterize = YES;   -&gt;  .layer.rasterizationScale=[UIScreen mainScreen].scale; 设置光栅化，可以使离屏渲染的结果缓存到内存中存为位图，使用的时候直接使用缓存，节省了一直离屏渲染损耗的性能。但是如果 layer 及 sublayers 常常改变的话，它就会一直不停的渲染及删除缓存重新创建缓存，所以这种情况下建议不要使用光栅化，这样也是比较损耗性能的。</p>\n</li>\n<li>\n<p>方法二：最简单的方法，就是图片不作处理，直接覆盖一张中间为圆形透明的图片（推荐使用）这种方法 GPU 计算多层的混合渲染 blending 也是会消耗一点性能的，但比第一种方法还是好上很多的</p>\n</li>\n<li>\n<p>方法三：Core Graphics 绘制圆角。这种方式 GPU 损耗最低，可以用 UIimageView 添加个点击手势当做 UIButton 使用。<br />\nUIGraphicsBeginImageContextWithOptions(avatarImageView.bounds.size, NO, [UIScreen mainScreen].scale);<br />\n[[UIBezierPath bezierPathWithRoundedRect:avatarImageView.bounds cornerRadius:50] addClip];[image drawInRect:avatarImageView.bounds];<br />\navatarImageView.image = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();<br />\n 这段方法可以写在 SDWebImage 的 completed 回调里，在主线程异步绘制。也可以封装到 UIImageView 里，写了个 DSRoundImageView。后台线程异步绘制，不会阻塞主线程。目前这种方法只用在 imageView 上，其他地方呢不知道怎么用，不过这种方法会耗费大量的 CPU 资源和占用内存，本人不太建议使用。</p>\n</li>\n</ul>\n<p>最后给大家测试下，因为我之前的 demo 没有切圆角，而是使用的阴影，所以我就用第一种方法给大家测一下。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mbdmx1bj30lu04ywfj.jpg\" alt=\"\" /></p>\n<p>然后运行，打开 Instruments，然后看屏幕</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mbm7cn6j30e40ox76i.jpg\" alt=\"\" /></p>\n<p>图层都是绿色没问题，我们再来看帧数，几乎到 60 ，效果很明显。<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mbsz37rj30j602k747.jpg\" alt=\"\" /></p>\n<p>由此可见以后大家再切圆角的时候多注意下，刚才就研究了这么多，有什么问题及时与我交流吧。。。</p>\n",
            "tags": [
                "UI",
                "性能优化"
            ]
        }
    ]
}