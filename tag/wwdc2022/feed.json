{
    "version": "https://jsonfeed.org/version/1",
    "title": "Molier • All posts by \"wwdc2022\" tag",
    "description": "iOS 开发 移动App 博客 杂谈 随笔 相册",
    "home_page_url": "https://oliverqueen.cn",
    "items": [
        {
            "id": "https://oliverqueen.cn/2022-08-24-WWDC22%EF%BC%9ARuntime%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%92%8CApp%E5%87%8F%E5%8C%85/",
            "url": "https://oliverqueen.cn/2022-08-24-WWDC22%EF%BC%9ARuntime%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%92%8CApp%E5%87%8F%E5%8C%85/",
            "title": "WWDC22：Runtime的性能优化和App减包",
            "date_published": "2022-08-24T07:04:39.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>本 Session 讲了为了让你的应用包体积更小，运行更快，启动速度更快，我们对 Swift 和 Objective-C 运行时做了怎样的优化。同时通过本 Session 你将发现如何通过高效的协议检查，更小的消息发送，以及优化后的 ARC 机制，来提高你的 App 性能。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202301102018054.png\" alt=\"\" /></p>\n<p><span id=\"more\"></span></p>\n<p><div class=\"media-container\"><div class=\"player\" data-type=\"audio\" data-src='[\"https://music.163.com/#/song?id=1929370102\"]'></div></div></p>\n<h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>WWDC2022 上苹果更新了 Xcode14，里面提到了一些相关的优化。其中讲了通过对 Swift 和 Objective-C 运行时做了一些优化，达到了包体积变得更小、运行速度更快，启动速度更快的目的。如果你是用 Xcode14 来构建 App，那么会有其中三点优化</p>\n<ul>\n<li>高效的协议检查（针对 Swift protocol check）</li>\n<li>更快的消息发送机制（message send）</li>\n<li>release 和 retain 调用优化（release &amp; retain）</li>\n<li>Autorelease elision 的优化（自动释放省略）</li>\n</ul>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/202301102019048.png\" alt=\"\" /></p>\n<p>当你用 Swift 或 Objective-C 编写代码时，其实是会经历三个个步骤。</p>\n<ul>\n<li>编码，通过 Xcode 编写代码</li>\n<li>编译，使用了 Swift 和 Clang 编译器</li>\n<li>运行，通过 Swift 和 Objective-C 运行时中完成</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gp9rcbq1j215t0u0754.jpg\" alt=\"image-20220823144936761\" /></p>\n<p>此次的这些关键优化其实就是在第三步骤运行时来完成的，运行时嵌入在我们所有平台的操作系统中。编译器在构建时不能做的事情，运行时可以做。而此次所有的修改其实对于开发者来说是无感透明的，所以任何代码都不用改动，只要你使用 Xcode14 来进行打包编译，便会享受的这些优化点。</p>\n<h2 id=\"swift协议检查protocol-checks\"><a class=\"anchor\" href=\"#swift协议检查protocol-checks\">#</a> Swift 协议检查（Protocol checks）</h2>\n<p>先来看一个例子！</p>\n<p><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个协议</span></span><br><span class=\"line\"><span class=\"keyword\">protocol</span> <span class=\"title class_\">CustomLoggable</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 协议中定义一个属性 customString，只读属性</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> customLogString: <span class=\"type\">String</span> &#123; <span class=\"keyword\">get</span> &#125;        </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个log函数，参数为Any类型</span></span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">log</span>(<span class=\"params\">value</span>: <span class=\"keyword\">Any</span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">//如果value遵循CustomLoggable协议，就输出字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> value <span class=\"operator\">=</span> value <span class=\"keyword\">as?</span> <span class=\"type\">CustomLoggable</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">debugPrint</span>(value.customLogString)        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"operator\">...</span>        </span><br><span class=\"line\">    &#125;       </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个Event类型 遵循协议，并实现customLogString</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Event</span>: <span class=\"title class_\">CustomLoggable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> date: <span class=\"type\">String</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> customLogString: <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;<span class=\"subst\">\\(<span class=\"keyword\">self</span>.name)</span>, on <span class=\"subst\">\\(<span class=\"keyword\">self</span>.date)</span>&quot;</span>    </span><br><span class=\"line\">    &#125;        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>看上面代码，因为 log 函数的参数需要输出字符串，所以在输出前要先判断这个 value 是否遵循 CustomLoggable 协议，Swift 是静态语言，所以一般来说这样的检查都是发生在编译时期。但是编译器不一定能拿到足够的协议元数据信息来完成检查。比如这里并不知道每次传入的 Any 类型是哪个确定类型，也就无法确定是否遵循  <code>CustomLoggable</code>  协议。所以这种检查常常发生运行时，系统借助计算好的协议检查元数据 (protocol check metadata)，运行库知道这个特殊对象是否符合协议。</p>\n<p>这些元数据的构建虽然大部分在编译期间，但是还是有一部分是要在运行时完成，比如上面的例子，而且一个项目中肯定不止有一个协议，所以随着协议越多运行时的效率就越低，对于用户来说这个时间大部分是启动时间，所以用户感知为启动时间变长。而 Xcode14 新推的的 Swift Runtime 解决了这个问题，只要你是用 Xcode14 编译且运行在 iOS16 及以上版即可。</p>\n<p>按照苹果的说法，他们会把 <code>是否遵循协议</code> 的这个判断前置到 build 时期，也就是把 <code>协议元数据计算</code> 的步骤前置到 build 中，具体就是他把这些操作放在 App 可执行文件和启动时任何动态库的 dyld 闭包的一部分</p>\n<p>为什么这样做可以节省启动时间，需要先了解下 app 启动流程，需要一个知识背景 <code>从iOS11开始dyld3被加入，iOS13第三方库也开始使用dyld3加载。</code> 所以我们要看下 dyld3 的加载流程</p>\n<p><img data-src=\"https://upload-images.jianshu.io/upload_images/2438680-b5edfa4c2bcdb205.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1044/format/webp\" alt=\"img\" /></p>\n<p><em>dyld 3</em> 主要包含了两个过程 进程外（启动前）和进程内（启动后），我们来看启动前做了那些事情</p>\n<ul>\n<li>进程外 <em>Mach-O</em> 分析器和编译器 （<em>out-of-process mach-o parser</em>）<br />\n<em>dyld 3</em> 中将采用提前写入把结果数据缓存成文件的方式构成一个 <em>lauch closure</em>（可以理解为缓存文件）</li>\n<li>分析依赖库</li>\n<li>执行符号查找</li>\n<li><em>Write closure</em> 缓存服务 (<em>launch closure cache</em> )<br />\n 系统程序的 <em>closure</em> 直接内置在 <em>shared cache</em> 中，而对于第三方 APP，将在 APP 安装或更新时生成，这样就能保证 <em>closure</em> 总是在 APP 打开之前准备好。说白了就是把上面做的结果全都缓存起来</li>\n</ul>\n<p>综上看来以前需要在 in-process 中做的事情，现在在 out-of-process 就可以完成，启动时或者运行时直接读取缓存数据即可，加快了启动速度和运行时的性能。其实在笔者看来当我们下载或者更新 App 的时候 App 上的进度条其实是分两部分 <code>正在下载</code> 和 <code>正在安装</code> ，此次的优化可能略微提高安装的时长来降低启动速度，提高运行时性能。</p>\n<p><code>on apps that rely heavily in Swift, this could add up to half the launch time</code>  如果有条件的同学可以试下是否可以提高这么多的启动耗时。</p>\n<h2 id=\"消息发送优化message-send\"><a class=\"anchor\" href=\"#消息发送优化message-send\">#</a> 消息发送优化（Message send）</h2>\n<p>直接抛结果，苹果这边给到的数据是使用 Xcode14 编译打包的数据可以让 ARM64 上发送消息消耗从 12 字节降低到 8 字节，二进制大小也有 2% 的降低，也就是苹果对包大小和性能都做了优化，默认是同时开启的，由苹果来平衡两者的关系，当然也可以使用 <code>objc_stubs_small</code>  来仅仅优化包大小。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5grqpljrej215t0u0aax.jpg\" alt=\"image-20220823161510950\" /></p>\n<p>下面我们看下是怎么优化的，同样使用官方代码举例</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 声明一个日历对象</span><br><span class=\"line\">NScalendar *cal = [self makeCalendar];</span><br><span class=\"line\"></span><br><span class=\"line\">// 声明一个日期对象并赋值</span><br><span class=\"line\">NSDateComponents *dateComponents = [[NSDateComponents alloc] init];</span><br><span class=\"line\">dateComponents.year = 2022;</span><br><span class=\"line\">dateComponents.month = 2022;</span><br><span class=\"line\">dateComponents.day = 2022;</span><br><span class=\"line\">S</span><br><span class=\"line\">// 把日期转换为date</span><br><span class=\"line\">NSDate *theDate = [cal dateFromComponents: dateComponents];</span><br><span class=\"line\"></span><br><span class=\"line\">// 返回date</span><br><span class=\"line\">return theDate;</span><br></pre></td></tr></table></figure></p>\n<p>大家知道 OC 调用方法最终会走到 <code>_objc_msgSend</code> ，所以上面代码不算最终的 return，会走 7 个  <code>_objc_msgSend</code> ，其中每一个都需要一条指令来调用就是 bl 如下图</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gsa0ef9kj20n00gidgx.jpg\" alt=\"image-20220823163343886\" /></p>\n<p>该函数定义为 <code>Id objc_msgSend(id self, SEL _cmd, ...) </code> ，参数定义为 self 是函数的调用方，SEL 为具体调用哪个函数，具体的方法查找流程就不在这里赘述。</p>\n<p>我们拿其中具体的一个函数调用来分析</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSDate *theDate = [cal dateFromComponents: dateComponents]; </span><br></pre></td></tr></table></figure></p>\n<p>比如这个函数调用，转化为 mesagesend 的时候就变成这样</p>\n<p><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_msgSend(cal, @selector(dateFromComponents))</span><br></pre></td></tr></table></figure></p>\n<p>为了告诉运行时调用哪个方法，我们必须传递一个 Selector 给这些 objc_msgSend 调用，就如上图的 <code>@selector(dateFromComponents)</code></p>\n<p>我们再来看 <code>Id objc_msgSend(id self, SEL _cmd, ...)</code>  执行后他是怎么执行汇编指令的。</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用adrp找到该方法的地址   消耗4字节</span><br><span class=\"line\">adrp x1, [selector &quot;dateFromComponents&quot;]  </span><br><span class=\"line\"></span><br><span class=\"line\">// 将 地址加载到X1寄存器中  消耗4字节</span><br><span class=\"line\">ldr  x1, [x1, selector &quot;dateFromComponents&quot;] </span><br><span class=\"line\"></span><br><span class=\"line\">// 执行bl指令跳转到该方法并执行  消耗4字节</span><br><span class=\"line\">bl _objc_msgSend</span><br></pre></td></tr></table></figure></p>\n<p>从上面的代码看出每次执行方法调用都会 走以上三个步骤，每个步骤消耗 4 字节 一共消耗 12 字节，而前两步是准备 selector，任何一次方法调用都会执行他，目前的策略是每调一个方法都会生成上面三步，那么此时优化空间就来了。</p>\n<p>因为这里存在相同的代码（前两步）， <code>我们可以考虑共享它，并且只在每个 selector 中触发它一次，而不是每次发送消息时都生成这段指令代码</code> 。所以我们可以把这部分相同代码提取出来，放到一个小助手函数中 (helper function), 并调用该函数。通过使用同一 selector 进行多次调用 (通过传递参数不同，内部指令是相同的，现在封装成一个存根函数，以前是散落在各个 _objc_msgSend 调用处)，我们可以保存所有这些指令字节。所以可以理解为 <code>把前两步封装一下</code></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gvtbfnh1j20n00git9h.jpg\" alt=\"image-20220823183604633\" /></p>\n<p>所以原来的调用就变成了</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bl _objc_msgSend$dateFromComponents 4字节</span><br><span class=\"line\">bl _objc_msgSend    4字节</span><br></pre></td></tr></table></figure></p>\n<p>这也就是苹果说的从 12 字节优化到 8 字节，其中 <code>_objc_msgSend$dateFromComponents</code>  也被称为 <code>selector stub 存根函数</code></p>\n<p>同样 <code>_objc_msgSend</code>  本身也有一个存根函数写法</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gw1kpzuzj20n00giwfd.jpg\" alt=\"image-20220823184401200\" /></p>\n<p>这样一来我们现在就有两个存根函数</p>\n<ul>\n<li>_objc_msgSend$dateFromComponents:</li>\n<li>_objc_msgSend:</li>\n</ul>\n<p>这两个函数封装了一些通用的东西，共享了最多的代码，使代码尽可能的小，但是这样带来的不足是我需要连着两个 bl 跳转，这对操作系统来说开销较大。所以为了平衡包体积和性能，我们可以使用下面这种方法来提升这一点。我们可以把前面调用的两个存根函数封装成一个 (都封装成_objc_msgSend$dateFromComponents)，这样，我们可以使代码更紧凑，不需要那么多调用。如下图这样</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gwei63esj20bo07u74l.jpg\" alt=\"image-20220823185626349\" /></p>\n<p>这就回到了之前的问题，你可以通过 <code>_objc_stubs_small</code>  标记了只降低包大小，或者采用默认的方式让系统自动平衡，两者的区别在汇编层面就体现在如下图</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gwg7hnugj20n00gidhc.jpg\" alt=\"image-20220823185804687\" /></p>\n<p>综上：这就是 Meesage send 占用从 12 bytes 降低到 8 bytes 和二进制大小下降 12% 的原因</p>\n<h2 id=\"retain-and-release\"><a class=\"anchor\" href=\"#retain-and-release\">#</a> Retain and release</h2>\n<p>这个优化是苹果这边使 Retain and release 的开销更小，苹果的说法是 Retain and release 的调用开销从 8 字节降低到 4 字节，同时包体积也会有 2% 的优化</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gwkqxaenj20n00gidg9.jpg\" alt=\"image-20220823190226429\" /></p>\n<p>我们知道 ARC 相比于 MRC 是开发者不需要再写 retain、release 这些代码，其实并不是不需要，而是编译器帮我们自动在需要的位置插入了这些代码，所以换句话说他们还是存在的，只是你看不到也不用在关心他们。</p>\n<p>还是拿之前的例子来说</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Retain/release calls inserted by ARC</span><br><span class=\"line\">NScalendar *cal = [self makeCalendar]; // bl    _objc_retain</span><br><span class=\"line\"></span><br><span class=\"line\">NSDateComponents *dateComponents = [[NSDateComponents alloc] init]; // bl    _objc_retain</span><br><span class=\"line\">dateComponents.year = 2022; </span><br><span class=\"line\">dateComponents.month = 2022;</span><br><span class=\"line\">dateComponents.day = 2022;</span><br><span class=\"line\"></span><br><span class=\"line\">NSDate *theDate = [cal dateFromComponents: dateComponents]; // bl    _objc_retain</span><br><span class=\"line\">return theDate;</span><br><span class=\"line\">// bl    _objc_release </span><br><span class=\"line\">// bl    _objc_release </span><br><span class=\"line\">// bl    _objc_release </span><br></pre></td></tr></table></figure></p>\n<p>在变量创建的时候我们使用 retain 来增加的他的引用计数不被销毁，在方法结束后我们使用 release 来销毁不需要的变量，这也是 iOS 的内存管理机制。在 ARC 下这些都是编译器我们插入的代码，我们无需关心。</p>\n<p>retain 和 release 都是 C 语言的函数，他们携带一个参数就是被操作的对象，同时他遵循 C 语言的 ABI，所以当你调用这些方法的时候系统还会为你做一些额外的事情，比如下图中的 mov 操作，而这些操正是我们优化的用武之地，通过自定义调用重新约定 retain/release 接口，我们可以根据对象指针的位置，适当的使用正确的变量，这样就可以不用移动它。简单的说， <code>就是修改了底层 ABI</code> 。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gwylzjkuj20n00giab1.jpg\" alt=\"image-20220823191546398\" /></p>\n<p>我们是怎么做的优化呢？看下之前的流程，我们用下面这行代码举例</p>\n<p><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_release(dateComponents); </span><br><span class=\"line\"><span class=\"comment\">// mov  x0, x20                    消耗4 字节                                                                                                                                                           </span></span><br><span class=\"line\"><span class=\"comment\">// bl    _objc_release         消耗4字节</span></span><br></pre></td></tr></table></figure></p>\n<p>流程为</p>\n<ul>\n<li>先执行 mov 把副本地址（X20, 也就是对象的地址）存到寄存器 x0</li>\n<li>然后 bl 跳转到 <code>_objc_release</code>  函数进行释放</li>\n</ul>\n<p>根据之前讲的每个指令消耗 4 字节，所以这里消耗 8 字节</p>\n<p>我们修改 ABI 之后其省掉调用 mov 指令 然后原本跳转到_objc_release 函数 改为跳转到 <code>_objc_release_x20</code>  函数，而 mov 的指令放到 C 语言更底层的 ABI 里面去做，你可以理解为 <code>我们封装了一个新的retain、release函数，你只要传入一个寄存器地址我就去更底层的地方完成mov操作，所以效率更高了</code> 。现在因为只用执行一条指令，所以内存消耗为 4 字节。现在的流程看起来为</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gx83ebs8j20n00giab9.jpg\" alt=\"image-20220823192452605\" /></p>\n<p>这么看来我们代码里大量的 release 和 retain 都经过这样的样的优化所以整体的二进制包降低 2% 同时调用内存消耗游 8 字节变为 4 字节，同时 ABI 接口修改，去除冗余 mov 指令调用，下沉到 ABI。 <code>由于 ABI 是内嵌系统</code> ，这里新增 mov 指令占用可以忽略不计。</p>\n<p><code>Apple 果然是坚持用户体验优先，为了更好体验不惜修改 c 的 ABI</code></p>\n<h2 id=\"autorelease-elision自动释放省略优化\"><a class=\"anchor\" href=\"#autorelease-elision自动释放省略优化\">#</a> Autorelease elision（自动释放省略优化）</h2>\n<p>iOS 中除了使用 release 之外还有另一个 就是 autorelease 自动释放机制，同样在这个地方苹果也做了自动释放省略的优化让自动释放机制效率更高。我们来看下面这个例子</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Return Value Autoreleases </span><br><span class=\"line\"></span><br><span class=\"line\">theWWDCDate = [event getWWDCDate];</span><br><span class=\"line\"></span><br><span class=\"line\">-(NSDate*)getWWDCDate &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    return theDate;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>创建一个临时对象 (theDate)，并将其返回给调用方 (event)。 <code>getWWDCDate()</code>  方法中返回临时的 theDate，然后调用完成 (返回 theDate 之后，getWWDCDate 就调用完成)。这时调用方（event）将其保存到自己的变量中（theWWDCDate 中）。</p>\n<p>根据系统插入 retain 和 release 的机制来说应该是这样的，但是明显 retain 处不能进行 release，因为我需要吧 theDate 返回回去，如果这里释放了我就没办法呢返回了。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gy19928nj20n00gi3yz.jpg\" alt=\"image-20220823195254398\" /></p>\n<p>因此，为了解决上述问题，需要使用一个特殊的约定用来返回这个临时返回值。这就引入了 Autorelease，这样调用者能够 retain 它。autorelease 在这里保证在调用方可以正常返回该值，而不被提前释放，延长释放生命周期。你之前可能看到过 autorelease 和 autoreleasePools：其实这是一种将 release 操作推迟到稍后某个时间的方法。所以上面的代码改为 Autorelease</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Return Value Autoreleases </span><br><span class=\"line\"></span><br><span class=\"line\">theWWDCDate = [[event getWWDCDate] retain];</span><br><span class=\"line\"></span><br><span class=\"line\">-(NSDate*)getWWDCDate &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    return [theDate autorelease]; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>系统并不知道他在什么时候会被释放，反正只要不在 retain 的时候释放就行，所以我在 retain 的时候先打个标记，标记他之后可能会被释放。但是这样的操作目前会带来一些开销，其实就是 <code>我虽然打了release标记，但是我明明一会还要retain，没必要多此一举</code> ，所以基于此我们之前引入了 <code>Autorelease elision</code>  来减少这部分开销（ <code>如果Autorelease后紧接一个retain我就都不做了</code> ）。我们先从汇编层面看下 Autorelease elision 做了什么</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5gy8n9wnzj20n00giwf7.jpg\" alt=\"image-20220823195959365\" /></p>\n<p>提炼出以下代码</p>\n<p><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// What the compiler emits</span></span><br><span class=\"line\"> bl    _getWWDCDate </span><br><span class=\"line\"> mov   x29, x29</span><br><span class=\"line\"> bl    _objc_retainAutoreleasedReturnValue</span><br><span class=\"line\"></span><br><span class=\"line\"> b    _objc_autoreleaseReturnValue   <span class=\"comment\">// autorelease -&gt; runtime -&gt; _objc_autoreleaseReturnValue</span></span><br></pre></td></tr></table></figure></p>\n<p>其实就是以下步骤</p>\n<ul>\n<li>当我们返回值调用 Autorelease 时候系统会调用 <code>_objc_autoreleaseReturnValue</code>  来返回一个 <code>autoreleased value</code></li>\n<li>执行 Autorelease 后编译器会添加个标记 <code>mov x29, x29</code>   而这句指令在实际运行中这个指令会变为二进制的形式变为 <code>0xAA1D03FD</code></li>\n<li>后续的操作就运行时会先判断是否有对应的标记 <code>0xAA1D03FD</code> ，如果有，这意味着编译器告诉 runtime, 我们将返回一个已经被标记，但是将立即被持有（retain） 的临时变量，后面就不需要再 retain 操作了</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5h056kleej20n00gigm5.jpg\" alt=\"image-20220823210550374\" /></p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static ALWAYS_INLINE bool </span><br><span class=\"line\">callerAcceptsOptimizedReturn(const void *ra)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // fd 03 1d aa    mov fp, fp</span><br><span class=\"line\">    // arm64 instructions are well-aligned</span><br><span class=\"line\">    if (*(uint32_t *)ra == 0xaa1d03fd) &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">        // 返回true 需要优化 把release、rentain删掉</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>说白了就是在返回值身上调用 <code>objc_autoreleaseReturnValue</code>  方法时，runtime 将这个返回值 object 标记（储存在 TLS 中），然后直接返回这个 object（不调用 autorelease）；同时，在外部接收这个返回值的 <code>objc_retainAutoreleasedReturnValue</code>  里，发现有之前的标记（TLS 中正好存了这个对象），那么直接返回这个 object（清楚之前的标记且不再调用 retain）。</p>\n<p>注意：TLS 相关的含义可以参考 [这里](<span class=\"exturl\" data-url=\"aHR0cDovL3NlYW5jaGVuc2UuZ2l0aHViLmlvLzIwMTgvMDkvMjAvZWFybGdyZXktc291cmNlLWNvZGUtcmVhZC0xLyNUTFM=\">EarlGrey 源码阅读（一） | SeanChense</span>)</p>\n<p>但是这里有一个问题，以二进制的形式来加载代码并不是很常见，而且我们不但要加载它还要比较他尤其在 CPU 上并不是最优策略，所以这里还是有开销的，因此我们看下如何优化。</p>\n<p>同样执行流程，当执行完 <code> _objc_autoreleaseReturnValue</code>  函数时候我们会获得一个返回地址，这个地址是一个指针，指向了被标记为 Autorelease 的对象。然后代码继续执行到 <code>_objc_retainAutoreleasedReturnValue</code>  这里要进行 reatin，而被 reatain 的变量地址我们也可以拿到，所以只要比较这两个指针即可，这样一来我们也不再需要 mov 操作</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h5h0ws62g0j20n00gidg3.jpg\" alt=\"image-20220823213224122\" /></p>\n<p>优化点</p>\n<ul>\n<li>把原来的比较二进制数据改为比较指针。速度更快效率更高</li>\n<li>减少 mov 指令 减少 4 字节，二进制大小预计降低 2%</li>\n</ul>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>这就是 Xcode14+iOS16 的编译期间优化，可以看出苹果也在帮我们完成 OKR 减少包体积，提高启动速度，增加代码执行效率，同时也能看出苹果在追求极致用户体验道路上所做的事情。本文部分翻译自<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL3ZpZGVvcy9wbGF5L3d3ZGMyMDIyLzExMDM2My8=\"> Improve app size and runtime performance</span>，同时也添加了自己的思考。</p>\n",
            "tags": [
                "iOS",
                "WWDC2022"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2022-06-13-WWDC2022-iOS%E7%AF%87%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/",
            "url": "https://oliverqueen.cn/2022-06-13-WWDC2022-iOS%E7%AF%87%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/",
            "title": "WWDC2022-iOS篇完全解析",
            "date_published": "2022-06-13T09:05:31.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景</h1>\n<p>Apple 于北京时间 2022 年 6 月 7 日举办了 WWDC2022，作为一名 Apple 开发者，不仅仅是为了保持技术敏感度，同时也希望在第一时间将新的内容呈现在大家眼前。本文对发布会内容做了整理归纳，并着重对 iOS 的新内容进行分析。希望这篇文章对大家有所帮助的同时也给我们的产品带来更多的可能性。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h344hz8cl3j21g20pswhk.jpg\" alt=\"9690f67c1bc2cc62bd8729e5182ef19a\" /></p>\n<p><span id=\"more\"></span></p>\n<p>相对于 iOS15 来说，iOS16 的整体变化比较大，尤其是在我们看得见的地方，比如一些 UI 样式，交互行为和一些新增的功能。下面会按照 WWDC 的出厂顺序来介绍，其中包含了每个改动点的细节以及个人的理解和后面的展望。</p>\n<h1 id=\"developer\"><a class=\"anchor\" href=\"#developer\">#</a> Developer</h1>\n<h2 id=\"xcode相关\"><a class=\"anchor\" href=\"#xcode相关\">#</a> Xcode 相关</h2>\n<p>新版的 Xcode 同样也跟新了相关的内容，帮助开发者提高开发效率。</p>\n<h4 id=\"方法吸顶以及代码提示\"><a class=\"anchor\" href=\"#方法吸顶以及代码提示\">#</a> 方法吸顶以及代码提示</h4>\n<p>在之前的版本中，如果方法函数过多超了一屏展示，随着滚动函数名不可见，而新版的 Xcode 提供了类似 TableViewHeader 的效果，让方法名和实现名字固定在顶部，方便随时查看和复制。对小屏还是比较友好的。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342t0jx5qj215h0u040m.jpg\" alt=\"enter image description here\" /></p>\n<p>同样在使用初始化方法的时候如果是支持传入参数的初始化方法也会通过斜体来进行参数提示 (Swift 专属)</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342t2czj8j20u00akt9s.jpg\" alt=\"enter image description here\" /></p>\n<h4 id=\"xcode安装体积\"><a class=\"anchor\" href=\"#xcode安装体积\">#</a> Xcode 安装体积</h4>\n<p>新版的 Xcode 优化了包体积，同时在进行安装的时候可以自定义需要哪些平台，需要哪些模拟器，笔者亲测相比之前的无脑把 AppleTV、Apple Watch、ipad 等都安装下来的情况来看，整个包体积减少了十几个 G 左右。对于小存储的 MacBook 是一个福音。</p>\n<h4 id=\"xcode编译与调试\"><a class=\"anchor\" href=\"#xcode编译与调试\">#</a> Xcode 编译与调试</h4>\n<p>根据苹果的描述新版 Xcode 优化项目的编译速度， <code>得益于更强大的并行编译能力，项目构建速度提升至高可达 25%</code> 。</p>\n<ul>\n<li>改善前：先编译 framework 里的代码，然后生成 module，然后编译 app 里的代码，最终经过链接完成了构建。</li>\n<li>改善后：通过提高并发，缩短了构建的关键的路径</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tn4mxij20yl0u0415.jpg\" alt=\"enter image description here\" /></p>\n<p>同时单元测试的效率也提高了 30%</p>\n<p>Xcode14 还支持输出编译期间每个阶段的耗时和详细信息，相比之前的只能通过控制台的名字描述要直观不少。<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342x91jz4j21910u0wir.jpg\" alt=\"编译耗时\" /></p>\n<p>对于 LLDB，现在还可以看到执行的过程和信息，对于一些需要长时间跑的命令较为友好，类似于 <code>--verbose</code>  参数的含义</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tgt828j21dg0323yy.jpg\" alt=\"enter image description here\" /></p>\n<p>在新版的 Xcode 中除了 App 和系统的日志，同样支持 LLDB 的日志输出，当时在用 LLDB 调试的时候发生 Crash，便可以到相关路径中找到对应日志。<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342t3pka9j21ay02kjrp.jpg\" alt=\"enter image description here\" /></p>\n<h2 id=\"开发者模式\"><a class=\"anchor\" href=\"#开发者模式\">#</a> 开发者模式</h2>\n<p>新版的 iOS 和 Watch OS 引入了新的开发者模式，原理和安卓的开发者模式类似，用苹果的话说是为了 <code>开发者模式可防止人们无意中在其设备上安装可能有害的软件，并减少开发者专用功能所暴露的攻击媒介。</code> ，对于普通人来说确实可以提高安全性，之前只要是加入了开发者账号的手机都可以从 Xcode 编译运行第三方的 App，或者按照企业证书的签名包，而不这些手机主人都是无感的，现在需要手机主人通过多重确认来打开此功能后才可以进行安装非 <code>App Store</code>  和 <code>Testfilght</code>  渠道的包。</p>\n<p>但是这个对于开发者来说并不友好，首先是调试过程有会多增加一些步骤，而且在自动化测试方面，所有的手机都要先通过命令来打开开发者模式，并且根据苹果的说法，使用命令行进行开关要确保手机没有密码，否则会被拒绝运行。这里笔者也尝试在未打开 <code>开发者模式</code> 的情况下进行 Xcode 编译，确实会失败。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342ygml7gj208y01kdfo.jpg\" alt=\"enter image description here\" /></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3358k3glij207s087aaa.jpg\" alt=\"\" /></p>\n<p>笔者预测该功能可能是为后续的第三方 App 市场做准备，因为现在虽然苹果不支持三方市场，但是普通用户还是可以通过一些三方网站安装重签包，同时他们并不知道这些包会带来潜在的危险，再加上欧盟一些反垄断政策的施压，所以苹果决定逐步开放三方应用市场，这应该就是第一步吧，先让用户意识到这样做可能会有一些危害。</p>\n<p><code>无论是美国的《美国选择与创新法案》、还是欧盟的《数字市场法案》，都要求苹果在App Store之外为用户提供额外的应用下载渠道。现在看来，苹果方面可能已经认为改变欧盟与美国的态度已经不太可能了，那么既然支持侧载或许无法避免，那么让用户更难发现侧载功能的入口就成为了备选项。</code></p>\n<h1 id=\"lockscreen\"><a class=\"anchor\" href=\"#lockscreen\">#</a> LockScreen</h1>\n<h2 id=\"锁屏样式\"><a class=\"anchor\" href=\"#锁屏样式\">#</a> 锁屏样式</h2>\n<p>重新修改了锁屏的样式，在优化了时间显示的字体的同时也在锁屏上提供了更多能力，展示更多的信息，并加入了一些新的交互样式，通过在锁屏界面长按来进入锁屏界面的编辑状态，这个动画效果有点类似安卓的编辑桌面的效果。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3430h983bg208a0gnhe7.gif\" alt=\"image\" /></p>\n<p>iOS16 的锁屏样式可以大致分为两类</p>\n<ul>\n<li>动态锁屏<br />\n比如在 Beta1 中可以看到的天气锁屏，依赖于天气 App 的信息，在点亮屏幕的一瞬间可以在锁定屏幕上动态显示天气的效果，比如雨雪风晴等，持续几秒钟后停止。笔者预测该能力后续会和 Livephoto 关联起来，实现用户自定义动态照片，毕竟现在的 livephoto 设置锁屏之后只有在长按才会触发播放，到时候长按的手势会和设置锁屏的手势冲突，所以 livephoto 必然会变成自动播放，</li>\n</ul>\n<p>再长远预测的话也可能后续会把该能力开放给第三方 App 来定制动态锁屏的图片，类型于现在的天气 App。比如 QQ 音乐的专辑封面，歌手的演唱动图等。目前动态背景只支持锁屏界面，解锁后进入桌面便会停止，估计是处于性能考虑，动态桌面的可能性不大，应该仅限于锁屏。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tiho1zg207u0gou0z.gif\" alt=\"image\" /></p>\n<ul>\n<li>静态照片<br />\n iPhone 一直可以支持设置静态照片为锁屏壁纸，但是 iOS16 给静态照片锁屏提供了更多的玩法。</li>\n<li>照片随机切换：用户可以选定一组照片来作为锁屏壁纸，类似于幻灯片放映的样式，切换的频率可以设置为  <code>每次点亮</code>  、  <code>每次点击</code>  、  <code>每小时</code>  、  <code>每天</code>  。</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tuul3fg207z0gnqvl.gif\" alt=\"image\" /></p>\n<ul>\n<li>照片景深：这个能力算是 iOS16 更新比较大的，通过机器学习模型将照片中的主体突出，可以遮挡在时间上，这里的主体可以是图片中任何可区分的物体，不仅仅是人像模式的照片。(在实际使用中，经常会失败，beta1 还是不够稳定)</li>\n</ul>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzExYno5bmoyMGkyMTJ5YWNpLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h34311bz9nj20i212yaci.jpg</span>&quot; alt=&quot;image#268px #578px&quot; style=&quot;zoom:50%;&quot; /&gt; &lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzI0OHBnOWoyMG11MTh1ZG1oLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h343248pg9j20mu18udmh.jpg</span>&quot; alt=&quot;image#292px #574px&quot; style=&quot;zoom:43%;&quot; /&gt;</p>\n<ul>\n<li>表情壁纸：将 IPhone 输入法中自带的表情进行一定规律的排列组合形成一张壁纸，最多支持输入六个表情。</li>\n<li>颜色壁纸：可以定义一些渐变颜色</li>\n<li>官方背景图壁纸。一些官方图片，支持景深效果</li>\n</ul>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MnRxcXZldWoyMGh3MTB3cTViLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tqqveuj20hw10wq5b.jpg</span>&quot; alt=&quot;image#189px #390px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h2 id=\"锁屏组件\"><a class=\"anchor\" href=\"#锁屏组件\">#</a> 锁屏组件</h2>\n<p>iOS16 在锁屏界面可以展示更多的信息，其中就包括了锁屏小组件的加入。可以看到锁屏顶部分三个区域。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzJkMTZoc2oyMGllMTNhZGllLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3432d16hsj20ie13adie.jpg</span>&quot; alt=&quot;image#270px #577px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<ul>\n<li>顶部：顶部区域是一个小的小组件区域，同时只能容纳一种小组件放置，🇳信息量有限。</li>\n<li>中部：中部区域是固定展示时间的区域，不可放置自定义小组件。只能展示时间信息，但是用户可自定义字体（包括阿拉伯文、天成文）和颜色。</li>\n<li>底部：底部区域为第二个小组件区域，范围较大，最多可容纳 4 个正方形（1*1）的小组件。同时支持排列组合。</li>\n</ul>\n<p>目前小组件的支持非常有限，目前只能将系统级的 App 的组件放上去，并不支持第三方 App，笔者尝试写了一个小组件，在主屏幕上可以正常添加，但是在锁定屏幕无法使用，猜测两个原因，一是目前是 Beta1 版可能还没有开放三方 App 的小组件，后续会陆续优化上来；第二个原因可能是处于性能或者其他因素考虑锁频组件和主屏组件不是一套逻辑，并不互通，但是通过查看 Xcode Beta 版本的代码，没有看到相关线索，不过 WWDC 也提到了，一些功能在后续会以 API 的形式像开发者提供。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MnR5bThndGoyMGk2MTMwNzdoLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tym8gtj20i613077h.jpg</span>&quot; alt=&quot;image#266px #571px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h2 id=\"锁屏通知\"><a class=\"anchor\" href=\"#锁屏通知\">#</a> 锁屏通知</h2>\n<p>iOS16 调整了锁屏的样式，增加了锁屏界面所展示的信息和交互，所以希望锁屏界面不要被大量的通知遮挡，因此从新调整了通知推送的位置和出现动画。iOS16 之前：通知铺满锁屏，同时新的通知会插到到最上面。从上往下依次排列。iOS16 之后：锁屏区域被限定在底部一小块区域，新来的通知会插到第一层，但是默认只展示 3 个（叠放的形式），想看更多的话跟之前一样，上拉即可。任何新增的通知，包括常驻的音乐播放调都是从下往上增长，通知增长到一定高度就会开始折叠，这样的好处就是可以给锁屏留出空间，不至于被占满。</p>\n<p>这样的修改确实可以让锁屏界面看的更整洁，且能让用户看到自己喜欢的锁屏画面，但是带来一个问题是用户想要查看通知内容时候需要多做一步上拉的操作，可能会稍微影响到 Push 的效果，比如点击率之类的指标。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3432t13nsg207m0go7wr.gif\" alt=\"image\" /></p>\n<h2 id=\"live-activities\"><a class=\"anchor\" href=\"#live-activities\">#</a> Live Activities</h2>\n<p>上面说的苹果弱化了通知展示的样式，默认采用了折叠策略给锁屏留出了更大的空间，但是为了让用户实时的追踪想要的信息便推出了  <code>Live Activities</code>  。该控件可以常驻在锁屏界面，且能够实时刷更新的一个 UI 控件，</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h342tq7i9qj214g0mg3zz.jpg\" alt=\"image\" /></p>\n<p>WWDC 上举了一个恰当的例子，比如我在追踪一场比赛，我需要知道实时的比分信息，但是又不方便拿着手机 app 观看直播，所以支持了  <code>Live Activities</code>  能力的 App 可以再锁屏界面来实时展示比赛信息，同时不需要解锁屏幕，还有优步的信息。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzMxbGNyM2oyMHdjMG13bjFnLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h34331lcr3j20wc0mwn1g.jpg</span>&quot; alt=&quot;image#321px #227px&quot; style=&quot;zoom: 33%;&quot; /&gt;&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzM3NWh2ZWoyMHc2MG0wanZhLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h343375hvej20w60m0jva.jpg</span>&quot; alt=&quot;image#334px #228px&quot; style=&quot;zoom: 35%;&quot; /&gt;</p>\n<p>这有点类似于锁屏的音乐播放条。同时 IOS16 针对音乐播放调界面也做 UI 优化，可以通过点击来实现封面图展开，同时背景设置为封面的魔法色，实现全屏沉浸式播放。但是笔者实测时候并未在 beta 版上成功使用该功能，SDK 中也没有看到相关代码。应该是在后续的版本开放更新。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzVsb3c4Z2oyMGhrMHhlNDFqLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3435low8gj20hk0xe41j.jpg</span>&quot; alt=&quot;image#305px #580px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h2 id=\"专注模式\"><a class=\"anchor\" href=\"#专注模式\">#</a> 专注模式</h2>\n<p>苹果去年推出了  <code>专注模式</code>  ，但是专注模式的切换需要到控制中心，或者设置菜单中进行切换，隐藏较深，在这次的 iOS16 中，苹果将专注模式和锁定屏幕绑定起来，也就是实现专注模式和锁定屏幕  <code>一一对应</code>  的关系，一个锁屏对应一套锁屏组件和一个专注模式。</p>\n<p>比如我下图中两个锁定屏幕分别对应两种模式，工作模式可以设置只接受某些 App 的推送（比如企业微信。WeSing 等），忽略某些不重要的通知。右边的游戏模式可以吧比较关注的电量信息放到锁屏，同时屏蔽通知避免游戏误操作。关键是在 iOS16 上两种模式的切换只要在锁屏上长按就可以进行更改，方便很多。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzV0a3QxZWoyMGcyMHpnYWQxLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3435tkt1ej20g20zgad1.jpg</span>&quot; alt=&quot;image#337px #744px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h1 id=\"信息app\"><a class=\"anchor\" href=\"#信息app\">#</a> 信息 App</h1>\n<h2 id=\"消息编辑\"><a class=\"anchor\" href=\"#消息编辑\">#</a> 消息编辑</h2>\n<p>根据 WWDC 的描述，信息 App 带来的三个呼声最高的功能（应该是国外用户）</p>\n<ul>\n<li>动态编辑信息：对于已经发送出去的信息，如果发现错别字，可以直接在自己刚刚发送的对话气泡上进行修改，像这样，就不需要再撤回然后重新辑后发送。</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3436v6e47g20go080e86.gif\" alt=\"image\" /></p>\n<ul>\n<li>\n<p>标记未读（国内玩腻了的）</p>\n</li>\n<li>\n<p>消息撤回（国内玩腻了的）</p>\n</li>\n</ul>\n<h2 id=\"shareapi\"><a class=\"anchor\" href=\"#shareapi\">#</a> ShareApi</h2>\n<p>iOS15 中提到了  <code>SharePlay</code>  的能力，但是当时该能力必须基于 FaceTime。在 iOS16 中，该能力已经扩展的信息 App 中。笔者认为，  <code>SharePlay</code>  的能力后续会形成套单独的 SDK（类似于 AirPlay 的 SDK），供第三方 App 接入，且不依赖 Facetim 和信息等系统 App。这对于音视频的 App 是有比较大的帮助，可以一起听歌、看视频。但是对于版权的管理要更为严格。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM3cmhidXc2Y2oyMGkyMGx3YWJ3LmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h37rhbuw6cj20i20lwabw.jpg</span>&quot; alt=&quot;image#389px #472px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h1 id=\"语音输入\"><a class=\"anchor\" href=\"#语音输入\">#</a> 语音输入</h1>\n<p>苹果在很早的版本就支持语音输入，但是有一个弊端就是语音输入和键盘输入是两个独立的过程。而在 iOS16 中输入文本时，可在语音和触控这两种方式间无缝切换。无需中断听写，照样可用键盘打字、轻点文本栏、移动光标，或插入快速输入建议。<br />\n<img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h37rautdseg20go080e89.gif\" alt=\"image\" /></p>\n<h1 id=\"coreml\"><a class=\"anchor\" href=\"#coreml\">#</a> CoreML</h1>\n<h2 id=\"livetext\"><a class=\"anchor\" href=\"#livetext\">#</a> LiveText</h2>\n<p>CoreML 是苹果早期发布的机型学习 API，通过他可训练一些人工智能相关的东西，其中 iOS15 推出的  <code>LiveText</code>  便是其中之一，他可以让我们对图片里面的一些文字做提取操作，在 iOS16 中，apple 增强了  <code>LiveText</code>  的能力，除了静态图片，还加入了视频帧的支持。  <code>Live Text in Video</code>  , 根据 WWDC 的描述，在播放视频的时候进行暂停，便可以提取当前帧上的文字内容。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h37rfclnkvj21mp0u0dkd.jpg\" alt=\"image\" /></p>\n<p>选中后除了对文字进行复制操作外，iOS16 还提供了一些其他的快捷功能，其中包括汇率转换、翻译。更重要的是，实况文本的 API 已经开发给开发者使用，很快我们就能从 app 的照片和视频中提取相关的文字信息。</p>\n<h2 id=\"visual-look-up\"><a class=\"anchor\" href=\"#visual-look-up\">#</a> Visual Look Up</h2>\n<p>也是苹果之前基于机器学习提供的一个能力，可以检测照片中的物体，来识别是什么东西，在 iOS16 中，该能力被大幅加强，同时集成到了照片 App 中。用户可以打开一个照片，通过长按，把照片主体拖动出来到相应的 App 中。（拖出的图片为 png 图片）</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3437xq1cag207n0gnkk7.gif\" alt=\"image\" /></p>\n<p>该能力已经提供独立的 API，目前的 Apple 的  <code>可立拍</code>   App 里面将 Core ML 的能力运用到视频处理中，大家可以下载体验。</p>\n<h1 id=\"apple-pay\"><a class=\"anchor\" href=\"#apple-pay\">#</a> Apple Pay</h1>\n<h2 id=\"apple-pay-later\"><a class=\"anchor\" href=\"#apple-pay-later\">#</a> Apple pay later</h2>\n<p>类似于国内的京东白条、蚂蚁花呗，不同的是   <code>Apple pay later</code>   只提供 4 周或者 6 周的分期还款，且无息。</p>\n<h2 id=\"钥匙共享\"><a class=\"anchor\" href=\"#钥匙共享\">#</a> 钥匙共享</h2>\n<p>通过常用的通讯类 app，安全地共享钱包 app 中的钥匙（智能家居钥匙，汽车钥匙等）。你可以决定钥匙的使用地点和时间，并能随时撤销。</p>\n<h2 id=\"追踪订单\"><a class=\"anchor\" href=\"#追踪订单\">#</a> 追踪订单</h2>\n<p>可以查看票据，还能直接在钱包 app 中追踪你的 Apple Pay 订单。商户可以将订单的相续信息推送到消费者的钱包里</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzhlcnF1ZmoyMGVnMHNrZ243LmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3438erqufj20eg0skgn7.jpg</span>&quot; alt=&quot;image#304px #601px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h1 id=\"apple-map\"><a class=\"anchor\" href=\"#apple-map\">#</a> Apple Map</h1>\n<h2 id=\"增加途经点规划\"><a class=\"anchor\" href=\"#增加途经点规划\">#</a> 增加途经点规划</h2>\n<p>国内高德百度已经玩了很久的功能，在导航的时候可以在起点和终点之间增加途经点。快车顺风车经常要用的功能。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzhzZjJlZ2oyMGR5MHQwbjA4LmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3438sf2egj20dy0t0n08.jpg</span>&quot; alt=&quot;image#297px #618px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h2 id=\"实时公交信息\"><a class=\"anchor\" href=\"#实时公交信息\">#</a> 实时公交信息</h2>\n<p>可以查看公交出行的公交信息，包括公交时间，公交线路，公交价格等，同样也是国内使用了很久的能力。</p>\n<h2 id=\"共享交通工具查看\"><a class=\"anchor\" href=\"#共享交通工具查看\">#</a> 共享交通工具查看</h2>\n<p>可以在地图上看到附近的共享汽车、共享滑板车、共享单车等。同样也是国能很多共享单车厂商实现了的能力。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uY2RuanNvbi5jb20vdHZhMS5zaW5haW1nLmNuL2xhcmdlL2U2YzlkMjRlZ3kxaDM0MzliM21lb2oyMGhxMHcwNzZxLmpwZw==\">https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3439b3meoj20hq0w076q.jpg</span>&quot; alt=&quot;image#307px #554px&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h1 id=\"apple-tv-amp-apple-news\"><a class=\"anchor\" href=\"#apple-tv-amp-apple-news\">#</a> Apple TV &amp;amp; Apple News</h1>\n<p>Apple TV 和 Apple News 是两个不同的东西，之所以放到一起说是因为他们在 iOS16 中提供了相同的能力，都新增了体育板块，可以每周免费观看两场比赛，同时可以和 iPhone 联动，在锁屏上展示   <code>Live Activities</code></p>\n<h1 id=\"家长控制\"><a class=\"anchor\" href=\"#家长控制\">#</a> 家长控制</h1>\n<p>家长控制的粒度更细，除了是否可以启动某个 App，还可以详细控制某个 App 的权限，比如禁止某个 App 访问摄像头权限，来避免儿童色情的问题。之后的开发者可能要在权限控制这里做额外的判断。除了允许、拒绝、未决定外，新增了家长控制的枚举条件。</p>\n<h1 id=\"homekit\"><a class=\"anchor\" href=\"#homekit\">#</a> HomeKit</h1>\n<p>接入了更多智能家居品牌。同时和其他主流品牌一起在 HomeKit 的基础上创立了新的智能家居协议标准   <code>matter</code>  。可以让智能家居跨平台协同操作。目前已经有一部分厂商支持了   <code>matter</code></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h3439rmf5bj21sq0sqtcw.jpg\" alt=\"image\" /></p>\n<h1 id=\"crarplay\"><a class=\"anchor\" href=\"#crarplay\">#</a> CrarPlay</h1>\n<p>苹果也看出了现在汽车发展的趋势就是大屏幕，而且一辆车往往不止一块屏幕，所以在 iOS16 上，苹果针对这个现象重新优化了 CraePlay，新的 CarPlay 不仅仅可以通过车机来控制 iPhone，还可以通过 iPhone 来设置车机的主题。 支持新 CarPlay 的车型将于 2023 年下半年生产，前期支持的车型为</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h343a6xc3bj21vm0tmtbn.jpg\" alt=\"image\" /></p>\n<p><code>新一代 CarPlay 车载将出类拔萃的 iPhone 体验带入车内。它可为车内所有的驾驶员屏幕提供内容，包括仪表盘在内，让你的爱车和 iPhone 在体验上融为一体。车载的收音机、空调等功能可直接通过 CarPlay 车载来控制。而多种个性化选项，包括小组件以及精选的仪表盘设计，更带来独特的驾驶体验。</code></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tva1.sinaimg.cn/large/e6c9d24egy1h343ak4evxj221o0t60ya.jpg\" alt=\"\" /></p>\n<h1 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h1>\n<p>以上就是 WWDC 中关于 iOS 的相关内容，笔者第一时间更新了 iOS16 的 Beta 版本，但也遇到一些问题</p>\n<ul>\n<li>iOS16 官方最低支持到 iPhone 8 系列，但是 iPhone 8 更新后，很多功能无法使用，建议使用 iPhoneXs 以及以上机型体验。</li>\n<li>WWDC 中提到的大部分功能现在都无法在 Beta1 中体验。且最新的 XcodeBeta 中也没有相关的新 Api，不过 WWDC 上也说了，iOS16 上的功能会在后续稍晚的时候以 API 的形式提供。</li>\n<li>Beta1 耗电发热非常夸张，尤其是在锁屏界面。可能还需相关优化，目前手机必须连着电源使用。</li>\n</ul>\n<p>文中提到得到一些功能更新虽然和国内开发者关系不大，但是毕竟都是业务层面的东西，底层都是通用的，毕竟技术无国界，也希望能将更新的技术用到自己的项目中，提高用户的产品体验，向用户展示出我们的专业能力和创新能力。希望这篇文章能对 iOS 开发者和产品同学在后续的技术、产品规划上有一定的帮助。</p>\n",
            "tags": [
                "iOS",
                "WWDC2022"
            ]
        }
    ]
}