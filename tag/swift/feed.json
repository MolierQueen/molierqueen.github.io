{
    "version": "https://jsonfeed.org/version/1",
    "title": "Molier • All posts by \"swift\" tag",
    "description": "iOS 开发 移动App 博客 杂谈 随笔 相册",
    "home_page_url": "https://oliverqueen.cn",
    "items": [
        {
            "id": "https://oliverqueen.cn/2018-05-08-RX-Swift-Study-One/",
            "url": "https://oliverqueen.cn/2018-05-08-RX-Swift-Study-One/",
            "title": "关于RxSwift的一点理解",
            "date_published": "2018-05-08T02:12:00.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"hello-rxswift\"><a class=\"anchor\" href=\"#hello-rxswift\">#</a> Hello RxSwift!</h2>\n<p>这本书可以让你用 Swift 来编写响应式编程代码。但是到底什么是 RxSwift, 这里有很好的定义：</p>\n<p>&lt;font color=orange&gt;RxSwift 是由可被观察的事件的异步队列和可操作的功能性的运算符组成的库，并且他可以由调度者通过参数的方式进行调度。&lt;/font&gt; &lt;br&gt;</p>\n<p><img data-src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1525870736284&amp;di=9f373001bac8687d5fe11b3d7b40016f&amp;imgtype=0&amp;src=http%3A%2F%2Fcode4app.com%2Fdata%2Fattachment%2Fforum%2F201703%2F21%2F210007p6wy7buzq6hqhhdu.png\" alt=\"\" /></p>\n<p>听起来很复杂？其实不用担心，因为无论是你编写响应式编程，还是理解他们背后的思想和一些相关的东西，官方通常都是用一些很吓人的术语来解释。尤其是当你第一次接触，或者是之前从未有人向你介绍过这些的时候，你就会觉得很可怕。</p>\n<p><span id=\"more\"></span></p>\n<p>本书的目标就是带你逐步的去理解 RxSwift 的 API，并且去运用每一个 API，然后把它们运用到实际的 iOSApp 中。</p>\n<p>你将会从 RxSwift 中最基本的功能开始，然后循序渐进的由中级到高级。花一些时间去广泛的理解里面的概念，这样以来读完本书后你就会精通 RxSwift 额思想和使用。其实 Rx 是非常广的话题，以至于不能单单通过这一本书来讲完，因此我们通过这本书让你对 RX 有一个坚实的了解，这样你就能继续提高自己的 Rx 水平了</p>\n<p>其实我们并没有非常确信 RxSwift 的思想是什么，让我们在这个章节里面通过几个简单的例子来帮助我们理解响应式编程。</p>\n<p>&lt;font color=orange&gt;RxSwift 本质其实就是当你的数据或者对象发生变化时候他会把这个变化放在一个单独的管道 (队列) 里面，以此来达到简化异步并发的过程的目的 &lt;/font&gt;&lt;br&gt;</p>\n<p>这里打个比方一个按钮我点击了就会触发一个时间 那么我每点击一次就会生成一个 Action 我们用一个管道去装在这些 Action，每加一个 Action 就会把他放管道里面，我们可以理解为管道里面流动的 Actions，且管道与管道之间相互独立。同理我们可以吧 Button 改成一个 UITExtField，Action 就是每一次输入事件。</p>\n<p>作为一个 iOS 的开发者我相信这已经很好帮你去理解什么是 RxSwift 了吧，这应该是比你在一开始看到的那些专业术语好理解的多。</p>\n<p>如果你还是不清楚，那么你至少应该理解，RxSwift 可以很轻松的帮你编写异步操作的代码，你要知道编写异步操作的代码是比较难的，所以所任何一点点的帮助都是受大家所欢迎的。</p>\n<h3 id=\"异步编程的介绍\"><a class=\"anchor\" href=\"#异步编程的介绍\">#</a> 异步编程的介绍</h3>\n<p>如果你想用一种通俗简单的语言来描述异步编程，比如你在做一个 iSO 的 App，那么你一定想到如下几个东西：</p>\n<ul>\n<li>\n<p>接受 Button 的点击事件</p>\n</li>\n<li>\n<p>当 text field 的 Action 和键盘的弹出和收起动画之间的关系</p>\n</li>\n<li>\n<p>从网上下载大图片</p>\n</li>\n<li>\n<p>往硬盘里面存数据</p>\n</li>\n<li>\n<p>播放视频</p>\n</li>\n</ul>\n<p>以上的所有东西看似是发生在同一时刻其实真的是吗？我们思考一个问题：比如你在看视频，这时候你点击了 textfield 弹出键盘，大家都知道键盘由下往上弹出是有一个动画的，就算键盘已经出现到了屏幕上，只要动画没有做完你的视频就不会暂停，真的是这样吗，内部又是如何实现的？如下图:</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1fr41y6xhkij31kw0q0h80.jpg\" alt=\"\" /></p>\n<p>程序里面不同的部分不会阻塞彼此的执行，iOS 提供了几种 API，通过多核 CPU 来在不同的线程上进行不同的工作。</p>\n<p>其实编写真正并行的代码其实是很复杂的，打个比方假如两个线程同时访问同一个资源，就会产生资源争夺的问题，比如谁先访问，谁后访问。</p>\n<h3 id=\"uikit中的一些异步的api\"><a class=\"anchor\" href=\"#uikit中的一些异步的api\">#</a> UIKit 中的一些异步的 API</h3>\n<p>苹果在 iOS SDK 中提供了很多 api，帮助你编写异步代码。你在你的项目中使用过这些但是可能还没有考虑过它们，因为它们是编写移动应用程序的基础。毕竟苹果爸爸封装好的，我们拿来用就好了，干嘛想那么多。</p>\n<p>你一定用过以下几点</p>\n<ul>\n<li>\n<p>NotificationCenter</p>\n</li>\n<li>\n<p>delegate</p>\n</li>\n<li>\n<p>Grand Central Dispatch(GCD)</p>\n</li>\n<li>\n<p>Closures（Block）</p>\n</li>\n</ul>\n<p>由于大部分的类都是异步的，并且 UI 在内部也是异步的，所以很难去猜测整个程序的执行顺序，因此你的 APp 会因为一些外部的原因而表现不同，比如用户的输入不同、网络环境的不同、或者一些其他的东西。用户每次在打开你的 APp 其实代码的执行顺序都是不同的 (当然除了一些自动化测试的场景，那些条件都是预先设置好的。)</p>\n<p>其实写好异步代码并不是绝对不可能的，毕竟苹果给我提供了非常强大的 API，相比较于其他平台这要好很多。不过问题在于编写复杂的异步代码很难，部分原因是因为苹果给我们提供了大量的 SDK，而且他们并不统一。如果使用 delegate 我们需要遵循特制的格式，block，NotificationCenter 等等都是这样的，所以并没有一种通用的、贯穿所有异步方法的 API，这样就导致读懂并且书写这样的异步代码很难。可以看下下图:</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1fr4342v718j31kw0nlgzj.jpg\" alt=\"\" /></p>\n<p>我们来比较两个代码片段来总结下这章。一个是异步一个是同步。</p>\n<h4 id=\"同步代码\"><a class=\"anchor\" href=\"#同步代码\">#</a> 同步代码</h4>\n<p>对数组的每个元素进行操作你应该很熟悉了吧，其实就是循环遍历嘛。这是一个非常简单而又坚实的功能，因为它保证了两件事:</p>\n<ul>\n<li>\n<p>它是同步执行的。</p>\n</li>\n<li>\n<p>在循环遍历时候他是不可变的</p>\n</li>\n</ul>\n<p>花点时间想想这意味着什么。当你遍历一个数组的时候，你不需要检查所有的元素是否仍然存在，并且您不需要重新返回，以防另一个线程在集合的开始插入一个元素。您假定您总是在循环的开始时遍历整个集合。试试以下代码:</p>\n<p><figure class=\"highlight smali\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var<span class=\"built_in\"> array </span>= [1, 2, 3]</span><br><span class=\"line\">for number in<span class=\"built_in\"> array </span>&#123;</span><br><span class=\"line\">  print(number)</span><br><span class=\"line\"> <span class=\"built_in\"> array </span>= [4, 5, 6]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">print(array)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 最后的输出结果：</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tKfTcgy1fr43rz56omj304p02at8i.jpg\" alt=\"\" /></p>\n<p>数组在 for 循环中是不可变的吗？执行顺序是什么？</p>\n<h4 id=\"异步代码\"><a class=\"anchor\" href=\"#异步代码\">#</a> 异步代码</h4>\n<p>再考虑一个类似的代码，如下用户通过点击事件触发下面代码，每次点击都会输出数组下一个元素，然后用户重复点击直到把数组所有的元素输出完成：<br />\n<figure class=\"highlight smali\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var<span class=\"built_in\"> array </span>= [1, 2, 3]</span><br><span class=\"line\">var currentIndex = 0</span><br><span class=\"line\"></span><br><span class=\"line\">//this method is connected in IB to a button</span><br><span class=\"line\">@IBAction func printNext(_ sender: Any) &#123;</span><br><span class=\"line\">  print(array[currentIndex])</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"built_in\"> if </span>currentIndex != array.count-1 &#123;</span><br><span class=\"line\">    currentIndex += 1</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 试想一下如果放在我们现实的 App 中真的可以这么执行吗？这个可说不准，因为如果在用户的两次点击之间又有其他的线程对这个数组进行了操作 (增加、删除元素) 那么数据就会发生错乱。而且如果 currentIndex 被另一个线程改变了那么你也不会得到预期的结果。</p>\n<p>其实多线程最重要的就是数据争夺的问题，然而 RxSwift 很好的解决了这个问题</p>\n",
            "tags": [
                "Swift"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-03-30-AlamoFire/",
            "url": "https://oliverqueen.cn/2018-03-30-AlamoFire/",
            "title": "AlamoFire的使用(下载队列，断点续传)",
            "date_published": "2018-03-30T09:54:38.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>最近开始做了一个新项目，几乎没有时间来写自己的博客，大部分都在写 feature（BUG），自己研究的东西很少，本来之前说好每个月要写两篇文章也没能坚持下来，最近在项目中遇到了一些问题，就在这里总结下吧。一些小的技巧而已，大神可以忽略了。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Alamofire/Alamofire/master/alamofire.png\" alt=\"\" /><br />\n<span id=\"more\"></span></p>\n<h2 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景</h2>\n<p>新项目包含了上传下载网络请求相关功能，由于是 swift 编写所以自然而然选择了 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FsYW1vZmlyZS9BbGFtb2ZpcmU=\">AlamoFire</span> (好像也没得选) 来做底层，正常的网络请求 post、get 等都是直接傻瓜式调用 AlamoFire 的接口，本文主要将一些细节问题</p>\n<h2 id=\"设置通用超时时间\"><a class=\"anchor\" href=\"#设置通用超时时间\">#</a> 设置通用超时时间</h2>\n<p>使用 Alamofire 发起请求时候有这两个接口</p>\n<p><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Creates a `DataRequest` using the default `SessionManager` to retrieve the contents of the specified `url`,</span></span><br><span class=\"line\"><span class=\"comment\">/// `method`, `parameters`, `encoding` and `headers`.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - parameter url:        The URL.</span></span><br><span class=\"line\"><span class=\"comment\">/// - parameter method:     The HTTP method. `.get` by default.</span></span><br><span class=\"line\"><span class=\"comment\">/// - parameter parameters: The parameters. `nil` by default.</span></span><br><span class=\"line\"><span class=\"comment\">/// - parameter encoding:   The parameter encoding. `URLEncoding.default` by default.</span></span><br><span class=\"line\"><span class=\"comment\">/// - parameter headers:    The HTTP headers. `nil` by default.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - returns: The created `DataRequest`.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">request</span>(<span class=\"keyword\">_</span> <span class=\"params\">url</span>: <span class=\"type\">URLConvertible</span>, <span class=\"params\">method</span>: <span class=\"type\">Alamofire</span>.<span class=\"type\">HTTPMethod</span> <span class=\"operator\">=</span> <span class=\"keyword\">default</span>, <span class=\"params\">parameters</span>: <span class=\"type\">Parameters</span>? <span class=\"operator\">=</span> <span class=\"keyword\">default</span>, <span class=\"params\">encoding</span>: <span class=\"type\">ParameterEncoding</span> <span class=\"operator\">=</span> <span class=\"keyword\">default</span>, <span class=\"params\">headers</span>: <span class=\"type\">HTTPHeaders</span>? <span class=\"operator\">=</span> <span class=\"keyword\">default</span>) -&gt; <span class=\"type\">Alamofire</span>.<span class=\"type\">DataRequest</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Creates a `DataRequest` using the default `SessionManager` to retrieve the contents of a URL based on the</span></span><br><span class=\"line\"><span class=\"comment\">/// specified `urlRequest`.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - parameter urlRequest: The URL request</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - returns: The created `DataRequest`.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">request</span>(<span class=\"keyword\">_</span> <span class=\"params\">urlRequest</span>: <span class=\"type\">URLRequestConvertible</span>) -&gt; <span class=\"type\">Alamofire</span>.<span class=\"type\">DataRequest</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 而我们在调用的时候通常会直接这么用</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> req : URLRequest = <span class=\"constructor\">URLRequest(<span class=\"params\">url</span>: URL(<span class=\"params\">fileURLWithPath</span>: <span class=\"string\">&quot;32&quot;</span>)</span>, cachePolicy: .useProtocolCachePolicy, timeoutInterval: <span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第一种方法调用，后面参数直接用default</span></span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Alamofire</span>.</span></span>request(<span class=\"constructor\">URL(<span class=\"params\">fileURLWithPath</span>: <span class=\"string\">&quot;32&quot;</span>)</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第二中调用，使传入request</span></span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Alamofire</span>.</span></span>request(req)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> semaphore = <span class=\"constructor\">DispatchSemaphore(<span class=\"params\">value</span>: 0)</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>其中第一种方法我们不能传入超时时间，第二中方法我们可以通过传入的 URLRequest 来设置超时时间，但是我们通常一个项目中大部分的请求，可能除了某些特殊的下载请求之外所有的超时时间都是一样的，这样的话我们需要同样的代码写好多遍，这个时候有两个办法</p>\n<ul>\n<li>\n<p>对生成 Request 的方法做一个封装，通用的参数如超时时间、header、请求方式 写死在方法里面，对于会变动的参数如 URL 和可以通过参数传入.</p>\n</li>\n<li>\n<p>创建  <code>Alamofire.SessionManager</code>  通过 sessionManager 来设置超时时间等一些通用的东西</p>\n</li>\n</ul>\n<p><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> networkManager : SessionManager = &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">config</span> : URLSessionConfiguration = URLSessionConfiguration<span class=\"variable\">.default</span></span><br><span class=\"line\">        <span class=\"keyword\">config</span><span class=\"variable\">.timeoutIntervalForRequest</span> = <span class=\"number\">10</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> manager = Alamofire<span class=\"variable\">.SessionManager</span><span class=\"variable\">.init</span>(configuration: <span class=\"keyword\">config</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> manager</span><br><span class=\"line\">    &#125;()</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"断点续传\"><a class=\"anchor\" href=\"#断点续传\">#</a> 断点续传</h2>\n<p>Alamofire 支持断点续传下载，原理就是将下载一半的数据保存到本地，然后下次再启动时候通过 data 的拼接来进行继续下载。用法也很简单，只是调用接口而已，关键是看开发者如何自己去维护这个已下载的数据，比如是存内存还是存硬盘，要存多久，淘汰策略是什么之类的。其实就是两个步骤， 断点和续传</p>\n<h4 id=\"第一步-断点\"><a class=\"anchor\" href=\"#第一步-断点\">#</a> 第一步 断点</h4>\n<p>监听下载中断，中断后将已经下载的数据进行保留，我这边用一个属性来存，具体到项目实现大家可以采用自己存储方式，存到硬盘或者数据库之类的</p>\n<p><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Alamofire<span class=\"selector-class\">.download</span>(<span class=\"string\">&quot;http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4&quot;</span>, method: <span class=\"selector-class\">.get</span>, parameters: nil, encoding: URLEncoding<span class=\"selector-class\">.default</span>, headers: nil) &#123; (url, response) -&gt; (destinationURL: URL, options: DownloadRequest.DownloadOptions) <span class=\"keyword\">in</span></span><br><span class=\"line\">            return (<span class=\"built_in\">URL</span>(fileURLWithPath: <span class=\"built_in\">String</span>(describing : <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"selector-class\">.documentDirectory</span>, <span class=\"selector-class\">.userDomainMask</span>, false)<span class=\"selector-attr\">[0]</span>+<span class=\"string\">&quot;123.mp4&quot;</span>)), <span class=\"selector-attr\">[.createIntermediateDirectories, .removePreviousFile]</span>)</span><br><span class=\"line\">            &#125;<span class=\"selector-class\">.responseJSON</span> &#123; (response) <span class=\"keyword\">in</span></span><br><span class=\"line\"></span><br><span class=\"line\">                switch response<span class=\"selector-class\">.result</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                case <span class=\"selector-class\">.success</span>:</span><br><span class=\"line\">                    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;success&quot;</span>)</span><br><span class=\"line\">                case <span class=\"selector-class\">.failure</span>:</span><br><span class=\"line\">                    <span class=\"comment\">//意外中断后在此处处理下载完成的部分</span></span><br><span class=\"line\">                    self<span class=\"selector-class\">.tmpData</span> = response<span class=\"selector-class\">.resumeData</span></span><br><span class=\"line\"></span><br><span class=\"line\">                default:</span><br><span class=\"line\">                    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;failed&quot;</span>)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"第二步-续传\"><a class=\"anchor\" href=\"#第二步-续传\">#</a> 第二步 续传</h4>\n<p>当下载再次启动时候，需要在上一步数据的基础上继续下载，我们调用 Alamofire 这个方法<br />\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Creates a `DownloadRequest` using the default `SessionManager` from the `resumeData` produced from a</span></span><br><span class=\"line\"><span class=\"comment\">/// previous request cancellation to retrieve the contents of the original request and save them to the `destination`.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// If `destination` is not specified, the contents will remain in the temporary location determined by the</span></span><br><span class=\"line\"><span class=\"comment\">/// underlying URL session.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// On the latest release of all the Apple platforms (iOS 10, macOS 10.12, tvOS 10, watchOS 3), `resumeData` is broken</span></span><br><span class=\"line\"><span class=\"comment\">/// on background URL session configurations. There&#x27;s an underlying bug in the `resumeData` generation logic where the</span></span><br><span class=\"line\"><span class=\"comment\">/// data is written incorrectly and will always fail to resume the download. For more information about the bug and</span></span><br><span class=\"line\"><span class=\"comment\">/// possible workarounds, please refer to the following Stack Overflow post:</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">///    - http://stackoverflow.com/a/39347461/1342462</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - parameter resumeData:  The resume data. This is an opaque data blob produced by `URLSessionDownloadTask`</span></span><br><span class=\"line\"><span class=\"comment\">///                          when a task is cancelled. See `URLSession -downloadTask(withResumeData:)` for additional</span></span><br><span class=\"line\"><span class=\"comment\">///                          information.</span></span><br><span class=\"line\"><span class=\"comment\">/// - parameter destination: The closure used to determine the destination of the downloaded file. `nil` by default.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - returns: The created `DownloadRequest`.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">download</span>(<span class=\"params\">resumingWith</span> <span class=\"params\">resumeData</span>: <span class=\"type\">Data</span>, <span class=\"params\">to</span> <span class=\"params\">destination</span>: <span class=\"type\">Alamofire</span>.<span class=\"type\">DownloadRequest</span>.<span class=\"type\">DownloadFileDestination</span>? <span class=\"operator\">=</span> <span class=\"keyword\">default</span>) -&gt; <span class=\"type\">Alamofire</span>.<span class=\"type\">DownloadRequest</span></span><br></pre></td></tr></table></figure><br />\n 这个接口需要我们传入已存在的数据，然后基于我们传入的数据进行下载，它支持从新指定目的地路径，如果你有需要可以重新指定<br />\n <figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Alamofire.download(resumingWith: tmpData!)</span><br></pre></td></tr></table></figure><br />\n 同样他返回一个 request 的对象，我们可以通过点语法来拿到进度、response 等信息</p>\n<h2 id=\"批量下载\"><a class=\"anchor\" href=\"#批量下载\">#</a> 批量下载</h2>\n<p>当我们需要同时下载很多东西的时候，往往需要我们自己维护一个下载队列，比如下一个载素材列表之类的。Alamo 给我们提供了下载的接口，但是下载的线程队列需要我们自己去维护，其实就是一个多线程并发队列。</p>\n<h4 id=\"gcd\"><a class=\"anchor\" href=\"#gcd\">#</a> GCD</h4>\n<p>我们很自然而然的想到 GCD，但是 GCD 有一个问题无法控制最大并发数，而且对队列的管理也并不完善，比如我们要下载 100 个文件，如果同时下载的话开辟 100 个线程，那肯定是不行的，先不说移动设备是否支持 (最多 70 个左右)，即使支持了那这个开销太大。虽说 GCD 的话可以使用信号量进行线程控制，但是每个线程的暂停启动之类的又是问题，而且毕竟是曲线救国的方法。</p>\n<h4 id=\"operationqueue\"><a class=\"anchor\" href=\"#operationqueue\">#</a> OperationQueue</h4>\n<p>Operation 及 OperationQueue 是基于 GCD 封装的对象，作为对象可以提供更多操作选择，可以用方法或 block 实现多线程任务，同时也可以利用继承、类别等进行一些其他操作；但同时实现代码相对复杂一些。但是他毕竟不像 GCD 那样使用 C 语言实现，所以效率会相比 GCD 低一些。但是对线程的控制的灵活性要远高于 GCD，对于下载线程来说可以优先选择这个。</p>\n<h4 id=\"实现\"><a class=\"anchor\" href=\"#实现\">#</a> 实现</h4>\n<p>我们把每一个下载任务封装成一个 operation。注意 Operation 不能直接使用，我们需要使用他的子类，这里我选择使用  <code>BlockOperation</code>  他的闭包则是需要执行的下载任务，然后我们把他添加进 queue 中便开始执行了任务</p>\n<p><figure class=\"highlight roboconf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let op : BlockOperation = BlockOperation &#123; [<span class=\"attribute\">weak self] in</span></span><br><span class=\"line\"><span class=\"attribute\">            Alamofire.download(&quot;http</span>://clips<span class=\"variable\">.vorwaerts-gmbh</span><span class=\"variable\">.de</span>/big_buck_bunny<span class=\"variable\">.mp</span>4&quot;, method: <span class=\"variable\">.get</span>, parameters: nil, encoding: URLEncoding<span class=\"variable\">.default</span>, headers: nil) &#123; (url, response) -&gt; (destinationURL: URL, options: DownloadRequest<span class=\"variable\">.DownloadOptions</span>) in</span><br><span class=\"line\">                return (URL(fileURLWithPath: String(describing : NSSearchPathForDirectoriesInDomains(<span class=\"variable\">.documentDirectory</span>, <span class=\"variable\">.userDomainMask</span>, false)[0]+&quot;123<span class=\"variable\">.mp</span>4&quot;)), [<span class=\"variable\">.createIntermediateDirectories</span>, <span class=\"variable\">.removePreviousFile</span>])</span><br><span class=\"line\">                &#125;<span class=\"variable\">.downloadProgress</span> &#123; [weak self] (pro) in</span><br><span class=\"line\">                    let percent = Float(pro<span class=\"variable\">.completedUnitCount</span>) / Float(pro<span class=\"variable\">.totalUnitCount</span>)</span><br><span class=\"line\">                    if count == 0 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                        self?<span class=\"variable\">.downLoadLabel</span><span class=\"variable\">.snp</span><span class=\"variable\">.remakeConstraints</span> &#123; (make) in</span><br><span class=\"line\">                            make<span class=\"variable\">.width</span><span class=\"variable\">.equalTo</span>(300 * percent)</span><br><span class=\"line\">                            make<span class=\"variable\">.height</span><span class=\"variable\">.equalTo</span>(30)</span><br><span class=\"line\">                            make<span class=\"variable\">.top</span><span class=\"variable\">.equalTo</span>((self?<span class=\"variable\">.stopButton</span><span class=\"variable\">.snp</span><span class=\"variable\">.bottom</span>)!)<span class=\"variable\">.offset</span>(30)</span><br><span class=\"line\">                            make<span class=\"variable\">.left</span><span class=\"variable\">.equalToSuperview</span>()<span class=\"variable\">.offset</span>(30)</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; else &#123;</span><br><span class=\"line\">                        self?<span class=\"variable\">.downLoadLabel</span>2<span class=\"variable\">.snp</span><span class=\"variable\">.remakeConstraints</span> &#123; (make) in</span><br><span class=\"line\">                            make<span class=\"variable\">.width</span><span class=\"variable\">.equalTo</span>(300 * percent)</span><br><span class=\"line\">                            make<span class=\"variable\">.height</span><span class=\"variable\">.equalTo</span>(30)</span><br><span class=\"line\">                            make<span class=\"variable\">.top</span><span class=\"variable\">.equalTo</span>((self?<span class=\"variable\">.downLoadLabel</span><span class=\"variable\">.snp</span><span class=\"variable\">.bottom</span>)!)<span class=\"variable\">.offset</span>(30)</span><br><span class=\"line\">                            make<span class=\"variable\">.left</span><span class=\"variable\">.equalToSuperview</span>()<span class=\"variable\">.offset</span>(30)</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;<span class=\"variable\">.responseJSON</span> &#123; (response) in</span><br><span class=\"line\"></span><br><span class=\"line\">                    switch response<span class=\"variable\">.result</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    case <span class=\"variable\">.success</span>:</span><br><span class=\"line\">                        print(&quot;success&quot;)</span><br><span class=\"line\">                    case <span class=\"variable\">.failure</span>:</span><br><span class=\"line\">                        self?<span class=\"variable\">.tmpData</span> = response<span class=\"variable\">.resumeData</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    default:</span><br><span class=\"line\">                        print(&quot;failed&quot;)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        queue<span class=\"variable\">.addOperation</span>(op)</span><br></pre></td></tr></table></figure><br />\n 每一个 opeeation 对象我们都可以设置他的优先级、启动、暂停、等属性，简单的调用接口就可以，在此就不一一作解释了。然后我们需要对我们的 queue 进行设置，我们设置最大并发数，大家可以根据实际情况来设置，demo 中我只有两个下载任务，所以我就设置最大并发数为 1 这样就是一个一个下载。<br />\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"built_in\">queue</span> : OperationQueue = &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> que : OperationQueue = OperationQueue()</span><br><span class=\"line\">        que.maxConcurrentOperationCount = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> que</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 我们运行然后点击开始下载</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fpw0vlzbp6g308h0gnkjm.gif\" alt=\"\" /></p>\n<p>很奇怪我们发现他还是同时下载，我们又试了其他的个数，无论多少都是同时下载，最大线程数量完全不起作用，再反过来看下上面加入 queue 的任务。正常来说每一个 operation 都要等上一个 operation 完成后才会执行，而系统判断完成的标准就是上一个 operation 的闭包走完，我们闭包中放入的是一个下载任务，而 Alamofire 的下载都是异步执行，所以导致 operation 的闭包走完了，但是其实下载是异步在另一个线程执行的，实际上下载没有完成，知道原因我们对症下药，只需要保证 operation 闭包中的代码是同步执行的就 OK 了。而 Alamofire 是基于 URLSession 来实现的，并没有像 connection 那样提供同步的方法，所以我们使用信号量卡一下，像这样</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fpw1444jp0j31610qbgrr.jpg\" alt=\"\" /></p>\n<p>这样之后就会按照我们设置好的队列进行了</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fpw15riwhjg308h0gnb2i.gif\" alt=\"\" /></p>\n<p>有人会说下载同步进行会不会有影响，其实不会的首先我们实现同步的方式是信号量，本质上还是异步的只是我们阻塞的当前的下载线程，这个被阻塞线程一定不是主线程 (除非 Alamofire 的开发者把他回调到主线程下载，这个基本不可能)，而且当我们把这个下载任务加到一个 operation 中之后，就注定不会在主线程中了，没一个 operation 都会被系统分配到一个非主线程的地方去做，所以这样不会性能有任何影响。</p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>因为时间紧迫，暂时做了这么多，也遇到了这些问题，所以写出了总结下，本文还会继续更新，会慢慢的整个网络层分享出来。就是可能更新会慢，毕竟工作量有点饱和。多谢关注</p>\n<p>\n        <div id=\"aplayer-bwMrXBRX\" class=\"aplayer aplayer-tag-marker\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t  <script>\n\t\t\t\t  var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":0,\"mutex\":true,\"music\":[{\"title\":\"Thank You Very Much\",\"author\":\"Margaret\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/Thankyou.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M000000VbGX83hRicw.jpg?max_age=2592000\",\"lrc\":\"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=001Ii3g54dIYpO\"}]};\n\t\t\t\t  options.element = document.getElementById(\"aplayer-bwMrXBRX\");\n\t\t\t\t  var ap = new APlayer(options);\n\t\t\t    window.aplayers || (window.aplayers = []);\n\t\t\t\t  window.aplayers.push(ap);\n\t\t\t  </script></p>\n",
            "tags": [
                "swift",
                "网络请求"
            ]
        }
    ]
}