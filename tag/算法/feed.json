{
    "version": "https://jsonfeed.org/version/1",
    "title": "Molier • All posts by \"算法\" tag",
    "description": "iOS 开发 移动App 博客 杂谈 随笔 相册",
    "home_page_url": "https://oliverqueen.cn",
    "items": [
        {
            "id": "https://oliverqueen.cn/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%F0%9F%98%8A/",
            "url": "https://oliverqueen.cn/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%F0%9F%98%8A/",
            "title": "位运算的简单理解😊",
            "date_published": "2018-01-19T06:20:39.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"1背景\"><a class=\"anchor\" href=\"#1背景\">#</a> 1：背景</h2>\n<p>从现代计算机中所有的数据二进制的形式存储在设备中。即 0、1 两种状态，计算机对二进制数据进行的运算 (+、-、*、/) 都是叫位运算，即将符号位共同参与运算的运算。</p>\n<p>我们每一种语言最终都会通过编译器转换成机器语言来执行，所以直接使用底层的语言就不需要便编译器的转换工作从而得到更高的执行效率，当然可读性可能会降低，这也是为什么汇编在大部分情况下有更快的速度。项目中合理的运用位运算能提高我们代码的执行效率。</p>\n<p>在 iOS 系统中位运算多见于枚举中，其他地方很少见，因为位运算是底层的计算机语言，而在 iOS 开发中不管是 Objective—C 还是 Swift 都属于高级的编程语言，大量的位运算都被苹果封装了起来，我们只关心调用的接口不用关心内部的实现。</p>\n<p><figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_OPTIONS</span>(<span class=\"type\">NSUInteger</span>, <span class=\"type\">NSLayoutFormatOptions</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllLeft</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeLeft</span>),</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllRight</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeRight</span>),</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllTop</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeTop</span>),</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllBottom</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeBottom</span>),</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllLeading</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeLeading</span>),</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllTrailing</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeTrailing</span>),</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br />\n<span id=\"more\"></span></p>\n<h2 id=\"10计算机计算原理\"><a class=\"anchor\" href=\"#10计算机计算原理\">#</a> 10：计算机计算原理</h2>\n<h4 id=\"加法和乘法\"><a class=\"anchor\" href=\"#加法和乘法\">#</a> 加法和乘法</h4>\n<p>举一个简单的例子来看下 CPU 是如何进行计算的，比如这行代码</p>\n<p><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">int a</span> = 35;</span><br><span class=\"line\"><span class=\"attribute\">int b</span> = 47;</span><br><span class=\"line\"><span class=\"attribute\">int c</span> = a + b;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 计算两个数的和，因为在计算机中都是以二进制来进行运算，所以上面我们所给的 int 变量会在机器内部先转换为二进制在进行相加</p>\n<p><figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">35: <span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>0<span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>1</span><br><span class=\"line\">47: <span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>0<span class=\"number\"> 1 </span>1<span class=\"number\"> 1 </span>1</span><br><span class=\"line\">————————————————————</span><br><span class=\"line\">82: <span class=\"number\"> 0 </span>1<span class=\"number\"> 0 </span>1<span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>0</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>再来看下乘法，执行如下的代码</p>\n<p><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a = 3;</span><br><span class=\"line\">int b = 2;</span><br><span class=\"line\">int c = a <span class=\"emphasis\">* b;</span></span><br><span class=\"line\"><span class=\"emphasis\"></span></span><br><span class=\"line\"><span class=\"emphasis\">3:  0 0 0 0 0 0 1 1  *</span>  2</span><br><span class=\"line\">————————————————————</span><br><span class=\"line\">6:  0 0 0 0 0 1 1 0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"emphasis\">*</span></span><br><span class=\"line\"><span class=\"emphasis\"></span></span><br><span class=\"line\"><span class=\"emphasis\">int a = 3;</span></span><br><span class=\"line\"><span class=\"emphasis\">int b = 4;</span></span><br><span class=\"line\"><span class=\"emphasis\">int c = a *</span> b;</span><br><span class=\"line\"></span><br><span class=\"line\">3:  0 0 0 0 0 0 1 1  <span class=\"emphasis\">*  4</span></span><br><span class=\"line\"><span class=\"emphasis\">————————————————————</span></span><br><span class=\"line\"><span class=\"emphasis\">12:  0 0 0 0 1 1 0 0</span></span><br><span class=\"line\"><span class=\"emphasis\"></span></span><br><span class=\"line\"><span class=\"emphasis\"><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span>*</span></span><br><span class=\"line\"></span><br><span class=\"line\">int a = 3;</span><br><span class=\"line\">int b = 8;</span><br><span class=\"line\">int c = a <span class=\"emphasis\">* b;</span></span><br><span class=\"line\"><span class=\"emphasis\"></span></span><br><span class=\"line\"><span class=\"emphasis\">3:  0 0 0 0 0 0 1 1  *</span>  8</span><br><span class=\"line\">————————————————————</span><br><span class=\"line\">24:  0 0 0 1 1 0 0 0</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 通过以上运算可以看出当用 a 乘 b，且如果 b 满足 2^N 的时候 就相当于把 a 的二进制数据向左移动 N 位，放到代码中 我们可以这样来写 <strong>a &lt;&lt; N</strong>, 所以上面<strong> 3 * 2、3 * 4、3 * 8</strong> 其实是可以写成<strong> 3&lt;&lt;1、3&lt;&lt;2、3&lt;&lt;3</strong>，运算结果都是一样的。</p>\n<p>那假如相乘的两个数都不满足 2<sup>N 怎么办呢？其实这个时候编译器会将其中一个数拆分成多个满足 2</sup>N 的数相加的情况，打个比方</p>\n<p><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> a = <span class=\"number\">15</span>;\t\t\t\t<span class=\"built_in\">int</span> a = <span class=\"number\">15</span></span><br><span class=\"line\"><span class=\"built_in\">int</span> b = <span class=\"number\">13</span>;      =&gt;    \t<span class=\"built_in\">int</span> b = (<span class=\"number\">4</span> + <span class=\"number\">8</span> + <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"built_in\">int</span> c = a * b;\t\t\t<span class=\"built_in\">int</span> c = a * b</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 最后其实执行相乘运算就会变成这样 <strong>15 * 4 + 15 * 8 + 15 * 1</strong>，按照上文说的移位来转换为位运算就会变成<strong> 15 &lt;&lt; 2 + 15 &lt;&lt; 3 + 15 &lt;&lt; 0</strong></p>\n<h4 id=\"减法和除法\"><a class=\"anchor\" href=\"#减法和除法\">#</a> 减法和除法</h4>\n<p>减法也是与加法同理只不过计算机内减法操作就是加上一个数的负数形式，且在操作系统中都是以补码的形式进行操作 (因为正数的源码补码反码都与本身相同)。首先，因为人脑可以知道第一位是符号位，在计算的时候我们会根据符号位，选择对真值区域的加减。但是对于计算机，加减乘数已经是最基础的运算，要设计的尽量简单。计算机辨别 &quot;符号位&quot; 显然会让计算机的基础电路设计变得十分复杂！于是人们想出了将符号位也参与运算的方法。我们知道，根据运算法则减去一个正数等于加上一个负数，即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法，这样计算机运算的设计就更简单了.</p>\n<p>除法的话其实和乘法原理相同，不过乘法是左移而除法是右移，但是除法的计算量要比乘法大得多，其大部分的消耗都在拆分数值，和处理小数的步骤上，所以如果我们在进行生成变量的时候如果遇到多位的小数我们尽量把他换成 string 的形式，这也是为什么浮点运算会消耗大量的时钟周期 (操作系统中每进行一个移位或者加法运算的过程所消耗的时间就是一个时钟周期，3.0GHz 频率的 CPU 可以在一秒执行运算 3.0<em>1024</em>1024*1024 个时钟周期)</p>\n<h2 id=\"11位运算符\"><a class=\"anchor\" href=\"#11位运算符\">#</a> 11：位运算符</h2>\n<p>使用的运算符包括下面：</p>\n<table>\n<thead>\n<tr>\n<th>含义</th>\n<th>运算符</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>左移</td>\n<td>&lt;&lt;</td>\n<td>0011  =&gt;  0110</td>\n</tr>\n<tr>\n<td>右移</td>\n<td>&gt;&gt;</td>\n<td>0110  =&gt;  0011</td>\n</tr>\n<tr>\n<td>按位或</td>\n<td>︳</td>\n<td>0011 &lt;br&gt; -------  =&gt; 1011&lt;br&gt;1011</td>\n</tr>\n<tr>\n<td>按位与</td>\n<td>&amp;</td>\n<td>0011 &lt;br&gt; -------  =&gt; 1011&lt;br&gt;1011</td>\n</tr>\n<tr>\n<td>按位取反</td>\n<td>~</td>\n<td>0011  =&gt; 1100</td>\n</tr>\n<tr>\n<td>按位异或 (相同为零不同为一)</td>\n<td>^</td>\n<td>0011 &lt;br&gt; -------  =&gt; 1000&lt;br&gt;1011</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"100颜色转换\"><a class=\"anchor\" href=\"#100颜色转换\">#</a> 100：颜色转换</h2>\n<h4 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景</h4>\n<p>上面说了 iOS 中经常见到的位运算的地方是在枚举中，那么颜色转换应该是除了枚举之外第二比较常用位运算的场景。打个比方设计师再给我们出设计稿的时候通常会在设计稿上按照 16 进制的样子给我们标色值。但是 iOS 中的 UIColor 并不支持使用十六进制的数据来初始化。所以我们需要将十六进制的色值转换为 UIColor。</p>\n<h4 id=\"原理分析\"><a class=\"anchor\" href=\"#原理分析\">#</a> 原理分析</h4>\n<p>UIColor 中通常是用传入 RGB 的数值来初始化，而且每个颜色的取值范围是十进制下的 0~255，而设计同学又给的是十六进制数据，所以在操作系统中需要把这两种进制的数据统一成二进制来进行计算，这就用到了位运算。这里用一个十六进制的色值来举例子比如<strong> 0xffa131</strong> 我们要转换就要先理解其组成</p>\n<ul>\n<li>\n<p>0x 或者 0X：十六进制的标识符，表示这个后面是个十六进制的数值，对数值本身没有任何意义</p>\n</li>\n<li>\n<p>ff 颜色中的 R 值，转换为二进制为 1111 1111</p>\n</li>\n<li>\n<p>a1 颜色中的 G 值，转换为二进制为 1010 0001</p>\n</li>\n<li>\n<p>31 颜色中的 B 值，转换为二进制为 0011 0001</p>\n</li>\n<li>\n<p>上述色彩值转换为二进制后为<strong> 1111 1111 1010 0001 0011 0001 (每一位十六进制的对应 4 位二进制，如果位数不够记得高位补零)</strong></p>\n</li>\n</ul>\n<p>通常来讲十六进制的颜色是按照上面的 RGB 的顺序排列的，但是并不固定，有时候可能会在其中加 A (Alpha) 值，具体情况按照设计为准，本文以通用情况举例。</p>\n<p>综上，我们只需把对应位的值转换为 10 进制然后 / 255.0f 就可得到 RGB 色彩值，从而转换为 UIColor</p>\n<h4 id=\"转换代码\"><a class=\"anchor\" href=\"#转换代码\">#</a> 转换代码</h4>\n<p>先列出代码，后续解析</p>\n<p><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (UIColor *)colorWithHex:(<span class=\"type\">long</span>)hexColor <span class=\"built_in\">alpha</span>:(<span class=\"type\">float</span>)opacity</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//将传入的十六进制颜色0xffa131 转换为UIColor</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">float</span> <span class=\"built_in\">red</span> = ((hexColor &amp; <span class=\"number\">0xFF0000</span>) &gt;&gt; <span class=\"number\">16</span>)/<span class=\"number\">255.0</span>f;</span><br><span class=\"line\">    <span class=\"type\">float</span> <span class=\"built_in\">green</span> = ((hexColor &amp; <span class=\"number\">0xFF00</span>) &gt;&gt; <span class=\"number\">8</span>)/<span class=\"number\">255.0</span>f;</span><br><span class=\"line\">    <span class=\"type\">float</span> <span class=\"built_in\">blue</span> = (hexColor &amp; <span class=\"number\">0xFF</span>)/<span class=\"number\">255.0</span>f;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [UIColor colorWithRed:<span class=\"built_in\">red</span> <span class=\"built_in\">green</span>:<span class=\"built_in\">green</span> <span class=\"built_in\">blue</span>:<span class=\"built_in\">blue</span> <span class=\"built_in\">alpha</span>:opacity];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 大概原理可以看出将 RGB 每个值都解析出来然后变成 UIColor，先拿第一步转换红色值来说，我们按照运算顺序一步步来讲 (默认将参数代入，用 0xffa131 代替 hexColor)</p>\n<ul>\n<li>\n<p><strong>0xffa131 &amp; 0xFF0000</strong></p>\n<p>我们知道红色值是前两位也就是<strong> ff</strong>，所以这一步我们既然要取出红色值就要把其他位全部置零来排除干扰，这步操作便是如此，在计算机系统内是二进制来实现的，即：&lt;br&gt;<br />\n1111 1111 1010 0001 0011 0001&lt;br&gt;-------------------------------------------  =&gt; &amp; =&gt; 1111 1111 0000 0000 0000&lt;br&gt;<br />\n1111 1111 0000 0000 0000 0000&lt;br&gt; 这部操作做完后可以看出将除了 R 值之外的 G 值 B 值全部置零了，但是离最终结果还差点，因为 0xFF 是 1111 1111，而我们的结果后面多出了 16 个 0，所以便有了第二步操作</p>\n</li>\n<li>\n<p><strong>&gt;&gt; 16</strong></p>\n<p>将上一步得到的结果右移 16 位即得到<strong> 0000 0000 0000 0000 1111 1111</strong> 高位的零可以忽略，这也是最终的结果</p>\n</li>\n<li>\n<p><strong>/ 255.0f</strong></p>\n<p>这一步应该都知道 UIColor 中传入的数值范围在 0~1，所以我们要做下转换</p>\n</li>\n<li>\n<p>后续的 G 值和 B 值都是一样的，只是大家注意位数就可以了，<strong>值得注意的是两个二进制数进行位运算一定保证两个数的位数相同，位数不够的那个数高位要用 0 补齐</strong></p>\n</li>\n</ul>\n<h2 id=\"101枚举\"><a class=\"anchor\" href=\"#101枚举\">#</a> 101：枚举</h2>\n<p>关于枚举中使用位运算我们之前也讲过，下面我们自己来写一个枚举 (伪代码)</p>\n<p><figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_OPTIONS</span>(<span class=\"type\">NSUInteger</span>, <span class=\"type\">TestOptions</span>) &#123;</span><br><span class=\"line\">     <span class=\"type\">TestOptionOne</span>     =    1 &lt;&lt; 0, （000001)</span><br><span class=\"line\"></span><br><span class=\"line\">  \t <span class=\"type\">TestOptionTwo</span>     =    1 &lt;&lt; 1,\t(000010)</span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"type\">TestOptionThree</span>   =    1 &lt;&lt; 2,\t(000100)</span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"type\">TestOptionFour</span>    =    1 &lt;&lt; 3,\t(001000)</span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"type\">TestOptionFive</span>    =    1 &lt;&lt; 4,\t(010000)</span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"type\">TestOptionSix</span>     =    1 &lt;&lt; 5,\t(100000)</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>解析<br />\n上面的枚举我后面用括号表明了位移后对应的二进制的值。这样写枚举的好处是我可以对其中选项多选比如<strong> TestOptionOne | TestOptionTwo （000001 | 000010 =&gt; 000011）</strong> 或者有其他的自定义组合。</li>\n</ul>\n<h2 id=\"110加密\"><a class=\"anchor\" href=\"#110加密\">#</a> 110：加密</h2>\n<p>在 iOS 中我们可以利用异或来进行加解密，异或的特性如下<br />\n <figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A ^ B = <span class=\"function\"><span class=\"params\">C</span> =&gt;</span> C ^ A = <span class=\"function\"><span class=\"params\">B</span> =&gt;</span> C ^ B = A</span><br></pre></td></tr></table></figure><br />\n 上文我们可以把 A 认为是需要加密的数据，B 认为是密钥 C 是加密后的数据<br />\n比如:</p>\n<p><figure class=\"highlight prolog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   char a[]=<span class=\"string\">&quot;MyPassword&quot;</span>;        <span class=\"comment\">/*要加密的密码*/</span></span><br><span class=\"line\">   char b[]=<span class=\"string\">&quot;cryptographic&quot;</span>;     <span class=\"comment\">/*密钥*/</span></span><br><span class=\"line\">   int i;</span><br><span class=\"line\">   <span class=\"comment\">/*加密代码*/</span></span><br><span class=\"line\">   for(i=<span class=\"number\">0</span>;a[i]!=<span class=\"string\">&#x27;\\0&#x27;</span>;i++)</span><br><span class=\"line\">a[i]=a[i]^b[i];</span><br><span class=\"line\">   printf(<span class=\"string\">&quot;You Password encrypted: %s\\n&quot;</span>,a);</span><br><span class=\"line\">   <span class=\"comment\">/*解密代码*/</span></span><br><span class=\"line\">   for(i=<span class=\"number\">0</span>;a[i]!=<span class=\"string\">&#x27;\\0&#x27;</span>;i++)</span><br><span class=\"line\">a[i]=a[i]^b[i];</span><br><span class=\"line\">   printf(<span class=\"string\">&quot;You Password: %s\\n&quot;</span>,a);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"111其他应用\"><a class=\"anchor\" href=\"#111其他应用\">#</a> 111：其他应用</h2>\n<ul>\n<li>记得 iOS 总有一道面试题<strong>在不使用第三个变量的情况下交换两个变量的值</strong>，这里用到异或的上面加解密中的特性。我有 x、y 两个个变量，做如下位运算操作</li>\n</ul>\n<p><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">void</span> exchange(int x , int y)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attribute\">x</span><span class=\"regexp\"> ^=</span> y;</span><br><span class=\"line\">    <span class=\"attribute\">y</span><span class=\"regexp\"> ^=</span> x;</span><br><span class=\"line\">    <span class=\"attribute\">x</span><span class=\"regexp\"> ^=</span> y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>判断一个数的奇偶性，其实我们可以用 **%2** 来判断，代码量不高，但是之前讲过，除法运算的时钟周期非常多，所以代码虽然不多并不代表效率高，我们可以用如下运算来完成:</li>\n</ul>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x&amp;<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;奇数&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;偶数&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 原理很简单，因为二进制是满二进一，一旦超过 1 就会变 0 并进一位，这时候和 00001 做 **&amp;** 操作一定会为 0，反之不为零。这样写效率会更高。</p>\n<ul>\n<li>计算两个数的平均值，通常我们都是（x+y）/2, 先不考虑效率问题，这样还会引起一个其他的问题，那就是 x+y 的值很有可能溢出大于 INT_MAX，所以我们采用位运算的办法来解决即可：</li>\n</ul>\n<p><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">average</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (x&amp;y)+((x^y)&gt;&gt;<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"1000总结\"><a class=\"anchor\" href=\"#1000总结\">#</a> 1000：总结</h2>\n<p>其实位运算的应用远远不止这些，在算法方面适当的使用还是很有帮助的。</p>\n",
            "tags": [
                "算法",
                "C语言",
                "排序"
            ]
        }
    ]
}