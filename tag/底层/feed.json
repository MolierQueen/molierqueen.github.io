{
    "version": "https://jsonfeed.org/version/1",
    "title": "Molier • All posts by \"底层\" tag",
    "description": "iOS 开发 移动App 博客 杂谈 随笔 相册",
    "home_page_url": "https://oliverqueen.cn",
    "items": [
        {
            "id": "https://oliverqueen.cn/2018-01-24-%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%85%A8%E7%9A%84iOS%E7%AB%AFHttpDns%E9%9B%86%E6%88%90%E6%96%B9%E6%A1%88/",
            "url": "https://oliverqueen.cn/2018-01-24-%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%85%A8%E7%9A%84iOS%E7%AB%AFHttpDns%E9%9B%86%E6%88%90%E6%96%B9%E6%A1%88/",
            "title": "可能是最全的iOS端HttpDns集成方案",
            "date_published": "2018-01-24T05:54:36.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"科普片\"><a class=\"anchor\" href=\"#科普片\">#</a> 科普片</h1>\n<h5 id=\"1-dns劫持的危害\"><a class=\"anchor\" href=\"#1-dns劫持的危害\">#</a> 1、DNS 劫持的危害</h5>\n<p>不知道大家有没有发现这样一个现象，在打开一些网页的时候会弹出一些与所浏览网页不相关的内容比如这样奇 (se) 怪 (qing) 的东西</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6jm5b190j30h60ugqkg.jpg\" alt=\"图一\" /></p>\n<p>或者这样<br />\n<span id=\"more\"></span></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6jmr1afuj30ww0ue4qp.jpg\" alt=\"图二\" />，</p>\n<p>其实造成这样的原因就是 DNS 劫持，在我们正常浏览的网页链接里面被恶意插入一些奇怪的东西。不止是这些，DNS 劫持还会对我们的个人信息安全造成很大的伤害，钓鱼网站之类的，也许我们所访问的网站根本不是我们需要的网站，或者根本打不开网页，有时还会消耗我们过多的流量。</p>\n<h5 id=\"2-什么是dns解析\"><a class=\"anchor\" href=\"#2-什么是dns解析\">#</a> 2、什么是 DNS 解析</h5>\n<p>现在假如我们访问一个网站 www.baidu.com 从按下回车到百度页面显示到我们的电脑上会经历如下几个步骤</p>\n<ul>\n<li>1：计算机会向我们的运营商 (移动、电信、联通等) 发出打开 www.baidu.com 的请求。</li>\n<li>2：运营商收到请求后会到自己的 DNS 服务器中找 www.baidu.com 这个域名所对应的服务器的 IP 地址 (也就是百度的服务器的 IP 地址)，这里比如是 180.149.132.47。</li>\n<li>3：运营商用第二步得到的 IP 地址去找到百度的服务器请求得到数据后返回给我们。</li>\n</ul>\n<p>其中第二步就是我们所说的 DNS 解析过程，域名和 IP 地址的关系其实就是我们的身份证号和姓名的关系，都是来标记一个人或者是一个网站的，只是 IP 地址 \\ 身份证号只是一串没有意义的数字，辨识度低，又不好记，所以就会在 IP 上加上一个域名以便区分，或是做的更加个性化，但是如果真的要来准确的区分还是要靠身份证号码或者是 IP 的，所以 DNS 解析就应运而生了。</p>\n<h5 id=\"3什么是dns劫持\"><a class=\"anchor\" href=\"#3什么是dns劫持\">#</a> 3：什么是 DNS 劫持</h5>\n<p>DNS 劫持，是指在 DNS 解析过程中拦截域名解析的请求，然后做一些自己的处理，比如返回假的 IP 地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能反应或访问的是假网址。根本原因就是以下两点：</p>\n<ul>\n<li>1：恶意攻击，拦截运营商的解析过程，把自己的非法东西嵌入其中。</li>\n<li>2：运营商为了利益或者一些其他的因素，允许一些第三方在自己的链接里打打广告之类的。</li>\n</ul>\n<h5 id=\"4防止dns劫持\"><a class=\"anchor\" href=\"#4防止dns劫持\">#</a> 4：防止 DNS 劫持</h5>\n<p>了解了 DNS 劫持的相关资料后我们就知道了，防止 NDS 劫持就要从第二步入手，因为 DNS 解析过程是运营商来操作的，我们不能去干涉他们，不然我们也就成了劫持者了，所以我们要做的就是在我们请求之前对我们的请求链接做一些修改，<span class=\"exturl\" data-url=\"aHR0cDovL3huLS13d3ctb3Q5ZHg4c3k0bm9qa284Y2c2azl1bmtwMWF3ODBkb3N5YS5iYWlkdS5jb20=\">将我们原本的请求链接 www.baidu.com</span> 修改为 180.149.132.47，然后请求出去，这样的话就运营商在拿到我们的请求后发现我们直接用的就是 IP 地址就会直接给我们放行，而不会去走他自己 DNS 解析了，也就是说我们把运营商要做的事情自己先做好了。不走他的 DNS 解析也就不会存在 DNS 被劫持的问题，从根本是解决了。</p>\n<h1 id=\"技术篇\"><a class=\"anchor\" href=\"#技术篇\">#</a> 技术篇</h1>\n<h5 id=\"5项目中的实际操作\"><a class=\"anchor\" href=\"#5项目中的实际操作\">#</a> 5：项目中的实际操作</h5>\n<h6 id=\"51dnspod相关\"><a class=\"anchor\" href=\"#51dnspod相关\">#</a> 5.1：DNSPOD 相关</h6>\n<p>我们知道要要把项目中请求的接口替换成成 IP 其实很简单，URL 是字符串，域名替换 IP，无非就是一个字符串替换而已，的确这块其实没有什么技术含量，而且现在像阿里云 (没开源)，七牛云 (开源)，等一些比较大的平台在这方面也都有了比较成熟的解决方案，一个 SDK，传个普通的 URL 进去就会返回一个域名被替换成 IP 的 URL 出来，也比较好用，这里要说一下 IP 地址的来源，如何拿到一个域名所对应的 IP 呢？这里就是需要用到另一个服务 ——HTTPDNS，国内比较有名的就是 DNSPOD，包括阿里，七牛等也是使用他们的 DNS 服务来解析，就是这个</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6jnbe2zhj30sa0i8dwv.jpg\" alt=\"DNSPOD logo\" /></p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6jnt2uw9j31kw0icava.jpg\" alt=\"简介\" /></p>\n<p>他会给我们提供一个接口，我们使用 HTTP 请求的方式去请求这个接口，参数带上我们的域名，他们就会把域名对应的 IP 列表返回回来。类似这样：<br />\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///这个请求URL的结构是固定的119.29.29.29是DNSPOD固定的服务器地址，ttl参数的意思是返回结果是否带ttl是个BOOL，dn就是我们需要解析的域名，id就是我们在dnspod上注册时候他给我们的一个KEY</span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *url = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@&quot;http://119.29.29.29/d?ttl=1&amp;dn=www.baidu.com&amp;id=KEY&quot;</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSMutableURLRequest</span> * request = [<span class=\"built_in\">NSMutableURLRequest</span> requestWithURL:[<span class=\"built_in\">NSURL</span> URLWithString:url] cachePolicy:<span class=\"built_in\">NSURLRequestUseProtocolCachePolicy</span> timeoutInterval:<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSData</span> * data = [<span class=\"built_in\">NSURLConnection</span> sendSynchronousRequest:request returningResponse:<span class=\"literal\">nil</span> error:&amp;networkError];</span><br></pre></td></tr></table></figure></p>\n<p>这里使用同步还是异步都是可以的，具体根据你们业务需求。</p>\n<h6 id=\"52项目中的使用\"><a class=\"anchor\" href=\"#52项目中的使用\">#</a> 5.2：项目中的使用</h6>\n<p>其实 dnspod 最难的部分是接入的部分，因为不同的 APP 不同的网络环境会导致各种各样的问题，如果你是一个新的项目那么接入难度会大大降低，因为你完全可以自己封装一套网络请求，把 DNS 解析相关的逻辑都封装到自己的网络请求中，这样你就可以得到 APP 所有的网络层的控制权，想干什么就干什么，但是如果是在一个已经比较完善的 APP 中加入 DNS 防劫持的话那就是比较困难，因为你不能拿到所有网络请求的控制权这篇文章中我主要使用是 NSURLProtocol + Runtime hook 方式来处理这些东西的，NSURLProtocol 属于 iOS 黑魔法的一种可以拦截任何从 APP 的 URL Loading System 系统中发出的请求，其中包括如下</p>\n<ul>\n<li>File Transfer Protocol (ftp://)</li>\n<li>Hypertext Transfer Protocol (http://)</li>\n<li>Hypertext Transfer Protocol with encryption (https://)</li>\n<li>Local file URLs (file:///)</li>\n<li>Data URLs (data://)</li>\n</ul>\n<p>如果你的请求不在以上列表中就不能进行拦截了，比如 WKWebview，AVPlayer (比较特殊，虽然请求也是 http/https 但是就是不走这套系统，苹果爸爸就是这样～) 等，其实对于正常来说光用已经 NSURLProtocol 足够了。<br />\n  NSURLProtocol 这个类我们不能直接使用，我们需要自己创建一个他的子类然后在我们的子类中操作他们像这样<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 注册自定义protocol</span></span><br><span class=\"line\">[<span class=\"built_in\">NSURLProtocol</span> registerClass:[CustomURLProtocol <span class=\"keyword\">class</span>]];</span><br><span class=\"line\"> <span class=\"built_in\">NSURLSessionConfiguration</span> *configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">configuration.protocolClasses = @[[CustomURLProtocol <span class=\"keyword\">class</span>]];</span><br></pre></td></tr></table></figure><br />\n 在这个类中我们可以拦截到请求，然后进行处理。这个类中有四个非常重要的方法<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"type\">BOOL</span>)canInitWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLRequest</span> *)canonicalRequestForRequest:(<span class=\"built_in\">NSURLRequest</span> *)request;</span><br><span class=\"line\">- (<span class=\"type\">void</span>)startLoading;</span><br><span class=\"line\"><span class=\"comment\">//对于拦截的请求，NSURLProtocol对象在停止加载时调用该方法</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)stopLoading;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"boolcaninitwithrequestnsurlrequest-request\"><a class=\"anchor\" href=\"#boolcaninitwithrequestnsurlrequest-request\">#</a> + (BOOL)canInitWithRequest:(NSURLRequest *)request;</h6>\n<p>通过返回值来告诉 NSUrlProtocol 对进来的请求是否拦截，比如我只拦截 HTTP 的，或者是某个域名的请求之类</p>\n<h6 id=\"nsurlrequest-canonicalrequestforrequestnsurlrequest-request\"><a class=\"anchor\" href=\"#nsurlrequest-canonicalrequestforrequestnsurlrequest-request\">#</a> + (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request;</h6>\n<p>如果上面的方法返回 YES 那么 request 会传到这里，这个地方通常不做处理 直接返回 request</p>\n<h6 id=\"-voidstartloading\"><a class=\"anchor\" href=\"#-voidstartloading\">#</a> - (void)startLoading;</h6>\n<p>这个地方就是对我们拦截的请求做一些处理，我们文中所做的 IP 对域名的替换就在这里进行，处理完之后将请求转发出去，比如这样<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)startLoading &#123;</span><br><span class=\"line\"><span class=\"comment\">///其中customRequest是处理过的请求(域名替换后的)</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLSession</span> *session = [<span class=\"built_in\">NSURLSession</span> sessionWithConfiguration:[[<span class=\"built_in\">NSURLSessionConfiguration</span> alloc] init] delegate:<span class=\"keyword\">self</span> delegateQueue:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:customRequest];</span><br><span class=\"line\">    [task resume];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 你可以在 - startLoading 中使用任何方法来对协议对象持有的 request 进行转发，包括 NSURLSession、 NSURLConnection 甚至使用 AFNetworking 等网络库，只要你能在回调方法中把数据传回 client，帮助其正确渲染就可以，比如这样：<br />\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session dataTask:(<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTask didReceiveResponse:(<span class=\"built_in\">NSURLResponse</span> *)response completionHandler:(<span class=\"type\">void</span> (^)(<span class=\"built_in\">NSURLSessionResponseDisposition</span>))completionHandler &#123;</span><br><span class=\"line\">    [[<span class=\"keyword\">self</span> client] URLProtocol:<span class=\"keyword\">self</span> didReceiveResponse:response cacheStoragePolicy:<span class=\"built_in\">NSURLCacheStorageAllowed</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    completionHandler(<span class=\"built_in\">NSURLSessionResponseAllow</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)URLSession:(<span class=\"built_in\">NSURLSession</span> *)session dataTask:(<span class=\"built_in\">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class=\"built_in\">NSData</span> *)data &#123;</span><br><span class=\"line\">    [[<span class=\"keyword\">self</span> client] URLProtocol:<span class=\"keyword\">self</span> didLoadData:data];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\nclient 在后面会有讲解。</p>\n<h6 id=\"-voidstoploading\"><a class=\"anchor\" href=\"#-voidstoploading\">#</a> - (void)stopLoading;</h6>\n<p>请求完毕后调用<br />\n大概的执行流程是这样</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6jtpp3z0j30ze1by122.jpg\" alt=\"流程\" /></p>\n<p>在 NSURLProtocol 中有一个贯穿始终的变量<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*!</span></span><br><span class=\"line\"><span class=\"comment\">    @method client</span></span><br><span class=\"line\"><span class=\"comment\">    @abstract Returns the NSURLProtocolClient of the receiver.</span></span><br><span class=\"line\"><span class=\"comment\">    @result The NSURLProtocolClient of the receiver.  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">readonly</span>, <span class=\"keyword\">retain</span>) <span class=\"type\">id</span> &lt;<span class=\"built_in\">NSURLProtocolClient</span>&gt; client;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 你可以认为是这个是请求的发送者，打个比方，A 想给 B 发送一个消息，由于距离遥远于是 A 去了邮局，A 把消息内容告诉了邮局，并且 A 在邮局登记了自己名字方便 B 有反馈的时候邮局来通知 A 查收。这个例子中邮局就是 NSURLProtocol，A 在邮局登记的名字就是 client。所有的 client 都实现了 NSURLProtocolClient 协议，协议的作用就是在 HTTP 请求发出以及接受响应时向其它对象传输数据：<br />\n<figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@protocol NSURLProtocolClient &lt;NSObject&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">- <span class=\"params\">(void)</span>URLProtocol:<span class=\"params\">(NSURLProtocol *)</span>protocol didReceiveResponse:<span class=\"params\">(NSURLResponse *)</span>response cacheStoragePolicy:<span class=\"params\">(NSURLCacheStoragePolicy)</span>policy;</span><br><span class=\"line\"></span><br><span class=\"line\">- <span class=\"params\">(void)</span>URLProtocol:<span class=\"params\">(NSURLProtocol *)</span>protocol didLoadData:<span class=\"params\">(NSData *)</span>data;</span><br><span class=\"line\"></span><br><span class=\"line\">- <span class=\"params\">(void)</span>URLProtocolDidFinishLoading:<span class=\"params\">(NSURLProtocol *)</span>protocol;</span><br><span class=\"line\">...</span><br><span class=\"line\">@<span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure><br />\n 当然这个协议中还有很多其他的方法，比如 HTTPS 验证、重定向以及响应缓存相关的方法，你需要在合适的时候调用这些代理方法，对信息进行传递。<br />\n到此正常情况下的 DNS 的解析过程已经结束，如果你发现按照如上操作之后并没有达到预期效果那么请往下看，(通常情况下完成以上操作 原有的 URL 的就会变成 http://123.456.789.123/XXX/XXX/XXX 的格式。如果发现请求不成功就往下看吧)</p>\n<h5 id=\"6遇到的坑点\"><a class=\"anchor\" href=\"#6遇到的坑点\">#</a> 6：遇到的坑点</h5>\n<h6 id=\"61我们知道运营商本来是根据域名来确定一个url的我们将域名改为ip之后虽然不用运营商帮我们解析了但是运营商在收到一串数字的时候也是懵逼状态我们还是需要将域名传给他们但是不能用正常的方式传我们需要把原来的域名加到http请求的header中的host字段下根据http协议的规定如果在url中无法找到域名的话就会去header中找这样一来我们既把域名告诉了运营商同时也直接制定了ip地址这个是必须配置的不然的话是请求不成功的\"><a class=\"anchor\" href=\"#61我们知道运营商本来是根据域名来确定一个url的我们将域名改为ip之后虽然不用运营商帮我们解析了但是运营商在收到一串数字的时候也是懵逼状态我们还是需要将域名传给他们但是不能用正常的方式传我们需要把原来的域名加到http请求的header中的host字段下根据http协议的规定如果在url中无法找到域名的话就会去header中找这样一来我们既把域名告诉了运营商同时也直接制定了ip地址这个是必须配置的不然的话是请求不成功的\">#</a> 6.1：我们知道运营商本来是根据域名来确定一个 URL 的，我们将域名改为 IP 之后虽然不用运营商帮我们解析了，但是运营商在收到一串数字的时候也是懵逼状态，我们还是需要将域名传给他们，但是不能用正常的方式传，我们需要把原来的域名加到 http 请求的 Header 中的 host 字段下，根据 Http 协议的规定，如果在 URL 中无法找到域名的话就会去 Header 中找，这样一来我们既把域名告诉了运营商同时也直接制定了 IP 地址，这个是必须配置的，不然的话是请求不成功的。</h6>\n<p><figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mutableRequest <span class=\"built_in\">set</span>Value:<span class=\"literal\">self</span>.request.URL.host <span class=\"keyword\">for</span>HTTPHeaderField:@<span class=\"string\">&quot;HOST&quot;</span>];</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"加上header再去请求就没问题了不过有些特殊的情况下会需要带上cookie同样也是加到header中\"><a class=\"anchor\" href=\"#加上header再去请求就没问题了不过有些特殊的情况下会需要带上cookie同样也是加到header中\">#</a> 加上 Header 再去请求就没问题了，不过有些特殊的情况下会需要带上 cookie，同样也是加到 Header 中</h6>\n<p><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">mutableRequest setValue:YOUR Cookie forHTTPHeaderField:@<span class=\"string\">&quot;Cookie&quot;</span></span>];</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"62关于afnetworking的问题现在大部分网络请求是基于afnetworking的这里有一个坑我们知道我们注册customprotocol的时候是这样\"><a class=\"anchor\" href=\"#62关于afnetworking的问题现在大部分网络请求是基于afnetworking的这里有一个坑我们知道我们注册customprotocol的时候是这样\">#</a> 6.2：关于 AfNetworking 的问题，现在大部分网络请求是基于 Afnetworking 的，这里有一个坑，我们知道我们注册 CustomProtocol 的时候是这样</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 注册自定义protocol</span></span><br><span class=\"line\">[<span class=\"built_in\">NSURLProtocol</span> registerClass:[CustomURLProtocol <span class=\"keyword\">class</span>]];</span><br><span class=\"line\"> <span class=\"built_in\">NSURLSessionConfiguration</span> *configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">configuration.protocolClasses = @[[CustomURLProtocol <span class=\"keyword\">class</span>]];</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"在系统的configuration加入我们的customprotocolprotocolclasses是一个数组里面可以放很多各种不同的customprotocol我们看一下afnetworking的初始化方法\"><a class=\"anchor\" href=\"#在系统的configuration加入我们的customprotocolprotocolclasses是一个数组里面可以放很多各种不同的customprotocol我们看一下afnetworking的初始化方法\">#</a> 在系统的 configuration 加入我们的 CustomProtocol，protocolClasses 是一个数组里面可以放很多各种不同的 CustomProtocol，我们看一下 afnetworking 的初始化方法。</h6>\n<p><figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AFHTTPSessionManager * sessionManager <span class=\"operator\">=</span> [AFHTTPSessionManager manager]<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure></p>\n<h6 id=\"我相信大家通常都会这么来创建但是这里我要说下manager并不是一个单利最后都会调到一个方法\"><a class=\"anchor\" href=\"#我相信大家通常都会这么来创建但是这里我要说下manager并不是一个单利最后都会调到一个方法\">#</a> 我相信大家通常都会这么来创建，但是这里我要说下 manager 并不是一个单利，最后都会调到一个方法</h6>\n<p><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">-</span> (instancetype)initWithSessionConfiguration:(<span class=\"type\">NSURLSessionConfiguration</span> <span class=\"operator\">*</span>)configuration &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> <span class=\"operator\">=</span> [<span class=\"keyword\">super</span> <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"operator\">!</span><span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"operator\">!</span>configuration) &#123;</span><br><span class=\"line\">        configuration <span class=\"operator\">=</span> [<span class=\"type\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.sessionConfiguration <span class=\"operator\">=</span> configuration;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.operationQueue <span class=\"operator\">=</span> [[<span class=\"type\">NSOperationQueue</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.operationQueue.maxConcurrentOperationCount <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.session <span class=\"operator\">=</span> [<span class=\"type\">NSURLSession</span> sessionWithConfiguration:<span class=\"keyword\">self</span>.sessionConfiguration delegate:<span class=\"keyword\">self</span> delegateQueue:<span class=\"keyword\">self</span>.operationQueue];</span><br><span class=\"line\">    .</span><br><span class=\"line\">    .</span><br><span class=\"line\">    .</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h6 id=\"大家注意第二个判断如果没有传入configuration的话他会创建一个默认的这样以至于我们之前在configuration的protocolclasses中注册类全部被这个新的configuration替换掉了所以无法解析-这里我采取的办法就是runtime-hook因为hook第三方的代码并不是一个很好的办法所以我直接hook-nsurlsession的sessionwithconfiguration方法因为通过观察afnetworking的源码最终都是走到这里的-hook之后把自己的configuration换进去像这样\"><a class=\"anchor\" href=\"#大家注意第二个判断如果没有传入configuration的话他会创建一个默认的这样以至于我们之前在configuration的protocolclasses中注册类全部被这个新的configuration替换掉了所以无法解析-这里我采取的办法就是runtime-hook因为hook第三方的代码并不是一个很好的办法所以我直接hook-nsurlsession的sessionwithconfiguration方法因为通过观察afnetworking的源码最终都是走到这里的-hook之后把自己的configuration换进去像这样\">#</a> 大家注意第二个判断，如果没有传入 configuration 的话他会创建一个默认的，这样以至于我们之前在 configuration 的 protocolClasses 中注册类全部被这个新的 configuration 替换掉了，所以无法解析。这里我采取的办法就是 runtime hook，因为 hook 第三方的代码并不是一个很好的办法，所以我直接 hook NSURLSession 的 sessionWithConfiguration 方法，因为通过观察 Afnetworking 的源码最终都是走到这里的。Hook 之后把自己的 configuration 换进去，像这样</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">NSURLSession</span> *)swizzle_sessionWithConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionConfiguration</span> *newConfiguration = configuration;</span><br><span class=\"line\">    <span class=\"comment\">// 在现有的Configuration中插入我们自定义的protocol</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (configuration) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSMutableArray</span> *protocolArray = [<span class=\"built_in\">NSMutableArray</span> arrayWithArray:configuration.protocolClasses];</span><br><span class=\"line\">        [protocolArray insertObject:[CustomProtocol <span class=\"keyword\">class</span>] atIndex:<span class=\"number\">0</span>];</span><br><span class=\"line\">        newConfiguration.protocolClasses = protocolArray;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newConfiguration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">        <span class=\"built_in\">NSMutableArray</span> *protocolArray = [<span class=\"built_in\">NSMutableArray</span> arrayWithArray:configuration.protocolClasses];</span><br><span class=\"line\">        [protocolArray insertObject:[CustomProtocol <span class=\"keyword\">class</span>] atIndex:<span class=\"number\">0</span>];</span><br><span class=\"line\">        newConfiguration.protocolClasses = protocolArray;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> swizzle_sessionWithConfiguration:newConfiguration];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"然后就完美解决了-不过要注意下系统的是有两个方法的\"><a class=\"anchor\" href=\"#然后就完美解决了-不过要注意下系统的是有两个方法的\">#</a> 然后就完美解决了。不过要注意下系统的是有两个方法的</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Customization of NSURLSession occurs during creation of a new session.</span></span><br><span class=\"line\"><span class=\"comment\"> * If you only need to use the convenience routines with custom</span></span><br><span class=\"line\"><span class=\"comment\"> * configuration options it is not necessary to specify a delegate.</span></span><br><span class=\"line\"><span class=\"comment\"> * If you do specify a delegate, the delegate will be retained until after</span></span><br><span class=\"line\"><span class=\"comment\"> * the delegate has been sent the URLSession:didBecomeInvalidWithError: message.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLSession</span> *)sessionWithConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLSession</span> *)sessionWithConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration delegate:(<span class=\"keyword\">nullable</span> <span class=\"type\">id</span> &lt;<span class=\"built_in\">NSURLSessionDelegate</span>&gt;)delegate delegateQueue:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSOperationQueue</span> *)queue;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"这两个方法不能确定最终会走那个所以为了保险起见都hook下hook的方式是一样的\"><a class=\"anchor\" href=\"#这两个方法不能确定最终会走那个所以为了保险起见都hook下hook的方式是一样的\">#</a> 这两个方法不能确定最终会走那个，所以为了保险起见都 hook 下，hook 的方式是一样的</h6>\n<h6 id=\"63avplayer请求avplayer是我们ios系统中系统自带的播放视频的框架用到地方也很多但是这个是比较坑的因为avplayer虽然也有httphttpsfile请求这个概念但是avplayer所有的请求都不会走url-loading-system也就是说所有由avplayer发出的请求都不能被我们的customprotocol拦截这时候大家也许会问不对呀我们正常调试的时候可以被拦截到的啊-其实苹果官方上是说avplayer在真机调试和模拟器调试时候走的完全不是一套策略也就是说在模拟器运行时候是完全正常的可以被拦截到也可以被解析但是在真机上面就恰恰相反了因为我们最后还是以真机为准所以我们采取的办法还是hook因为我们需要在媒体url传给avplayer前就要将相关东西配置好域名替换啊加host啊之类的所以我们要找avplayer的入口先看初始化方法我发现项目中使用一个avurlasset来初始化avplayer那么avurlasset又是什么呢继续查到avurlasset的初始化方法可以发现这个方法\"><a class=\"anchor\" href=\"#63avplayer请求avplayer是我们ios系统中系统自带的播放视频的框架用到地方也很多但是这个是比较坑的因为avplayer虽然也有httphttpsfile请求这个概念但是avplayer所有的请求都不会走url-loading-system也就是说所有由avplayer发出的请求都不能被我们的customprotocol拦截这时候大家也许会问不对呀我们正常调试的时候可以被拦截到的啊-其实苹果官方上是说avplayer在真机调试和模拟器调试时候走的完全不是一套策略也就是说在模拟器运行时候是完全正常的可以被拦截到也可以被解析但是在真机上面就恰恰相反了因为我们最后还是以真机为准所以我们采取的办法还是hook因为我们需要在媒体url传给avplayer前就要将相关东西配置好域名替换啊加host啊之类的所以我们要找avplayer的入口先看初始化方法我发现项目中使用一个avurlasset来初始化avplayer那么avurlasset又是什么呢继续查到avurlasset的初始化方法可以发现这个方法\">#</a> 6.3：AVPlayer 请求，AVPlayer 是我们 iOS 系统中系统自带的播放视频的框架，用到地方也很多，但是这个是比较坑的，因为 AVPlayer 虽然也有 http/https/file…… 请求这个概念，但是 AVPlayer 所有的请求都不会走 URL Loading System，也就是说所有由 AVPlayer 发出的请求都不能被我们的 CustomProtocol 拦截，这时候大家也许会问，不对呀，我们正常调试的时候可以被拦截到的啊。其实苹果官方上是说 AVPlayer 在真机调试和模拟器调试时候走的完全不是一套策略，也就是说在模拟器运行时候是完全正常的，可以被拦截到也可以被解析，但是在真机上面就恰恰相反了，因为我们最后还是以真机为准，所以我们采取的办法还是 hook，因为我们需要在媒体 URL 传给 AVPlayer 前就要将相关东西配置好，域名替换啊，加 host 啊之类的，所以我们要找 AVPlayer 的入口，先看初始化方法，我发现项目中使用一个 AVURLAsset 来初始化 AVPlayer，那么 AVURLAsset 又是什么呢？继续查到 AVURLAsset 的初始化方法，可以发现这个方法：</h6>\n<p><figure class=\"highlight smali\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*!</span><br><span class=\"line\">  @method\t\tinitWithURL:options:</span><br><span class=\"line\">  @abstract\t\tInitializes an<span class=\"built_in\"> instance </span>of AVURLAsset for inspection of a media resource.</span><br><span class=\"line\">  @param\t\tURL</span><br><span class=\"line\">\t\t\t\tAn<span class=\"built_in\"> instance </span>of NSURL that references a media resource.</span><br><span class=\"line\">  @param\t\toptions</span><br><span class=\"line\">\t\t\t\tAn<span class=\"built_in\"> instance </span>of NSDictionary that contains keys for specifying options for the initialization of the AVURLAsset. See AVURLAssetPreferPreciseDurationAndTimingKey<span class=\"built_in\"> and </span>AVURLAssetReferenceRestrictionsKey above.</span><br><span class=\"line\">  @result\t\tAn<span class=\"built_in\"> instance </span>of AVURLAsset.</span><br><span class=\"line\">*/</span><br><span class=\"line\">- (instancetype)initWithURL:(NSURL *)URL options:(nullable NSDictionary&lt;NSString *, id&gt; *)options NS_DESIGNATED_INITIA<span class=\"class\">LIZER;</span></span><br></pre></td></tr></table></figure></p>\n<h6 id=\"其中url就是我们传给avplayer播放的url找到目标就hook下就可以了具体过程就不多说了还是字符串替换但是有一点需要注意的是我之前上文说过做完ip对域名的替换之后还需要设置下request的host但是这个地方只有一个url并没有request该如何处理呢其实这个方法里面的opinion参数就是处理这个的可以添加cookie之类的类似与httpheader的东西可以添加这几个key\"><a class=\"anchor\" href=\"#其中url就是我们传给avplayer播放的url找到目标就hook下就可以了具体过程就不多说了还是字符串替换但是有一点需要注意的是我之前上文说过做完ip对域名的替换之后还需要设置下request的host但是这个地方只有一个url并没有request该如何处理呢其实这个方法里面的opinion参数就是处理这个的可以添加cookie之类的类似与httpheader的东西可以添加这几个key\">#</a> 其中 URL 就是我们传给 AVPlayer 播放的 URL，找到目标就 Hook 下就可以了，具体过程就不多说了还是字符串替换，但是有一点需要注意的是，我之前上文说过做完 IP 对域名的替换之后还需要设置下 request 的 Host，但是这个地方只有一个 URL 并没有 Request 该如何处理呢？其实这个方法里面的 opinion 参数就是处理这个的，可以添加 cookie 之类的类似与 httpheader 的东西，可以添加这几个 Key</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">AVF_EXPORT</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">AVURLAssetPreferPreciseDurationAndTimingKey</span> <span class=\"built_in\">NS_AVAILABLE</span>(<span class=\"number\">10</span>_7, <span class=\"number\">4</span>_0);</span><br><span class=\"line\"><span class=\"built_in\">AVF_EXPORT</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">AVURLAssetReferenceRestrictionsKey</span> <span class=\"built_in\">NS_AVAILABLE</span>(<span class=\"number\">10</span>_7, <span class=\"number\">5</span>_0);</span><br><span class=\"line\"><span class=\"built_in\">AVF_EXPORT</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">AVURLAssetHTTPCookiesKey</span> <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0);</span><br><span class=\"line\"><span class=\"built_in\">AVF_EXPORT</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">AVURLAssetAllowsCellularAccessKey</span> <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">10</span>_0);</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"但是并没有发现和host相关的key其实这个key是有的就是avurlassethttpheaderfieldskey只是因为这个key没暴露出来-这个地方不太确定是不是苹果的私有api网上查了大量的资料也没有个说法甚至我亲自去苹果开发者去问苹果也没有给任何答复各种说法都有具体使用的话就是\"><a class=\"anchor\" href=\"#但是并没有发现和host相关的key其实这个key是有的就是avurlassethttpheaderfieldskey只是因为这个key没暴露出来-这个地方不太确定是不是苹果的私有api网上查了大量的资料也没有个说法甚至我亲自去苹果开发者去问苹果也没有给任何答复各种说法都有具体使用的话就是\">#</a> 但是并没有发现和 Host 相关的 Key，其实这个 key 是有的就是 AVURLAssetHTTPHeaderFieldsKey 只是因为这个 Key 没暴露出来。这个地方不太确定是不是苹果的私有 API，网上查了大量的资料也没有个说法，甚至我亲自去苹果开发者去问，苹果也没有给任何答复，各种说法都有，具体使用的话就是</h6>\n<p><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"variable language_\">self</span> <span class=\"symbol\">swizzle_initWithURL:</span>videoURL <span class=\"symbol\">options:</span>@&#123;AVURLAssetHTTPHeaderFieldsKey : @&#123;@<span class=\"string\">&quot;Host&quot;</span><span class=\"symbol\">:host</span>&#125;&#125;]</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"这样使用是没有任何问题的但是毕竟是没有暴露出来的方法我们不能这样明目张胆的使用其实对于字符串来说还是比较好规避的只要不要明文出现这个key就可以我在这里使用了一个加密吧key变成密文然后这个地方通过解密获取就像这样\"><a class=\"anchor\" href=\"#这样使用是没有任何问题的但是毕竟是没有暴露出来的方法我们不能这样明目张胆的使用其实对于字符串来说还是比较好规避的只要不要明文出现这个key就可以我在这里使用了一个加密吧key变成密文然后这个地方通过解密获取就像这样\">#</a> 这样使用是没有任何问题的，但是毕竟是没有暴露出来的方法，我们不能这样明目张胆的使用，其实对于字符串来说还是比较好规避的，只要不要明文出现这个 KEY 就可以，我在这里使用了一个加密，吧 key 变成密文然后这个地方通过解密获取，就像这样：</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//加密后的KEY</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">NSString</span> * headerKey = <span class=\"string\">@&quot;35905FF45AFA4C579B7DE2403C7CA0CCB59AA83D660E60C9D444AFE13323618F&quot;</span>;</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\"><span class=\"comment\">//getRequestHeaderKey方法为解密方法</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> swizzle_initWithURL:videoURL options:@&#123;[<span class=\"keyword\">self</span> getRequestHeaderKey] : @&#123;<span class=\"string\">@&quot;Host&quot;</span>:host&#125;&#125;];</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"这样之后就大功告成了avplayer可以在dns被劫持的情况下播放了\"><a class=\"anchor\" href=\"#这样之后就大功告成了avplayer可以在dns被劫持的情况下播放了\">#</a> 这样之后就大功告成了，AVPlayer 可以在 DNS 被劫持的情况下播放了，</h6>\n<h6 id=\"64post请求这块也算是一个大坑我们知道http的post请求会包含一个body体里面包含我们需要上传的参数等一些资料对于post请求我们的nsurlprotocol是可以正常拦截的但是我们拦截之后发现无论怎么样我们获得的body体都为nil后来查了一些资料发下又是苹果爸爸在做手脚-nsurlprotocol在拦截nsurlsession的post请求时不能获取到request中的httpbody这个貌似早就国外的论坛上传开了但国内好像还鲜有人知据苹果官方的解释是body是nsdata类型即可能为二进制内容而且还没有大小限制所以可能会很大为了性能考虑索性就拦截时就不拷贝了内流满面脸-为了解决这个问题我们可以通过把body数据放到header中不过header的大小好像是有限制的我试过2m是没有问题不过超过10m就直接request-timeout了-而且当body数据为二进制数据时这招也没辙了因为header里都是文本数据另一种方案就是用一个nsdictionary或nscache保存没有请求的body数据用url为key最后方法就是别用nsurlsession老老实实用古老的nsurlconnection算了-你以为这么就结束了吗并没有后来查了大量的资料发现既然post请求的httpbody没有苹果复制下来那我们就不用httpbody我们再往底层去看就会发现httpbodystream这个东西我们可以通过他来获取请求的body体具体代吗如下\"><a class=\"anchor\" href=\"#64post请求这块也算是一个大坑我们知道http的post请求会包含一个body体里面包含我们需要上传的参数等一些资料对于post请求我们的nsurlprotocol是可以正常拦截的但是我们拦截之后发现无论怎么样我们获得的body体都为nil后来查了一些资料发下又是苹果爸爸在做手脚-nsurlprotocol在拦截nsurlsession的post请求时不能获取到request中的httpbody这个貌似早就国外的论坛上传开了但国内好像还鲜有人知据苹果官方的解释是body是nsdata类型即可能为二进制内容而且还没有大小限制所以可能会很大为了性能考虑索性就拦截时就不拷贝了内流满面脸-为了解决这个问题我们可以通过把body数据放到header中不过header的大小好像是有限制的我试过2m是没有问题不过超过10m就直接request-timeout了-而且当body数据为二进制数据时这招也没辙了因为header里都是文本数据另一种方案就是用一个nsdictionary或nscache保存没有请求的body数据用url为key最后方法就是别用nsurlsession老老实实用古老的nsurlconnection算了-你以为这么就结束了吗并没有后来查了大量的资料发现既然post请求的httpbody没有苹果复制下来那我们就不用httpbody我们再往底层去看就会发现httpbodystream这个东西我们可以通过他来获取请求的body体具体代吗如下\">#</a> 6.4：POST 请求这块也算是一个大坑，我们知道 http 的 post 请求会包含一个 body 体，里面包含我们需要上传的参数等一些资料，对于 POST 请求我们的 NSURLProtocol 是可以正常拦截的，但是我们拦截之后发现无论怎么样我们获得的 body 体都为 nil！后来查了一些资料发下又是苹果爸爸在做手脚。NSURLProtocol 在拦截 NSURLSession 的 POST 请求时不能获取到 Request 中的 HTTPBody，这个貌似早就国外的论坛上传开了，但国内好像还鲜有人知，据苹果官方的解释是 Body 是 NSData 类型，即可能为二进制内容，而且还没有大小限制，所以可能会很大，为了性能考虑，索性就拦截时就不拷贝了（内流满面脸）。为了解决这个问题，我们可以通过把 Body 数据放到 Header 中，不过 Header 的大小好像是有限制的，我试过 2M 是没有问题，不过超过 10M 就直接 Request timeout 了。。。而且当 Body 数据为二进制数据时这招也没辙了，因为 Header 里都是文本数据，另一种方案就是用一个 NSDictionary 或 NSCache 保存没有请求的 Body 数据，用 URL 为 key，最后方法就是别用 NSURLSession，老老实实用古老的 NSURLConnection 算了。。。你以为这么就结束了吗？并没有，后来查了大量的资料发现，既然 post 请求的 httpbody 没有苹果复制下来，那我们就不用 httpbody，我们再往底层去看就会发现 HTTPBodyStream 这个东西我们可以通过他来获取请求的 body 体具体代吗如下</h6>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark -</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark 处理POST请求相关POST  用HTTPBodyStream来处理BODY体</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSMutableURLRequest</span> *)handlePostRequestBodyWithRequest:(<span class=\"built_in\">NSMutableURLRequest</span> *)request &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableURLRequest</span> * req = [request mutableCopy];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([request.HTTPMethod isEqualToString:<span class=\"string\">@&quot;POST&quot;</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!request.HTTPBody) &#123;</span><br><span class=\"line\">            uint8_t d[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">            <span class=\"built_in\">NSInputStream</span> *stream = request.HTTPBodyStream;</span><br><span class=\"line\">            <span class=\"built_in\">NSMutableData</span> *data = [[<span class=\"built_in\">NSMutableData</span> alloc] init];</span><br><span class=\"line\">            [stream open];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ([stream hasBytesAvailable]) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">NSInteger</span> len = [stream read:d maxLength:<span class=\"number\">1024</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (len &gt; <span class=\"number\">0</span> &amp;&amp; stream.streamError == <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">                    [data appendBytes:(<span class=\"type\">void</span> *)d length:len];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            req.HTTPBody = [data <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">            [stream close];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> req;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h6 id=\"这样之后的req就是携带了body体的request啦可以愉快地做post请求啦\"><a class=\"anchor\" href=\"#这样之后的req就是携带了body体的request啦可以愉快地做post请求啦\">#</a> 这样之后的 req 就是携带了 body 体的 request 啦，可以愉快地做 post 请求啦。</h6>\n<h6 id=\"65wkwebview是新出的浏览器控件这里就不多说了wkwebview不走url-loading-system所以也不会被拦截不过也是有办法的但是因为这次项目中没有用到所以没有过多的去研究后续我会写一篇关于这个博客不是很难依旧是runtime大法\"><a class=\"anchor\" href=\"#65wkwebview是新出的浏览器控件这里就不多说了wkwebview不走url-loading-system所以也不会被拦截不过也是有办法的但是因为这次项目中没有用到所以没有过多的去研究后续我会写一篇关于这个博客不是很难依旧是runtime大法\">#</a> 6.5：WKWebview 是新出的浏览器控件，这里就不多说了，WKWebview 不走 URL Loading System，所以也不会被拦截，不过也是有办法的，但是因为这次项目中没有用到，所以没有过多的去研究，后续我会写一篇关于这个博客，不是很难，依旧是 runtime 大法。</h6>\n<h6 id=\"66sni环境这个可是坑了我好久好久的东西所以我会放在最后去说sni环境因为涉及到证书验证所以是在https的基础上来说的sniserver-name-indication是为了解决一个服务器使用多个域名和证书的扩展-一句话简述它的工作原理就是在连接到服务器建立ssl链接之前先发送要访问站点的域名hostname这样服务器根据这个域名返回一个合适的证书-其实关于sni环境在这里就不过多解释阿里云文档有很明白的解释同时他也有安卓和ios在sni环境下的处理文档我们发现安卓部分写的很详细可是已到了ios这边就这样了\"><a class=\"anchor\" href=\"#66sni环境这个可是坑了我好久好久的东西所以我会放在最后去说sni环境因为涉及到证书验证所以是在https的基础上来说的sniserver-name-indication是为了解决一个服务器使用多个域名和证书的扩展-一句话简述它的工作原理就是在连接到服务器建立ssl链接之前先发送要访问站点的域名hostname这样服务器根据这个域名返回一个合适的证书-其实关于sni环境在这里就不过多解释阿里云文档有很明白的解释同时他也有安卓和ios在sni环境下的处理文档我们发现安卓部分写的很详细可是已到了ios这边就这样了\">#</a> 6.6：SNI 环境，这个可是坑了我好久好久的东西，所以我会放在最后去说，SNI 环境因为涉及到证书验证所以是在 https 的基础上来说的，SNI（Server Name Indication）是为了解决一个服务器使用多个域名和证书的扩展。一句话简述它的工作原理就是，在连接到服务器建立 SSL 链接之前先发送要访问站点的域名（Hostname），这样服务器根据这个域名返回一个合适的证书。其实关于 SNI 环境在这里就不过多解释，**<span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vZG9jdW1lbnRfZGV0YWlsLzMwMTQzLmh0bWw=\"> 阿里云文档</span> ** 有很明白的解释，同时他也有安卓和 iOS 在 SNI 环境下的处理文档，我们发现安卓部分写的很详细，可是已到了 iOS 这边就这样了：</h6>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6juzsqdqj31kw0bbn5v.jpg\" alt=\"阿里云文档截图\" /></p>\n<h6 id=\"三行文字加三个链接就完事了-其实在遇到这个坑的时候我也查过很多相关资料无非就是这三行话加这三个链接复制来复制去没有实质性的进展大部分公司或者是项目没有这么重的httpdns需求所以也就不会有这个环境即使遇到了也就直接关闭httpdns了后来只能自己去用cfnetwork一点点实现-具体代码就不跟大家粘贴了因为涉及到一些公司内部的代码不过我会把我主要的参考资料发给大家-这里有个小技巧因为都在说cfnetwork是比较底层的网络实现好多东西需要开发者自行处理比如一些变量的释放之类的所以我们能少用尽量少用因为cfnetwork是为snihttps环境服务所以我们在拦截判断的时候可以区分是用上层的网络请求转发还是用底层的cfnetwork来转发\"><a class=\"anchor\" href=\"#三行文字加三个链接就完事了-其实在遇到这个坑的时候我也查过很多相关资料无非就是这三行话加这三个链接复制来复制去没有实质性的进展大部分公司或者是项目没有这么重的httpdns需求所以也就不会有这个环境即使遇到了也就直接关闭httpdns了后来只能自己去用cfnetwork一点点实现-具体代码就不跟大家粘贴了因为涉及到一些公司内部的代码不过我会把我主要的参考资料发给大家-这里有个小技巧因为都在说cfnetwork是比较底层的网络实现好多东西需要开发者自行处理比如一些变量的释放之类的所以我们能少用尽量少用因为cfnetwork是为snihttps环境服务所以我们在拦截判断的时候可以区分是用上层的网络请求转发还是用底层的cfnetwork来转发\">#</a> 三行文字加三个链接就完事了。其实在遇到这个坑的时候我也查过很多相关资料，无非就是这三行话加这三个链接复制来复制去，没有实质性的进展，大部分公司或者是项目没有这么重的 Httpdns 需求，所以也就不会有这个环境，即使遇到了也就直接关闭 httpdns 了，后来只能自己去用 CFNetwork 一点点实现。具体代码就不跟大家粘贴了因为涉及到一些公司内部的代码，不过我会把我 **<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0RhdmUxOTkxL2FsaWNsb3VkLWlvcy1kZW1vL2Jsb2IvbWFzdGVyL2h0dHBkbnNfaW9zX2RlbW8vaHR0cGRuc19pb3NfZGVtby9DRkh0dHBNZXNzYWdlVVJMUHJvdG9jb2wubQ==\"> 主要的参考资料</span> ** 发给大家。这里有个小技巧，因为都在说 CFNetwork 是比较底层的网络实现，好多东西需要开发者自行处理比如一些变量的释放之类的，所以我们能少用尽量少用，因为 Cfnetwork 是为 SNI (https) 环境服务，所以我们在拦截判断的时候可以区分是用上层的网络请求转发还是用底层的 cfnetwork 来转发，</h6>\n<p><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span>.request.<span class=\"type\">URL</span>.scheme isEqualToString:@<span class=\"string\">&quot;https&quot;</span>] ) &#123;</span><br><span class=\"line\"><span class=\"comment\">//使用CFnetwork</span></span><br><span class=\"line\">        curRequest <span class=\"operator\">=</span> req;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.task <span class=\"operator\">=</span> [[<span class=\"type\">CustomCFNetworkRequestTask</span> alloc] initWithURLRequest:originalRequest swizzleRequest:curRequest delegate:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.task) &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span>.task startLoading];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//使用普通网络请求</span></span><br><span class=\"line\">        <span class=\"type\">NSURLSessionConfiguration</span> <span class=\"operator\">*</span>configuration <span class=\"operator\">=</span> [<span class=\"type\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.session <span class=\"operator\">=</span> [<span class=\"type\">NSURLSession</span> sessionWithConfiguration:configuration delegate:<span class=\"keyword\">self</span> delegateQueue:[<span class=\"type\">NSOperationQueue</span> mainQueue]];</span><br><span class=\"line\">        <span class=\"type\">NSURLSessionTask</span> <span class=\"operator\">*</span>task <span class=\"operator\">=</span> [<span class=\"keyword\">self</span>.session dataTaskWithRequest:req];</span><br><span class=\"line\">        [task resume];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"我是这么做的\"><a class=\"anchor\" href=\"#我是这么做的\">#</a> 我是这么做的。</h6>\n<h6 id=\"67在nsurlprotocol中的那几个类方法中是可以发送同步请求的但是在实例方法发送同步请求就会卡死所以实例方法中不能有任何的阻塞进行同步操作-不然就卡死\"><a class=\"anchor\" href=\"#67在nsurlprotocol中的那几个类方法中是可以发送同步请求的但是在实例方法发送同步请求就会卡死所以实例方法中不能有任何的阻塞进行同步操作-不然就卡死\">#</a> 6.7：在 NSURLProtocol 中的那几个类方法中是可以发送同步请求的，但是在实例方法发送同步请求就会卡死，所以实例方法中不能有任何的阻塞，进行同步操作。不然就卡死。</h6>\n<h5 id=\"7总结\"><a class=\"anchor\" href=\"#7总结\">#</a> 7：总结</h5>\n<p>完成了以上的步骤之后你回发现在 DNS 坏掉的情况下手机里面除了微信 QQ (他们也做了 DNS 解析) 之外其他应用都不能上网了但是你的 App 依然可以正常浏览网络数据。这就是我最近在做的时候遇到的一些问题，有什么问题及时与我交流吧</p>\n",
            "tags": [
                "网络",
                "底层",
                "httpdns"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-24-iOS-Runtime%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%90%8C%E7%B1%BB%E7%9A%84Method-Swizzling/",
            "url": "https://oliverqueen.cn/2018-01-24-iOS-Runtime%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%90%8C%E7%B1%BB%E7%9A%84Method-Swizzling/",
            "title": "iOS Runtime简单介绍，以及不同类的Method Swizzling",
            "date_published": "2018-01-24T04:18:50.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h5 id=\"runtime介绍\"><a class=\"anchor\" href=\"#runtime介绍\">#</a> Runtime 介绍：</h5>\n<p>runtime 顾名思义就是运行时，其实我们的 App 从你按下 command+R 开始一直到 App 运行起来经历了大致两个阶段，1：编译时，2：运行时。还记得一道很经典的面试题<br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kbsn9yxj30kk03et8z.jpg\" alt=\"\" /></p>\n<p>这里给大家解释下：首先， * testObject 是告诉编译器，testObject 是一个指向某个 Objective-C 对象的指针。因为不管指向的是什么类型的对象，<br />\n<span id=\"more\"></span><br />\n 一个指针所占的内存空间都是固定的，所以这里声明成任何类型的对象，最终生成的可执行代码都是没有区别的。这里限定了 NSString 只不过是告诉编译器，请把 testObject 当做一个 NSString 来检查，如果后面调用了非 NSString 的方法，会产生警告。接着，你创建了一个 NSData 对象，然后把这个对象所在的内存地址保存在 testObject 里。那么运行时 (从这段代码执行开始，到程序结束)，testObject 指向的内存空间就是一个 NSData 对象。你可以把 testObject 当做一个 NSData 对象来用。 所以编译时是 NSString，运行时是 NSData。<br />\nruntime 是什么：<br />\n在 runtime 中，所有的类在 OC 中都会被定义成一个结构体，像这样<br />\n类在 runtime 中的表示<br />\n struct objc_class {<br />\n    Class isa;// 指针，顾名思义，表示是一个什么，  // 实例的 isa 指向类对象，类对象的 isa 指向元类<br />\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> !__OBJC2__</span></span><br><span class=\"line\">        Class super_class;  <span class=\"comment\">//指向父类</span></span><br><span class=\"line\">        <span class=\"type\">const</span> <span class=\"type\">char</span> *name;  <span class=\"comment\">//类名</span></span><br><span class=\"line\">        <span class=\"type\">long</span> version;     <span class=\"comment\">//类的版本信息，默认初始化为 0。我们可以在运行期对其进行修改（class_setVersion）或获取（class_getVersion）。</span></span><br><span class=\"line\">        <span class=\"type\">long</span> info;   <span class=\"comment\">/*供运行期使用的一些位标识。有如下一些位掩码：</span></span><br><span class=\"line\"><span class=\"comment\">                        CLS_CLASS (0x1L) 表示该类为普通 class ，其中包含实例方法和变量；</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法；</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_INITIALIZED (0x4L) 表示该类已经被运行期初始化了，这个标识位只被 objc_addClass 所设置；</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_POSING (0x8L) 表示该类被 pose 成其他的类；（poseclass 在ObjC 2.0中被废弃了）；</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_MAPPED (0x10L) 为ObjC运行期所使用</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_FLUSH_CACHE (0x20L) 为ObjC运行期所使用</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_GROW_CACHE (0x40L) 为ObjC运行期所使用</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_NEED_BIND (0x80L) 为ObjC运行期所使用</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_METHOD_ARRAY (0x100L) 该标志位指示 methodlists 是指向一个 objc_method_list 还是一个包含 objc_method_list 指针的数组；*/</span></span><br><span class=\"line\">        <span class=\"type\">long</span> instance_size  <span class=\"comment\">//该类的实例变量大小（包括从父类继承下来的实例变量）；</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">objc_ivar_list</span> *ivars <span class=\"comment\">//成员变量列表</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">objc_method_list</span> **methodLists; <span class=\"comment\">//方法列表</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">objc_cache</span> *cache;<span class=\"comment\">//缓存   一种优化，调用过的方法存入缓存列表，下次调用先找缓存</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">objc_protocol_list</span> *protocols <span class=\"comment\">//协议列表</span></span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><br />\n 相关的定义<br />\n /// 描述类中的一个方法<br />\n typedef struct objc_method *Method;</p>\n<p>/// 实例变量<br />\n typedef struct objc_ivar *Ivar;</p>\n<p>/// 类别 Category<br />\ntypedef struct objc_category *Category;</p>\n<p>/// 类中声明的属性<br />\n typedef struct objc_property *objc_property_t;</p>\n<p>ObjC 为每个类的定义生成两个 objc_class ，一个即普通的 class，另一个即 metaclass。我们可以在运行期创建这两个 objc_class 数据结构，然后使用 objc_addClass 动态地创建新的类定义。</p>\n<h5 id=\"runtime能干什么\"><a class=\"anchor\" href=\"#runtime能干什么\">#</a> runtime 能干什么：</h5>\n<ul>\n<li>：1：获取一个类中的列表比如方法列表、属性列表、协议列表、成员变量列表像如下这样 其中获取到的属性、方法都是可以获取 public 和 private 的。</li>\n</ul>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unsigned <span class=\"built_in\">int</span> count;</span><br><span class=\"line\">    Class clas = <span class=\"literal\">[WKW<span class=\"identifier\">ebViewController</span> <span class=\"identifier\">class</span>]</span>; <span class=\"comment\">//是我自己的类，之所以不用系统的类是因为系统的类方法属性太多了</span></span><br><span class=\"line\"></span><br><span class=\"line\">    objc_property_t<span class=\"operator\"> * </span>propertyList = <span class=\"keyword\">class</span><span class=\"constructor\">_copyPropertyList(<span class=\"params\">clas</span>, &amp;<span class=\"params\">count</span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">        const <span class=\"built_in\">char</span> *propertyName = property<span class=\"constructor\">_getName(<span class=\"params\">propertyList</span>[<span class=\"params\">i</span>])</span>;</span><br><span class=\"line\">        <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;  %@  属性(包括私有) --------&gt;&gt;&gt;&gt;&gt;    %@&quot;</span>,<span class=\"params\">clas</span>,[NSString <span class=\"params\">stringWithUTF8String</span>:<span class=\"params\">propertyName</span>])</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;-------------------------------------------------------------------------------------------------------------- &quot;</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Method<span class=\"operator\"> * </span>methodList = <span class=\"keyword\">class</span><span class=\"constructor\">_copyMethodList(<span class=\"params\">clas</span>, &amp;<span class=\"params\">count</span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">        Method methodName = methodList<span class=\"literal\">[<span class=\"identifier\">i</span>]</span>;</span><br><span class=\"line\">        <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;  %@ 方法(包括私有)  --------&gt;&gt;&gt;&gt;&gt;    %@&quot;</span>,<span class=\"params\">clas</span>,NSStringFromSelector(<span class=\"params\">method_getName</span>(<span class=\"params\">methodName</span>)</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;-------------------------------------------------------------------------------------------------------------- &quot;</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    Ivar *ivarList = <span class=\"keyword\">class</span><span class=\"constructor\">_copyIvarList(<span class=\"params\">clas</span>, &amp;<span class=\"params\">count</span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i&lt;count; i++) &#123;</span><br><span class=\"line\">        Ivar myIvar = ivarList<span class=\"literal\">[<span class=\"identifier\">i</span>]</span>;</span><br><span class=\"line\">        const <span class=\"built_in\">char</span> *ivarName = ivar<span class=\"constructor\">_getName(<span class=\"params\">myIvar</span>)</span>;</span><br><span class=\"line\">        <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;%@ 成员变量(包括私有) --------&gt;&gt;&gt;&gt;&gt; %@&quot;</span>,<span class=\"params\">clas</span>, [NSString <span class=\"params\">stringWithUTF8String</span>:<span class=\"params\">ivarName</span>])</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;-------------------------------------------------------------------------------------------------------------- &quot;</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//获取协议列表</span></span><br><span class=\"line\">    __unsafe_unretained Protocol **protocolList = <span class=\"keyword\">class</span><span class=\"constructor\">_copyProtocolList([<span class=\"params\">self</span> <span class=\"params\">class</span>], &amp;<span class=\"params\">count</span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i&lt;count; i++) &#123;</span><br><span class=\"line\">        Protocol *myProtocal = protocolList<span class=\"literal\">[<span class=\"identifier\">i</span>]</span>;</span><br><span class=\"line\">        const <span class=\"built_in\">char</span> *protocolName = protocol<span class=\"constructor\">_getName(<span class=\"params\">myProtocal</span>)</span>;</span><br><span class=\"line\">        <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;%@ 协议 --------&gt;&gt;&gt;&gt;&gt; %@&quot;</span>,<span class=\"params\">clas</span>, [NSString <span class=\"params\">stringWithUTF8String</span>:<span class=\"params\">protocolName</span>])</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br />\n 输出后的结果是<br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kc7w3zcj30pk0ajdks.jpg\" alt=\"image.png\" /><br />\n 其中也包括了私有方法。</p>\n<ul>\n<li>2：拦截方法调用<br />\n有的时候我们用一个类或者一个实例变量去调用一个方法，由于操作失误或者是其他原因，导致这个所被调用的方法并不存在，报出这样的错误，然后闪退！<br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kcfrky6j30tr0120sy.jpg\" alt=\"image.png\" /></li>\n</ul>\n<p>这个时候如果我们想避免这些崩溃，我们就需要在运行时对其做一些手脚。iOS 中方法调用的流程：其实调用方法就是发送消息，所有调用方法的代码例如   [obj aaa]  在运行时 runtime 会将这段代码转换为 objc_msgSend (obj, [@selector]);（本质就是发送消息）然后 obj 会通过其中 isa 指针去该类的缓存中 (cache) 查找对应函数的 Method, 如果没有找到，再去该类的方法列表（methodList）中查找，如果没有找到再去该类的父类找，如果找到了，就先将方法添加到缓存中，以便下次查找，然后通过 method 中的指针定位到指定方法执行。如果一直没有找到，便会走完如下四个方法之后崩溃。</p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    如果调用的是不存在的实例方法则会在奔溃前进入该方法，防止崩溃可以在此处做处理</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+(<span class=\"type\">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 如果调用的是不存在的类方法则会在奔溃前进入该方法，防止崩溃可以在此处做处理</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+(<span class=\"type\">BOOL</span>)resolveClassMethod:(SEL)sel &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 这个方法会把你所调用的不存在的方法重定向到一个声明了该方法的类中，只需要你返回一个有该方法的</span></span><br><span class=\"line\"><span class=\"comment\"> 类就可以，如果你重定向的这个类仍然不具有该方法那么会继续崩溃</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">-(<span class=\"type\">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 将你不存在的方法打包成NSInvocation对象，做完你自己的处理之后</span></span><br><span class=\"line\"><span class=\"comment\"> 调用invokeWithTarget让某个target来处理该方法</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">-(<span class=\"type\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)anInvocation &#123;</span><br><span class=\"line\">    [anInvocation invokeWithTarget:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>3：动态添加方法<br />\n因为我们调用了一个不存在的方法导致崩溃，那么我们在判断出不存在后就动态添加上一个方法吧 这样不就不会蹦了吗？我们先写一个方法用来给我们做出提示</li>\n</ul>\n<p><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- <span class=\"params\">(void)</span> errorMethod &#123;</span><br><span class=\"line\">    NSLog<span class=\"params\">(@<span class=\"string\">&quot;no method!!!!!!!&quot;</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 如果调用了没有的方法，那么就把这个方法添加进去，然后把被调用的方法的指针指向这个 error1：，那么一旦调用了没有的方法就会走这个。我们来看代码</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+(BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class=\"line\">    Method errorMethod =  <span class=\"keyword\">class</span><span class=\"constructor\">_getInstanceMethod([<span class=\"params\">self</span> <span class=\"params\">class</span>], @<span class=\"params\">selector</span>(<span class=\"params\">errorMethod</span>)</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">[NSS<span class=\"identifier\">tringFromSelector</span>(<span class=\"identifier\">sel</span>) <span class=\"identifier\">isEqualToString</span>:@&quot;<span class=\"identifier\">testMethod</span>&quot;]</span>) &#123;</span><br><span class=\"line\">        BOOL isAdd =  <span class=\"keyword\">class</span><span class=\"constructor\">_addMethod([<span class=\"params\">self</span> <span class=\"params\">class</span>], <span class=\"params\">sel</span>, <span class=\"params\">method_getImplementation</span>(<span class=\"params\">errorMethod</span>)</span>, <span class=\"keyword\">method</span><span class=\"constructor\">_getTypeEncoding(<span class=\"params\">errorMethod</span>)</span>);</span><br><span class=\"line\">        <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;tinajia  = %d&quot;</span>,<span class=\"params\">isAdd</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//Do something</span></span><br><span class=\"line\">    return YES;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>主要用到</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    添加方法</span></span><br><span class=\"line\"><span class=\"comment\">     @param class] 在哪个类里添加</span></span><br><span class=\"line\"><span class=\"comment\">     @param sel 添加的方法的名字</span></span><br><span class=\"line\"><span class=\"comment\">     @param errorMethod 添加的方法的实现IMP指</span></span><br><span class=\"line\"><span class=\"comment\">     @param types 方法的标示符</span></span><br><span class=\"line\"><span class=\"comment\">     @return 是否添加成功</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">BOOL isAdd =  <span class=\"keyword\">class</span><span class=\"constructor\">_addMethod([<span class=\"params\">self</span> <span class=\"params\">class</span>], <span class=\"params\">sel</span>, <span class=\"params\">method_getImplementation</span>(<span class=\"params\">errorMethod</span>)</span>, <span class=\"keyword\">method</span><span class=\"constructor\">_getTypeEncoding(<span class=\"params\">errorMethod</span>)</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>然后运行下：</p>\n<p><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">WKWebViewController</span> <span class=\"operator\">*</span> vc<span class=\"operator\">=</span> [[<span class=\"type\">WKWebViewController</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">[vc performSelector:<span class=\"meta\">@selector</span>(testMethod)];</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>我调用了并不存在的 testMethod 方法并没有崩溃并且方法已经成功添加了</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kexyuzgj30f801mwel.jpg\" alt=\"image.png\" /></p>\n<ul>\n<li>\n<p>4：动态交换方法（也叫 iOS 黑魔法，慎用）<br />\n没什么好例子，用一个网上说的例子 (引用别人的东西，懒得复制了，就截了图)</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kg3i5z6j30hv0fj0z9.jpg\" alt=\"\" /></p>\n<p>其实本质即使 SEL 和 IMP 的交换，原理是这样的：在 iOS 中每一个类中都有一个叫 dispatch table 的东西，里面存放在 SEL 和他所对应的 IMP 指针，之前也说过方法调用就是通过 sel 找 IMP 指针然后指针定位调用方法。方法交换就是对这个 dispatch table 进行操作。让 A 的 SEL 去对应 B 的 IMP，B 的 SEL 对应 A 的 IMP，如图</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kgrq52oj30f80betcz.jpg\" alt=\"\" /></p>\n<p>这样就达到方法交换的目的，下面看代码：</p>\n</li>\n</ul>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)changeMethod &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  如果是类方法 要使用 !</span></span><br><span class=\"line\">    <span class=\"comment\">//  如果是系统的集合类的属性要用元类 比如 __NSSetM = NSMutableSet</span></span><br><span class=\"line\">    <span class=\"comment\">//  Class  class = NSClassFromString(@&quot;__NSSetM&quot;);</span></span><br><span class=\"line\">    <span class=\"comment\">//  Class metaClass = objc_getMetaClass([NSStringFromClass(class) UTF8String]);</span></span><br><span class=\"line\">    Class systemClass = <span class=\"constructor\">NSClassFromString(<span class=\"params\">__NSSetM</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    SEL sel_System = <span class=\"constructor\">NSSelectorFromString(<span class=\"params\">addObject</span>:)</span>;</span><br><span class=\"line\">    SEL sel_Custom = @selector(swizzle_addObject:);</span><br><span class=\"line\"></span><br><span class=\"line\">    Method method_System = <span class=\"keyword\">class</span><span class=\"constructor\">_getInstanceMethod(<span class=\"params\">systemClass</span>, <span class=\"params\">sel_System</span>)</span>;</span><br><span class=\"line\">    Method method_Custom = <span class=\"keyword\">class</span><span class=\"constructor\">_getInstanceMethod([<span class=\"params\">self</span> <span class=\"params\">class</span>], <span class=\"params\">sel_Custom</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    IMP imp_System = <span class=\"keyword\">method</span><span class=\"constructor\">_getImplementation(<span class=\"params\">method_System</span>)</span>;</span><br><span class=\"line\">    IMP imp_Custom = <span class=\"keyword\">method</span><span class=\"constructor\">_getImplementation(<span class=\"params\">method_Custom</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">method</span><span class=\"constructor\">_exchangeImplementations(<span class=\"params\">method_System</span>, <span class=\"params\">method_Custom</span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)swizzle_addObject:(id) obj &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj) &#123;</span><br><span class=\"line\">        <span class=\"literal\">[<span class=\"identifier\">self</span> <span class=\"identifier\">swizzle_addObject</span>:<span class=\"identifier\">obj</span>]</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>主要代码  method_exchangeImplementations (method1, method2); 这两个参数很简单，就是两个需要交换的方法。<br />\n最后我调用了 m1 但是实际上走了 m2。</p>\n<h5 id=\"动态交换方法的原理以及交换过程中指针的变化\"><a class=\"anchor\" href=\"#动态交换方法的原理以及交换过程中指针的变化\">#</a> 动态交换方法的原理以及交换过程中指针的变化</h5>\n<p>在通常的方法交换中我们通常有两种情景，一种是我会针对被交换的类建一个 category，然后 hook 的方法会写在 category 中。另一种是自己创建一个 Tool 类里面放些常用的工具方法其中包含了方法交换。可能大家普遍选择第一种方法，但是如果你需要 hook 的类非常多的 (我实际项目中就遇到这样的问题) 那你就需要针对不同的类创建 category，就会导致文件过多，且每一个文件中只有一个 hook 方法，这样一来左侧一堆文件，所以我用了第二种方法，但是在使用过程中出现一个问题，先看下我的代码结构</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6khw8c97j30740ag74v.jpg\" alt=\"image.png\" /></p>\n<p>我要 hook 的是 ViewController 中的 viewDidLoad 方法，我建立了两个类一个是 ViewController 的 category，另一个是 Tool 类，为了一会区别演示不同类 hook 的不同 (两个类中 hook 的代码完全一样)</p>\n<ul>\n<li>ViewController 中将要被替换的系统方法</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kir8y63j309a02rglq.jpg\" alt=\"被替换的方法(系统方法)\" /></p>\n<ul>\n<li>Category 中将要用来替换的自定义方法</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kj5dcykj308z02lwep.jpg\" alt=\"用来替换的方法(自定义方法)\" /></p>\n<ul>\n<li>然后在 ViewController 中的 load 中做方法替换</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kjlzvdqj30f90b43zw.jpg\" alt=\"进行方法替换\" /></p>\n<p>运行一下的输出结果想必大家已经猜到了先执行 custom 再执行 system，这是通常情况下大家的做法。<br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kjxsheej30d701h3yl.jpg\" alt=\"结果\" /></p>\n<p>下面再来看下如果我将替换方法写在不同类中会怎样，调用 Tool 中的交换方法</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kka2s8uj30dx0anwfp.jpg\" alt=\"执行Tool中的交换方法\" /></p>\n<p>然后直接看结果了，因为代码都是一模一样的我直接复制过去的</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kliitupj30yd08w422.jpg\" alt=\"结果\" /></p>\n<p>发生了 crash，原因是 ViewController 中没有 swizzel_viewDidLoad_custom 这个方法，为什么不同类的交换会出现这种问题，我们用个图来说明下</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6km0wogkj30yg0pz43q.jpg\" alt=\"image.png\" /></p>\n<p>解决的办法是我们在交换方法之前要先像其中添加方法，也就是说把 customMethod 添加到 SystemClass 中，但是注意要把 customMethod 的实现指向 syetemMethod 的实现。这样一来就可以达到 SystemClass 调用 customMethod 却执行 systemMethod 的代码的效果，实现以上要求我们需要在交换之前执行这个方法。</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span><span class=\"constructor\">_addMethod(<span class=\"params\">systemClass</span>, <span class=\"params\">sel_Custom</span>, <span class=\"params\">imp_System</span>, <span class=\"params\">method_getTypeEncoding</span>(<span class=\"params\">method_System</span>)</span>)</span><br></pre></td></tr></table></figure></p>\n<p>其中第一个参数是需要往哪个类添加；第二个参数是要添加的方法的方法名；第三个参数是所添加的方法的方法实现，第四个是方法的标识符。经过就该之后我们的代码是这样</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">之前的都一样就省略</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">class</span><span class=\"constructor\">_addMethod(<span class=\"params\">systemClass</span>, <span class=\"params\">sel_Custom</span>, <span class=\"params\">imp_System</span>, <span class=\"params\">method_getTypeEncoding</span>(<span class=\"params\">method_System</span>)</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">class</span><span class=\"constructor\">_replaceMethod(<span class=\"params\">systemClass</span>, <span class=\"params\">sel_System</span>, <span class=\"params\">imp_Custom</span>, <span class=\"params\">method_getTypeEncoding</span>(<span class=\"params\">method_System</span>)</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">method</span><span class=\"constructor\">_exchangeImplementations(<span class=\"params\">method_System</span>, <span class=\"params\">method_Custom</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>我们来看下执行完 add 操作之后此时的方法和类的对应关系 (红色的为 add 的修改)</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kmhkzidj30yg0g378f.jpg\" alt=\"关系\" /></p>\n<p>因为 SystemClass 中本身不包含 customMethod 所以 add 一定是成功的，也就是说会进入判断执行 replace 方法。</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span><span class=\"constructor\">_replaceMethod(<span class=\"params\">systemClass</span>, <span class=\"params\">sel_System</span>, <span class=\"params\">imp_Custom</span>, <span class=\"params\">method_getTypeEncoding</span>(<span class=\"params\">method_System</span>)</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>第一个参数：需要修改的方法的所在的类；第二个参数：需要替换其实现的方法名；第三个参数：需要把哪个实现替换给他；第四个参数：方法标识符。此时看下我们做完 replace 之后的类与方法名以及他们实现的关系 (红色的为 replace 的修改)。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6kn9m5btj30yg0ifgqa.jpg\" alt=\"关系\" /></p>\n<p>此时大家已经看出来了，虽然没有执行 exchange 方法，但是我已经达到了方法交换的目的。系统执行 systemMethod 时候会走 customMethod 的实现但是因为在 customMethod 方法中我会递归执行 [self customMethod]，所以又会走到 systemMethod 的实现，因为之前进行了方法添加，所以此时 A 类中有了 customMethod 方法，不会再发生之前的 crash。达到一个不同类进行 Method Swizzling 的目的。</p>\n<h5 id=\"综上来看一个完整严谨的methodswizzling应该在交换前先add并且add方法的参数不能错\"><a class=\"anchor\" href=\"#综上来看一个完整严谨的methodswizzling应该在交换前先add并且add方法的参数不能错\">#</a> 综上来看一个完整严谨的 MethodSwizzling 应该在交换前先 add，并且 add 方法的参数不能错</h5>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)changeMethod &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Class systemClass = <span class=\"constructor\">NSClassFromString(@<span class=\"string\">&quot;你的类&quot;</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    SEL sel_System = @selector(系统方法);</span><br><span class=\"line\">    SEL sel_Custom = @selector(你自己的方法);</span><br><span class=\"line\"></span><br><span class=\"line\">    Method method_System = <span class=\"keyword\">class</span><span class=\"constructor\">_getInstanceMethod(<span class=\"params\">systemClass</span>, <span class=\"params\">sel_System</span>)</span>;</span><br><span class=\"line\">    Method method_Custom = <span class=\"keyword\">class</span><span class=\"constructor\">_getInstanceMethod([<span class=\"params\">self</span> <span class=\"params\">class</span>], <span class=\"params\">sel_Custom</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    IMP imp_System = <span class=\"keyword\">method</span><span class=\"constructor\">_getImplementation(<span class=\"params\">method_System</span>)</span>;</span><br><span class=\"line\">    IMP imp_Custom = <span class=\"keyword\">method</span><span class=\"constructor\">_getImplementation(<span class=\"params\">method_Custom</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">class</span><span class=\"constructor\">_addMethod(<span class=\"params\">systemClass</span>, <span class=\"params\">sel_Custom</span>, <span class=\"params\">imp_System</span>, <span class=\"params\">method_getTypeEncoding</span>(<span class=\"params\">method_System</span>)</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">class</span><span class=\"constructor\">_replaceMethod(<span class=\"params\">systemClass</span>, <span class=\"params\">sel_System</span>, <span class=\"params\">imp_Custom</span>, <span class=\"params\">method_getTypeEncoding</span>(<span class=\"params\">method_System</span>)</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">method</span><span class=\"constructor\">_exchangeImplementations(<span class=\"params\">method_System</span>, <span class=\"params\">method_Custom</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h5 id=\"以上代码无论是写在工具类中还是category中都是没有问题的\"><a class=\"anchor\" href=\"#以上代码无论是写在工具类中还是category中都是没有问题的\">#</a> 以上代码无论是写在工具类中还是 category 中都是没有问题的。</h5>\n",
            "tags": [
                "底层",
                "runtime"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-24-%E8%AE%B0%E4%B8%80%E6%AC%A1Runtime-Hook%E7%9A%84%E9%97%AE%E9%A2%98/",
            "url": "https://oliverqueen.cn/2018-01-24-%E8%AE%B0%E4%B8%80%E6%AC%A1Runtime-Hook%E7%9A%84%E9%97%AE%E9%A2%98/",
            "title": "记一次Runtime Hook的问题",
            "date_published": "2018-01-24T03:35:57.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h4 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景</h4>\n<p>项目中遇到一个问题，需要引入两个 SDK，我们暂且命名为 A 和 B，由于业务需要这两个 SDK 都需要对一个系统函数 C 进行 hook, 但是有一个前提，由于 B 所做的是一个统计相关的 SDK，所以 B 要监控 App 内的所有代码这其中也包括了 SDK A 所做的一些操作，所以我们必须确保 B 在 hook C 函数时候  A 已经对 C 函数 hook 完毕，其实这就涉及到 hook 顺序的问题。<br />\n<span id=\"more\"></span></p>\n<h4 id=\"研究\"><a class=\"anchor\" href=\"#研究\">#</a> 研究</h4>\n<p>先看下代码，我用 hookMethod 来模仿系统方法。<br />\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>) TEST_HOOK_TWICE &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> changeOrginalSelectorName:<span class=\"string\">@&quot;hookedMethod&quot;</span> inClass:<span class=\"string\">@&quot;RootViewController&quot;</span> withCustomSelectorName:<span class=\"string\">@&quot;swizzle_hookedMethod1&quot;</span> isClassMethod:<span class=\"literal\">NO</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> changeOrginalSelectorName:<span class=\"string\">@&quot;hookedMethod&quot;</span> inClass:<span class=\"string\">@&quot;RootViewController&quot;</span> withCustomSelectorName:<span class=\"string\">@&quot;swizzle_hookedMethod2&quot;</span> isClassMethod:<span class=\"literal\">NO</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> hookedMethod];</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)hookedMethod &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;原始方法&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)swizzle_hookedMethod1 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;1&quot;</span>);</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> swizzle_hookedMethod1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)swizzle_hookedMethod2 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;2&quot;</span>);</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> swizzle_hookedMethod2];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 然后看下没有 hook 之前的样子</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6ll1zt21j30j80jk3zc.jpg\" alt=\"原本的样子\" /></p>\n<p>然后我们执行代码<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一步：交换A中的方法和系统方法</span></span><br><span class=\"line\"> [<span class=\"keyword\">self</span> changeOrginalSelectorName:<span class=\"string\">@&quot;hookedMethod&quot;</span> inClass:<span class=\"string\">@&quot;RootViewController&quot;</span> withCustomSelectorName:<span class=\"string\">@&quot;swizzle_hookedMethod1&quot;</span> isClassMethod:<span class=\"literal\">NO</span>];</span><br><span class=\"line\"><span class=\"comment\">//第二步：交换B中的方法和系统方法</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> changeOrginalSelectorName:<span class=\"string\">@&quot;hookedMethod&quot;</span> inClass:<span class=\"string\">@&quot;RootViewController&quot;</span> withCustomSelectorName:<span class=\"string\">@&quot;swizzle_hookedMethod2&quot;</span> isClassMethod:<span class=\"literal\">NO</span>];</span><br><span class=\"line\"><span class=\"comment\">//第三步：调用系统方法</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> hookedMethod];</span><br></pre></td></tr></table></figure><br />\n 然后我们一步一步来看，先看调用第一步之后是什么样子的 (红色箭头为第一步之后的样子)</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6llhzf0uj30ki0k2q3z.jpg\" alt=\"第一步之后\" /></p>\n<p>然后看第二步调用完之后的样子 (绿色是第二步调用)</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6lm7mfshj30jo0iu75m.jpg\" alt=\"第二部之后的样子\" /></p>\n<p>接下来我们调用系统方法也就是第三步，然后我们看下流程是怎样的 (每个方法实现里面都会递归调用下自身，为了是 hook 时候不改变原有逻辑)</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6lmi43vmj30yg03v756.jpg\" alt=\"调用顺序\" /></p>\n<p>这样一来就很明显 如果想想监控住所有的代码那就需要在 A IMP 这步，因为之前的 Hook 顺序是先 A -&gt; B -&gt; System 这样一来只要我们改一下顺序改为 B -&gt; A -&gt; System 就可以让 B SDK 监控到所有的代码。</p>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6ln0wmlyj30yg07ign0.jpg\" alt=\"调用顺序\" /></p>\n",
            "tags": [
                "底层",
                "runtime",
                "Hook"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-23-iOS%E4%B8%AD%E4%BD%BF%E7%94%A8OpenGL%E5%AE%9E%E7%8E%B0%E5%A2%9E%E9%AB%98%E5%8A%9F%E8%83%BD/",
            "url": "https://oliverqueen.cn/2018-01-23-iOS%E4%B8%AD%E4%BD%BF%E7%94%A8OpenGL%E5%AE%9E%E7%8E%B0%E5%A2%9E%E9%AB%98%E5%8A%9F%E8%83%BD/",
            "title": "iOS中使用OpenGL实现增高功能",
            "date_published": "2018-01-23T13:23:49.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"功能效果\"><a class=\"anchor\" href=\"#功能效果\">#</a> 功能效果</h3>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6lpd4q64g308u0fqnpe.gif\" alt=\"demo示例\" /><br />\n<span id=\"more\"></span></p>\n<h3 id=\"功能分析\"><a class=\"anchor\" href=\"#功能分析\">#</a> 功能分析</h3>\n<ul>\n<li>\n<p>功能：渲染一张传入的图片 -&gt; 手动选择编辑区域 -&gt; 通过滑块来编辑区域的增高或者缩短</p>\n</li>\n<li>\n<p>OpenGL 原理：</p>\n<ul>\n<li>\n<p>因为 OpenGL 只能绘制三角形，所以在处理图像或者图形的时候我们需要将被处理的对象用三角行来分割转换为三角形和顶点的组成的对象。</p>\n</li>\n<li>\n<p>OpenGL 里面坐标是以左下角为原点 X 轴向上为正，Y 轴向右为正</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"功能实现\"><a class=\"anchor\" href=\"#功能实现\">#</a> 功能实现</h3>\n<ul>\n<li>渲染图片拆分图片：\n<ul>\n<li>拆分方法 1：通过图形看出是一个矩形，而矩形是可以分成两个三角形和四个顶点，通过此可以用 GL 渲染出图片。</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6lpjw6g3j30dw0ee7ft.jpg\" alt=\"拆分三角形\" /></p>\n<p>这样拆分之后虽然可以正常渲染，但是带来的问题是我的四个顶点都是死的，也就是四个顶点必须是画布的四个顶点，改变顶点的坐标后只能导致整张画布的变动，而不是某一个区域的变动，拉伸的话也是整张图片的拉伸，所以想要实现局部处理的话这种分割方式不可行。</p>\n<ul>\n<li>拆分方法 2：将整张图片先拆分为三个矩形，然后再把每个矩形拆分成两个三角形，得到 6 个三角形，8 个顶点，如下图：</li>\n</ul>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6lprpvrrj30dw0eddrh.jpg\" alt=\"拆分2\" /></p>\n<p>这样一来就可以保证中间的矩形的高度可以任意变化而上下两部分的高度不变只改变位置，也就是说我们这个 DEMO 中所做的任何拉伸操作都是对中间矩形的操作，换而言之就是改变最上面的矩形和最下面的矩形之间的距离来达到对中间区域的拉伸和压缩的目的。根据拆分的方式我们用顶点的坐标创建一个数组<br />\n <figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">//</span>顶点数组</span><br><span class=\"line\">GLfloat vertices[] = &#123;   </span><br><span class=\"line\">    -1.2, -1.2,     <span class=\"string\">//</span>左下</span><br><span class=\"line\">    1.2, -1.2,      <span class=\"string\">//</span>右下</span><br><span class=\"line\">    -1.2, -0.4,     <span class=\"string\">//</span>小矩形左下</span><br><span class=\"line\">    1.2, -0.4,      <span class=\"string\">//</span>小矩形右下</span><br><span class=\"line\">    -1.2,  0.4,     <span class=\"string\">//</span>小矩形左上</span><br><span class=\"line\">    1.2,  0.4,      <span class=\"string\">//</span>小矩形右上</span><br><span class=\"line\">    -1.2,  1.2,     <span class=\"string\">//</span>左上</span><br><span class=\"line\">    1.2,  1.2,      <span class=\"string\">//</span>右上</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"string\">//</span>填充纹理的数组</span><br><span class=\"line\">GLfloat texCoords[] = &#123;     </span><br><span class=\"line\">    0, 0,        <span class=\"string\">//</span>左下                  <span class=\"string\">//</span>下标为 0 1</span><br><span class=\"line\">    1, 0,        <span class=\"string\">//</span>右下                  <span class=\"string\">//</span>下标为2 3</span><br><span class=\"line\">    0, 1.0/3.0,  <span class=\"string\">//</span>小矩形左下             <span class=\"string\">//</span>下标为4 5</span><br><span class=\"line\">    1, 1.0/3.0,  <span class=\"string\">//</span>小矩形右下             <span class=\"string\">//</span>下标为6 7</span><br><span class=\"line\">    0, 2.0/3.0,  <span class=\"string\">//</span>小矩形左上角           <span class=\"string\">//</span>下标为8 9</span><br><span class=\"line\">    1, 2.0/3.0,  <span class=\"string\">//</span>小矩形右上角           <span class=\"string\">//</span>下标为10 11</span><br><span class=\"line\">    0, 1,        <span class=\"string\">//</span>左上                  <span class=\"string\">//</span>下标为12 13</span><br><span class=\"line\">    1, 1,        <span class=\"string\">//</span>右上                  <span class=\"string\">//</span>下标为14 15</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>手动选择区域：通过添加带有自定义手势的 UIView 来实现拖动修改选择区域。</li>\n</ul>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*****************CustomPanView代码******************</span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">CustomPanViewDelegate</span> &lt;<span class=\"title\">NSObject</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  开始拖拽</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param customPanView 自身</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param centerY       自身所在的y坐标</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)beginDragWithCoustomPanView:(<span class=\"built_in\">UIView</span> *)customPanView centerY:(<span class=\"built_in\">CGFloat</span>)centerY;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CustomPanView</span> : <span class=\"title\">UIView</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"type\">id</span>&lt;CustomPanViewDelegate&gt; delegate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*****************CustomPanViewDelegate代码******************</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark -</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark 拖拽View的代理方法</span></span><br><span class=\"line\">-(<span class=\"type\">void</span>)beginDragWithCoustomPanView:(<span class=\"built_in\">UIView</span> *)customPanView centerY:(<span class=\"built_in\">CGFloat</span>)centerY &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 限制范围：裁剪区不能大于图片区域</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (customPanView.center.y &gt;= imageBottom) &#123;</span><br><span class=\"line\">        customPanView.center = <span class=\"built_in\">CGPointMake</span>(customPanView.center.x, imageBottom);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (customPanView.center.y &lt;= imageTop) &#123;</span><br><span class=\"line\">        customPanView.center = <span class=\"built_in\">CGPointMake</span>(customPanView.center.x, imageTop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    获取两条线的坐标</span></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> topY = _topView.center.y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> bottomY = _bottomView.center.y;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    根据两条线的坐标刷新裁剪区域UI</span></span><br><span class=\"line\">    [_cutLabel setFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, topY &lt; bottomY ? topY : bottomY, SCREEN_WIDTH, fabs(bottomY - topY))];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    算出裁剪起始坐标和结束坐标</span></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> fromPoint = topY &lt; bottomY ? (imageBottom - bottomY) / imageHeight : (imageBottom - topY) / imageHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> toPoint = topY &lt; bottomY ? (imageBottom - topY) / imageHeight : (imageBottom - bottomY) / imageHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//将中间的矩形的顶点坐标和坐标联系裁剪区域联系起来。</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> sendFromePoint:fromPoint endPoint:toPoint];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_cutLabel.frame.size.height &lt; <span class=\"number\">30</span>) &#123;  <span class=\"comment\">//隐藏文字</span></span><br><span class=\"line\">        _cutLabel.text = <span class=\"string\">@&quot;&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        _cutLabel.text = <span class=\"string\">@&quot;编辑区域&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.slider setValue:<span class=\"number\">0.0</span> animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    tmpHeight = <span class=\"number\">0.0</span>f;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 使用一个 Delegate 将拖移后的 Y 坐标返回，因为是竖直运动的所以我们只关心 Y 轴坐标。</p>\n<ul>\n<li>改变大小：通过将 UISliderBar 的 ValueChange 和顶点坐标关联来实现改变顶点坐标，之后调用 GLKView 的 display 的方法来刷新 UI，将变化的过程展现出来。</li>\n</ul>\n<p><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)action:(UISlider *)sender &#123;</span><br><span class=\"line\">    <span class=\"regexp\">//</span>判断是否是向右滑动</span><br><span class=\"line\">    isRightDirection = sender.value &gt;= judgeDirection ? YES : NO;</span><br><span class=\"line\">    <span class=\"regexp\">//</span>所改变的高度</span><br><span class=\"line\">    changeHeight = sender.value - tmpHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"regexp\">//</span>遍历数组</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (int i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">16</span>; i ++) &#123;</span><br><span class=\"line\">        <span class=\"regexp\">//</span>将Y坐标筛选出来</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i % <span class=\"number\">2</span> != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"regexp\">//</span>下半部分矩形</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt;= <span class=\"number\">7</span>) &#123;</span><br><span class=\"line\">                <span class=\"regexp\">//</span>下半部分矩形Y轴做减法减去变化的高度</span><br><span class=\"line\">                vertices[i] = verticesCopy[i] - changeHeight;</span><br><span class=\"line\">                <span class=\"regexp\">//</span>上半部分矩形</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">9</span>) &#123;</span><br><span class=\"line\">                <span class=\"regexp\">//</span>上半部分矩形Y轴做加法加上变化的高度</span><br><span class=\"line\">                vertices[i] = verticesCopy[i] + changeHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"regexp\">//</span>缩小时候如果编辑区域已经成为一条线了就不能在缩小了</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vertices[<span class=\"number\">11</span>] &gt; vertices[<span class=\"number\">7</span>]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        [self.glView display];</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>通过 glReadPixels 来从内存中读取像素数据，GLubyte -&gt; CGImageRef -&gt; UIimage 然后最相关的保存或者其他操作。</li>\n</ul>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#pragma mark -</span><br><span class=\"line\">#pragma mark 获取处理后的图片</span><br><span class=\"line\">- (UIImage *) createImage &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> imageY = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> imgHeight = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isRightDirection) &#123; <span class=\"comment\">// 判断slider滑动方向</span></span><br><span class=\"line\"></span><br><span class=\"line\">        imageY = fabs(imageTop - fabs(changeHeight<span class=\"operator\"> * </span>perOpengleseCoordinate))<span class=\"operator\"> * </span>screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">        imgHeight = fabs(imageHeight + <span class=\"number\">2</span><span class=\"operator\"> * </span>fabs(changeHeight<span class=\"operator\"> * </span>perOpengleseCoordinate))<span class=\"operator\"> * </span>screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        imageY = fabs(imageTop + fabs(changeHeight<span class=\"operator\"> * </span>perOpengleseCoordinate))<span class=\"operator\"> * </span>screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">        imgHeight = fabs(imageHeight - <span class=\"number\">2</span><span class=\"operator\"> * </span>fabs(changeHeight<span class=\"operator\"> * </span>perOpengleseCoordinate))<span class=\"operator\"> * </span>screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> imageWidth = SCREEN_WIDTH<span class=\"operator\"> * </span>screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> dataLength = imageWidth<span class=\"operator\"> * </span>imgHeight<span class=\"operator\"> * </span><span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    GLubyte *data = (GLubyte*)malloc(dataLength<span class=\"operator\"> * </span>sizeof(GLubyte));</span><br><span class=\"line\"></span><br><span class=\"line\">    gl<span class=\"constructor\">PixelStorei(GL_PACK_ALIGNMENT, 4)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    gl<span class=\"constructor\">ReadPixels(0, <span class=\"params\">imageY</span>, <span class=\"params\">imageWidth</span>, <span class=\"params\">imgHeight</span>, GL_RGBA, GL_UNSIGNED_BYTE, <span class=\"params\">data</span>)</span>;  <span class=\"comment\">//从内存中读取像素</span></span><br><span class=\"line\">    CGDataProviderRef <span class=\"built_in\">ref</span> = <span class=\"constructor\">CGDataProviderCreateWithData(NULL, <span class=\"params\">data</span>, <span class=\"params\">dataLength</span>, NULL)</span>;</span><br><span class=\"line\">    CGColorSpaceRef colorspace = <span class=\"constructor\">CGColorSpaceCreateDeviceRGB()</span>;</span><br><span class=\"line\">    CGImageRef iref = <span class=\"constructor\">CGImageCreate(<span class=\"params\">imageWidth</span>, <span class=\"params\">imgHeight</span>, 8, 32, <span class=\"params\">imageWidth</span> <span class=\"operator\">*</span> 4, <span class=\"params\">colorspace</span>, <span class=\"params\">kCGBitmapByteOrder32Big</span> | <span class=\"params\">kCGImageAlphaPremultipliedLast</span>,<span class=\"params\">ref</span>, NULL, <span class=\"params\">true</span>, <span class=\"params\">kCGRenderingIntentDefault</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"constructor\">UIGraphicsBeginImageContext(CGSizeMake(<span class=\"params\">imageWidth</span>, <span class=\"params\">imgHeight</span>)</span>);</span><br><span class=\"line\">    CGContextRef cgcontext = <span class=\"constructor\">UIGraphicsGetCurrentContext()</span>;</span><br><span class=\"line\">    <span class=\"constructor\">CGContextSetBlendMode(<span class=\"params\">cgcontext</span>, <span class=\"params\">kCGBlendModeCopy</span>)</span>;</span><br><span class=\"line\">    <span class=\"constructor\">CGContextDrawImage(<span class=\"params\">cgcontext</span>, CGRectMake(0, 0, <span class=\"params\">imageWidth</span>, <span class=\"params\">imgHeight</span>)</span>, iref);</span><br><span class=\"line\"></span><br><span class=\"line\">    CGImageRef imageMasked = <span class=\"constructor\">CGBitmapContextCreateImage(<span class=\"params\">cgcontext</span>)</span>;</span><br><span class=\"line\">    UIImage<span class=\"operator\"> * </span>image = <span class=\"literal\">[UII<span class=\"identifier\">mage</span> <span class=\"identifier\">imageWithCGImage</span>:<span class=\"identifier\">imageMasked</span> <span class=\"identifier\">scale</span>:<span class=\"identifier\">screenScale</span> <span class=\"identifier\">orientation</span>:UII<span class=\"identifier\">mageOrientationUp</span>]</span>;</span><br><span class=\"line\">    <span class=\"constructor\">UIGraphicsEndImageContext()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    free(data);</span><br><span class=\"line\">    <span class=\"constructor\">CFRelease(<span class=\"params\">ref</span>)</span>;</span><br><span class=\"line\">    <span class=\"constructor\">CFRelease(<span class=\"params\">colorspace</span>)</span>;</span><br><span class=\"line\">    <span class=\"constructor\">CGImageRelease(<span class=\"params\">iref</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    return image;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n",
            "tags": [
                "底层",
                "OpenGL",
                "UI"
            ]
        },
        {
            "id": "https://oliverqueen.cn/2018-01-23-CFNetwork%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/",
            "url": "https://oliverqueen.cn/2018-01-23-CFNetwork%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/",
            "title": "CFNetwork的介绍和使用",
            "date_published": "2018-01-23T13:04:15.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"cfnetwork背景简介\"><a class=\"anchor\" href=\"#cfnetwork背景简介\">#</a> CFNetwork 背景简介</h3>\n<p>CFNetwork 是 ISO 中一个比较底层的网络框架，C 语言编写，可以控制一些更底层的东西，如各种常用网络协议、socket 通讯等，我们通常使用的 NSURL 则更倾向于 API 数据请求等，虽然框架也提供了一些操作，但是远不如 CFNetwork 丰富。CFNetwork 已经接近于 UNIX 系统的 socket 通信了，使用 CFHttpMessageRef 进行 HTTP 连接的好处就是控制的粒度更细了，例如你可以设置 SSL 连接的 PeerName，证书验证的方式，还可以控制每个响应包的接收。不过 CFNetwork 本质上还是应用层上的封装的通用 API。使用者可以不用关心底层协议的实际细节。下图是 CFNetwork 在 iOS 系统中的位置 (图片来源于官方文档)。</p>\n<p><span id=\"more\"></span><br />\n<img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mit8tsij30bn06lwen.jpg\" alt=\"image.png\" /></p>\n<p>由上图可以看出目前 iOS 的网络编程分四层：</p>\n<ul>\n<li>\n<p>WebKit：属于 Cocoa 层，苹果很多地方用到的页面渲染引擎 WKWebview；</p>\n</li>\n<li>\n<p>NSURL：也属于 Cocoa 层，对各类 URL 请求的封装 (NSURLRequest)；</p>\n</li>\n<li>\n<p>CFNetwork：属于 Core Foundation 层，基于 C 的封装，同样的还有 CFNetServices (write/readstream)；</p>\n</li>\n<li>\n<p>BSD sockets：属于 OS 层，也是基于 C 的封装；</p>\n</li>\n</ul>\n<h3 id=\"cfnetwork结构\"><a class=\"anchor\" href=\"#cfnetwork结构\">#</a> CFNetwork 结构</h3>\n<p><img data-src=\"https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/006tNc79gy1fo6mlt3gwcj30od0a474w.jpg\" alt=\"image.png\" /><br />\n 上图也是官方文档的图片，描述了 CFNetwork 的结构，下面逐一讲解。</p>\n<h5 id=\"cfsocket-api\"><a class=\"anchor\" href=\"#cfsocket-api\">#</a> CFSocket API</h5>\n<p>Socket 是网络通讯的底层基础，两个 socket 端口可以互发数据。我们通常使用的是 BSD socket，CFSocket 则是 BSD socket 的抽象，基本上实现了几乎所有 BSD socket 的功能，并且还融入了 run loop。</p>\n<h5 id=\"cfstream-api\"><a class=\"anchor\" href=\"#cfstream-api\">#</a> CFStream API</h5>\n<p>CFStream API 提供了数据读写的方法，即读写流，使用它可以为内存、文件、网络（使用 socket）的数据建立 stream，我们进行网络请求就是对数据的读写，CFStream 提供 API 对两种 CFType 对象提供抽象：CFReadStream and CFWriteStream。它同时也是 CFHTTP 和 CFFTP 的基础。stream 有一个很重要的特性就是一旦数据流被提供或者被消耗，就不能从流中重新取出。比如这样</p>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint8_t d[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">//循环条件：流中是否有可用数据(被读过的数据不可用了)</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> ([<span class=\"keyword\">self</span>.inputStream hasBytesAvailable]) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//读取相应长度的数据数据</span></span><br><span class=\"line\">    <span class=\"built_in\">NSInteger</span> len = [<span class=\"keyword\">self</span>.inputStream read:d maxLength:<span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"comment\">//如果读取到数据，便将数据快拼接</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &gt; <span class=\"number\">0</span> &amp;&amp; !<span class=\"keyword\">self</span>.inputStream.streamError) &#123;</span><br><span class=\"line\">        [data appendBytes:(<span class=\"type\">void</span> *)d length:len];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"cfftp-api\"><a class=\"anchor\" href=\"#cfftp-api\">#</a> CFFTP API</h5>\n<p>对用 FTP 协议通信的封装，能下载、上传文件和目录到 FTP 服务器。CFFTP 建立的连接可以是同步或者异步，此次不做详解。</p>\n<h5 id=\"cfhttp-api\"><a class=\"anchor\" href=\"#cfhttp-api\">#</a> CFHTTP API</h5>\n<p>是 HTTP 协议的抽象，主要对象是 CFHTTPMessageRef (类似于我们通常的 NSURLRequest) 我们需要像构建 NSURLRequest 那样来构建 CFHTTPMessageRef，同样包含一下几个元素</p>\n<ul>\n<li>\n<p>必须元素</p>\n<ul>\n<li>\n<p>请求方法 (类型为 CFStringRef)：POST、GET、DELETE 等..</p>\n</li>\n<li>\n<p>请求的 URL 地址 (类型为 CFURLRef)：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmFpZHUuY29t\">https://www.baidu.com</span></p>\n</li>\n<li>\n<p>请求的 HTTP 版本 (类型为 CFStringRef)：通常使用 kCFHTTPVersion1_1</p>\n</li>\n<li>\n<p>kCFAllocatorDefault：用于创建消息引用的指定默认的系统内存分配器。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>可选参数</p>\n<ul>\n<li>body 体 (类型为 CFDataRef)</li>\n</ul>\n</li>\n</ul>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">CFHTTPMessageSetBody</span>(<span class=\"built_in\">CFHTTPMessageRef</span> message, <span class=\"built_in\">CFDataRef</span> bodyData) <span class=\"built_in\">CF_AVAILABLE</span>(<span class=\"number\">10</span>_1, <span class=\"number\">2</span>_0);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>消息头部，如 User-Agent 等；</li>\n</ul>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CFHTTPMessageSetHeaderFieldValue</span>(<span class=\"built_in\">CFHTTPMessageRef</span> message, <span class=\"built_in\">CFStringRef</span> headerField, <span class=\"built_in\">CFStringRef</span> __<span class=\"keyword\">nullable</span> value) <span class=\"built_in\">CF_AVAILABLE</span>(<span class=\"number\">10</span>_1, <span class=\"number\">2</span>_0);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"cfnetwork请求过程\"><a class=\"anchor\" href=\"#cfnetwork请求过程\">#</a> CFNetwork 请求过程</h3>\n<h5 id=\"1构造并创建cfhttpmessageref对象\"><a class=\"anchor\" href=\"#1构造并创建cfhttpmessageref对象\">#</a> 1：构造并创建 CFHTTPMessageRef 对象</h5>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//构造的方式上一步已讲</span></span><br><span class=\"line\"><span class=\"built_in\">CFHTTPMessageCreateRequest</span>(<span class=\"built_in\">CFAllocatorRef</span> __<span class=\"keyword\">nullable</span> alloc, <span class=\"built_in\">CFStringRef</span> requestMethod, <span class=\"built_in\">CFURLRef</span> url, <span class=\"built_in\">CFStringRef</span> httpVersion) <span class=\"built_in\">CF_AVAILABLE</span>(<span class=\"number\">10</span>_1, <span class=\"number\">2</span>_0);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"2使用cfhttpmessageref对象创建输入流\"><a class=\"anchor\" href=\"#2使用cfhttpmessageref对象创建输入流\">#</a> 2：使用 CFHTTPMessageRef 对象创建输入流</h5>\n<p><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一个参数传默认</span></span><br><span class=\"line\"><span class=\"built_in\">CFReadStreamCreateForHTTPRequest</span>(<span class=\"built_in\">CFAllocatorRef</span> __<span class=\"keyword\">nullable</span> alloc, <span class=\"built_in\">CFHTTPMessageRef</span> request) <span class=\"built_in\">CF_DEPRECATED</span>(<span class=\"number\">10</span>_2, <span class=\"number\">10</span>_11, <span class=\"number\">2</span>_0, <span class=\"number\">9</span>_0, <span class=\"string\">&quot;Use NSURLSession API for http requests&quot;</span>);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"3适配sni环境一个-ip-地址上可以为不同域名分配使用不同的-ssl-证书这同时意味着共享-ip-的虚拟主机也可实现-ssltls-连接\"><a class=\"anchor\" href=\"#3适配sni环境一个-ip-地址上可以为不同域名分配使用不同的-ssl-证书这同时意味着共享-ip-的虚拟主机也可实现-ssltls-连接\">#</a> 3：适配 SNI 环境（一个 IP 地址上可以为不同域名分配使用不同的 SSL 证书；这同时意味着，共享 IP 的虚拟主机也可实现 SSL/TLS 连接。）</h5>\n<p>因为配置 sni 环境的所有配置都是基于输入流来操作，所以我们构建完成输入流之后来处理 sni，像这样<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span>.inputStream setProperty:<span class=\"built_in\">NSStreamSocketSecurityLevelNegotiatedSSL</span> forKey:<span class=\"built_in\">NSStreamSocketSecurityLevelKey</span>];</span><br><span class=\"line\"><span class=\"comment\">//请求的URL的Host</span></span><br><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *sslProperties = @&#123; (__bridge <span class=\"type\">id</span>) kCFStreamSSLPeerName : host &#125;;</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.inputStream setProperty:sslProperties forKey:(__bridge_transfer <span class=\"built_in\">NSString</span> *) kCFStreamPropertySSLSettings];</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"4打开输入流\"><a class=\"anchor\" href=\"#4打开输入流\">#</a> 4：打开输入流</h5>\n<p>打开输入流分为两步</p>\n<ul>\n<li>设置代理：[self.inputStream setDelegate:weakSelf]</li>\n<li>加入当前的 runloop：<br />\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[_inputStream <span class=\"symbol\">removeFromRunLoop:</span><span class=\"keyword\">self</span>.runloop <span class=\"symbol\">forMode:</span>[<span class=\"keyword\">self</span> runloopMode]];</span><br></pre></td></tr></table></figure></li>\n<li>调用 Open 方法</li>\n</ul>\n<h5 id=\"5收到代理数据回调\"><a class=\"anchor\" href=\"#5收到代理数据回调\">#</a> 5：收到代理数据回调</h5>\n<p><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- <span class=\"params\">(void)</span>stream:<span class=\"params\">(NSStream *)</span>aStream handleEvent:<span class=\"params\">(NSStreamEvent)</span>eventCode;</span><br></pre></td></tr></table></figure><br />\n 其中分为几个状态<br />\n <figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_OPTIONS</span>(<span class=\"type\">NSUInteger</span>, <span class=\"type\">NSStreamEvent</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventNone</span> = 0,</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventOpenCompleted</span> = 1UL &lt;&lt; 0,</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventHasBytesAvailable</span> = 1UL &lt;&lt; 1,</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventHasSpaceAvailable</span> = 1UL &lt;&lt; 2,</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventErrorOccurred</span> = 1UL &lt;&lt; 3,</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventEndEncountered</span> = 1UL &lt;&lt; 4</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br />\n 通常我们会关心 NSStreamEventOpenCompleted、NSStreamEventHasBytesAvailable、NSStreamEventErrorOccurred、<br />\n由于数据是以流的形式回来，我们需要在在 NSStreamEventHasBytesAvailable 下取出数据然后做数据拼接，拼接好完整的数据才可使用，像这样<br />\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"built_in\">NSStreamEventHasBytesAvailable</span>:</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">UInt8</span> buffer[BUFFER_SIZE]; <span class=\"comment\">//设置缓存区</span></span><br><span class=\"line\">    <span class=\"built_in\">NSInteger</span> numBytesRead = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSInputStream</span> *inputstream = (<span class=\"built_in\">NSInputStream</span> *) aStream;</span><br><span class=\"line\">    <span class=\"comment\">// Read data</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        numBytesRead = [inputstream read:buffer maxLength:<span class=\"keyword\">sizeof</span>(buffer)];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numBytesRead &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span>.resultData appendBytes:buffer length:numBytesRead];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (numBytesRead &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">break</span>;</span><br></pre></td></tr></table></figure><br />\n 循环结束后我们的 resultData 就是完整的返回数据了。</p>\n",
            "tags": [
                "网络",
                "底层"
            ]
        }
    ]
}