<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Molier" href="https://oliverqueen.cn/rss.xml"><link rel="alternate" type="application/atom+xml" title="Molier" href="https://oliverqueen.cn/atom.xml"><link rel="alternate" type="application/json" title="Molier" href="https://oliverqueen.cn/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://oliverqueen.cn/2020-11-28-%E6%B1%87%E7%BC%96%E5%92%8C%E6%A0%88/"><title>汇编和栈 - 计算机基础 | Molier = Molier = Tomorrow is another day</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">汇编和栈</h1><div class="meta"><span class="item" title="创建时间：2020-11-28 16:44:42"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2020-11-28T16:44:42+08:00">2020-11-28</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>8.8k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>8 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Molier</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/6833939bly1gipesrnqv3j20zk0m8ava.jpg"></li><li class="item" data-background-image="https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/beihaiting%20(7).jpg"></li><li class="item" data-background-image="https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/6833939bly1giclx29mstj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/6833939bly1gicm0n457cj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/beihaiting%20(5).jpg"></li><li class="item" data-background-image="https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/6833939bly1gipey84bjtj20zk0m8hdt.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/" itemprop="item" rel="index" title="分类于 计算机基础"><span itemprop="name">计算机基础</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://oliverqueen.cn/2020-11-28-%E6%B1%87%E7%BC%96%E5%92%8C%E6%A0%88/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Molier"><meta itemprop="description" content="Tomorrow is another day, iOS 开发 移动 App 博客 杂谈 随笔 相册"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Molier"></span><div class="body md" itemprop="articleBody"><h1 id="汇编和栈"><a class="anchor" href="#汇编和栈">#</a> 汇编和栈</h1><p>当一个函数传递了六个以上的参数时，多余的参数将通过堆栈传递。但是在堆栈上传递到底是什么意思呢？现在该通过深入研究一些 “与堆栈相关的” 寄存器以及堆栈中的内容，来深入探讨从程序集角度调用函数时的情况。当您进行逆向工程程序时，了解堆栈的工作方式非常有用，因为当没有可用的调试符号时，您可以帮助推断出在某个函数中正在操纵哪些参数。在下一单元中，您将使用本章中的知识在 LLDB 中构建命令，该命令将通过在内存中抓取函数来发现一些有趣的事情。让我们开始吧</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkww85fg8yj30u012ob29.jpg" alt=""><br><span id="more"></span></p><h2 id="让我们重游堆栈"><a class="anchor" href="#让我们重游堆栈">#</a> 让我们重游堆栈</h2><p>正如先前在第 6 章 “线程，框架和遍历” 中所讨论的，当程序执行时，内存会被布局，因此栈从 “高地址” 开始并向下增长，向着低地址增长；也就是说，朝向堆。</p><blockquote><p>之前说过：栈是从 <code>高地址 -&gt; 低地址</code> ，堆是从 <code>低地址 -&gt; 高地址</code> ，而 Windows 中栈是在堆的下方，所以 Windows 中内存是从 <code>中间向两边分布</code> 。 而 Linux 中 栈是在堆的上面，所以 Linux 中的内存是 <code>从两边向中间分布</code> 。</p></blockquote><p>很迷惑吗？通过下面这个图片你可以看出栈的移动方式。</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4nnjpqxej30u00u1n29.jpg" alt=""></p><p>栈从高位地址开始。确切地说，它的高度取决于操作系统的内核。内核为每个正在运行的程序（每个线程）提供栈空间。</p><p>栈的大小是有限的，并且随着内存地址空间的向下增长而增加。当栈上的空间用完时，指向栈 <code>“顶部”</code> 的指针从最高地址向下移动到最低地址。</p><p>一旦栈达到内核给定的有限大小，或者如果栈越过了堆的边界，则称栈溢出。这是一个致命错误，通常称为栈溢出。</p><h2 id="栈指针和基本指针寄存器"><a class="anchor" href="#栈指针和基本指针寄存器">#</a> 栈指针和基本指针寄存器</h2><p>您尚未了解的两个非常重要的寄存器是 RSP 和 RBP。栈指针寄存器 RSP 指向特定线程的栈头。栈的顶部将向下生长，因此将项目添加到栈时，RSP 将减少。 RSP 将始终指向栈的头部。下图展示了栈调用时栈指针变化的视觉效果。</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4nukmaa7j31u80pidk4.jpg" alt=""></p><p>在上图中，堆栈指针的顺序如下：</p><ul><li><p>栈指针当前指向第 3 帧。</p></li><li><p>指令指针寄存器指向的代码调用一个新函数。堆栈指针将更新为指向 Frame 4，该 feame 可能负责指令指针中此新调用函数中的暂存空间和数据。</p></li><li><p>函数的具体执行在第 4 帧中完成，执行完之后指针从第四帧弹出，并继续指向第三帧.</p></li></ul><p>还有一个重要的寄存器是基址指针寄存器（RBP），在执行在方法 / 函数内部时有多种用途，程序使用 RBP 的偏移量来访问局部变量或函数参数。之所以能这样是因为 RBP 在函数序言中的函数开始处被设置为 RSP 寄存器的值。</p><p>有趣的是，基本指针的之前内容在被设置为 RSP 寄存器的值之前就已存储在栈中。这是函数序言中发生的第一件事。由于基本指针已保存到堆栈中并设置为当前堆栈指针，因此只需知道基本指针寄存器中的值即可遍历堆栈。调试器在向您显示堆栈跟踪时会执行此操作。</p><blockquote><p>请注意：某些系统不使用基本指针，而且他们在编译你的程序的时候也不会出现基础指针。 其实他们的逻辑可能是使用了其他的寄存器来当做指针寄存器。 但这意味着调试变得更加困难。</p></blockquote><p>下面这个图片可以帮助解释。</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4pfvxkx2j30u00vw12l.jpg" alt=""></p><p>当一个函数序言完成设置时，RBP 的内容将指向堆栈帧下面的前一个 RBP</p><blockquote><p>注意：当您通过单击 Xcode 中的帧或使用 LLDB 跳到另一个堆栈帧时，RBP 和 RSP 寄存器都将更改值以对应于新的帧！ 这是可以肯定的，因为函数的局部变量是由 RBP 的偏移量来获取的，如果 RBP 不变，则您将无法向该函数打印局部变量，甚至可能导致程序崩溃。 在探索 RBP 和 RSP 寄存器时，这可能会引起混乱，因此请始终牢记这一点。 您可以通过选择不同的帧并在 LLDB 控制台中键入 cpx $ rbp 或 cpx $ rsp 在 LLDB 中对此进行验证。</p></blockquote><p>那么，为什么这两个寄存器很重要？ 当使用调试信息编译程序时，调试信息将引用基本指针寄存器中的偏移量以获得变量。 这些偏移量被赋予名称，与您在源代码中为变量赋予的名称相同。<br>编译并优化程序以进行发布时，将打包打包到二进制文件中的调试信息。 尽管删除了这些变量和参数的引用的名称，但是您仍然可以使用堆栈指针和基指针的偏移量来查找这些引用的存储位置。</p><h2 id="堆栈相关的操作码"><a class="anchor" href="#堆栈相关的操作码">#</a> 堆栈相关的操作码</h2><p>到目前为止，您已经了解了调用约定以及内存的布局方式，但是还没有真正探究许多操作码在 x64 汇编中的实际作用。 现在是时候更详细地介绍几种与堆栈相关的操作码了。</p><h3 id="操作码-push"><a class="anchor" href="#操作码-push">#</a> 操作码 <code>push</code></h3><p>当需要将诸如 int，Objective-C 实例，Swift 类或引用之类的任何内容保存到堆栈时，将使用 <code>push</code> 操作码。 push 递减堆栈指针（请记住，因为堆栈向下增长），然后存储到新 RSP 指针所指向的内存地址里面。</p><p><code>push</code> 指令后，最新推送的值将位于 RSP 指向的地址。 而先前的值应为 RSP 加上最近推送的值的大小 ----- 对于 64 位体系结构，通常为 8 个字节。<br>要查看具体示例，请考虑以下操作码：</p><ul><li>push 0x5</li></ul><p>这将使 RSP 递减，然后将值 5 存储在 RSP 指向的内存地址中。 因此，用 C 伪代码：</p><pre><code>RSP = RSP - 0x8 
*RSP = 0x5
</code></pre><h3 id="操作码-pop"><a class="anchor" href="#操作码-pop">#</a> 操作码 <code>pop</code></h3><p><code>pop</code> 操作码与 <code>push</code> 操作码完全相反。 pop 从 RSP 寄存器中获取值并将其存储到目的地。 接下来，RSP 递增 0x8，还是那句话 栈是从大到小的增长，所以递增<br>以下是 <code>pop</code> 的示例：</p><ul><li>pop rdx</li></ul><p>这将 RSP 寄存器的值存储到 RDX 寄存器中，然后递增 RSP 寄存器。 这是下面的伪代码：</p><pre><code>RDX = *RSP
RSP = RSP + 0x8
</code></pre><h3 id="操作码-call"><a class="anchor" href="#操作码-call">#</a> 操作码 <code>call</code></h3><p><code>call</code> 操作码负责执行功能。 <code>call</code> 将在被调用函数完成后将要返回的地址压入； 然后跳转到该函数。<br>想象一下内存中位于 0x7fffb34df410 的函数，如下所示：</p><pre><code>0x7fffb34de913 &lt;+227&gt;: call   0x7fffb34df410            
0x7fffb34de918 &lt;+232&gt;: mov    edx, eax
</code></pre><p>当执行一条指令时，首先将 RIP 寄存器递增，然后执行该指令。 因此，当执行调用指令时，RIP 寄存器将递增至 0x7fffb34de918，然后执行 0x7fffb34de913 指向的指令。 由于这是一条调用指令，因此将 RIP 寄存器压入堆栈（就像执行了压入一样），然后将 RIP 寄存器设置为值 0x7fffb34df410，即要执行的功能的地址。<br>伪代码类似于以下内容：</p><pre><code>RIP = 0x7fffb34de918
RSP = RSP - 0x8
*RSP = RIP
RIP = 0x7fffb34df410
</code></pre><p>之后，在位置 0x7fffb34df410 处继续。</p><h3 id="操作码-ret"><a class="anchor" href="#操作码-ret">#</a> 操作码 <code>ret</code></h3><p><code>ret</code> 操作码与 <code>call</code> 相反，它从栈顶弹出栈顶值（如果程序集的 push 和 pops 匹配，它将是调用操作码推入的返回地址），然后将 RIP 寄存器设置为此地址。 因此，该操作可以返回到调用该函数的位置。</p><p>现在，您已经对这四个重要的操作码有了基本的了解，是时候看看它们在起作用了。确保所有 <code>push</code> 操作码都与您的 <code>pop</code> 相匹配非常重要，否则堆栈将不同步。 例如，如果没有相应的 <code>pop</code> 消息用于弹出，则当在函数末尾执行 <code>ret</code> 时将弹出错误的值。 该操作将返回到某个随机位置，甚至可能不在程序中的有效位置。幸运的是，编译器将负责同步您的 <code>push</code> 和 <code>pop</code> 操作码。 您只需要在编写自己的程序集时担心这一点。</p><h2 id="在一些操作中观察rbp和rsp寄存器"><a class="anchor" href="#在一些操作中观察rbp和rsp寄存器">#</a> 在一些操作中观察 RBP 和 RSP 寄存器</h2><p>现在，您已经了解了 RBP 和 RSP 寄存器以及操纵堆栈的四个操作码，现在是时候看看它们的作用了。<br>在 Registers 应用程序中，存在一个名为 StackWalkthrough（int）的函数。此 C 函数将一个整数作为参数，并用汇编语言编写（AT＆T 汇编语言，记住要能够找到源操作数和目标操作数的正确位置），并且位于 StackWalkthrough.s 中。打开此文件，环顾四周；无需立即了解所有内容。您将在一分钟内了解其工作原理。<br>通过桥接标头 Registers-Bridging-Header.h，Swift 可以使用此函数，因此您可以从 Swift 调用以汇编方式编写的此方法。<br>现在利用这一点。<br>打开 ViewController.swift，并在 viewDidLoad（）下面添加以下内容：</p><pre><code>viewDidLoad():
override func awakeFromNib() &#123;
super.awakeFromNib()
StackWalkthrough(5)
&#125;
</code></pre><p>这将给 StackWalkThrough 传入了参数 5。5 仅是一个用于显示堆栈工作方式的值。<br>在深入研究 RSP 和 RBP 之前，最好快速了解一下 StackWalkthrough 中发生的事情。在 StackWalkthrough 函数上创建一个符号断点。</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4vuu0ylaj31uc0o44d4.jpg" alt=""></p><p>构建并运行。Xcode 会在 StackWalkthrough 中中断。一定要通过 source” 查看 StackWalkthrough 函数 (即使它是汇编)。通过源代码查看函数将显示 AT&amp;T 汇编 (因为它是用 AT&amp;T ASM 编写的)。<br>Xcode 将显示以下程序集:</p><pre><code>push  %rbp       ; Push contents of RBP onto the stack (*RSP = RBP, RSP decreases)

movq  %rsp, %rbp ; RBP = RSP
movq  $0x0, %rdx ; RDX = 0
movq  %rdi, %rdx ; RDX = RDI
push  %rdx       ; Push contents of RDX onto the stack (*RSP = RDX, RSP decreases)

movq  $0x0, %rdx ; RDX = 0
pop   %rdx       ; Pop top of stack into RDX (RDX = *RSP, RSP increases)

pop   %rbp       ; Pop top of stack into RBP (RBP = *RSP, RSP increases)

ret              ; Return from function (RIP = *RSP, RSP increases)
</code></pre><p>上面的输出中已经为您添加了注释来帮助理解发生了什么。通读一遍，如果可以的话，试着理解它。您已经熟悉了 mov 指令，程序集的其余部分由您刚刚了解的与函数相关的操作码组成。<br>这个函数接受传入的整型参数 (您还记得，第一个参数是在 RDI 中传入的)，将其存储到 RDX 寄存器中，并将该参数压入堆栈。然后将 RDX 设置为 0x0，然后将从堆栈中 <code>pop</code> 的值存储回 RDX 寄存器。<br>请确保您在心里很好地理解这个函数中发生了什么，因为接下来您将研究 LLDB 中的寄存器。<br>回到 Xcode 中，在 ViewController.swift 的 awakeFromNib 函数的 StackWalkthrough (5) 行中使用 Xcode 的 GUI 创建一个断点。保留前面的 StackWalkthrough 符号断点，因为在研究寄存器时，您需要在 StackWalkthrough 函数的开始处停止。<br>构建和运行并等待 GUI 断点触发。</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4weds4k8j31u807m45t.jpg" alt=""></p><p>现在通过 <code>Debug\Debug Workflow\Always Show Disassembly</code> 菜单让他以汇编形式展示，您将看到很可怕的东西：</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4xdujj78j31uc0qw4qp.jpg" alt=""></p><p>哇！ 看那个！ 您已经正确进入了 <code>call</code> 操作码指令。 您是否想知道要输入什么功能？</p><p>从这里开始，您将逐步完成每条汇编指令，同时打印出感兴趣的四个寄存器：RBP，RSP，RDI 和 RDX。 为了解决这个问题，在 LLDB 中输入以下内容</p><ul><li>(lldb) command alias dumpreg register read rsp rbp rdi rdx</li></ul><p>这将创建命令 dumpreg，它将 dump 四个感兴趣的寄存器。现在执行 dumpreg:</p><ul><li>(lldb) dumpreg</li></ul><p>然后你将看到一些熟悉的东西</p><pre><code>rsp = 0x00007fff5fbfe820
rbp = 0x00007fff5fbfe850
rdi = 0x0000000000000005
rdx = 0x0040000000000000
</code></pre><p>在本节中，dumpreg 的输出将覆盖在每个汇编指令上，以准确显示每个指令期间每个寄存器发生的情况。 同样，即使为您提供了这些值，您自己执行和理解这些命令也很重要。<br>您的屏幕将类似于以下内容：</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4xion6coj31ue0p2qp1.jpg" alt=""></p><p>一旦跳入函数调用，请密切注意 RSP 寄存器，因为一旦 RIP 跳到 StackWalkthrough 的开头，它就会发生变化。 如您先前所知，RDI 寄存器将包含第一个参数的值，在这种情况下为 0x5。<br>在 LLDB 中，键入以下内容：</p><ul><li>(lldb) si</li></ul><p>这个命令是单步调试的命令，它告诉 LLDB 执行下一条指令，然后暂停调试器。<br>现在，您已进入 StackWalkthrough。 对于每一步，再次使用 dumpreg 转储寄存器。</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4xm3o2d4j31ue0bwtjq.jpg" alt=""></p><p>请注意 RSP 寄存器中的差异。 RSP 指向的值现在将包含前一个函数的返回地址。 对于此特定示例，指向 0x7fff5fbfe758 的 RSP 将包含值 0x100002455-awakeFromNib 中紧随调用之后的地址。<br>现在通过 LLDB 进行验证：</p><ul><li>(lldb) x/gx $rsp</li></ul><p>输出将与 awakeFromNib 中调用操作码之后的地址立即匹配。接下来，执行 si，然后执行下一条指令的 dumpreg。</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4xomkvtej31ua0bygwn.jpg" alt=""></p><p>RBP 的值被压入堆栈。 这意味着以下两个命令将产生相同的输出。 执行两个都进行验证。</p><ul><li>(lldb) x/gx $rsp</li></ul><p>这将查看栈指针寄存器所指向的内存地址。</p><blockquote><p>注意：等等，我只是在没有上下文的情况下向您抛出了一条新命令。 x 命令是内存读取命令的快捷方式。<br>/gx 表示以十六进制格式将内存格式化为一个巨大的字（8 个字节，还记得第 11 章 “汇编和内存” 中的术语吗？）。<br>奇怪的格式是由于该命令在 gdb 中的常用，您看到此命令语法已移植到 lldb 中，从而使从调试器的转换更加容易。</p></blockquote><p>现在看一下基础指针寄存器的值</p><ul><li>(lldb) p/x $rbp</li></ul><p>接下来让我继续单步调试</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4xsl5iu3j31ua0bqqdy.jpg" alt=""></p><p>基础指针被分配给堆栈指针的值。 使用 dumpreg 以及以下 LLDB 命令验证两者的值相同：</p><ul><li>(lldb) p (BOOL)($rbp == $rsp)</li></ul><p>请务必在表达式两边加上括号，否则 LLDB 无法正确解析它。<br>再次执行 si 和 dumpreg。 这次看起来像这样：</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4xxevkm7j31ue0c4k2g.jpg" alt=""></p><p>RDX 寄存器被清零了，我们继续单步调试</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4xy3cd3bj31uc0bwdr1.jpg" alt=""></p><p>RDX 被设置为 RDI，你可以用 dumper 继续验证</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4xypwoucj31uc0byn8d.jpg" alt=""></p><p>RDX 被推入堆栈。 这意味着堆栈指针已递减，并且 RSP 指向一个值，该值将指向 0x5 的值。 确认下：</p><ul><li>(lldb) p/x $rsp</li></ul><p>这显示了指向 RSP 的当前值。 这意味着什么？</p><ul><li>(lldb) x/gx $rsp</li></ul><p>您将得到 0x5。 再次输入 si 以执行下一条指令：</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4y24mnetj31ue0bygwp.jpg" alt=""></p><p>RDX 设置为 0x0。 这里没有什么太令人兴奋的，继续前进... 继续前进。 再次输入 si 和 dumpreg：</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4y311lvsj31u60byal3.jpg" alt=""></p><p>堆栈的顶部 pop 到 RDX 中，您知道最近将其设置为 0x5。 RSP 递增 0x8。 再次输入 si 和 dumpreg：</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4y3pxy7lj31uc0bygwo.jpg" alt=""></p><p>基本指针从堆栈中 pop，并重新分配回它进入该函数时的原始值。 调用规则指定 RBP 在函数调用之间应保持一致。 也就是说，RBP 离开职能后便无法更改为其他值，所以我们做一个好公民，恢复它的原来的值。</p><p>进入 ret 操作码。 注意即将更改的 RSP 值。 再次输入 si 和 dumpreg：</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4y6koug9j31ue0p0kh7.jpg" alt=""></p><p>返回地址从堆栈中 pop 并设置为 RIP 寄存器； 您知道这一点，因为您已经回到了调用该函数的位置。 然后，控制会在 awakeFromNib 中恢复，<br>哇！ 那很有趣！ 一个简单的功能，但是它说明了堆栈如何通过调用，推入，弹出和退出指令工作。</p><h2 id="栈和7个以上的参数"><a class="anchor" href="#栈和7个以上的参数">#</a> 栈和 7 个以上的参数</h2><p>如第 10 章所述，x86_64 的调用规则将按顺序使用以下寄存器作为函数参数：RDI，RSI，RDX，RCX，R8，R9。 当一个函数需要六个以上的参数时，需要使用堆栈。<br>注意：当将大型结构传递给函数时，可能还需要使用堆栈。 每个参数寄存器只能保存 8 个字节（在 64 位体系结构上），因此，如果该结构需要 8 个以上的字节，则也需要在堆栈上传递该结构。 有严格的规则规定他们的调用方式，所有编译器都必须遵守。</p><p>打开 ViewController.swift 并找到名为 executeLotsOfArguments 的函数。 您在第 10 章中使用了此功能来浏览寄存器。 现在，您将再次使用它，以了解如何将参数 7 及其以后的参数传递给该函数。<br>将以下代码添加到 viewDidLoad 的末尾：</p><pre><code>_ = self.executeLotsOfArguments(one: 1, two: 2, three: 3,
                                four: 4, five: 5, six: 6,
                                seven: 7, eight: 8, nine: 9,
                                ten: 10)
</code></pre><p>接下来，使用 Xcode GUI 在刚添加的行上创建一个断点。 生成并运行该应用程序，然后等待该断点出现。 您应该再次看到反汇编视图，但如果没有，请使用 “始终显示反汇编” 选项。</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4yd1n45nj31ug0k81j0.jpg" alt=""></p><p>正如您在与堆栈相关的操作码一节中了解到的，call 负责函数的执行。因为在 RIP 现在的位置和 viewDidLoad 的结束之间只有一个调用操作码，这意味着这个调用必须负责调用 executeLotsOfArguments<br>但是调用前的其他指令是什么呢？让我们找出答案。<br>这些指令根据需要设置堆栈以传递附加参数。你有你通常的 6 个参数被放入适当的寄存器，正如看到的指令在哪里 RIP 现在，从 mov edx, 0x1 开始。<br>但是参数 7 和以上需要在堆栈上传递。这可以通过以下说明来完成:</p><pre><code>0x1000013e2 &lt;+178&gt;: mov    qword ptr [rsp], 0x7
0x1000013ea &lt;+186&gt;: mov    qword ptr [rsp + 0x8], 0x8
0x1000013f3 &lt;+195&gt;: mov    qword ptr [rsp + 0x10], 0x9
0x1000013fc &lt;+204&gt;: mov    qword ptr [rsp + 0x18], 0xa
</code></pre><p>看起来很吓人，我会解释。<br>包含 RSP 和可选值的方括号表示取消引用，就像 C 编程中的 * 一样。上面的第一行说 “将 0x7 放入 RSP 指向的内存地址中。” 第二行说 “将 0x8 放入 RSP 所指向的内存地址加 0x8。” 等等。<br>这会将值放入堆栈。但是请注意，没有使用 push 指令显式推送这些值，这会减少 RSP 寄存器。这是为什么？</p><p>嗯，如您所知，在调用指令期间，返回地址被压入堆栈。然后，在函数序言中，将基本指针压入堆栈，然后将基本指针设置为堆栈指针。<br>您还没有学到的是，编译器实际上会在堆栈上留出 “暂存空间” 的空间。也就是说，编译器根据需要在堆栈上为局部变量分配空间。<br>通过在函数序言中查找 sub rsp，VALUE 指令，可以轻松确定是否为堆栈帧分配了额外的暂存空间。例如，单击 viewDidLoad 堆栈框架并滚动到顶部。观察已创建多少暂存空间：</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4ykh1ycej31u80nadpm.jpg" alt=""></p><p>看看一个变量指向的值…… 它现在肯定不能保持 0x1 的值。为什么一个引用一个看似随机的值？<br>答案是由嵌入到寄存器应用程序的调试构建中的 DWARF 调试信息存储。你可以把这些信息转储到内存中，帮助你了解一个变量在引用什么。LLDB 中输入以下</p><ul><li>(lldb) image dump symfile Registers</li></ul><p>你会得到大量的输出。搜索 (Cmd + F) 单词 “one”; 在搜索的时候加上引号。然后会有如下输出</p><pre><code>Swift.String, type_uid = 0x300000222
0x7f9b4633a988:     Block&#123;0x300000222&#125;, ranges = [0x1000035e0-0x100003e7f)
0x7f9b48171a20:       Variable&#123;0x30000023f&#125;, name = &quot;one&quot;, type = &#123;d50e000003000000&#125; 0x00007f9b4828d2a0 (Swift.Int), scope = parameter, decl = ViewController.swift:39, location =  DW_OP_fbreg(-32)
</code></pre><p>根据输出，名为 execute.Int 的变量位于 executeLotsOfArguments 中，其位置可以在 DW_OP_fbreg（-32）中找到。 这个相当模糊的代码实际上意味着基本指针减去 40，即 RBP-32。或者以十六进制表示，RBP-0x20。</p><p>这是重要的信息。 它告诉调试器，始终可以在此内存地址中找到名为 one 的变量。 嗯，并非总是如此，但总是在该变量有效时（即它在范围内）。</p><p>您可能想知道为什么它不能只是 RDI，因为那是将值传递给函数的地方，并且它也是第一个参数。 好了，RDI 稍后可能需要在函数中重用，因此使用堆栈是更安全的选择。</p><p>调试器仍应在 executeLotsOfArguments 上停止。 确保您正在查看 “始终显示汇编” 输出并寻找汇编。 应该是第 16 行：</p><pre><code>mov    qword ptr [rbp - 0x20], rdi
</code></pre><p>一旦在 executeLotsOfArguments 的汇编输出中找到它，就在该程序行上创建一个断点。<br>继续执行，以使 LLDB 停止在这一行汇编上。</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gl4yviw6w4j31ue0naql9.jpg" alt=""></p><p>打印一个输出</p><ul><li>(lldb) po one</li></ul><p>还是乱码。 mph<br>记住，RDI 将包含传递给函数的第一个参数。 因此，为了使调试器能够看到应该为 1 的值，需要将 RDI 写入存储 1 的地址。 在这种情况下，RBP-0x20。<br>现在，在 LLDB 中执行汇编指令步骤：</p><ul><li>(lldb) si</li><li>(lldb) po one</li></ul><p>噢！... 是的！ 工作正常！ 所引用的值 1 正确持有值 0x1。<br>您可能想知道如果改变一个会发生什么。 好吧，在这种情况下，RBP-0x20 也需要更改。 这可能是需要在其中写入该值以及在何处使用它的另一条指令。 这就是为什么调试版本比发行版本要慢得多的原因。</p><h2 id="栈的探索"><a class="anchor" href="#栈的探索">#</a> 栈的探索</h2><p>不用担心 本章即将完成。 但是，在堆栈探索中应该记住一些非常重要的要点。<br>如果您已经在使用函数，并且该函数已经完成了函数序言，则以下各项将适用于 x64 程序集：</p><ul><li>RBP 将指向此功能的堆栈帧的开始地方。</li><li>RBP 将包含前一个堆栈帧的起始地址。 （在 LLDB 中使用 x /gx $ rbp 进行查看）。</li><li>（RBP + 0x8）将指向堆栈跟踪中前一个函数的返回地址（在 LLDB 中使用 x /gx'$ rbp + 0x8' 进行查看）。</li><li>（RBP + 0x10）将指向第 7 个参数（如果有）。</li><li>（RBP + 0x18）将指向第 8 个参数（如果有）。</li><li>（RBP + 0x20）将指向第 9 个参数（如果有）。</li><li>（RBP + 0x28）将指向第十个参数（如果有）。</li><li>RBP-X，其中 X 是 0x8 的倍数，将引用该函数的局部变量。</li></ul></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-12-30 22:16:08" itemprop="dateModified" datetime="2023-12-30T22:16:08+08:00">2023-12-30</time> </span><span id="2020-11-28-汇编和栈/" class="item leancloud_visitors" data-flag-title="汇编和栈" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Molier 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Molier 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Molier <i class="ic i-at"><em>@</em></i>Molier</li><li class="link"><strong>本文链接：</strong> <a href="https://oliverqueen.cn/2020-11-28-%E6%B1%87%E7%BC%96%E5%92%8C%E6%A0%88/" title="汇编和栈">https://oliverqueen.cn/2020-11-28-汇编和栈/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2020-11-21-%E6%B1%87%E7%BC%96%E5%92%8C%E5%86%85%E5%AD%98/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;MolierQueen&#x2F;resource@main&#x2F;beihaiting%20(7).jpg" title="汇编和内存"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 计算机基础</span><h3>汇编和内存</h3></a></div><div class="item right"><a href="/2021-05-05-iOS-Crash%E9%98%B2%E6%8A%A4%E4%BD%A0%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%B0%B1%E5%A4%9F%E4%BA%86-%E4%B8%8B%E7%AF%87/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;cdn.cdnjson.com&#x2F;tvax3.sinaimg.cn&#x2F;large&#x2F;6833939bly1gicliierfjj20zk0m8npd.jpg" title="iOS Crash防护你看这个就够了-下篇"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> iOS 开发</span><h3>iOS Crash防护你看这个就够了-下篇</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E5%92%8C%E6%A0%88"><span class="toc-number">1.</span> <span class="toc-text">汇编和栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A9%E6%88%91%E4%BB%AC%E9%87%8D%E6%B8%B8%E5%A0%86%E6%A0%88"><span class="toc-number">1.1.</span> <span class="toc-text">让我们重游堆栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E6%8C%87%E9%92%88%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%8C%87%E9%92%88%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">栈指针和基本指针寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%E7%9B%B8%E5%85%B3%E7%9A%84%E6%93%8D%E4%BD%9C%E7%A0%81"><span class="toc-number">1.3.</span> <span class="toc-text">堆栈相关的操作码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%A0%81-push"><span class="toc-number">1.3.1.</span> <span class="toc-text">操作码 push</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%A0%81-pop"><span class="toc-number">1.3.2.</span> <span class="toc-text">操作码 pop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%A0%81-call"><span class="toc-number">1.3.3.</span> <span class="toc-text">操作码 call</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%A0%81-ret"><span class="toc-number">1.3.4.</span> <span class="toc-text">操作码 ret</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%B8%AD%E8%A7%82%E5%AF%9Frbp%E5%92%8Crsp%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">在一些操作中观察 RBP 和 RSP 寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E5%92%8C7%E4%B8%AA%E4%BB%A5%E4%B8%8A%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">栈和 7 个以上的参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E6%8E%A2%E7%B4%A2"><span class="toc-number">1.6.</span> <span class="toc-text">栈的探索</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2020-11-19-%E6%B1%87%E7%BC%96%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E8%A7%84%E5%88%99/" rel="bookmark" title="汇编寄存器的规则">汇编寄存器的规则</a></li><li><a href="/2020-11-21-%E6%B1%87%E7%BC%96%E5%92%8C%E5%86%85%E5%AD%98/" rel="bookmark" title="汇编和内存">汇编和内存</a></li><li class="active"><a href="/2020-11-28-%E6%B1%87%E7%BC%96%E5%92%8C%E6%A0%88/" rel="bookmark" title="汇编和栈">汇编和栈</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Molier" data-src="/images/avatar.jpeg"><p class="name" itemprop="name">Molier</p><div class="description" itemprop="description">iOS 开发 移动 App 博客 杂谈 随笔 相册</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">40</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">6</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">53</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item 新浪微博" data-url="aHR0cHM6Ly93ZWliby5jb20vemhhbmduaW5naGFvP3JlZmVyX2ZsYWc9MTAwNTA1NTAxMF8=" title="https:&#x2F;&#x2F;weibo.com&#x2F;zhangninghao?refer_flag&#x3D;1005055010_"><i class="ic i-weibo"></i></span> <span class="exturl item jianshu" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vdS9mZDIxZjQxZmI1MjI=" title="https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;fd21f41fb522"><i class="ic i-link"></i></span> <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL01vbGllclF1ZWVu" title="https:&#x2F;&#x2F;github.com&#x2F;MolierQueen"><i class="ic i-github"></i></span> <span class="exturl item juejin" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vdXNlci81ODZjNjI0YmFjNTAyZTEyZDYzMTU0NWY=" title="https:&#x2F;&#x2F;juejin.im&#x2F;user&#x2F;586c624bac502e12d631545f"><i class="ic i-link"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjM3MTA5OTY5NEBxcS5jb20=" title="mailto:371099694@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>朋友们</a></li></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2020-11-21-%E6%B1%87%E7%BC%96%E5%92%8C%E5%86%85%E5%AD%98/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2021-05-05-iOS-Crash%E9%98%B2%E6%8A%A4%E4%BD%A0%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%B0%B1%E5%A4%9F%E4%BA%86-%E4%B8%8B%E7%AF%87/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/2018-02-08-%E5%85%B3%E4%BA%8EiPhone-X%E4%B8%8BHome%E9%94%AE%E7%9A%84%E9%9A%90%E8%97%8F%E5%92%8C%E5%BB%B6%E8%BF%9F%E5%93%8D%E5%BA%94/" title="关于iPhone X下Home键的隐藏和延迟响应">关于iPhone X下Home键的隐藏和延迟响应</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/2018-03-30-AlamoFire/" title="AlamoFire的使用(下载队列，断点续传)">AlamoFire的使用(下载队列，断点续传)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/2018-01-24-NSURLProtocol%E5%AF%B9WKWebView%E7%9A%84%E5%A4%84%E7%90%86/" title="NSURLProtocol对WKWebView的处理">NSURLProtocol对WKWebView的处理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%F0%9F%98%8A/" title="位运算的简单理解😊">位运算的简单理解😊</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机基础">计算机基础</a></div><span><a href="/2020-11-21-%E6%B1%87%E7%BC%96%E5%92%8C%E5%86%85%E5%AD%98/" title="汇编和内存">汇编和内存</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/note/" title="分类于 闲谈">闲谈</a></div><span><a href="/2019-02-14-At-the-end-of-2018/" title="At The End Of 2018">At The End Of 2018</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/2018-01-23-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Http%E8%AF%B7%E6%B1%82%E3%80%81DNS%E5%8A%AB%E6%8C%81%E4%B8%8E%E8%A7%A3%E6%9E%90/" title="深入理解Http请求、DNS劫持与解析">深入理解Http请求、DNS劫持与解析</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/note/" title="分类于 闲谈">闲谈</a></div><span><a href="/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E9%80%89%E6%8B%A9/" title="程序员如何进阶">程序员如何进阶</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/2018-01-23-IOS%E4%B8%8B%E4%B8%89%E7%A7%8DDNS%E8%A7%A3%E6%9E%90%E6%96%B9%E5%BC%8F%E5%88%86%E6%9E%90%EF%BC%88LocalDns%EF%BC%89/" title="IOS下三种DNS解析方式分析（LocalDns）">IOS下三种DNS解析方式分析（LocalDns）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/2021-07-27-%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E4%B8%80%E5%9C%BAPresentation/" title="如何做好一场Presentation">如何做好一场Presentation</a></span></li></ul></div></div><div class="status"><div class="copyright">&copy; 1992 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-"></i> </span><span class="author" itemprop="copyrightHolder">Molier @ Molier</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">217k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">3:18</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2020-11-28-汇编和栈/",favicon:{show:"MolierBolg",hide:"MolierBolg"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>