<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Molier" href="https://oliverqueen.cn/rss.xml"><link rel="alternate" type="application/atom+xml" title="Molier" href="https://oliverqueen.cn/atom.xml"><link rel="alternate" type="application/json" title="Molier" href="https://oliverqueen.cn/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://oliverqueen.cn/2020-11-21-%E6%B1%87%E7%BC%96%E5%92%8C%E5%86%85%E5%AD%98/"><title>汇编和内存 - 计算机基础 | Molier = Molier = Tomorrow is another day</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">汇编和内存</h1><div class="meta"><span class="item" title="创建时间：2020-11-21 16:50:53"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2020-11-21T16:50:53+08:00">2020-11-21</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>8.5k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>8 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Molier</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/1347194558381.jpg"></li><li class="item" data-background-image="https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/1347194692446.jpg"></li><li class="item" data-background-image="https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/6833939bly1gipetlbztpj20zk0m84qp.jpg"></li><li class="item" data-background-image="https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/1347194346111.jpg"></li><li class="item" data-background-image="https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/134719450540.jpg"></li><li class="item" data-background-image="https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/6833939bly1gicliwyw55j20zk0m8hdt.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/" itemprop="item" rel="index" title="分类于 计算机基础"><span itemprop="name">计算机基础</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://oliverqueen.cn/2020-11-21-%E6%B1%87%E7%BC%96%E5%92%8C%E5%86%85%E5%AD%98/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Molier"><meta itemprop="description" content="Tomorrow is another day, iOS 开发 移动 App 博客 杂谈 随笔 相册"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Molier"></span><div class="body md" itemprop="articleBody"><h1 id="汇编和内存"><a class="anchor" href="#汇编和内存">#</a> 汇编和内存</h1><p>你已经开了汇编学习的旅程，并且在前几章中你已经学习了汇编调用的一些黑魔法，你现在知道了，当一个函数被调用，他的参数和返回值是如何传递的。但是您还没学到的是将代码加载到内存后如何执行代码。</p><p>在本章中，您将探索程序的执行方式。 您将看到一个特殊的寄存器，该寄存器用于告诉处理器应该从何处读取下一条指令，以及不同大小和内存分组如何产生截然不同的结果。</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkww85fg8yj30u012ob29.jpg" alt=""></p><p><span id="more"></span></p><h2 id="设置英特尔风格汇编体验tm"><a class="anchor" href="#设置英特尔风格汇编体验tm">#</a> 设置英特尔风格汇编体验™</h2><p>如上一章所述，显示汇编有两种主要方法。 一种类型是 AT＆T 程序集，这个也是 LLDB 的默认程序集。 这种格式具有以下格式：</p><pre><code>opcode（操作码）  source（源）  destination（目的地）
</code></pre><p>看一个具体的例子</p><pre><code>movq  $0x78, %rax
</code></pre><p>这个操作会将十六进制值 <code>0x78</code> 移动到 <code>RAX</code> 寄存器中。 尽管这种汇编形式对某些人来说很不错，但从现在开始，您将使用英特尔的表示形式。</p><blockquote><p>注意：汇编的选择有点像一场大战，有的人说用 Inter 的格式，有的说是用 AT&amp;T 的格式，在 StackOverflow 中查看以下<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTcyNjAyL2F0dC12cy1pbnRlbC1zeW50YXgtYW5kLWxpbWl0YXRpb25z">讨论</span><br>选择使用英特尔是因为大家都觉得英特尔在阅读方面更好，但有时在写作方面更差。 由于您正在学习调试，因此大部分时间是在阅读汇编而不是编写汇编。</p></blockquote><p>把以下的两行内容添加进 <code>~/.lldbinit file</code> 文件底部</p><ul><li>settings set target.x86-disassembly-flavor intel</li><li>settings set target.skip-prologue false</li></ul><p>第一行告诉 LLDB 以 Intel 风格显示 x86 汇编（32 位和 64 位）。<br>第二行告诉 LLDB 不要跳过函数序言。 您在本书的前面已经了解了这一点，从现在开始，请不要跳过序言，因为您将直接从函数的第一条指令检查汇编。</p><p>&lt;font color=#0099ff size=3 face=&quot;黑体&quot;&gt; 关于函数序言和函数尾声可以再参考这篇<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3phbmcxNDE1ODg3NjEvYXJ0aWNsZS9kZXRhaWxzLzEwMzk4NDIyNg==">文章</span> &lt;/font&gt;</p><p>&lt;font color=#DC143C size=3 face=&quot;黑体&quot;&gt; 注意：在编辑〜/.lldbinit 文件时，请确保您不使用 TextEdit 之类的程序，因为它将在文件中添加不必要的字符，这可能导致 LLDB 无法正确解析该文件。 一种简单（尽管很危险）的添加方法是通过如下的 Terminal 命令：echo“ settings set target.x86-disassembly-flavor intel” &gt;&gt;〜/.lldbinit。<br>确保其中有两个 “&gt;&gt;”，否则将覆盖〜/.lldbinit 文件中的所有先前内容。 如果您对终端机不满意，最好的选择是 nano（您之前使用过的编辑器）。&lt;/font&gt;</p><p>英特尔风格将交换源值和目标值，删除 '％' 和 '$' 字符以及进行许多其他许多更改。 由于您还不会使用 AT＆T 语法，因此这里就不解释全部的差异，我们只单单学习 Inter 程序集就够了。</p><p>看下面的示例，就是以 Inter 风格来展示，他看起来比较干净，比较好阅读。</p><pre><code>mov  rax, 0x78
</code></pre><p>同样，这会将十六进制值 0x78 移到 RAX 寄存器中。<br>与前面显示的 AT＆T 风格相比，Intel 风格交换了源操作数和目标操作。 现在，目标操作数在源操作数之前。 在进行汇编时，务必始终确定正确的风格，这很重要，因为如果您不清楚要使用的风格，则可能会采取不同的操作。</p><p>从现在开始，我们就开始使用 Inter 的汇编格式了。 如果您看到以 $ 字符开头的数字十六进制常量或以％开头的寄存器，你就要把他们转换成 Inter 的形式</p><blockquote><p>注：笔者反而觉得 AT&amp;T 的风格更适合中国汉语的语法，只是前面的 % 和 $ 有些奇怪罢了</p></blockquote><h2 id="创建cpx命令"><a class="anchor" href="#创建cpx命令">#</a> 创建 cpx 命令</h2><p>首先，您将创建自己的 LLDB 命令，之后会用到。<br>再次打开〜/.lldbinit（vim）。 然后将以下内容添加到文件底部：</p><ul><li>command alias -H &quot;Print value in ObjC context in hexadecimal&quot; -h &quot;Print in hex&quot; -- cpx expression -f x -l objc --</li></ul><p>cpx 是一个便捷命令，您可以使用 Objective-C 上下文以十六进制格式打印出某些内容。 尤其是在打印出寄存器内容时会用到。<br>请记住，寄存器在 Swift 上下文中不可用，因此您需要使用 Objective-C 上下文。<br>现在，您已经具有从汇编的角度探讨本章内容所需的工具！</p><h2 id="位字节和其他术语"><a class="anchor" href="#位字节和其他术语">#</a> 位，字节和其他术语</h2><p>在开始探索内存之前，您需要了解一些有关内存分组方式的词汇。</p><ul><li>位 ：可以包含 1 或 0 的值称为位。您可以说在 64 位体系结构中每个地址有 64 位。很简单。</li><li>字节：当 8 位组合在一起时，它们称为字节。一个字节可以容纳多少个唯一值？您可以通过计算 2 ^ 8（从 0 开始到 255 的 256 个值）来确定。</li></ul><p>许多信息以字节表示。例如，C 语言中 sizeof（）函数以字节为单位返回对象的大小。</p><p>如果您熟悉 ASCII 字符编码，您会想起所有 ASCII 字符都可以保存在一个字节中。<br>现在是时候看看实际操作中的术语并学习一些技巧。<br>打开 Registers macOS 应用程序，您将在本章的资源文件夹中找到该应用程序。接下来，构建并运行该应用程序。一旦运行，请暂停程序并启动 LLDB 控制台。这将导致使用非 Swift 调试上下文，因为默认情况下暂停应用程序会带来非 Swift 上下文。<br>在 LLDB 中键入以下内容：</p><ul><li>p sizeof('A')</li></ul><p>这将打印出组成 'A' 字符所需的字节数</p><pre><code>(unsigned long) $0 = 1
</code></pre><p>然后输入如下命令</p><ul><li>p/t 'A'</li></ul><p>你会得到</p><pre><code>(char) $1 = 0b01000001
</code></pre><p>这是 ASCII 中字符 A 的二进制表示。<br>显示信息字节的另一种更常见的方法是使用十六进制值。 需要两个十六进制数字以十六进制表示一个信息字节。</p><p>然后我们输入以下命令来打印出 “A” 的十六进制表示形式：</p><ul><li>p/x 'A'</li></ul><p>你将会得到</p><pre><code>(char) $2 = 0x41
</code></pre><p>十六进制非常适合查看内存，因为一个十六进制数字恰好代表 4 位。 因此，如果您有 2 个十六进制数字，则您有 1 个字节。 如果您有 8 个十六进制数字，则您有 4 个字节。 等等。<br>这里还有一些适用于您的术语，这些术语在以后的章节中会很有用：</p><ul><li>Nybble：4 位，十六进制单个值</li><li>Half word：16 位或 2 个字节</li><li>Word：32 位或 4 个字节</li><li>Double word or Giant word：64 位或 8 字节。</li></ul><p>使用此术语，您将可以探索不同的内存块。</p><h2 id="rip寄存器"><a class="anchor" href="#rip寄存器">#</a> RIP 寄存器</h2><p>当程序执行时，将要执行的代码加载到内存中。 程序中接下来要执行的代码的位置由一个非常重要的寄存器决定：RIP 或指令指针寄存器。<br>让我们来看看实际情况。 再次打开 “register demo” 应用程序，然后导航到 AppDelegate.swift 文件。 修改文件，使其包含以下代码：</p><pre><code>@NSApplicationMain
class AppDelegate: NSObject, NSApplicationDelegate &#123;

func applicationWillBecomeActive(
    _ notification: Notification) &#123;
    print(&quot;\(#function)&quot;)
    self.aBadMethod()
&#125;

func aBadMethod() &#123;
    print(&quot;\(#function)&quot;)
&#125;

func aGoodMethod() &#123;
    print(&quot;\(#function)&quot;)
&#125;
&#125;
</code></pre><p>构建并运行该应用程序。 毫无疑问，控制台将会输出 该方法名 <code>applicationWillBecomeActive（_ :)</code> ，然后输出 <code>aBadMethod</code> 。我们在在 aBadMethod 的开始处创建一个断点：</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkwqomut9kj31v30u0h5e.jpg" alt=""></p><p>再次构建并运行。 在 aBadMethod 的开头命中断点后，导航至 Debug \ Debug Workflow \ Always Show Disassembly in Xcode。 现在，您将看到程序的实际汇编！</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkwqrg4bs4j30u00w8tq1.jpg" alt=""></p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkwqpnpyuwj32b30u0b29.jpg" alt=""></p><p>然后我们在控制台输入以下命令：</p><pre><code>cpx $rip
</code></pre><p>这将使用您先前创建的 cpx 命令打印出指令指针寄存器。<br>您会注意到输出 LLDB 的地址与 Xcode 中绿线突出显示的地址是一样的：</p><pre><code>(unsigned long) $1 = 0x0000000100008910
</code></pre><p>当然了每个人的电脑上显示的地址是不同的，而且每次执行时候的地址都可能不一样，但是在单次运行中绿线和控制台上显示的肯定是完全一样的。你试着在控制台下打以下命令：</p><pre><code>(lldb) image lookup -vrn ^Registers.*aGoodMethod
</code></pre><p>这是一个很常用的查找命令，其中包含典型的正则表达式参数以及添加的参数 <code>-v</code> ，该参数输出详细信息就像 <code>--verbose</code> 。<br>您会看到很多的东西。 在控制台中使用 <code>command + F</code> 来搜索关键字 <code>range = [</code> 其中范围中的第一个值便是</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkwra1dlerj31m00u0hdu.jpg" alt=""></p><p>该地址称为加载地址。 这是此函数在内存中的实际物理地址！这与您在 <code>image lookup</code> 命令中看到的常规输出不同，它仅显示函数相对于可执行文件的偏移量，也称为实现偏移量。 寻找函数地址时，区分加载地址和可执行文件中的实现偏移很重要，因为它会有所不同。</p><p>将这个新地址复制到范围括号的开头。 对于此特定示例，aGoodMethod 的加载地址位于 0x0000000100008910。 现在将 aGoodMethod 的地址指向 RIP 寄存器。输入以下指令</p><ul><li>register write rip 0x0000000100008910</li></ul><p>单击继续，使用 Xcode 调试按钮单击 “继续”。 请一定用 Xcode 的按钮来继续，不要是用 <code>continue</code> 命令，因为在修改 RIP 寄存器并在控制台中继续操作时就会崩溃。按下 Xcode 继续按钮后，您会看到神奇的事情 -&gt; 未执行 aBadMethod（），而是执行了 aGoodMethod（）。 通过查看控制台日志中的输出来验证这一点。</p><blockquote><p>注意：修改 RIP 寄存器实际上非常危险。 您需要确 RIP 寄存器上的数据不会再被使用了，因为新功能将对 RIP 寄存器做出不正确的假设。 由于 aGoodMethod 和 aBadMethod 在功能上非常相似，因此您从一开始就停了下来，并且由于没有对 Registers 应用程序进行任何修改，因此不必担心。</p></blockquote><h2 id="寄存器和比特分解"><a class="anchor" href="#寄存器和比特分解">#</a> 寄存器和比特分解</h2><p>如上一章所述，x64 具有 16 个通用寄存器：RDI，RSI，RAX，RDX，RBP，RSP，RCX，RDX，R8，R9，R10，R11，R12，R13，R14 和 R15。<br>为了保持与 i386 的 32 位架构等以前的体系结构的兼容性，可以将寄存器分为 32 位，16 位或 8 位值。</p><p>对于具有不同体系结构历史的寄存器，寄存器名称中的最前面的字符确定寄存器的大小。 例如，RIP 寄存器以 R 开头，它表示 64 位。 如果您希望使用等效于 RIP 寄存器的 32 位，则可以将 R 字符换成 E，以获得 EIP 寄存器。</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkwsm5uzn1j30wj0u0qf1.jpg" alt=""></p><p>为什么这些有用？ 因为使用寄存器时，有时传递到寄存器的值不需要全部使用 64 位。 例如，考虑布尔数据类型：您真正需要的只是 1 或 0 以指示是或否（尽管实际上，布尔值将占用寄存器一个字节）。 基于语言的功能和约束，编译器知道这一点，有时只会将信息写入寄存器的某些部分。<br>让我们来看看实际情况。<br>删除 Registers 项目中的所有断点。 生成并运行项目。 现在，让程序暂停。输入以下内容：</p><ul><li>register write rdx 0x0123456789ABCDEF</li></ul><p>这会将值写入 RDX 寄存器。让我们停一分钟。 &lt;font color=red size=3&gt; 提示：您应该注意，写入寄存器可能会导致程序崩溃，尤其是当您希望写入的寄存器具有某种类型的数据时 &lt;/font&gt;。 但是你现在是在 demo 上做调试，所以请不要担心您的程序是否崩溃！<br>确认此值已成功写入 RDX 寄存器：</p><ul><li>p/x $rdx</li></ul><p>输出</p><pre><code>(unsigned long) $0 = 0x0123456789abcdef
</code></pre><p>然后输入</p><ul><li>p/x $dx</li></ul><p>这将打印出 DX 寄存器，该寄存器是 EDX 寄存器的最低有效部分。 因此，这是一个半字。 您应该看到以下内容：</p><pre><code>0xcdef
</code></pre><p>再输入</p><ul><li>p/x $dl</li></ul><p>这将打印出 DL 寄存器，它是 DX 寄存器的最低有效位 - 这次是一个字节。 您应该看到以下内容</p><pre><code>0xef
</code></pre><p>最后输出如下指令</p><ul><li>p/x $dh</li></ul><p>这为您提供了 DX 寄存器的最高有效部分，即 DL 给出的另一半。 DL 中的 L 代表 “低” 而 DH 中的 H 代表 “高” 也就不足为奇了。<br>探索汇编时，请注意不同尺寸的寄存器。 寄存器的大小可以为其中包含的值提供线索。 例如，您可以轻松地查找通过 AL 寄存器返回布尔值的函数，因为布尔值将使用 8 个字节，&lt;font color=red size=3&gt; 而 AL 是 64 位 “返回值寄存器” RAX 的 8 位部分 &lt;/font&gt;</p><h2 id="寄存器-r8-到-r15"><a class="anchor" href="#寄存器-r8-到-r15">#</a> 寄存器 R8 到 R15</h2><p>由于 R8 至 R15 系列寄存器仅针对 64 位架构而创建，因此它们使用完全不同的格式表示较小的寄存器。</p><p>现在，您将看下 R9 的不同大小如何选择。生成并运行 Registers 应用程序，然后暂停调试器。像以前一样，将相同的十六进制值写入 R9 寄存器：</p><ul><li>register write $r9 0x0123456789abcdef</li></ul><p>输入以下内容，以确认您已设置 R9 寄存器成功：</p><ul><li>p/x $ r9</li></ul><p>输入以下内容，这将打印 R9 寄存器的低 32 位。请注意，它与您为 RDX 指定低 32 位（即 EDX）的方式有何不同。</p><ul><li>p/x $ r9d</li></ul><p>然后输入以下内容，这次您获得 R9 的低 16 位。同样，这与您为 RDX 进行此操作的方式不同</p><ul><li>p/x $ r9w</li></ul><p>再输入以下内容，打印出 R9 的低 8 位</p><ul><li>p/x $ r9l</li></ul><p>尽管这看起来有些乏味，但是您正在建立阅读汇编语言的技巧。</p><h2 id="内存中断"><a class="anchor" href="#内存中断">#</a> 内存中断</h2><p>现在，您已经了解了指令指针，是时候进一步探索其背后的内存了。顾名思义，指令指针实际上是一个指针。它不执行 RIP 寄存器中存储的指令，而是执行 RIP 寄存器中指向的指令。</p><p>在 LLDB 中看到这一点也许会更好地描述它。返回 Registers 应用程序中，打开 AppDelegate.swift 并再次在 aBadMethod 上设置一个断点。生成并运行该应用程序。</p><p>命中断点并停止程序后，导航回到汇编视图。如果您忘记了该操作，但尚未为其创建键盘快捷键，则可以在 Debug \ Debug Workflow \ Always Show Disassembly 下找到它。<br>您会看到一堆汇编指令。看一下 RIP 寄存器的位置，该位置应指向函数的最开始。<br>对于该项目，aBadMethod 的起始地址始于 0x100008910。和往常一样，您的地址可能会有所不同。<br>在 LLDB 控制台中，键入以下内容：</p><ul><li>cpx $rip</li></ul><p>到现在为止，这将打印出指令指针寄存器的内容。如预期的那样，您将获得 aBadMethod 起始地址。 但是同样，RIP 寄存器指向内存中的值。 它指的是什么？ 嗯，您可以摆脱疯狂的 C 编码技巧（您还记得吗？）并取消引用指针，但是使用 LLDB 可以找到一种更为优雅的方法。<br>输入以下内容，将地址替换为您的 aBadMethod 函数的地址：</p><ul><li>memory read -fi -c1 0x100008910</li></ul><p>哇，该命令到底能做什么？ <code>memory read</code> 采用一个值，并读取您提供的内存地址所指向的内容。 <code>-f</code> 命令是一个格式参数。 在这种情况下，它是汇编指令格式。 最后，您说的是只希望使用 count 或 - c 参数打印一条汇编指令。<br>您将获得类似于以下内容的输出：</p><pre><code>-&gt;  0x1000017c0: 55  pushq  %rbp
</code></pre><p>这是一些很好的输出。 它告诉您十六进制（0x55）中提供的汇编指令以及操作码，这些指令是 <code>pushq ％rbp</code> 操作</p><blockquote><p>注意：等等，您看到 '％' 吗？！ LLDB 中存在一个错误，当您以指令格式打印代码时，该错误不符合您的汇编风格。 请记住，如果您看到这种情况，则源和目标操作数将被反转！这就是 inter 指令集和 AT&amp;T 指令集的区别。</p></blockquote><p>让我们再看一下输出中的 “55”。 这是整个指令（即整个 pushq ％rbp）的编码。 不相信我吗？ 您可以验证它。 在 LLDB 中输入以下内容：</p><ul><li>expression -f i -l objc -- 0x55</li></ul><p>这实际上要求 LLDB 将 0x55 解释为 x64 操作码。 您将获得以下输出：</p><pre><code>$1 = 55 pushq％rbp
</code></pre><p>该命令有点长，但这是因为如果您在 Swift 调试上下文中，则需要切换到 Objective-C 上下文。 但是，如果移至 Objective-C 调试上下文，则可以使用简短得多的便捷表达式。</p><p>尝试单击 Xcode 左侧面板中的其他框架，以进入一个不包含 Swift 或 Objective-C / Swift 桥接代码的 Objective-C 上下文。 单击 Objective-C 函数中的任何框架。</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkwvrtvgixj30u01efnix.jpg" alt=""></p><p>下一步，在 LLDB 控制台中键入以下内容：</p><ul><li>p/i 0x55</li></ul><p>好多了，对吧？<br>现在，回到手中的应用程序。 在 LLDB 中键入以下内容，再次用 aBadMethod 函数地址替换地址：</p><ul><li>memory read -fi -c10 0x1000017c0</li></ul><p>你讲获得以下输出：</p><pre><code>-&gt; 0x100008910: 55                    pushq  %rbp
0x100008911: 48 89 e5              movq   %rsp, %rbp
0x100008914: 48 81 ec c0 00 00 00  subq   $0xc0, %rsp
0x10000891b: 4c 89 6d f8           movq   %r13, -0x8(%rbp)
0x10000891f: b8 01 00 00 00        movl   $0x1, %eax
0x100008924: 89 c7                 movl   %eax, %edi
0x100008926: e8 d5 05 00 00        callq  0x100008f00               ; symbol stub for: generic specialization &lt;preserving fragile attribute, Any&gt; of Swift._allocateUninitializedArray&lt;A&gt;(Builtin.Word) -&gt; (Swift.Array&lt;A&gt;, Builtin.RawPointer)
0x10000892b: 48 89 c7              movq   %rax, %rdi
0x10000892e: 48 89 45 a8           movq   %rax, -0x58(%rbp)
0x100008932: 48 89 55 a0           movq   %rdx, -0x60(%rbp)
</code></pre><p>这里需要注意一些有趣的事情：汇编指令的长度可以变化。 看一下第一条指令，然后看输出中的其余指令。 第一条指令的长度为 1 个字节，用 0x55 表示。 以下指令的长度为三个字节。<br>确保您仍在 Objective-C 上下文中，并尝试打印出负责此指令的操作码。 它只有三个字节，所以您只需将它们连接在一起</p><ul><li>p/i 0x4889e5</li></ul><p>您将获得与 <code>mov ％rsp，％rbp</code> 指令完全无关的另一条指令！ 您会看到以下内容：</p><pre><code>e5 89  inl    $0x89, %eax
</code></pre><p>是怎么做到的呢？ 也许现在是谈论字节序的好时机。</p><h2 id="字节序这东西倒过来了"><a class="anchor" href="#字节序这东西倒过来了">#</a> 字节序... 这东西倒过来了</h2><p>x64 以及 ARM 系列体系结构设备均使用低位字节序，这意味着数据以最低有效字节在先的形式存储在内存中。 如果要将数字 0xabcd 存储在内存中，则会先存储 0xcd 字节，然后再存储 0xab 字节。<br>回到指令示例，这意味着指令 0x4889e5 将以 0xe5、0x89、0x48 的形式存储在存储器中。<br>返回到您先前遇到的 mov 指令，请尝试反转用于构成汇编指令的字节。 在 LLDB 中输入以下内容：</p><ul><li>p/i 0xe58948</li></ul><p>您现在将获得预期的汇编表示：</p><pre><code>$2 = 48 89 e5  movq   %rsp, %rbp
</code></pre><p>让我们再看看一些小端实践的例子。 在 LLDB 中输入以下内容：</p><ul><li>memory read -s1 -c20 -fx 0x100008910</li></ul><p>此命令读取地址为 0x100008910 的内存。 -s1 选项可读取 1 个字节的大小块，-c20 选项可读取 20 个字节的大小块。 您会看到类似这样的内容：</p><pre><code>0x100008910: 0x55 0x48 0x89 0xe5 0x48 0x81 0xec 0xc0
0x100008918: 0x00 0x00 0x00 0x4c 0x89 0x6d 0xf8 0xb8
0x100008920: 0x01 0x00 0x00 0x00
</code></pre><p>现在，将大小增加一倍，数量减少一半，就像这样：</p><ul><li>memory read -s2 -c10 -fx 0x100008910</li></ul><p>你会看到这样的输出</p><pre><code>0x100008910: 0x4855 0xe589 0x8148 0xc0ec 0x0000 0x4c00 0x6d89 0xb8f8
0x100008920: 0x0001 0x0000
</code></pre><p>请注意，当将内存值分组在一起时，由于使用了低位字节序，它们将被颠倒。<br>现在，将大小再增加一倍，数量再减少一半：</p><ul><li>memory read -s4 -c5 -fx 0x100008910</li></ul><p>然后你会看到如下输出</p><pre><code>0x100008910: 0xe5894855 0xc0ec8148 0x4c000000 0xb8f86d89
0x100008920: 0x00000001
</code></pre><p>与之前的输出相比，这些值再次被颠倒。<br>记住这一点非常重要，但在探索你自己的记忆时，这会让你变得很混乱。不仅内存的大小会给您一个潜在的错误答案，而且顺序也会给您一个潜在的错误答案。当你开始对着电脑大喊大叫时，当你试图弄清楚某样东西应该如何工作时，请记住这一点！</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-12-30 22:16:08" itemprop="dateModified" datetime="2023-12-30T22:16:08+08:00">2023-12-30</time> </span><span id="2020-11-21-汇编和内存/" class="item leancloud_visitors" data-flag-title="汇编和内存" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Molier 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Molier 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Molier <i class="ic i-at"><em>@</em></i>Molier</li><li class="link"><strong>本文链接：</strong> <a href="https://oliverqueen.cn/2020-11-21-%E6%B1%87%E7%BC%96%E5%92%8C%E5%86%85%E5%AD%98/" title="汇编和内存">https://oliverqueen.cn/2020-11-21-汇编和内存/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2020-11-19-%E6%B1%87%E7%BC%96%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E8%A7%84%E5%88%99/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;MolierQueen&#x2F;resource@main&#x2F;1347194346111.jpg" title="汇编寄存器的规则"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 计算机基础</span><h3>汇编寄存器的规则</h3></a></div><div class="item right"><a href="/2020-11-28-%E6%B1%87%E7%BC%96%E5%92%8C%E6%A0%88/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;MolierQueen&#x2F;resource@main&#x2F;1347194416221.jpg" title="汇编和栈"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 计算机基础</span><h3>汇编和栈</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E5%92%8C%E5%86%85%E5%AD%98"><span class="toc-number">1.</span> <span class="toc-text">汇编和内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%8B%B1%E7%89%B9%E5%B0%94%E9%A3%8E%E6%A0%BC%E6%B1%87%E7%BC%96%E4%BD%93%E9%AA%8Ctm"><span class="toc-number">1.1.</span> <span class="toc-text">设置英特尔风格汇编体验™</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAcpx%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.</span> <span class="toc-text">创建 cpx 命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E5%AD%97%E8%8A%82%E5%92%8C%E5%85%B6%E4%BB%96%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.3.</span> <span class="toc-text">位，字节和其他术语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rip%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">RIP 寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E6%AF%94%E7%89%B9%E5%88%86%E8%A7%A3"><span class="toc-number">1.5.</span> <span class="toc-text">寄存器和比特分解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8-r8-%E5%88%B0-r15"><span class="toc-number">1.6.</span> <span class="toc-text">寄存器 R8 到 R15</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%B8%AD%E6%96%AD"><span class="toc-number">1.7.</span> <span class="toc-text">内存中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E5%BA%8F%E8%BF%99%E4%B8%9C%E8%A5%BF%E5%80%92%E8%BF%87%E6%9D%A5%E4%BA%86"><span class="toc-number">1.8.</span> <span class="toc-text">字节序... 这东西倒过来了</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2020-11-19-%E6%B1%87%E7%BC%96%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E8%A7%84%E5%88%99/" rel="bookmark" title="汇编寄存器的规则">汇编寄存器的规则</a></li><li class="active"><a href="/2020-11-21-%E6%B1%87%E7%BC%96%E5%92%8C%E5%86%85%E5%AD%98/" rel="bookmark" title="汇编和内存">汇编和内存</a></li><li><a href="/2020-11-28-%E6%B1%87%E7%BC%96%E5%92%8C%E6%A0%88/" rel="bookmark" title="汇编和栈">汇编和栈</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Molier" data-src="/images/avatar.jpeg"><p class="name" itemprop="name">Molier</p><div class="description" itemprop="description">iOS 开发 移动 App 博客 杂谈 随笔 相册</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">40</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">6</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">53</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item 新浪微博" data-url="aHR0cHM6Ly93ZWliby5jb20vemhhbmduaW5naGFvP3JlZmVyX2ZsYWc9MTAwNTA1NTAxMF8=" title="https:&#x2F;&#x2F;weibo.com&#x2F;zhangninghao?refer_flag&#x3D;1005055010_"><i class="ic i-weibo"></i></span> <span class="exturl item jianshu" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vdS9mZDIxZjQxZmI1MjI=" title="https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;fd21f41fb522"><i class="ic i-link"></i></span> <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL01vbGllclF1ZWVu" title="https:&#x2F;&#x2F;github.com&#x2F;MolierQueen"><i class="ic i-github"></i></span> <span class="exturl item juejin" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vdXNlci81ODZjNjI0YmFjNTAyZTEyZDYzMTU0NWY=" title="https:&#x2F;&#x2F;juejin.im&#x2F;user&#x2F;586c624bac502e12d631545f"><i class="ic i-link"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjM3MTA5OTY5NEBxcS5jb20=" title="mailto:371099694@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>朋友们</a></li></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2020-11-19-%E6%B1%87%E7%BC%96%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E8%A7%84%E5%88%99/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2020-11-28-%E6%B1%87%E7%BC%96%E5%92%8C%E6%A0%88/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/iPa%E9%80%86%E5%90%91%E4%B9%8B%E8%B7%AF/" title="iPa逆向之路">iPa逆向之路</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/2018-01-24-%E8%87%AA%E5%AE%9A%E4%B9%89AlertView/" title="自定义AlertView">自定义AlertView</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/2022-05-26-Apple%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/" title="Apple登录流程详解">Apple登录流程详解</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/note/" title="分类于 闲谈">闲谈</a></div><span><a href="/2019-02-14-At-the-end-of-2018/" title="At The End Of 2018">At The End Of 2018</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/2018-06-19-MusicAbout/" title="关于实现唱吧清唱功能的理解">关于实现唱吧清唱功能的理解</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/2018-01-23-CFNetwork%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/" title="CFNetwork的介绍和使用">CFNetwork的介绍和使用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/common/" title="分类于 通用开发">通用开发</a></div><span><a href="/2018-01-24-%E8%BD%AC-%E5%A6%82%E4%BD%95%E6%8E%8C%E6%8F%A1%E6%89%80%E6%9C%89%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/" title="(转)如何掌握所有的程序语言">(转)如何掌握所有的程序语言</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/2018-01-24-%E5%9C%A8iOS%E5%B7%A5%E7%A8%8B%E4%B8%ADCocoapods%E7%9A%84%E4%BD%BF%E7%94%A8/" title="在iOS工程中Cocoapods的使用">在iOS工程中Cocoapods的使用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/2018-01-23-%E5%85%B3%E4%BA%8E%E8%A7%86%E5%9B%BE%E5%9C%A8%E5%88%87%E5%9C%86%E8%A7%92%E6%97%B6%E5%80%99%E7%9A%84%E5%AF%BC%E8%87%B4%E7%9A%84%E6%80%A7%E8%83%BD%E4%B8%8B%E9%99%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A2%E8%AE%A8/" title="关于视图在切圆角时候的导致的性能下降的一些探讨">关于视图在切圆角时候的导致的性能下降的一些探讨</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/common/" title="分类于 通用开发">通用开发</a></div><span><a href="/2018-08-23-ChangeSvnToGit/" title="SVN切换到Git">SVN切换到Git</a></span></li></ul></div></div><div class="status"><div class="copyright">&copy; 1992 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-"></i> </span><span class="author" itemprop="copyrightHolder">Molier @ Molier</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">217k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">3:18</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2020-11-21-汇编和内存/",favicon:{show:"MolierBolg",hide:"MolierBolg"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>