<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Molier" href="https://oliverqueen.cn/rss.xml"><link rel="alternate" type="application/atom+xml" title="Molier" href="https://oliverqueen.cn/atom.xml"><link rel="alternate" type="application/json" title="Molier" href="https://oliverqueen.cn/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://oliverqueen.cn/2020-11-19-%E6%B1%87%E7%BC%96%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E8%A7%84%E5%88%99/"><title>汇编寄存器的规则 - 计算机基础 | Molier = Molier = Tomorrow is another day</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">汇编寄存器的规则</h1><div class="meta"><span class="item" title="创建时间：2020-11-19 17:12:10"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2020-11-19T17:12:10+08:00">2020-11-19</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>12k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>11 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Molier</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/6833939bly1giclize41wj20zk0m87gk.jpg"></li><li class="item" data-background-image="https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/6833939bly1gipexj2jgzj20zk0m8b09.jpg"></li><li class="item" data-background-image="https://cdn.jsdelivr.net/gh/MolierQueen/resource@main/134719477569.jpg"></li><li class="item" data-background-image="https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/6833939bly1giclhtuo6nj20zk0m8ttm.jpg"></li><li class="item" data-background-image="https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/6833939bly1giclh5u05ej20zk0m87df.jpg"></li><li class="item" data-background-image="https://cdn.cdnjson.com/tvax3.sinaimg.cn/large/6833939bly1gipexe4oykj20zk0m87ji.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/" itemprop="item" rel="index" title="分类于 计算机基础"><span itemprop="name">计算机基础</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://oliverqueen.cn/2020-11-19-%E6%B1%87%E7%BC%96%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E8%A7%84%E5%88%99/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Molier"><meta itemprop="description" content="Tomorrow is another day, iOS 开发 移动 App 博客 杂谈 随笔 相册"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Molier"></span><div class="body md" itemprop="articleBody"><h1 id="汇编寄存器的规则"><a class="anchor" href="#汇编寄存器的规则">#</a> 汇编寄存器的规则</h1><p>在本章中，您将了解到 CPU 使用的寄存器，并研究和修改传入函数的参数。您还将了解常见的苹果计算机架构，以及如何在函数中使用它们的寄存器。这就是所谓的架构调用约定。</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkulov9q1ej31c10u0x6s.jpg" alt=""><br><span id="more"></span><br>了解汇编如何工作以及特定架构的调用约定如何工作是一项极其重要的技能。它可以让您观察没有源代码的函数参数，并允许您修改传入函数的参数。此外，有时转到底层汇编层面会更好，因为您的源代码可能对您不知道的变量有不同的或未知的名称。<br>例如，假设您想知道函数调用的第二个参数，但是我并不知道参数的名称是什么。汇编的知识会帮助你来观察这些函数中的参数。</p><h2 id="汇编101"><a class="anchor" href="#汇编101">#</a> 汇编 101</h2><p>等等，所以到底什么是汇编？来看一个场景：您是否曾经打了一个断点，但是中断到没有源代码的地方？然后看到看到大量内存地址和可怕的简短命令？你是不是缩成一团，悄悄地对自己说你再也不会看这些密集的东西了？嗯… 这就是所谓的汇编！<br>这里有一张 Xcode 中的断点调试图，它展示了模拟器中函数的汇编。<br><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gktboylxxdj322z0li150.jpg" alt=""></p><p>通过上图可以看出汇编代码可以被分成几个不同的部分。汇编指令中的每一行都包含一个操作码，可以认为是对计算机来说非常简单的指令。那么操作码是什么样子的呢？操作码是在计算机上执行一项简单任务的指令。例如下面的程序集片段:</p><p></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pushq   %rbx</span><br><span class="line">subq    $0x228, %rsp </span><br><span class="line">movq    %rdi, %rbx </span><br></pre></td></tr></table></figure><p></p><p>在这个汇编模块中，您可以看到三种操作码: <code>pushq</code> 、 <code>subq</code> 和 <code>movq</code> 可以将操作码项看作要执行的操作。操作码后面的内容是源标签和目标标签。也就是说，这些是操作码所作用的对象。在上面的示例中，有几个寄存器，显示为 <code>rbx</code> 、 <code>rsp</code> 、 <code>rdi</code> 和 <code>rbp</code> 。前面的 <code>%</code> 告诉您这是一个寄存器。</p><p>此外，您还可以找到一个十六进制的数字常量，如 0x228。这个常数之前的美元符号告诉你它是一个绝对值。现在不需要知道这段代码在做什么，因为您首先需要了解每个符号的含义。然后你会学到更多关于操作码的知识，并在以后的章节中编写你自己的程序。</p><blockquote><p>注意：在上面的示例中，请注意，在寄存器和常量之前有一堆％和 $。 这就是反汇编程序格式化程序集的展示方式。 但是可以通过两种主要方式展示汇编。 第一个是 <code>英特尔程序集</code> ，第二个是 <code>AT＆T程序集</code> 。默认情况下，Apple 的反汇编程序工具都会以 AT＆T 格式显示，就如上例所示。 尽管这是一种很好的格式，但在眼睛上可能会有些困难。 在下一章中，您将把汇编格式更改为 Intel，并且从那以后将完全使用 Intel 汇编语法。</p></blockquote><h2 id="x86_64-vs-arm64"><a class="anchor" href="#x86_64-vs-arm64">#</a> x86_64 vs ARM64</h2><p>作为 Apple 平台的开发人员，学习汇编时要处理两种主要架构：x86_64 架构和 ARM64 架构。 x86_64 是最可能在 macOS 计算机上使用的体系结构，除非您运行的是 “古老” 的 Macintosh。x86_64 是 64 位体系结构，这意味着每个地址最多可以容纳 64 个 1 或 0。 另外，较旧的 Mac 使用 32 位架构，但是 Apple 在 2010 年底停止生产 32 位 Mac。 在 macOS 下运行的程序可能是 64 位兼容的，包括 Simulator 上的程序。 话虽如此，即使您的 macOS 是 x86_64，它仍然可以运行 32 位程序。如果对使用的硬件架构有疑问，可以在终端中运行以下命令来获取计算机的硬件架构：</p><ul><li>uname -m</li></ul><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gktcxe1lm2j30c902xgll.jpg" alt=""></p><p>在能耗要求很高的移动设备（如 iPhone）上使用 ARM64 体系结构。ARM 强调节能功能，因此它减少了一组操作码，有助于简化复杂的汇编指令，从而降低了能耗。 这对您来说是个好消息，因为关于 ARM 的体系结构你需要学习的并不多。这是与之前显示的方法相同的屏幕截图，除了这次是在 iPhone 7 上的 ARM64 程序集中：<br><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gktd6atsyvj32140mv4bh.jpg" alt=""><br>您现在可能无法区分这两种架构，但是您很快就会知道它们就像手背一样.</p><blockquote><p>Apple 最初在其许多 iOS 设备中都提供了 32 位 ARM 处理器，但此后便转移到了 64 位 ARM 处理器。 32 位 iOS 设备几乎已过时，因为 Apple 已通过各种 iOS 版本逐步淘汰了它们。 例如，iPhone 5 是最终的 32 位 iOS 设备，iOS 11 不支持该设备。支持 iOS 11 的 “最低” iPhone 是 64 位设备 iPhone 5s。近年来，32 位设备已出现在其他 Apple 产品中。 Apple Watch 的前两代是 32 位设备，但是第三代是 64 位设备。 此外，在较新的 macOS 设备上发现的 Apple Touch Bar（无疑是花哨的）也使用 32 位架构。</p></blockquote><p>由于最好专注于您将来的需求，因此本书将主要关注两种架构的 64 位汇编。 此外，您将首先开始学习 x86_64 程序集，然后过渡到学习 ARM64 程序集，以免感到困惑。 好吧，不要太困惑。</p><h2 id="x86_64-寄存器调用规则"><a class="anchor" href="#x86_64-寄存器调用规则">#</a> x86_64 寄存器调用规则</h2><p>您的 CPU 使用一组寄存器来操纵正在运行的程序中的数据。这些是存储的基础，就像计算机中的 RAM 一样。但是，它们位于 CPU 本身上，因此 CPU 的这些部分可以快速访问这些寄存器。效率非常高，大多数指令涉及一个或多个寄存器，并执行一些操作，例如将寄存器的内容写入内存，将存储器的内容读取到寄存器或对两个寄存器执行算术运算例如 加，减等。</p><p>在 x64 中（从现在开始，x64 是 x86_64 的缩写），机器使用 16 个通用寄存器来操纵数据。<br>这些寄存器是 RAX，RBX，RCX，RDX，RDI，RSI，RSP，RBP 和 R8 至 R15。这些名称对您现在意义不大，但是您很快就会发现每个寄存器的重要性。“在 x64 中调用函数时，寄存器的方式和使用遵循非常特定的规则。这决定了函数的参数应该去哪里以及函数完成时函数的返回值应该在哪里。这很重要，因此可以将一个编译器编译的代码与另一个编译器编译的代码一起使用。</p><p>比如你看下面这个行代码：</p><pre><code>NSString *name = @&quot;Zoltan&quot;;
NSLog(@&quot;Hello world, I am %@. I'm %d, and I live in %@.&quot;, name, 30, @&quot;my father's basement&quot;);
</code></pre><p>NSLog 函数调用中传递了四个参数。 其中一些值按原样传递，而一个参数存储在局部变量中，然后在函数中作为参数引用。 但是，通过汇编查看代码时，计算机并不关心变量的名称 (name)； 它只关心该变量在内存中的位置。</p><p>在 x64 汇编中调用函数时，以下寄存器用作参数。 尝试将它们提交到内存中，因为将来您会经常使用它们：</p><pre><code>第一个参数：RDI
第二个参数：RSI
第三个参数：RDX
第四个参数：RCX
第五个参数：R8
第六个参数：R9
</code></pre><p>如果有六个以上的参数，则使用程序的堆栈将其他参数传递给该函数。</p><p>回到简单的 Objective-C 代码，上面的 OC 代码可以像下面这样的伪代码流程在寄存器中传递：</p><p></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RDI</span> = @<span class="string">&quot;Hello world, I am %@. I&#x27;m %d, and I live in %@.&quot;</span><span class="comment">;</span></span><br><span class="line"><span class="built_in">RSI</span> = @<span class="string">&quot;Zoltan&quot;</span><span class="comment">;</span></span><br><span class="line"><span class="built_in">RDX</span> = <span class="number">30</span><span class="comment">;</span></span><br><span class="line"><span class="built_in">RCX</span> = @<span class="string">&quot;my father&#x27;s basement&quot;</span><span class="comment">;</span></span><br><span class="line">NSLog(<span class="built_in">RDI</span>, <span class="built_in">RSI</span>, <span class="built_in">RDX</span>, <span class="built_in">RCX</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p></p><p>NSLog 调用完成后，指定的寄存器将包含如上所述的适当值。但是，一旦函数序言（准备堆栈和寄存器的函数的开始部分）完成执行，这些寄存器中的值就可能改变。生成的程序集可能会覆盖存储在这些寄存器中的值，或者在代码不再需要这些引用时丢弃这些引用。<br>这意味着，一旦离开函数的开始，就不能再假定这些寄存器将保存您要观察的期望值，除非您实际查看汇编代码看看它在做什么。<br>使用此调用规则的浏览寄存器会严重影响您的调试（和断点）策略。必须在函数调用开始时停止以查看或修改参数，而不必实际进入程序集。</p><h2 id="objective-c-和寄存器"><a class="anchor" href="#objective-c-和寄存器">#</a> Objective-C 和寄存器</h2><p>如上一节所述，寄存器使用特定的调用规则。 您也可以将该知识其应用于其他语言。<br>当 Objective-C 执行方法时，将执行一个名为 <code>objc_msgSend</code> 的特殊 C 函数。 这些功能实际上有几种不同的类型，但稍后会介绍更多。 这是 Objective-C 动态消息分发的核心。 作为第一个参数，objc_msgSend 获取在其上发送消息的对象的引用。 随后是一个选择器，它只是一个 char *，用于指定在对象上调用的方法的名称。 最后，如果选择器指定应有参数，则 objc_msgSend 在函数中采用可变数量的参数。<br>让我们来看一个在 iOS 环境中的具体示例：</p><p></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span> <span class="built_in">UIApplicationClass</span> = [<span class="built_in">UIApplication</span> <span class="keyword">class</span>];</span><br><span class="line">objc_msgSend(<span class="built_in">UIApplicationClass</span>, <span class="string">&quot;sharedApplication&quot;</span>);</span><br></pre></td></tr></table></figure><p></p><p>第一个参数是对 UIApplication 类的引用，其后是 sharedApplication 选择器 其实就是需要被调用的方法。 判断是否有参数的一种简单方法是简单地检查 Objective-C 选择器中的冒号。 每个冒号将代表一个方法中的参数。<br>我们下面来看一个 OC 的方法：</p><p></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">NSString</span> *helloWorldString = [@<span class="string">&quot;Can&#x27;t Sleep; &quot;</span>stringByAppendingString:@<span class="string">&quot;Clowns will eat me&quot;</span>];</span><br></pre></td></tr></table></figure><p></p><p>最终编译会变成：</p><p></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">NSString</span> *helloWorldString; </span><br><span class="line"><span class="attribute">helloWorldString</span> = objc_msgSend(@<span class="string">&quot;Can&#x27;t Sleep; &quot;</span>, <span class="string">&quot;stringByAppendingString:&quot;</span>, @<span class="string">&quot;Clowns will eat me&quot;</span>);</span><br></pre></td></tr></table></figure><p></p><p>第一个参数是 NSString 的实例（@“Can't Sleep;”），后跟方法选择器，然后是方法调用的参数。</p><h2 id="将理论付诸实践"><a class="anchor" href="#将理论付诸实践">#</a> 将理论付诸实践</h2><p>在本节中，您将使用本章资源包中提供的名为 Registers 的项目。<br>通过 Xcode 打开该项目，然后运行。</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gktgwlp1cuj30x40glgoh.jpg" alt=""></p><p>这是一个非常简单的应用程序，仅显示 64 位寄存器里面的内容。 需要注意的是，该应用程序不会实时的显示寄存器的值； 它只能在特定的函数调用期间显示寄存器的值。 这意味着您不会看到这些寄存器的值有太多更改，因为在调用获取寄存器值的函数时它们可能具有相同（或相似）的值。<br>现在，您已经了解了 Registers macOS 应用程序背后的功能，为 NSViewController 的 viewDidLoad 方法创建一个符号断点。 记住，因为您正在使用 Mac 应用程序，所以请使用 “NS” 代替 “ UI”。</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gktm1acug7j30ws0c8n13.jpg" alt=""></p><p>生成并重新运行该应用程序。触发断点后在 LLDB 控制台中键入以下内容：</p><ul><li>(lldb) register read</li></ul><p>这将列出处于暂停执行状态的所有主要寄存器。 但是输出了太多信息。 您应该有选择地打印出寄存器，并将其视为 Objective-C 对象。如果您还记得的话，-[NSViewController viewDidLoad] 将被转换为以下程序集伪代码：</p><p></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RDI</span> = UIViewControllerInstance </span><br><span class="line"><span class="built_in">RSI</span> = <span class="string">&quot;viewDidLoad&quot;</span></span><br><span class="line">objc_msgSend(<span class="built_in">RDI</span>, <span class="built_in">RSI</span>)</span><br></pre></td></tr></table></figure><p></p><p>考虑到 x64 调用规则，并且知道 objc_msgSend 的工作方式，您可以找到要加载的特定 NSViewController。<br>在 LLDB 控制台中键入以下内容：</p><ul><li>(lldb) po $rdi</li></ul><p>然后你会看到如下输出：</p><p></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;Registers.ViewController: 0x6080000c13b0&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>它输出了 RDI 寄存器中的 NSViewController 引用，您现在知道该引用是该方法的第一个参数的位置。</p><p>在 LLDB 中，为寄存器加上 $ 字符很重要，因此 LLDB 知道您需要的是寄存器的值，而不是源代码中与范围相关的变量。 是的，这与您在刚刚反汇编视图中看到的汇编不同！ 烦人吧？</p><blockquote><p>注：善于观察的你可能已经注意到了在 OC 代码中打断点，在 LLDB 的回溯内看不到 objc_msgSend 的影子。这是因为 objc_msgSend 方法簇执行了 jmp。意思就是说 objc_msgSend 扮演了中转的角色，一但 OC 代码开始执行，所有的关于 objc_msgSend 的栈中的回溯都将消失。这是一种叫做尾递归调用的优化。因为 mesgsend 开始执行证明之前的栈帧已经清空了。</p></blockquote><p>尝试打印出 RSI 寄存器，不出意外的话应该是方法名。 在 LLDB 控制台中输入以下内容：</p><ul><li>(lldb) po $rsi</li></ul><p>结果你会输出这个</p><p></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">140735181830794</span><br></pre></td></tr></table></figure><p></p><p>为什么是这样？ Objective-C 选择器基本上只是一个 char *。 这意味着，像所有 C 类型一样，LLDB 不知道如何格式化此数据。 因此，您必须将此引用显式转换为所需的数据类型。<br>将 RSI 寄存器强制转换为正确的类型使用如下指令</p><ul><li>po (char *)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>s</mi><mi>i</mi><mtext>或者</mtext><mi>p</mi><mi>o</mi><mo stretchy="false">(</mo><mi>S</mi><mi>E</mi><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">rsi 或者 po (SEL)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">或</span><span class="mord cjk_fallback">者</span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span>rsi</li></ul><p>便可以得到方法名字</p><p></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;viewDidLoad&quot;</span></span><br></pre></td></tr></table></figure><p></p><p>现在，该探讨带有参数的 Objective-C 方法了。 由于您已经断点了 viewDidLoad，因此可以放心地假设 NSView 实例已加载。 感兴趣的方法是 mouseUp：由 NSView 的父类 NSResponder 实现的选择器。<br>在 LLDB 中，在 NSResponder 的 mouseUp：选择器上创建一个断点，然后继续执行。 如果您不记得该怎么做，则需要以下命令：</p><ul><li>(lldb) b -[NSResponder mouseUp:]</li><li>(lldb) continue</li></ul><p>现在，点击应用程序窗口。 确保单击 NSScrollView 的外部，因为 NSScrollView 它会拦截您的单击，并且不会命中 -[NSResponder mouseUp：] 断点。</p><p>点击后，LLDB 就会在 mouseUp：断点处停止。 通过在 LLDB 控制台中键入以下内容，打印出 NSResponder 的引用：</p><ul><li>(lldb) po $rdi</li></ul><p>会出现如下的输出</p><p></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;NSView: 0x608000120140&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>但是，该方法是带参数的！ 在 LLDB 控制台中输入以下内容：</p><ul><li>(lldb) po $rdx</li></ul><p>输出</p><p></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“NSEvent: <span class="attribute">type</span>=LMouseUp loc=(351.672,137.914) <span class="attribute">time</span>=175929.4 <span class="attribute">flags</span>=0 <span class="attribute">win</span>=0x6100001e0400 <span class="attribute">winNum</span>=8622 <span class="attribute">ctxt</span>=0x0 <span class="attribute">evNum</span>=10956 <span class="attribute">click</span>=1 <span class="attribute">buttonNumber</span>=0 <span class="attribute">pressure</span>=0 deviceID:0x300000014400000 <span class="attribute">subtype</span>=NSEventSubtypeTouch”</span><br></pre></td></tr></table></figure><p></p><p>也可以看到参数类型</p><ul><li>po [$rdx class]</li></ul><p></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">NSEvent</span></span><br></pre></td></tr></table></figure><p></p><p>太酷了，是吗？有时使用寄存器和断点很有用，以便获得内存中还存在的对象的引用。例如，如果您想将前部 NSWindow 更改为红色，但是在代码中没有对该视图的引用，又不想重新编译任何代码怎么办？ 您只需创建一个断点就可以轻松调试，从寄存器中获取引用并根据需要操纵该对象的实例。 您现在将尝试将主窗口更改为红色。”</p><blockquote><p>注：尽管 NSResponder 实现了 mouseDown: 方法，但 NSWindow 重写了它。你可以输出所有实现了 mouseDown: 的类，你就可以看出这个方法被那些类重写了，而不用去看源码。输出所有实现了 mouseDown: 方法的 OC 类的命令是：&lt;u&gt;image lookup -rn '\ mouseDown:&lt;/u&gt;'</p></blockquote><p>首先使用 LLDB 控制台删除所有以前的断点：</p><ul><li>breakpoint delete</li></ul><p>像如下输出</p><p></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) breakpoint <span class="keyword">delete</span></span><br><span class="line">About <span class="keyword">to</span> <span class="keyword">delete</span> <span class="keyword">all</span> breakpoints, <span class="keyword">do</span> you want <span class="keyword">to</span> <span class="keyword">do</span> that?: [Y/n] Y</span><br><span class="line"><span class="keyword">All</span> breakpoints removed. (<span class="number">3</span> breakpoints)</span><br><span class="line">(lldb) </span><br></pre></td></tr></table></figure><p></p><p>然后在 LLDB 控制台中键入以下内容：</p><ul><li>(lldb) breakpoint set -o -S &quot;-[NSWindow mouseDown:]</li><li>(lldb) continue</li></ul><p>这句话的作用是设置一个单发断点，只会触发一次，然后点击应用程序触发断点，在 LLDB 控制台中键入以下内容：</p><ul><li>(lldb) po [$rdi setBackgroundColor:[NSColor redColor]]</li><li>(lldb) continue</li></ul><p>之后就可以看到效果</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkuam4sxojj30qo0i8go0.jpg" alt=""></p><h2 id="swift和寄存器"><a class="anchor" href="#swift和寄存器">#</a> Swift 和寄存器</h2><p>在 Swift 中探索寄存器时，您将遇到两个问题，这使汇编调试比 Objective-C 困难。</p><ul><li><p>首先，在 Swift 调试上下文内寄存器不可用。意味着你不得不获取到任何你想要的数据，并使用 OC 调试上下文打印出传入 Swift 函数的寄存器。记住你可以使用 expression -l objc -O 命令，或者使用在书中第八章（“Persisting and Customizing Commands”）的 cpo 命令。幸运的是，register read 命令依然是可以使用的。</p></li><li><p>其次，Swift 相对于 OC 并不是动态的。事实上，有时候最好假设 Swift 像 C 语言一样。如果知道了一个内存地址，你应该显示地强转为你想要的类型。不然 Swift 调试器没有任何线索去解释内存地址。</p></li></ul><p>话虽这么说，但是 Swift 使用了相同的寄存器调用规则。 但是有一个非常重要的区别。 当 Swift 调用一个函数时，它__不需要使用 objc_msgSend__，除非您当然标记了使用动态方法。 这意味着当 Swift 调用函数时，先前分配给选择器的 RSI 寄存器实际上就是函数的第二个参数。好了，足够的理论 - 是时候将其付诸实践了。</p><p>在 Registers 项目中，导航到 ViewController.swift 并将以下函数添加到该类：</p><p></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">executeLotsOfArguments</span>(<span class="params">one</span>: <span class="type">Int</span>, <span class="params">two</span>: <span class="type">Int</span>, <span class="params">three</span>: <span class="type">Int</span>,</span><br><span class="line">                                <span class="params">four</span>: <span class="type">Int</span>, <span class="params">five</span>: <span class="type">Int</span>, <span class="params">six</span>: <span class="type">Int</span>,</span><br><span class="line">                                <span class="params">seven</span>: <span class="type">Int</span>, <span class="params">eight</span>: <span class="type">Int</span>, <span class="params">nine</span>: <span class="type">Int</span>,</span><br><span class="line">                                <span class="params">ten</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;arguments are: <span class="subst">\(one)</span>, <span class="subst">\(two)</span>, <span class="subst">\(three)</span>, <span class="subst">\(four)</span>, <span class="subst">\(five)</span>, <span class="subst">\(six)</span>, <span class="subst">\(seven)</span>, <span class="subst">\(eight)</span>, <span class="subst">\(nine)</span>, <span class="subst">\(ten)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p></p><p>现在，在 viewDidLoad 中，使用适当的参数调用此函数：</p><p></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">self</span>.<span class="title function_ invoke__">executeLotsOfArguments</span>(<span class="attr">one</span>: <span class="number">1</span>, <span class="attr">two</span>: <span class="number">2</span>, <span class="attr">three</span>: <span class="number">3</span>, <span class="attr">four</span>: <span class="number">4</span>, <span class="attr">five</span>: <span class="number">5</span>, <span class="attr">six</span>: <span class="number">6</span>, <span class="attr">seven</span>: <span class="number">7</span>, <span class="attr">eight</span>: <span class="number">8</span>, <span class="attr">nine</span>: <span class="number">9</span>, <span class="attr">ten</span>: <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p></p><p>在与 executeLotsOfArguments 声明相同的行上放置一个断点，以便调试器将在函数的开始处停止。 这很重要，否则如果函数已经开始执行，则寄存器可能会被破坏。然后删除您在 -[NSViewController viewDidLoad] 上设置的符号断点。生成并运行该应用程序，然后等待 executeLotsOfArguments 断点停止执行。我们先列出所有的寄存器。 在 LLDB 中，键入以下内容：</p><ul><li>register read -f d</li></ul><p>这将列出所有的寄存器，并使用 - f d 选项以十进制显示格式。 输出将类似于以下内容：</p><p></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register read -f d</span><br><span class="line">General Purpose Registers:</span><br><span class="line">       <span class="built_in">rax</span> = <span class="number">10</span></span><br><span class="line">       <span class="built_in">rbx</span> = <span class="number">7</span></span><br><span class="line">       <span class="built_in">rcx</span> = <span class="number">4</span></span><br><span class="line">       <span class="built_in">rdx</span> = <span class="number">3</span></span><br><span class="line">       <span class="built_in">rdi</span> = <span class="number">1</span></span><br><span class="line">       <span class="built_in">rsi</span> = <span class="number">2</span></span><br><span class="line">       <span class="built_in">rbp</span> = <span class="number">140732785005232</span></span><br><span class="line">       <span class="built_in">rsp</span> = <span class="number">140732785004720</span></span><br><span class="line">        <span class="built_in">r8</span> = <span class="number">5</span></span><br><span class="line">        <span class="built_in">r9</span> = <span class="number">6</span></span><br><span class="line">       <span class="built_in">r10</span> = <span class="number">9</span></span><br><span class="line">       <span class="built_in">r11</span> = <span class="number">8</span></span><br><span class="line">       <span class="built_in">r12</span> = <span class="number">140668105198352</span></span><br><span class="line">       <span class="built_in">r13</span> = <span class="number">105553138827696</span></span><br><span class="line">       <span class="built_in">r14</span> = <span class="number">104</span></span><br><span class="line">       <span class="built_in">r15</span> = <span class="number">8</span></span><br><span class="line">       <span class="built_in">rip</span> = <span class="number">4430734802</span>  Registers<span class="string">`Registers.ViewController.executeLotsOfArguments(one: Swift.Int, two: Swift.Int, three: Swift.Int, four: Swift.Int, five: Swift.Int, six: Swift.Int, seven: Swift.Int, eight: Swift.Int, nine: Swift.Int, ten: Swift.Int) -&gt; () + 178 at ViewController.swift:68:15</span></span><br><span class="line"><span class="string">    rflags = 514</span></span><br><span class="line"><span class="string">        cs = 43</span></span><br><span class="line"><span class="string">        fs = 0</span></span><br><span class="line"><span class="string">        gs = 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">(lldb) </span></span><br></pre></td></tr></table></figure><br>如您所见，寄存器遵循 x64 调用规则。 RDI，RSI，RDX，RCX，R8 和 R9 保留您的前六个参数。<p></p><blockquote><p>注意：关于 LLDB，我一直没有告诉您的是，LLDB 可以以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>g</mi><mi>X</mi><mtext>形式来引用寄存器，其中</mtext><mi>X</mi><mtext>是参数号。还记得</mtext><mi>R</mi><mi>D</mi><mi>I</mi><mtext>是第一个参数，而</mtext><mi>R</mi><mi>S</mi><mi>I</mi><mtext>是第二个参数吗</mtext><mo stretchy="false">?</mo><mtext>在</mtext><mi>L</mi><mi>L</mi><mi>D</mi><mi>B</mi><mtext>中，可以通过</mtext></mrow><annotation encoding="application/x-tex">arg{X}形式来引用寄存器，其中X是参数号。还记得RDI是第一个参数，而RSI是第二个参数吗?在LLDB中，可以通过</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord"><span class="mord mathnormal" style="margin-right:.07847em">X</span></span><span class="mord cjk_fallback">形</span><span class="mord cjk_fallback">式</span><span class="mord cjk_fallback">来</span><span class="mord cjk_fallback">引</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">寄</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">器</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord mathnormal" style="margin-right:.07847em">X</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">号</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">还</span><span class="mord cjk_fallback">记</span><span class="mord cjk_fallback">得</span><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="mord mathnormal" style="margin-right:.02778em">D</span><span class="mord mathnormal" style="margin-right:.07847em">I</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">第</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">而</span><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord mathnormal" style="margin-right:.07847em">I</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">第</span><span class="mord cjk_fallback">二</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">吗</span><span class="mclose">?</span><span class="mord cjk_fallback">在</span><span class="mord mathnormal">L</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:.02778em">D</span><span class="mord mathnormal" style="margin-right:.05017em">B</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">过</span></span></span></span> arg1 引用第一个参数 (RDI)。随着示例的进行，您可以使用 $arg2 引用第二个参数 (RSI)，以此类推。这些方便值也可以在 ARM64 调用约定中使用，即使 ARM64 使用不同的寄存器。您应该记住寄存器调用规则，以便本书尽量减少使用这些寄存器辅助变量。</p></blockquote><p>您可能还会注意到其他参数存储在其他一些其他寄存器中。 确实如此，但这只是为其余参数设置堆栈的代码中的剩余部分。 请记住，第六个参数之后的参数将进入堆栈。</p><h2 id="rax用于返回的寄存器"><a class="anchor" href="#rax用于返回的寄存器">#</a> RAX，用于返回的寄存器</h2><p>等等 -- 还有呢！到这里，你已经了解了函数中六个寄存器是如何调用的，但是返回值呢？</p><p>幸运的是，只有一个指定的寄存器用于返回值：RAX。回到 executeLotsOfArguments 函数并改变函数的返回值，像这样：</p><p></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">executeLotsOfArguments</span>(<span class="params">one</span>: <span class="type">Int</span>, <span class="params">two</span>: <span class="type">Int</span>, <span class="params">three</span>: <span class="type">Int</span>,</span><br><span class="line">                                <span class="params">four</span>: <span class="type">Int</span>, <span class="params">five</span>: <span class="type">Int</span>, <span class="params">six</span>: <span class="type">Int</span>,</span><br><span class="line">                                <span class="params">seven</span>: <span class="type">Int</span>, <span class="params">eight</span>: <span class="type">Int</span>, <span class="params">nine</span>: <span class="type">Int</span>,</span><br><span class="line">                                <span class="params">ten</span>: <span class="type">Int</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;arguments are: <span class="subst">\(one)</span>, <span class="subst">\(two)</span>, <span class="subst">\(three)</span>, <span class="subst">\(four)</span>, <span class="subst">\(five)</span>, <span class="subst">\(six)</span>, <span class="subst">\(seven)</span>, <span class="subst">\(eight)</span>, <span class="subst">\(nine)</span>, <span class="subst">\(ten)</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Mom, what happened to the cat?&quot;</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p></p><p>然后 viewdidlaod 中调用</p><p></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _ = self.execute<span class="constructor">LotsOfArguments(<span class="params">one</span>: 1, <span class="params">two</span>: 2, <span class="params">three</span>: 3, <span class="params">four</span>: 4, <span class="params">five</span>: 5, <span class="params">six</span>: 6, <span class="params">seven</span>: 7, <span class="params">eight</span>: 8, <span class="params">nine</span>: 9, <span class="params">ten</span>: 10)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><p>在 executeLotsOfArguments 中的某处创建一个断点。 再次生成并运行，然后等待函数停止执行。 接下来，在 LLDB 控制台中键入以下内容：</p><ul><li>(lldb) finish</li></ul><p>命令会结束完成函数的执行并停住调试器。这时，函数返回值会在 RAX 内。输入如下命令：</p><ul><li>(lldb) register read rax</li></ul><p>你将会看见如下输出</p><p></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rax</span> <span class="operator">=</span> <span class="number">0</span>x0000000100003760  <span class="string">&quot;Mom, what happened to the cat?</span></span><br></pre></td></tr></table></figure><br>了解 RAX 中的返回值非常重要，因为它将构成您将在后面的部分中编写的调试脚本的基础。<p></p><h2 id="改变寄存器值"><a class="anchor" href="#改变寄存器值">#</a> 改变寄存器值</h2><p>为了巩固您对寄存器的理解，您将在一个已编译的应用程序中修改寄存器。<br>关闭 Xcode 和 Registers 项目。 打开终端窗口，然后启动 iPhone X Simulator。 通过键入以下内容来执行此操作：</p><ul><li>xcrun simctl list | grep &quot;iPhone X”</li></ul><p></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Phone</span>: iPhone <span class="number">12</span> Pro Max (<span class="number">16</span>A6D554-<span class="number">3</span>C10-<span class="number">4</span>A67-<span class="number">9039</span>-<span class="number">31</span>B8BE33871F) (Shutdown)</span><br></pre></td></tr></table></figure><p></p><p>UDID 就是你要找的。使用它并通过如下命令打开 iOS 模拟器（替换其中的 UDID 部分）：</p><ul><li>open /Applications/Xcode.app/Contents/Developer/Applications/Simulator.app --args -CurrentDeviceUDID 16A6D554-3C10-4A67-9039-31B8BE33871F</li></ul><p>保证模拟器已经启动而且在主屏幕上。你可以通过按下 Command + Shift + H 键回到主屏幕。一旦模拟器准备好了，回到终端窗口将 LLDB 绑定到 SpringBoard 程序上。</p><ul><li>lldb -n SpringBoard</li></ul><p>这样会将 LLDB 绑定到正在模拟器上运行的 SpringBoard 实例上！SpringBoard 就是在 iOS 上控制主屏幕的程序。</p><p>一旦绑定，输入如下命令：</p><ul><li>(lldb) p/x @&quot;Yay! Debugging<br>可以看到类似如下的输出：</li></ul><p></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(__NSCFString *) $3 = <span class="number">0x0000618000644080</span> @<span class="string">&quot;Yay! Debugging!&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>注意下刚刚创建的这个 NSString 实例，因为很快你会用到它。现在，给 UILabel 的 setText: 方法设置一个断点：<p></p><ul><li>(lldb) b -[UILabel setText:]</li><li>(lldb) breakpoint command add</li></ul><p>LLDB 会吐出一些输出且进入多行编辑模式。这个命令让你在刚刚打的断点处添加多个额外要执行的命令。输入如下，使用刚才的 NSString 地址替换下面的内存地址：</p><p></p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">po $rdx = <span class="number">0x0000618000644080</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript"><span class="keyword">continue</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript"><span class="variable constant_">DONE</span></span></span><br></pre></td></tr></table></figure><br>回去重新看下你刚刚做的。你在 UILabel 的 setText: 方法上添加了一个断点。一旦遇到该方法，你就会用一个叫 Yay! Debugging! 的 NSString 实例替换 RDX--- 第三个参数。<p></p><p>使用 continue 命令让调试器继续执行：</p><ul><li>(lldb) continue</li></ul><p>看看 SpringBoard 模拟器程序什么发生了改变。从下往上扫带出控制中心，观察改变的地方：</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkujcb1fmaj30en0qk0xc.jpg" alt=""></p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkujaok2e0j30hf0v2aft.jpg" alt=""></p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkujb8rg0aj30k60tj787.jpg" alt=""></p><p>尽管这似乎是一个很酷的花招编程技巧，但它却展示了通过有限的汇编和寄存器的知识能够在程序内产生你之前没见过的大的变化。</p><p>从调试的角度来看，这也很有用，因为您可以快速直观地验证 -[UILabel setText：] 在 SpringBoard 应用程序中的执行位置，并运行断点条件以查找设置特定 UILabel 文本的确切代码行。</p><h2 id="寄存器和sdk"><a class="anchor" href="#寄存器和sdk">#</a> 寄存器和 SDK</h2><p>了解寄存器的工作方式以及应用程序的功能可以快速帮助您找到感兴趣的项目。举个简单的例子：通常，我会遇到一个 UIButton，并想知道 IBAction 和接收器，当我点击该按钮时会发生什么。在最高断点处，我可能会发疯…… 认识我自己，我通常在 UIView 或 UIViewController（也许是 UITableViewCell？）中包含 IBAction，并且通常使用某种名称为 “tapped” 的方法。<br>因此，也许下面的 LLDB 命令会起作用？</p><ul><li>(lldb) rb View(Controller|Cell)?\s(?i).*tapped</li></ul><p>但是我错误地假设同事 / 其他开发人员正在使用与我相同的命名约定；这个想法行不通。相反，我知道，每当执行 IBAction 方法时，它都必须经过 UIApplication 单例，在该单例中，它将遍历响应者链来找到合适的接收者。为此，将调用 UIControl 的 - sendAction：to：forEvent：方法。<br>我可以在此方法上设置一个断点，并探索 sendAction：和 to：参数以查找 IBAction 正在执行的代码。<br>这个想法可以应用到您拥有和没有源代码的应用程序中。我经常发现，即使在我确实有源代码的应用程序中，使用此方法也更快，然后在应用程序中看到数千个 IBAction。</p><p>... 但仅出于演示目的，让我们将其应用于 iOS Maps 应用程序。我对右上方按钮的名称和接收者感到好奇，该按钮可以直接定位用户的具体位置。<br><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkujmtqa2qj30dz0qoq82.jpg" alt=""></p><p>通过 LLDB 附加到 Maps 应用程序并为 -[UIControl sendAction：to：forEvent：] 设置断点后，很容易找到 UIButton 的名称和接收者。<br>sendAction：参数（RDX）将使用选择器，而 to：参数将是 IBAction 的接收器（RCX）。</p><p><img data-src="https://cdn.cdnjson.com/tva1.sinaimg.cn/large/0081Kckwgy1gkujqoz7vsj30x50j2q7u.jpg" alt=""><br>用寄存器知识和轻按 UIButton 查找代码，这有多酷？</p><h2 id="下一步"><a class="anchor" href="#下一步">#</a> 下一步</h2><p>好的，学了这么长时间，来休息下，看看你学到了什么：</p><p>架构（X86）定义了一个调用规则，该规则规定了函数参数及其返回值的存储位置。</p><ul><li>在 Objective-C 中，RDI 寄存器是调用 NSObject 的引用，RSI 是选择器，RDX 是第一个参数，依此类推。</li><li>在 Swift 中，RDI 是第一个参数，RSI 是第二个参数，依此类推，前提是 Swift 方法未使用动态分配。</li><li>RAX 寄存器用于函数中的返回值，无论您使用的是 Objective-C 还是 Swift。</li></ul><p>您可以利用寄存器做很多事情。尝试浏览您没有源代码的应用；将为解决棘手的调试问题奠定良好的基础。</p><p>尝试附加到 iOS Simulator 上的应用程序，并使用程序集，智能断点和断点命令绘制出 UIViewController 的生命周期。</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-12-30 22:16:08" itemprop="dateModified" datetime="2023-12-30T22:16:08+08:00">2023-12-30</time> </span><span id="2020-11-19-汇编寄存器的规则/" class="item leancloud_visitors" data-flag-title="汇编寄存器的规则" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Molier 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Molier 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Molier <i class="ic i-at"><em>@</em></i>Molier</li><li class="link"><strong>本文链接：</strong> <a href="https://oliverqueen.cn/2020-11-19-%E6%B1%87%E7%BC%96%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E8%A7%84%E5%88%99/" title="汇编寄存器的规则">https://oliverqueen.cn/2020-11-19-汇编寄存器的规则/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2019-02-14-At-the-end-of-2018/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;cdn.cdnjson.com&#x2F;tvax3.sinaimg.cn&#x2F;large&#x2F;6833939bly1giclx29mstj20zk0m8hdt.jpg" title="At The End Of 2018"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 闲谈</span><h3>At The End Of 2018</h3></a></div><div class="item right"><a href="/2020-11-21-%E6%B1%87%E7%BC%96%E5%92%8C%E5%86%85%E5%AD%98/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;cdn.cdnjson.com&#x2F;tvax3.sinaimg.cn&#x2F;large&#x2F;6833939bly1gipeuv80yoj20zk0m8kjl.jpg" title="汇编和内存"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 计算机基础</span><h3>汇编和内存</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">1.</span> <span class="toc-text">汇编寄存器的规则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96101"><span class="toc-number">1.1.</span> <span class="toc-text">汇编 101</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x86_64-vs-arm64"><span class="toc-number">1.2.</span> <span class="toc-text">x86_64 vs ARM64</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x86_64-%E5%AF%84%E5%AD%98%E5%99%A8%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-number">1.3.</span> <span class="toc-text">x86_64 寄存器调用规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#objective-c-%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">Objective-C 和寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E7%90%86%E8%AE%BA%E4%BB%98%E8%AF%B8%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.5.</span> <span class="toc-text">将理论付诸实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#swift%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.6.</span> <span class="toc-text">Swift 和寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rax%E7%94%A8%E4%BA%8E%E8%BF%94%E5%9B%9E%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.7.</span> <span class="toc-text">RAX，用于返回的寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E5%AF%84%E5%AD%98%E5%99%A8%E5%80%BC"><span class="toc-number">1.8.</span> <span class="toc-text">改变寄存器值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8Csdk"><span class="toc-number">1.9.</span> <span class="toc-text">寄存器和 SDK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E4%B8%80%E6%AD%A5"><span class="toc-number">1.10.</span> <span class="toc-text">下一步</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2020-11-19-%E6%B1%87%E7%BC%96%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E8%A7%84%E5%88%99/" rel="bookmark" title="汇编寄存器的规则">汇编寄存器的规则</a></li><li><a href="/2020-11-21-%E6%B1%87%E7%BC%96%E5%92%8C%E5%86%85%E5%AD%98/" rel="bookmark" title="汇编和内存">汇编和内存</a></li><li><a href="/2020-11-28-%E6%B1%87%E7%BC%96%E5%92%8C%E6%A0%88/" rel="bookmark" title="汇编和栈">汇编和栈</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Molier" data-src="/images/avatar.jpeg"><p class="name" itemprop="name">Molier</p><div class="description" itemprop="description">iOS 开发 移动 App 博客 杂谈 随笔 相册</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">40</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">6</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">53</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item 新浪微博" data-url="aHR0cHM6Ly93ZWliby5jb20vemhhbmduaW5naGFvP3JlZmVyX2ZsYWc9MTAwNTA1NTAxMF8=" title="https:&#x2F;&#x2F;weibo.com&#x2F;zhangninghao?refer_flag&#x3D;1005055010_"><i class="ic i-weibo"></i></span> <span class="exturl item jianshu" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vdS9mZDIxZjQxZmI1MjI=" title="https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;fd21f41fb522"><i class="ic i-link"></i></span> <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL01vbGllclF1ZWVu" title="https:&#x2F;&#x2F;github.com&#x2F;MolierQueen"><i class="ic i-github"></i></span> <span class="exturl item juejin" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vdXNlci81ODZjNjI0YmFjNTAyZTEyZDYzMTU0NWY=" title="https:&#x2F;&#x2F;juejin.im&#x2F;user&#x2F;586c624bac502e12d631545f"><i class="ic i-link"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjM3MTA5OTY5NEBxcS5jb20=" title="mailto:371099694@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>朋友们</a></li></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2019-02-14-At-the-end-of-2018/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2020-11-21-%E6%B1%87%E7%BC%96%E5%92%8C%E5%86%85%E5%AD%98/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/2018-01-23-%E5%9C%A8iOS11%E4%B8%8Bapp%E5%9B%BE%E6%A0%87%E5%8F%98%E7%A9%BA%E7%99%BD%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" title="在iOS11下app图标变空白的问题解决">在iOS11下app图标变空白的问题解决</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/2018-01-23-iOS%E4%B8%AD%E4%BD%BF%E7%94%A8OpenGL%E5%AE%9E%E7%8E%B0%E5%A2%9E%E9%AB%98%E5%8A%9F%E8%83%BD/" title="iOS中使用OpenGL实现增高功能">iOS中使用OpenGL实现增高功能</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/2018-01-24-%E5%9C%A8iOS%E5%B7%A5%E7%A8%8B%E4%B8%ADCocoapods%E7%9A%84%E4%BD%BF%E7%94%A8/" title="在iOS工程中Cocoapods的使用">在iOS工程中Cocoapods的使用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/2018-01-24-%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%85%A8%E7%9A%84iOS%E7%AB%AFHttpDns%E9%9B%86%E6%88%90%E6%96%B9%E6%A1%88/" title="可能是最全的iOS端HttpDns集成方案">可能是最全的iOS端HttpDns集成方案</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/2021-05-03-iOS%20Crash%E9%98%B2%E6%8A%A4%E4%BD%A0%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%B0%B1%E5%A4%9F%E4%BA%86-%E4%B8%8A%E7%AF%87/" title="iOS Crash防护你看这个就够了 - 上篇">iOS Crash防护你看这个就够了 - 上篇</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/2018-03-30-AlamoFire/" title="AlamoFire的使用(下载队列，断点续传)">AlamoFire的使用(下载队列，断点续传)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/note/" title="分类于 闲谈">闲谈</a></div><span><a href="/2018-02-12-At-The-End-Of-2017/" title="At The End Of 2017">At The End Of 2017</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机基础">计算机基础</a></div><span><a href="/2020-11-28-%E6%B1%87%E7%BC%96%E5%92%8C%E6%A0%88/" title="汇编和栈">汇编和栈</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ios/" title="分类于 iOS 开发">iOS 开发</a></div><span><a href="/iPa%E9%80%86%E5%90%91%E4%B9%8B%E8%B7%AF/" title="iPa逆向之路">iPa逆向之路</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%85%B6%E4%BB%96/" title="分类于 其他">其他</a></div><span><a href="/2018-01-19-test-source/" title="Welcome To My Site">Welcome To My Site</a></span></li></ul></div></div><div class="status"><div class="copyright">&copy; 1992 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-"></i> </span><span class="author" itemprop="copyrightHolder">Molier @ Molier</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">217k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">3:18</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2020-11-19-汇编寄存器的规则/",favicon:{show:"MolierBolg",hide:"MolierBolg"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>